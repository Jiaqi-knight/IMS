(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: Read3ds.m *)
(* Context: *)
(* Author:jan korvink *)
(* 
  Date: 23.11.2005, 
  Freiburg vs Karlsruhe, in ICE *)
(* Summary: This handles 3ds files *)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.2.1 *)
(* 
  Mathematica Version: 5.2 *)
(* History: 
    Initial *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* 
  Limitations: *)
(* Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* 3DS file import  *)

(* Copyright (C) 2005 Jan G. Korvink *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)





(* Start Package *)
BeginPackage["Imtek`Interfaces`Read3ds`" ];





(* *)
(* documentation *)
(* *)

(* constructors *)
(* selectors *)
(* predicates *)
(* functions *)

imsRead3DS::usage="imsRead3DS[filePath] parses a 3D Studio file, extracts only the vertices and faces from the file, and returns these as a Graphics3D object. The program can only handle Version 3 files. \n\nNote: Since I had no official specification of the file structure, I based the program on a freeware C-implementation and extended it to handle all exceptions that occurred in files available to me. As more information becomes avalable, the program will be extended.\n\nAlso note that the program is slow. It is NOT an example of good Mathematica programming!\n\nCurrent Errors: I do not handle the object transformations correctly. Thus, if the file describes objects that are still to be transformed to their final positions, these are placed at their definition positions. This is the current next job.";



(* *)
(* options docu *)
(* *)

imsRead3DSDebug::usage="imsRead3DSDebug->False is the default setting for the imsRead3DS option that switches on extensive debug print information. Use with care.";\

imsWireframe::usage="imsWireframe->False specifies that the imported objects are drawn as folled polygons.";\





(* *)
(* Error Messages *)
(* *)



Begin["`Private`"];



(* private imports *)
(* 
  this is only for the old FEMNeumann operator *)
Needs[ "Imtek`ShowStatus`" \
]
<<Experimental`





MAIN3DS=16^^4D4D;

(* Main Chunks *)

EDIT3DS=16^^3D3D; (* this is the start of the editor config *)

KEYF3DS=16^^B000; (* this is the start of the keyframer config *)

(* sub defines of EDIT3DS *)
EDITMATERIAL=16^^AFFF;
EDITCONFIG1=16^^0100;
EDITCONFIG2=16^^3E3D;
EDITVIEWP1=16^^7012;
EDITVIEWP2=16^^7011;
EDITVIEWP3=16^^7020;
EDITVIEW1=16^^7001;
EDITBACKGR=16^^1200;
EDITAMBIENT=16^^2100;
EDITOBJECT=16^^4000;

EDITUNKNW01=16^^1100;
EDITUNKNW02=16^^1201;
EDITUNKNW03=16^^1300;
EDITUNKNW04=16^^1400;
EDITUNKNW05=16^^1420;
EDITUNKNW06=16^^1450;
EDITUNKNW07=16^^1500;
EDITUNKNW08=16^^2200;
EDITUNKNW09=16^^2201;
EDITUNKNW10=16^^2210;
EDITUNKNW11=16^^2300;
EDITUNKNW12=16^^2302 ;(* new chunk type *)
EDITUNKNW13=16^^3000;
EDITUNKNW14=16^^AFFF;
EDITUNKNW15=16^^3D3E; (* added by JGK *)

(* sub defines of EDITMATERIAL *)
MATNAME01=16^^A000 ;(* 
  includes name (see mli doc for materials) *)

(* sub defines of EDITOBJECT *)
OBJTRIMESH=16^^4100;
OBJLIGHT=16^^4600;
OBJCAMERA=16^^4700;

OBJUNKNWN01=16^^4010;
OBJUNKNWN02=16^^4012 ;(* Could be shadow *)

(* sub defines of OBJCAMERA *)
CAMUNKNWN01=16^^4710 ;(* new chunk type *)

CAMUNKNWN02=16^^4720; (* new chunk type *)

(* sub defines of OBJLIGHT *)
LITOFF=16^^4620;
LITSPOT=16^^4610;
LITUNKNWN01=16^^465A;

(* sub defines of OBJTRIMESH *)
TRIVERTEXL=16^^4110;
TRIFACEL2=16^^4111;(* unknown yet *)
TRIFACEL1=16^^4120;
TRIMATERIAL=16^^4130;
TRIUNKNWN01=16^^4140;
TRISMOOTH=16^^4150;
TRILOCAL=16^^4160;
TRIVISIBLE=16^^4165;

(* sub defs of KEYF3DS *)

KEYFUNKNWN01=16^^B009;
KEYFUNKNWN02=16^^B00A;
KEYFFRAMES=16^^B008;
KEYFOBJDES=16^^B002;

KEYFOBJHIERARCH=16^^B010;
KEYFOBJDUMMYNAME=16^^B011;
KEYFOBJUNKNWN01=16^^B013;
KEYFOBJUNKNWN02=16^^B014;
KEYFOBJUNKNWN03=16^^B015;
KEYFOBJPIVOT=16^^B020;
KEYFOBJUNKNWN04=16^^B021;
KEYFOBJUNKNWN05=16^^B022;

(* these define the different color chunk types *)
COLRGB=16^^0010;
COLTRU=16^^0011;
COLUNK=16^^0013;(* unknown *)

(* defines for viewport chunks *)
TOP=16^^0001;
BOTTOM=16^^0002;
LEFT=16^^0003;
RIGHT=16^^0004;
FRONT=16^^0005;
BACK=16^^0006;
USER=16^^0007;
CAMERA=16^^0008; (* 16^^FFFF is the code read from file *)
LIGHT=16^^0009;
DISABLED=16^^0010;
BOGUS=16^^0011;

bin3ds=0;
data={};

currentchunk=0;
viewsread=0;
numbfaces=0;
numbvertices=0;
viewports={};
tempname="";
transmat=Table[0,{4},{4}]; (* translation matrix for objects *)

verticesList={};
facesList={};
transmatList={};

DebugFlag=False;





fseek[fileHandle_,position_,whence_]:=Module[{absPosition},
        If[whence==SEEKSET,
          absPosition=position
          ];
        If[whence==SEEKCUR,
          absPosition=position+StreamPosition[fileHandle]
          ];
        SetStreamPosition[fileHandle,absPosition]
        ]/;(whence==SEEKSET||whence==SEEKCUR);





ReadInt[]:=BinaryRead[bin3ds,"UnsignedInteger16",ByteOrdering\[Rule]-1];
ReadChar[]:=BinaryRead[bin3ds,"UnsignedInteger8"];
ReadLong[]:=BinaryRead[bin3ds,"UnsignedInteger32",ByteOrdering\[Rule]-1];
ReadReal[]:=
    convertIEEENumber[
      BinaryRead[bin3ds,"UnsignedInteger32",ByteOrdering\[Rule]-1]];

convertIEEENumber[num_]:=Module[{myDigits,sgnPart,exponentPart,mantissaPart},
      myDigits=IntegerDigits[num,2,32];
      {sgnPart,exponentPart,mantissaPart}={myDigits[[1]],
          myDigits[[Range[2,9]]],myDigits[[Range[10,32]]]};
      If[sgnPart\[Equal]0,sgnPart=1,sgnPart=-1];
      exponentPart=2^(FromDigits[exponentPart,2]-127);
      mantissaPart=FromDigits[{Join[{1},mantissaPart],1},2];
      Return[N[sgnPart*exponentPart*mantissaPart]]
      ];

GetChunkFilePointer[]:=StreamPosition[bin3ds];
 (* compensate for the already read Marker *)

ReadChunkLength[]:=ReadLong[]-2;

ChangeChunkPointer[chunkLength_]:=fseek[bin3ds,chunkLength,SEEKSET];



ReadName[]:=Module[{charCounter=1,letter,tempname={}},
      letter=ReadChar[];
      if[letter\[Equal]0,Return[charCounter]];
      (* dummy object *) 
      tempname={tempname,letter};
      charCounter++;
      While [letter\[NotEqual]0&&(charCounter<=12),
        letter=ReadChar[];
        tempname={tempname,letter};
        charCounter++
        ];
      --charCounter;
      tempname=FromCharacterCode[Drop[Flatten[tempname],-1]];
      If[DebugFlag,
        Print["     Found name : \"",tempname,"\" of length: ",charCounter]
        ];
      Return[charCounter]
      ];

ReadLongName[]:=Module[{charCounter=1,letter,tempname={}},
      letter=ReadChar[];
      if[letter\[Equal]0,Return[charCounter]];
      (* dummy object *) 
      tempname={tempname,letter};
      charCounter++;
      While [(letter\[NotEqual]0),
        letter=ReadChar[];
        tempname={tempname,letter};
        charCounter++
        ];
      --charCounter;
      tempname=FromCharacterCode[Drop[Flatten[tempname],-1]];
      If[DebugFlag,
        Print["     Found name : \"",tempname,"\" of length: ",charCounter]
        ];
      Return[charCounter]
      ];

ReadRGBColor[]:=Module[{rgbval},
      rgbval={ReadReal[],ReadReal[],ReadReal[]};
      If[DebugFlag,
        Print["     Found Color (RGB) def of: R: ",rgbval[[1]],",G: ",
          rgbval[[2]],",B: ",rgbval[[3]]]
        ];
      
      (* Return the number of bytes read *)
      Return[12]
      ];

ReadTrueColor[]:=Module[{truecval},
      truecval={ReadReal[],ReadReal[],ReadReal[]};
      If[DebugFlag,
        Print["     Found Color (24bit) def of: R: ",truecval[[1]],",G: ",
          truecval[[2]],",B: ",truecval[[3]]]
        ];
      
      (* Return the number of bytes read *)
      Return[3]
      ];



PrintEntryData[currentPointer_,chunkLength_,functionName_]:=Module[{},
      If[DebugFlag,
        Print[" -> In ",functionName,": Reached position ",
          BaseForm[currentPointer,16]," = ",currentPointer," in file"];
        Print["    Chunk length: ",BaseForm[chunkLength,16]," = ",
          chunkLength]
        ]
      ];

PrintExitData[currentPointer_,chunkLength_,functionName_]:=
    Module[{absPosition},
      If[DebugFlag,
        absPosition=currentPointer+chunkLength;
        Print["    Read ",chunkLength,"*2 Bytes"];
        Print[" <- Reached position: ",BaseForm[absPosition,16]," = ",
          absPosition, " in ",functionName]
        ]
      ];

PrintFoundChunk[chunkName_,chunkId_]:=Module[{},
      If[DebugFlag,
        Print[" Found ",chunkName," chunk id: ",BaseForm[chunkId,16]]
        ]
      ];

PrintFalseItem[functionName_,intCounter_,tempint_]:=If[DebugFlag,
      Print["*** Error in ",functionName," found tempint: ",
        BaseForm[tempint,16]," = ",tempint," at intCounter: ",
        BaseForm[intCounter,16]," = ",intCounter]
      ];

PrintSkippedItem[functionName_,intCounter_,tempint_]:=If[DebugFlag,
      Print["    In ",functionName," Skipping tempint: ",BaseForm[tempint,16],
        " = ",tempint," at intCounter: ",BaseForm[intCounter,16]," = ",
        intCounter]
      ];

PrintOverShoot[chunkName_,intCounter_,limit_]:=If[intCounter>limit,
      If[DebugFlag,
        Print["Error in ",chunkName," intCounter: ",intCounter," > ",limit]
        ];
      Abort[]
      ];





ReadKeyfChunk[]:=
    Module[{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4},
      currentPointer=GetChunkFilePointer[];
      chunkLength   =ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadKeyfChunk]];
      
      
      (*
        While[ (foundEnd\[Equal]False),
            tempint=ReadInt[];
            intCounter+=2;
            
            Switch [tempint,
              
              KEYFUNKNWN01,
              PrintFoundChunk["KEYFUNKNWN01",tempint];
              intCounter+=ReadUnknownChunk[tempint],
              
              KEYFUNKNWN02,
              PrintFoundChunk["KEYFUNKNWN02",tempint];
              intCounter+=ReadUnknownChunk[tempint],
              
              KEYFFRAMES,
              PrintFoundChunk["KEYFFRAMES Keyframer",tempint];
              intCounter+=ReadUnknownChunk[tempint],
              
              KEYFOBJDES,
              
              PrintFoundChunk["KEYFOBJDES Keyframer object description",
                tempint];
              intCounter+=ReadUnknownChunk (tempint),
              
              EDITVIEW1,
              PrintFoundChunk["EDITVIEW1 View main def",tempint];
              intCounter+=ReadViewChunk[],
              
              _,
              PrintFalseItem[SymbolName[ReadKeyfChunk],intCounter,tempint]
              ];
            
            If[intCounter==chunkLength,
              foundEnd=True
              ]
            ];
        *)
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadKeyfChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      (* move to the new chunk position *)
      Return [chunkLength]
      ];






ReadSpotChunk[]:=Module[{currentPointer,chunkLength,target,hotspot,falloff},
      currentPointer=GetChunkFilePointer[];
      chunkLength   =ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadSpotChunk]];
      
      target={ReadReal[],ReadReal[],ReadReal[]};
      hotspot=ReadReal[];
      falloff=ReadReal[];
      If[DebugFlag,
        Print["      The target of the spot is at: X: ",target[[1]]," Y: ",
          target[[2]]," Y: ",target[[3]]];
        Print["      The hotspot of this light is : ",hotspot];
        Print["      The falloff of this light is : ",falloff]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadSpotChunk]];
      ChangeChunkPointer[currentPointer+chunkLength]; 
      Return[chunkLength];
      ];



ReadSmoothingChunk[]:=Module[{currentPointer,chunkLength,smoothing},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadSmoothingChunk]];
      
      smoothing=Table[ReadLong[],{numbfaces}];
      If[DebugFlag,
        Print["      The smoothing group is ",TableForm[smoothing]]
        ];
      
      PrintExitData[currentPointer,chunkLength,
        SymbolName[ReadSmoothingChunk]];
      ChangeChunkPointer[currentPointer+chunkLength]; 
      Return[chunkLength];
      ];



ReadUnknownChunk[chunkid_]:=Module[{currentPointer,chunkLength},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadUnknownChunk]];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadUnknownChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadMatDefChunk[]:=Module[{currentPointer,chunkLength},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadMatDefChunk]];
      
      If[ReadLongName[]\[Equal]0,
        If[DebugFlag,Print[ ("* No Material name found")]]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadMatDefChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadMaterialChunk[]:=
    Module[{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadMaterialChunk]];
      
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch[tempint,
          MATNAME01,
          PrintFoundChunk["MATNAME01 Material Name",tempint];
          intCounter+=ReadMatDefChunk[]
          ]; 
        
        PrintOverShoot[SymbolName[ReadMaterialChunk],intCounter,chunkLength];
        If [intCounter==chunkLength, foundEnd=True
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,
        SymbolName[ReadMaterialChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



FindCameraChunk[]:=Module[{chunkLength=0,tmp},
      Table[ReadInt[],{12}];
      chunkLength=12*2;
      chunkLength+=(tmp=ReadName[]);
      If[tmp\[Equal]0,
        If[DebugFlag,Print[("* No Camera name found")]]
        ];
      
      Return[chunkLength]
      ];



ReadViewPortChunk[]:=Module[{ currentPointer,chunkLength,port,attribs},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadViewPortChunk]];
      
      viewsread++;
      attribs=ReadInt[];
      If[DebugFlag,if[ (attribs\[Equal]3),
          Print["<Snap> active in viewport"]
          ];
        if[(attribs\[Equal]5),
          Print["<Grid> active in viewport"]
          ]
        ];
      Table[ReadInt[],{5}];
      (* read 5 ints to get to the viewport *)
      port=ReadInt[];
      if[((port\[Equal]16^^FFFF)||(port\[Equal]0)),
        FindCameraChunk[];
        port=CAMERA;
        ];
      If[DebugFlag,
        Print["Reading [",viewports[[port]],"] information with id: ", 
          BaseForm[port,16]]
        ];
      
      PrintExitData[currentPointer,chunkLength,
        SymbolName[ReadViewPortChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadViewChunk[]:=
    Module[{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadViewChunk]];
      
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
         intCounter+=2;
        
        Switch[ (tempint),
          
          EDITVIEWP1,
          PrintFoundChunk["EDITVIEWP1 Viewport",tempint];
          intCounter+=ReadViewPortChunk[],
          
          EDITVIEWP2,
          PrintFoundChunk["EDITVIEWP2 Viewport",tempint];
          intCounter+=ReadUnknownChunk[EDITVIEWP2],
          
          EDITVIEWP3,
          PrintFoundChunk["EDITVIEWP3 Viewport",tempint];
          intCounter+=ReadViewPortChunk[],
          
          _,
          PrintFalseItem[SymbolName[ReadViewChunk],intCounter,tempint]
          ];
        
        PrintOverShoot[SymbolName[ReadViewChunk],intCounter,chunkLength];
        If [intCounter\[Equal]chunkLength, foundEnd=True
          ];
        If [viewsread\[Equal]3, foundEnd=True
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadViewChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      (* move to the new chunk position *)
      Return[chunkLength]
      ];



ReadBackgrChunk[]:=Module[
{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4},
      (* 2 id+4 pointer *)
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadBackgrChunk]];
      
      While [foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch[tempint,
          
          COLRGB,
          PrintFoundChunk["COLRGB Color def (RGB)",tempint];
          intCounter+=ReadRGBColor[],
          
          COLTRU,
          PrintFoundChunk["COLRGB Color def (RGB)",tempint];
          intCounter+=ReadTrueColor[],
          
          _,
          PrintFalseItem[SymbolName[ReadBackgrChunk],intCounter,tempint]
          ];
        
        PrintOverShoot[SymbolName[ReadBackgrChunk],intCounter,chunkLength];
        If[intCounter==chunkLength,foundEnd=True
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadBackgrChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      (* move to the new chunk position *)
      Return[chunkLength]
      ];



ReadAmbientChunk[]:=Module[
{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4},
      (* 2 id+4 pointer *)
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadAmbientChunk]];
      
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch[ tempint,
          
          COLRGB,
          PrintFoundChunk["COLRGB Color def (RGB)",tempint];
          intCounter+=ReadRGBColor[],
          
          COLTRU,
          PrintFoundChunk["COLTRU Color def (24bit)",tempint];
          intCounter+=ReadTrueColor[],
          
          _,
          PrintFalseItem[SymbolName[ReadAmbientChunk],intCounter,tempint]
          ];
        
        PrintOverShoot[SymbolName[ReadAmbientChunk],intCounter,chunkLength];
        If[intCounter==chunkLength,foundEnd=True
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadAmbientChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      (* move to the new chunk position *)
      Return[chunkLength]
      ];



ReadVerticesChunk[]:=Module[{currentPointer,chunkLength,vertices, numbv},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadVerticesChunk]];
      
      numbvertices=ReadInt[];
      vertices=Table[{ReadReal[],ReadReal[],ReadReal[]},{numbvertices}];
      verticesList={verticesList,Nodes[vertices]};
      If[DebugFlag,
        Print["      Found (",numbvertices,") vertices:"];
        Print["      ",TableForm[vertices]];
        ];
      
      PrintExitData[currentPointer,chunkLength,
        SymbolName[ReadVerticesChunk]]; 
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadFacesChunk[]:=
    Module[{foundEnd=False,currentPointer,chunkLength,tempdiff,faces,
        intCounter=4,tempint}, (* a,b,c,Diff (Diff= AB: BC: CA: ) *)
      
      currentPointer=GetChunkFilePointer[];
      chunkLength   =ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadFacesChunk]];
      
      numbfaces =ReadInt[];
      intCounter+=2;
      
      faces=Table[
          {ReadInt[],ReadInt[],ReadInt[],tempdiff=BitAnd[ReadInt[],16^^000F];
            BitAnd[tempdiff,16^^0004]/4,BitAnd[tempdiff,16^^0002]/2,
            BitAnd[tempdiff,16^^0001]},{numbfaces}];
      If[DebugFlag,
        Print["      Found (",numbfaces,") faces"];
        Print["      ",TableForm[faces]]
        ];
      intCounter+=numbfaces*8;
      facesList={facesList,Panel[faces]};
      
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch[tempint,
          
          TRIMATERIAL,
          PrintFoundChunk["TRIMATERIAL",tempint];
          intCounter+=ReadUnknownChunk[TRIMATERIAL],
          
          TRISMOOTH,
          PrintFoundChunk["TRISMOOTH",tempint];
          intCounter+=ReadSmoothingChunk[],
          
          _,
          PrintFalseItem[SymbolName[ReadFacesChunk],intCounter,tempint]
          ];
        PrintOverShoot[SymbolName[ReadFacesChunk],intCounter,chunkLength];
        If[intCounter==chunkLength, foundEnd=True]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadFacesChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return [chunkLength];
      ];



ReadTranslationChunk[]:=Module[{currentPointer,chunkLength},
      currentPointer=GetChunkFilePointer[];
      chunkLength   =ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadTranslationChunk]];
      
      transmat={{ReadReal[],ReadReal[],ReadReal[],0.},{ReadReal[],ReadReal[],
            ReadReal[],0.},{ReadReal[],ReadReal[],ReadReal[],0.},{ReadReal[],
            ReadReal[],ReadReal[],1.}};
      transmatList={transmatList, TRANS[transmat]};
      If[DebugFlag,
        Print["     The translation matrix is: ",MatrixForm[transmat]]
        ];
      
      PrintExitData[currentPointer,chunkLength,
        SymbolName[ReadTranslationChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadBooleanChunk[]:=Module[
      {currentPointer,chunkLength,boolean},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,
        SymbolName[ReadBooleanChunk]];
      
      boolean=ReadChar[];
      If[boolean\[Equal]0,boolean=False,boolean=True];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadBooleanChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[{chunkLength,boolean}]
      ];



ReadObjChunk[]:=
    Module[{foundEnd=False,boolean=True,tempint,currentPointer,chunkLength,
        intCounter=4,tmp},
      (* 2 id+4 pointer *)
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadObjChunk]];
      
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch[tempint,
          
          TRIVERTEXL,
          PrintFoundChunk["TRIVERTEXL Object vertices",tempint];
          intCounter+=ReadVerticesChunk[],
          
          TRIFACEL1,
          PrintFoundChunk["TRIFACEL1 Object faces (1)",tempint];
          intCounter+=ReadFacesChunk[],
          
          TRIFACEL2,
          PrintFoundChunk["TRIFACEL2 Object faces (2)",tempint];
          intCounter+=ReadUnknownChunk[tempint],
          
          TRILOCAL,
          PrintFoundChunk["TRILOCAL Object translation",tempint];
          intCounter+=ReadTranslationChunk[],
          
          TRIVISIBLE,
          PrintFoundChunk["TRIVISIBLE Object vis/invis",tempint];
          {tmp,boolean}=ReadBooleanChunk[];
          intCounter+=tmp,
          
          TRIUNKNWN01,
          PrintFoundChunk["TRIUNKNWN01 Object faces (2)",tempint];
          intCounter+=ReadUnknownChunk[tempint],
          
          _,
          PrintFalseItem[SymbolName[ReadObjChunk],intCounter,tempint]
          ];
        
        PrintOverShoot[SymbolName[ReadObjChunk],intCounter,chunkLength];
        If[intCounter==chunkLength, foundEnd=True]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadObjChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadLightChunk[]:=Module[{foundEnd=False,boolean,
        tempint,currentPointer,chunkLength,intCounter=4,lightcoors,tmp}, (* 
        2 id+4 pointer *) 
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadLightChunk]];
      
      lightcoors={ReadReal[],ReadReal[],ReadReal[]};
      If[DebugFlag,
        Print["     Found light at coordinates: X: ",lightcoors[[1]],", Y: ",
          lightcoors[[2]],", Z: ",lightcoors[[3]]]
        ];
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=0;
        
        Switch[tempint,
          LITUNKNWN01,
          PrintFoundChunk["LITUNKNWN01 Light",tempint];
          intCounter+=ReadUnknownChunk[LITUNKNWN01],
          
          LITOFF,
          PrintFoundChunk["LITOFF Light is (on/off)",tempint];
          {tmp,boolean}=ReadBooleanChunk[];
          intCounter+=tmp;
          If[DebugFlag,
            If[ (boolean\[Equal]True) ,
              Print["      Light is on"],
              Print["      Light is off"]
              ]
            ],
          
          LITSPOT,
          PrintFoundChunk["LITSPOT SpotLight",tempint];
          intCounter+=ReadSpotChunk[],
          
          COLRGB,
          PrintFoundChunk["COLRGB Color def (RGB)",tempint];
          intCounter+=ReadRGBColor[],
          
          COLTRU,
          PrintFoundChunk["COLTRU Color def (24bit)",tempint];
          intCounter+=ReadTrueColor[],
          
          _,
          PrintFalseItem[SymbolName[ReadLightChunk],intCounter,tempint]
          ];
        
        PrintOverShoot[SymbolName[ReadLightChunk],intCounter,chunkLength];
        if[intCounter==chunkLength,foundEnd=True
          ];
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadLightChunk]]; 
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength]
      ];



ReadCameraChunk[]:=

    Module[{currentPointer,chunkLength,cameraeye,camerafocus,rotation,lens},
      currentPointer=GetChunkFilePointer[];
      chunkLength   =ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadCameraChunk]];
      
      cameraeye={ReadReal[],ReadReal[],ReadReal[]};
      If[DebugFlag,
        Print["     Found Camera viewpoint at coordinates: X: ",
          cameraeye[[1]],", Y: ",cameraeye[[2]],", Z: ",cameraeye[[3]]]
        ];
      camerafocus={ReadReal[],ReadReal[],ReadReal[]};
      If[DebugFlag,
        Print["     Found Camera focus coors at coordinates: X: ",
          camerafocus [[1]],", Y: ",camerafocus [[2]],",Z: ",
          camerafocus [[3]]]
        ];
      rotation=ReadReal[];
      lens=ReadReal[];
      If[DebugFlag,
        Print["     Rotation of camera is:  ",rotation];
        Print["     Lens in used camera is: ",lens,"mm"]
        ];
      
      If[(chunkLength-38)>0, (* this means more chunks are to follow *)
      
          If[DebugFlag,
          Print["     **** found extra cam chunks ****"]
          ];
        If[ReadInt[]==CAMUNKNWN01,
          If[DebugFlag,
            PrintFoundChunk["CAMUNKNWN01",tempint];
            Print["     **** Found cam 1 type ch ****"]
            ];
          ReadUnknownChunk[CAMUNKNWN01]
          ];
        
        If[ReadInt[]==CAMUNKNWN02,
          If[DebugFlag,
            PrintFoundChunk["CAMUNKNWN02",tempint];
            Print["     **** Found cam 2 type ch ****"]
            ];
          ReadUnknownChunk[CAMUNKNWN02]
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadCameraChunk]]; 
      ChangeChunkPointer[currentPointer+chunkLength];
      Return[chunkLength];
      ];



ReadObjectChunk[]:=
    Module[{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4,
        tmp},
      (* 2 id+4 pointer *)
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadObjectChunk]];
      
      intCounter+=(tmp=ReadName[]);
      If[DebugFlag,
        If[tmp\[Equal]0,
          Print["* Dummy Object found"]
          ]
        ];
      
      While[ foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch [tempint,
          
          OBJUNKNWN01,
          PrintFoundChunk["OBJUNKNWN01",tempint];
          intCounter+=ReadUnknownChunk[OBJUNKNWN01],
          
          OBJUNKNWN02,
          PrintFoundChunk["OBJUNKNWN02",tempint];
          intCounter+=ReadUnknownChunk[OBJUNKNWN02],
          
          OBJTRIMESH,
          PrintFoundChunk["OBJTRIMESH Obj/Mesh",tempint];
          intCounter+=ReadObjChunk[],
          
          OBJLIGHT,
          PrintFoundChunk["OBJLIGHT Light",tempint];
          intCounter+=ReadLightChunk[],
          
          OBJCAMERA,
          PrintFoundChunk["OBJCAMERA Camera",tempint];
          intCounter+=ReadCameraChunk[],
          
          _,
          PrintFalseItem[SymbolName[ReadObjectChunk],intCounter,tempint]
          ];
        
        PrintOverShoot[SymbolName[ReadObjectChunk],intCounter,chunkLength];
        If[intCounter==chunkLength,
          foundEnd=True
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadObjectChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];
      (* move to the new chunk position *)
      Return[chunkLength]
      ];



ReadEditChunk[]:=
    Module[{foundEnd=False,tempint,currentPointer,chunkLength,intCounter=4},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadEditChunk]];
      
      While[foundEnd\[Equal]False,
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch[tempint,
          
          EDITUNKNW01,
          PrintFoundChunk["EDITUNKNW01",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW01],
          
          EDITUNKNW02,
          PrintFoundChunk["EDITUNKNW02",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW02],
          
          EDITUNKNW03,
          PrintFoundChunk["EDITUNKNW03",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW03],
          
          EDITUNKNW04,
          PrintFoundChunk["EDITUNKNW04",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW04],
          
          EDITUNKNW05,
          PrintFoundChunk["EDITUNKNW05",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW05],
          
          EDITUNKNW06,
          PrintFoundChunk["EDITUNKNW06",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW06],
          
          EDITUNKNW07,
          PrintFoundChunk["EDITUNKNW07",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW07],
          
          EDITUNKNW08,
          PrintFoundChunk["EDITUNKNW08",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW08],
          
          EDITUNKNW09,
          PrintFoundChunk["EDITUNKNW09",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW09],
          
          EDITUNKNW10,
          PrintFoundChunk["EDITUNKNW10",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW10],
          
          EDITUNKNW11,
          PrintFoundChunk["EDITUNKNW11",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW11],
          
          EDITUNKNW12,
          PrintFoundChunk["EDITUNKNW12",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW12],
          
          EDITUNKNW13,
          PrintFoundChunk["EDITUNKNW13",tempint];
            intCounter+=ReadUnknownChunk[EDITUNKNW13],
          
          EDITUNKNW14,
          PrintFoundChunk["EDITUNKNW14",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW14],
          
          EDITUNKNW15,
          PrintFoundChunk["EDITUNKNW15",tempint];
          intCounter+=ReadUnknownChunk[EDITUNKNW15],
          
          EDITCONFIG1,
          PrintFoundChunk["EDITCONFIG1",tempint];
          intCounter+=ReadUnknownChunk[EDITCONFIG1],
          
          EDITCONFIG2,
          PrintFoundChunk["EDITCONFIG2",tempint];
          intCounter+=ReadUnknownChunk[EDITCONFIG2],
          
          EDITVIEWP1,
          PrintFoundChunk["EDITVIEWP1",tempint];
          intCounter+=ReadUnknownChunk[EDITVIEWP1],
          
          EDITVIEWP2,
          PrintFoundChunk["EDITVIEWP2",tempint];
          intCounter+=ReadUnknownChunk[EDITVIEWP2],
          
          EDITVIEWP3,
          PrintFoundChunk["EDITVIEWP3",tempint];
          intCounter+=ReadUnknownChunk[EDITVIEWP3],
          
          EDITMATERIAL,
          PrintFoundChunk["EDITMATERIAL Materials",tempint];
          intCounter+=ReadMaterialChunk[],
          
          EDITVIEW1,
          PrintFoundChunk["EDITVIEW1 View main def.",tempint];
          intCounter+=ReadViewChunk[],
          
          EDITBACKGR,
          PrintFoundChunk["EDITBACKGR Background",tempint];
          intCounter+=ReadBackgrChunk[],
          
          EDITAMBIENT,
          PrintFoundChunk["EDITAMBIENT Ambient",tempint];
          intCounter+=ReadAmbientChunk[],
          
          EDITOBJECT,
          PrintFoundChunk["EDITOBJECT Object",tempint];
          intCounter+=ReadObjectChunk[],
          
          _,
          PrintFalseItem[SymbolName[ReadEditChunk],intCounter,tempint]
          ];
        PrintOverShoot[SymbolName[ReadEditChunk],intCounter,chunkLength];
        If[intCounter==chunkLength,
          foundEnd=True
          ]
        ];
      
      PrintExitData[currentPointer,chunkLength,SymbolName[ReadEditChunk]];
      ChangeChunkPointer[currentPointer+chunkLength];Return [chunkLength]
      ];





ReadMainChunk[]:=Module[
{ foundEnd=False,tempint,currentPointer,chunkLength,
        intCounter=4 (* Skip the header data *)},
      currentPointer=GetChunkFilePointer[];
      chunkLength=ReadChunkLength[];
      PrintEntryData[currentPointer,chunkLength,SymbolName[ReadMainChunk]];
      
      While[(foundEnd\[Equal]False),
        tempint=ReadInt[];
        intCounter+=2;
        
        Switch [tempint,
          KEYF3DS,
          PrintFoundChunk["KEYF3DS Keyframer",tempint];
          intCounter+=ReadKeyfChunk[],
          
          EDIT3DS,
          PrintFoundChunk["EDIT3DS Editor",tempint];
          intCounter+=ReadEditChunk[],
          
          _,
          PrintSkippedItem[SymbolName[ReadMainChunk],intCounter,tempint]
          ];
        
        If[intCounter==chunkLength, 
          foundEnd=True;
          PrintExitData[currentPointer,chunkLength,SymbolName[ReadMainChunk]]
          ]
        ]
      
      ];





ReadPrimaryChunk[]:=Module[{version},
      If[ReadInt[]\[Equal]MAIN3DS,
        PrintFoundChunk["MAIN3DS Main",MAIN3DS];
        (* find version number *)
        fseek[bin3ds,28,SEEKSET];
        version=ReadChar[];
        If [version<3,
          
          Print["Sorry this lib can only read 3ds files of version 3.0 and higher"]\
;
          Print ["The version of the file you want to read is: ",version];
          Abort[]
          ];
        fseek[bin3ds,2,SEEKSET];
        ReadMainChunk[];
        Return [True]
        ,
        Return [True]
        ];
      Return [False]
      ];





Options[imsRead3DS]={imsRead3DSDebug\[Rule]False,imsWireframe\[Rule]True};
imsRead3DS[fileName_String,myOptions___]:=
    Module[{data,drawWireframe,drawHead},
      verticesList={};
      facesList={};
      transmatList={};
      DebugFlag=imsRead3DSDebug/.{myOptions}/.Options[imsRead3DS];
      drawWireframe=imsWireframe/.{myOptions}/.Options[imsRead3DS];
      If[drawWireframe\[Equal]True,
        drawHead=Line,drawHead=Polygon];
      
      bin3ds=OpenRead[fileName,BinaryFormat\[Rule]True];
      imsClearStatus[];
      imsShowStatus[ "Loading 3ds binary file: " <> fileName ];
      While[!ReadPrimaryChunk[]];
      Close[bin3ds];
      
      verticesList=Flatten[verticesList];
      facesList=Flatten[facesList];
      transmatList=Flatten[transmatList];
      
      imsShowStatus[ "Finished loading 3ds binary file: " <> fileName ];
      
      If[Length[verticesList]\[NotEqual]Length[facesList],
        Print[
          "FILE (READ) ERROR: Number of node and face packets not equal."],
        data=Table[
            
            drawHead[(verticesList\[LeftDoubleBracket]i,
                        1\[RightDoubleBracket])[[#]]]&/@((Drop[#,-3]+1)&/@(\
facesList\[LeftDoubleBracket]i,1\[RightDoubleBracket])),
            {i,1,Length[verticesList]}
            ]
        ];
      If[drawWireframe\[Equal]True,
        Return[Graphics3D[{data}]],
        Return[Graphics3D[{EdgeForm[],data}]]
        ];
      
      ];



End[] (* of Begin Private *)



(* Protect[] (* anything *) *)
EndPackage[] 















































































































































































































































































































