(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.2'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[    164169,       5011]*)
(*NotebookOutlinePosition[    164831,       5034]*)
(*  CellTagsIndexPosition[    164787,       5030]*)
(*WindowFrame->Normal*)



Notebook[{

Cell[CellGroupData[{
Cell[TextData[StyleBox[" 3D-Studio File Format (.3ds, from Autodesk Ltd.) \
Import package",
  FontWeight->"Bold",
  FontColor->RGBColor[0, 0, 1]]], "Subtitle"],

Cell[CellGroupData[{

Cell["Introduction", "Section"],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Title : \ Read3ds . 
          m\ *) \)\(\[IndentingNewLine]\)\( (*\ \(Context\)\(:\)\ *) \)\(\
\[IndentingNewLine]\)\( (*\ 
      Author : jan\ korvink\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Date : \ 23.11  .2005, \ \[IndentingNewLine]Freiburg\ vs\ Karlsruhe, \ 
      in\ ICE\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Summary : \ 
        This\ handles\ 3  ds\ files\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Package\ \(Copyright : \ GNU\ GPL\)\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Package\ \(Version : \ 0.2  .1\)\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Mathematica\ \(Version : \ 5.2\)\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      History : \ \[IndentingNewLine]Initial\ *) \)\(\[IndentingNewLine]\)\( \
(*\ \(Keywords\)\(:\)\ *) \)\(\[IndentingNewLine]\)\( (*\ \(Sources\)\(:\)\ \
*) \)\(\[IndentingNewLine]\)\( (*\ \(Warnings\)\(:\)\ *) \)\(\
\[IndentingNewLine]\)\( (*\ \(Limitations\)\(:\)\ \
*) \)\(\[IndentingNewLine]\)\( (*\ \(Discussion\)\(:\)\ *) \)\(\
\[IndentingNewLine]\)\( (*\ \(Requirements\)\(:\)\ *) \)\(\[IndentingNewLine]\
\)\( (*\ \(Examples\)\(:\)\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\)\)], \
"Input",
  InitializationCell->True],

Cell[CellGroupData[{

Cell["Disclaimer", "Subsubsection"],

Cell[BoxData[
    \(\(\( (*\ Whereever\ the\ GNU\ GPL\ is\ not\ applicable, \ 
      the\ software\ should\ be\ used\ in\ the\ same\ \(\(spirit\)\(.\)\)\ \
*) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      Users\ of\ this\ code\ must\ verify\ correctness\ for\ their\ \
\(\(application\)\(.\)\)\ *) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\
\( (*\ Free\ Software\ Foundation, \(\(Inc\)\(.\)\), 59\ Temple\ Place, 
      Suite\ 330, Boston, MA\ 02111 - 1307\ USA\ *) \)\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(\( (*\ \(Disclaimer\)\(:\)\ *) \)\(\[IndentingNewLine]\)\(\
\[IndentingNewLine]\)\( (*\ 
      3  DS\ file\ import\ \ \
*) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      Copyright\ \((C)\)\ 2005\ Jan\ G . \ 
          Korvink\ *) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ \
\(This\ program\ is\ free\ software;\)\ *) \)\(\[IndentingNewLine]\)\(\
\[IndentingNewLine]\)\( (*\ 
      you\ can\ redistribute\ it\ and/
          or\ modify\ it\ under\ the\ terms\ of\ the\ GNU\ General\ Public\ \
License\ *) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ \(as\ \
published\ by\ the\ Free\ Software\ Foundation; 
      either\ version\ 2\ of\ the\ License\)\(,\)\ *) \)\(\[IndentingNewLine]\
\)\(\[IndentingNewLine]\)\( (*\ 
      or\ \((at\ your\ option)\)\ any\ later\ version . 
          This\ program\ is\ distributed\ in\ the\ hope\ that\ *) \)\(\
\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      it\ will\ be\ useful, \(but\ WITHOUT\ ANY\ WARRANTY;\)\ *) \)\(\
\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      without\ even\ the\ implied\ warranty\ of\ MERCHANTABILITY\ or\ FITNESS\
\ FOR\ A\ PARTICULAR\ \(\(PURPOSE\)\(.\)\)\ *) \)\(\[IndentingNewLine]\)\(\
\[IndentingNewLine]\)\( (*\ 
      See\ the\ GNU\ General\ Public\ License\ for\ more\ details . \ 
          You\ should\ have\ received\ a\ copy\ of\ \
*) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      the\ GNU\ General\ Public\ License\ along\ with\ this\ program; 
      if\ not, \ 
      write\ to\ the\ *) \)\(\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( \
(*\ Free\ Software\ Foundation, \(\(Inc\)\(.\)\), 59\ Temple\ Place, 
      Suite\ 330, Boston, MA\ 02111 - 1307\ USA\ *) \)\)\)], "Input",
  InitializationCell->True],

Cell[TextData[{
  "Notebook \[Copyright] 2003  Jan G. Korvink\n\nJan G. Korvink\nAlte \
Landstrasse 101a\nCH-8803 R\[UDoubleDot]schlikon\nSwitzerland\n",
  Cell[BoxData[
      FormBox[
        ButtonBox[\(korvink@imtek . de\),
          ButtonData:>{
            URL[ "mailto:korvink@imtek.de"], None},
          ButtonStyle->"Hyperlink"], TraditionalForm]]],
  "\n\n (See: ",
  ButtonBox["License.nb",
    ButtonData:>{
      "/usr/groups/simulation/platform/common/mathematica/Documentation/\
English/Imtek/License.nb", "License"},
    ButtonStyle->"Hyperlink"],
  ")\n \nThis program is free software; you can redistribute it and/or modify \
it under the terms of the GNU General Public License as published by the Free \
Software Foundation; either version 2 of the License, or (at your option) any \
later version.\n\nThis program is distributed in the hope that it will be \
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of \
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General \
Public License for more details.\n\nYou should have received a copy of the \
GNU General Public License along with this program; if not, write to the Free \
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 \
 USA"
}], "Author"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Start Package", "Section"],

Cell[BoxData[
    \(\(\( (*\ 
      Start\ Package\ \
*) \)\(\[IndentingNewLine]\)\(BeginPackage["\<Imtek`Interfaces`Read3ds`\>"\ \
];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Documentation // Error - Messages", "Section"],

Cell[CellGroupData[{

Cell["Docu", "Subsection"],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      documentation\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\(\
\[IndentingNewLine]\)\(\[IndentingNewLine]\)\( (*\ 
      constructors\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      selectors\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      predicates\ *) \)\(\n\)\( (*\ 
      functions\ *) \)\(\n\)\(\[IndentingNewLine]\)\(imsRead3DS::usage = \
"\<imsRead3DS[filePath] parses a 3D Studio file, extracts only the vertices \
and faces from the file, and returns these as a Graphics3D object. The \
program can only handle Version 3 files. \n\nNote: Since I had no official \
specification of the file structure, I based the program on a freeware \
C-implementation and extended it to handle all exceptions that occurred in \
files available to me. As more information becomes avalable, the program will \
be extended.\n\nAlso note that the program is slow. It is NOT an example of \
good Mathematica programming!\n\nCurrent Errors: I do not handle the object \
transformations correctly. Thus, if the file describes objects that are still \
to be transformed to their final positions, these are placed at their \
definition positions. This is the current next job.\>";\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Options Docu", "Subsection"],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      options\ docu\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\(\
\[IndentingNewLine]\)\(\[IndentingNewLine]\)\(\(imsRead3DSDebug::usage = \
"\<imsRead3DSDebug->False is the default setting for the imsRead3DS option \
that switches on extensive debug print information. Use with care.\>";\)\
\[IndentingNewLine]
    \(imsWireframe::usage = "\<imsWireframe->False specifies that the \
imported objects are drawn as folled polygons.\>";\)\[IndentingNewLine]
    \)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Error Messages", "Subsection"],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Error\ Messages\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\)\)], "Input",\

  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Start Private", "Section"],

Cell[BoxData[
    \(\(Begin["\<`Private`\>"];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Needs - Private Imports", "Section"],

Cell[BoxData[
    \(\(\( (*\ private\ imports\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      this\ is\ only\ for\ the\ old\ FEMNeumann\ operator\ *) \)\(\
\[IndentingNewLine]\)\(Needs[\ "\<Imtek`ShowStatus`\>"\ ]\[IndentingNewLine]
    << Experimental`\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Functions // Overloads", "Section"],

Cell[CellGroupData[{

Cell["Global Data", "Subsection"],

Cell[BoxData[{
    \(\(MAIN3DS = 16^^4D4D;\)\n\n (*\ 
      Main\ Chunks\ *) \), "\[IndentingNewLine]", 
    \(\(EDIT3DS = 16^^3D3D;\)\  (*\ 
      this\ is\ the\ start\ of\ the\ editor\ config\ *) \), "\n", 
    \(\(KEYF3DS = 16^^B000;\)\  (*\ 
      this\ is\ the\ start\ of\ the\ keyframer\ config\ *) \
\[IndentingNewLine]\n (*\ 
      sub\ defines\ of\ EDIT3DS\ *) \), "\[IndentingNewLine]", 
    \(\(EDITMATERIAL = 16^^AFFF;\)\), "\n", 
    \(\(EDITCONFIG1 = 16^^0100;\)\), "\n", 
    \(\(EDITCONFIG2 = 16^^3E3D;\)\), "\n", 
    \(\(EDITVIEWP1 = 16^^7012;\)\), "\n", 
    \(\(EDITVIEWP2 = 16^^7011;\)\), "\n", 
    \(\(EDITVIEWP3 = 16^^7020;\)\), "\n", 
    \(\(EDITVIEW1 = 16^^7001;\)\), "\n", 
    \(\(EDITBACKGR = 16^^1200;\)\), "\n", 
    \(\(EDITAMBIENT = 16^^2100;\)\), "\n", 
    \(\(\(EDITOBJECT = 16^^4000;\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(EDITUNKNW01 = 16^^1100;\)\), "\n", 
    \(\(EDITUNKNW02 = 16^^1201;\)\), "\n", 
    \(\(EDITUNKNW03 = 16^^1300;\)\), "\n", 
    \(\(EDITUNKNW04 = 16^^1400;\)\), "\n", 
    \(\(EDITUNKNW05 = 16^^1420;\)\), "\n", 
    \(\(EDITUNKNW06 = 16^^1450;\)\), "\n", 
    \(\(EDITUNKNW07 = 16^^1500;\)\), "\n", 
    \(\(EDITUNKNW08 = 16^^2200;\)\), "\n", 
    \(\(EDITUNKNW09 = 16^^2201;\)\), "\n", 
    \(\(EDITUNKNW10 = 16^^2210;\)\), "\n", 
    \(\(EDITUNKNW11 = 16^^2300;\)\), "\n", 
    \(\(EDITUNKNW12 = 16^^2302\ ;\) (*\ new\ chunk\ type\ *) \), "\n", 
    \(\(EDITUNKNW13 = 16^^3000;\)\), "\n", 
    \(\(EDITUNKNW14 = 16^^AFFF;\)\), "\n", 
    \(EDITUNKNW15 = 16^^3D3E; \  (*\ 
      added\ by\ JGK\ *) \n\[IndentingNewLine] (*\ 
      sub\ defines\ of\ EDITMATERIAL\ *) \n
    MATNAME01 = 16^^A000\ ;  (*\ 
      includes\ name\ \((see\ mli\ doc\ for\ materials)\)\ *) \n\
\[IndentingNewLine] (*\ sub\ defines\ of\ EDITOBJECT\ *) \), "\n", 
    \(\(OBJTRIMESH = 16^^4100;\)\), "\n", 
    \(\(OBJLIGHT = 16^^4600;\)\), "\n", 
    \(\(\(OBJCAMERA = 16^^4700;\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(OBJUNKNWN01 = 16^^4010;\)\), "\n", 
    \(\(OBJUNKNWN02 = 16^^4012\ ;\) (*\ 
      Could\ be\ shadow\ *) \[IndentingNewLine]\n (*\ 
      sub\ defines\ of\ OBJCAMERA\ *) \), "\n", 
    \(\(CAMUNKNWN01 = 16^^4710\ ;\) (*\ new\ chunk\ type\ *) \), "\n", 
    \(\(CAMUNKNWN02 = 16^^4720;\)\  (*\ new\ chunk\ type\ *) \n\n (*\ 
      sub\ defines\ of\ OBJLIGHT\ *) \), "\[IndentingNewLine]", 
    \(\(LITOFF = 16^^4620;\)\), "\n", 
    \(\(LITSPOT = 16^^4610;\)\), "\n", 
    \(\(LITUNKNWN01 = 16^^465A;\)\[IndentingNewLine]\n (*\ 
      sub\ defines\ of\ OBJTRIMESH\ *) \), "\n", 
    \(\(TRIVERTEXL = 16^^4110;\)\), "\n", 
    \(\(TRIFACEL2 = 16^^4111;\) (*\ unknown\ yet\ *) \), "\n", 
    \(\(TRIFACEL1 = 16^^4120;\)\), "\n", 
    \(\(TRIMATERIAL = 16^^4130;\)\), "\n", 
    \(\(TRIUNKNWN01 = 16^^4140;\)\), "\n", 
    \(\(TRISMOOTH = 16^^4150;\)\), "\n", 
    \(\(TRILOCAL = 16^^4160;\)\), "\n", 
    \(\(TRIVISIBLE = 16^^4165;\)\n\[IndentingNewLine] (*\ 
      sub\ defs\ of\ KEYF3DS\ *) \n\), "\[IndentingNewLine]", 
    \(\(KEYFUNKNWN01 = 16^^B009;\)\), "\n", 
    \(\(KEYFUNKNWN02 = 16^^B00A;\)\), "\n", 
    \(\(KEYFFRAMES = 16^^B008;\)\), "\n", 
    \(\(\(KEYFOBJDES = 16^^B002;\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(KEYFOBJHIERARCH = 16^^B010;\)\), "\n", 
    \(\(KEYFOBJDUMMYNAME = 16^^B011;\)\), "\n", 
    \(\(KEYFOBJUNKNWN01 = 16^^B013;\)\), "\n", 
    \(\(KEYFOBJUNKNWN02 = 16^^B014;\)\), "\n", 
    \(\(KEYFOBJUNKNWN03 = 16^^B015;\)\), "\n", 
    \(\(KEYFOBJPIVOT = 16^^B020;\)\), "\n", 
    \(\(KEYFOBJUNKNWN04 = 16^^B021;\)\), "\n", 
    \(\(KEYFOBJUNKNWN05 = 16^^B022;\)\n\n (*\ 
      these\ define\ the\ different\ color\ chunk\ types\ *) \), "\
\[IndentingNewLine]", 
    \(\(COLRGB = 16^^0010;\)\), "\n", 
    \(\(COLTRU = 16^^0011;\)\), "\n", 
    \(\(COLUNK = 16^^0013;\) (*\ unknown\ *) \[IndentingNewLine]\n (*\ 
      defines\ for\ viewport\ chunks\ *) \), "\n", 
    \(\(TOP = 16^^0001;\)\), "\n", 
    \(\(BOTTOM = 16^^0002;\)\), "\n", 
    \(\(LEFT = 16^^0003;\)\), "\n", 
    \(\(RIGHT = 16^^0004;\)\), "\n", 
    \(\(FRONT = 16^^0005;\)\), "\n", 
    \(\(BACK = 16^^0006;\)\), "\n", 
    \(\(USER = 16^^0007;\)\), "\n", 
    \(\(CAMERA = 16^^0008;\)\  (*\ 
      16^^FFFF\ is\ the\ code\ read\ from\ file\ *) \), "\n", 
    \(\(LIGHT = 16^^0009;\)\), "\n", 
    \(\(DISABLED = 16^^0010;\)\), "\n", 
    \(\(BOGUS = 16^^0011;\)\)}], "Input",
  InitializationCell->True],

Cell[BoxData[{
    \(\(bin3ds = 0;\)\), "\[IndentingNewLine]", 
    \(\(\(data = {};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(currentchunk = 0;\)\), "\[IndentingNewLine]", 
    \(\(viewsread = 0;\)\), "\[IndentingNewLine]", 
    \(\(numbfaces = 0;\)\), "\[IndentingNewLine]", 
    \(\(numbvertices = 0;\)\), "\[IndentingNewLine]", 
    \(\(viewports = {};\)\), "\[IndentingNewLine]", 
    \(\(tempname = "\<\>";\)\), "\[IndentingNewLine]", 
    \(\(transmat = Table[0, {4}, {4}];\)\  (*\ 
      translation\ matrix\ for\ objects\ *) \), "\[IndentingNewLine]", 
    \(\(verticesList = {};\)\), "\[IndentingNewLine]", 
    \(\(facesList = {};\)\), "\[IndentingNewLine]", 
    \(\(\(transmatList = {};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(DebugFlag = False;\)\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Reading and Pointer Utilities", "Subsection"],

Cell["\<\
A short is always a two byte integer.
A long is always a four byte integer.
A float is always a four byte IEEE floating point number.
A cstr is a zero byte terminated ASCII string without a length.
A char is a single byte integer.\
\>", "Text"],

Cell[BoxData[
    \(\(fseek[fileHandle_, position_, whence_] := 
        Module[{absPosition}, \[IndentingNewLine]If[
              whence == SEEKSET, \[IndentingNewLine]absPosition = 
                position\[IndentingNewLine]]; \[IndentingNewLine]If[
              whence == SEEKCUR, \[IndentingNewLine]absPosition = 
                position + 
                  StreamPosition[
                    fileHandle]\[IndentingNewLine]]; \
\[IndentingNewLine]SetStreamPosition[fileHandle, 
              absPosition]\[IndentingNewLine]] /; \((whence == SEEKSET || 
              whence == SEEKCUR)\);\)\)], "Input",
  InitializationCell->True],

Cell["Old code I leave here just as a reminder!", "Text"],

Cell[BoxData[
    \(\(\( (*\[IndentingNewLine]<< 
        Utilities`BinaryFiles`\[IndentingNewLine]*) \)\(\[IndentingNewLine]\)\
\( (*\[IndentingNewLine]ReadInt[] := 
        ReadBinary[bin3ds, Int16, 
          ByteOrder \[Rule] LeastSignificantByteFirst]; \n
      ReadChar[] := ReadBinary[bin3ds, Int8]; \n
      ReadLong[] := 
        ReadBinary[bin3ds, Int32, 
          ByteOrder \[Rule] LeastSignificantByteFirst]; \n
      ReadReal[] := 
        convertIEEENumber[
          ReadBinary[bin3ds, Int32, 
            ByteOrder \[Rule] 
              LeastSignificantByteFirst]];\[IndentingNewLine]*) \)\)\)], \
"Input"],

Cell[BoxData[{
    \(\(ReadInt[] := 
        BinaryRead[bin3ds, "\<UnsignedInteger16\>", 
          ByteOrdering \[Rule] \(-1\)];\)\), "\n", 
    \(\(ReadChar[] := BinaryRead[bin3ds, "\<UnsignedInteger8\>"];\)\), "\n", 
    \(\(ReadLong[] := 
        BinaryRead[bin3ds, "\<UnsignedInteger32\>", 
          ByteOrdering \[Rule] \(-1\)];\)\), "\n", 
    \(\(ReadReal[] := 
        convertIEEENumber[
          BinaryRead[bin3ds, "\<UnsignedInteger32\>", 
            ByteOrdering \[Rule] \(-1\)]];\)\)}], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(convertIEEENumber[num_] := 
        Module[{myDigits, sgnPart, exponentPart, 
            mantissaPart}, \[IndentingNewLine]myDigits = 
            IntegerDigits[num, 2, 32]; \[IndentingNewLine]{sgnPart, 
              exponentPart, mantissaPart} = {myDigits[\([1]\)], 
              myDigits[\([Range[2, 9]]\)], 
              myDigits[\([Range[10, 32]]\)]}; \[IndentingNewLine]If[
            sgnPart \[Equal] 0, sgnPart = 1, 
            sgnPart = \(-1\)]; \[IndentingNewLine]exponentPart = 
            2^\((FromDigits[exponentPart, 2] - 
                  127)\); \[IndentingNewLine]mantissaPart = 
            FromDigits[{Join[{1}, mantissaPart], 1}, 
              2]; \[IndentingNewLine]Return[
            N[sgnPart*exponentPart*
                mantissaPart]]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\(GetChunkFilePointer[] := 
        StreamPosition[bin3ds];\)\(\[IndentingNewLine]\)
    \(\ \)\)\( (*\ 
      compensate\ for\ the\ already\ read\ Marker\ *) \)\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(ReadChunkLength[] := ReadLong[] - 2;\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(ChangeChunkPointer[chunkLength_] := 
        fseek[bin3ds, chunkLength, SEEKSET];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[{
    \(\(tempname = {tempname, 0};\)\), "\[IndentingNewLine]", 
    \(\(tempname = {tempname, 0};\)\)}], "Input"],

Cell[BoxData[
    \(\(ReadName[] := 
        Module[{charCounter = 1, letter, 
            tempname = {}}, \[IndentingNewLine]letter = 
            ReadChar[]; \[IndentingNewLine]if[letter \[Equal] 0, 
            Return[charCounter]]; \[IndentingNewLine] (*\ 
            dummy\ object\ *) \ \[IndentingNewLine]tempname = {tempname, 
              letter}; \[IndentingNewLine]\(charCounter++\); \
\[IndentingNewLine]While\ [
            letter \[NotEqual] 
                0 && \((charCounter <= 12)\), \[IndentingNewLine]letter = 
              ReadChar[]; \[IndentingNewLine]tempname = {tempname, 
                letter}; \[IndentingNewLine]\(charCounter++\)\
\[IndentingNewLine]]; \[IndentingNewLine]\(--charCounter\); \
\[IndentingNewLine]tempname = 
            FromCharacterCode[
              Drop[Flatten[tempname], \(-1\)]]; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found name : \"\>", 
              tempname, "\<\" of length: \>", 
              charCounter]\[IndentingNewLine]]; \[IndentingNewLine]Return[
            charCounter]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(ReadLongName[] := 
        Module[{charCounter = 1, letter, 
            tempname = {}}, \[IndentingNewLine]letter = 
            ReadChar[]; \[IndentingNewLine]if[letter \[Equal] 0, 
            Return[charCounter]]; \[IndentingNewLine] (*\ 
            dummy\ object\ *) \ \[IndentingNewLine]tempname = {tempname, 
              letter}; \[IndentingNewLine]\(charCounter++\); \
\[IndentingNewLine]While\ [\((letter \[NotEqual] 
                0)\), \[IndentingNewLine]letter = 
              ReadChar[]; \[IndentingNewLine]tempname = {tempname, 
                letter}; \[IndentingNewLine]\(charCounter++\)\
\[IndentingNewLine]]; \[IndentingNewLine]\(--charCounter\); \
\[IndentingNewLine]tempname = 
            FromCharacterCode[
              Drop[Flatten[tempname], \(-1\)]]; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found name : \"\>", 
              tempname, "\<\" of length: \>", 
              charCounter]\[IndentingNewLine]]; \[IndentingNewLine]Return[
            charCounter]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(ReadRGBColor[] := 
        Module[{rgbval}, \[IndentingNewLine]rgbval = {ReadReal[], ReadReal[], 
              ReadReal[]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found Color (RGB) def \
of: R: \>", rgbval[\([1]\)], "\<,G: \>", rgbval[\([2]\)], "\<,B: \>", 
              rgbval[\([3]\)]]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine] (*\ 
            Return\ the\ number\ of\ bytes\ read\ \
*) \[IndentingNewLine]Return[12]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(ReadTrueColor[] := 
        Module[{truecval}, \[IndentingNewLine]truecval = {ReadReal[], 
              ReadReal[], ReadReal[]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found Color (24bit) \
def of: R: \>", truecval[\([1]\)], "\<,G: \>", truecval[\([2]\)], "\<,B: \>", 
              truecval[\([3]\)]]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine] (*\ 
            Return\ the\ number\ of\ bytes\ read\ \
*) \[IndentingNewLine]Return[3]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Debug print statements", "Subsection"],

Cell[BoxData[
    \(\(PrintEntryData[currentPointer_, chunkLength_, functionName_] := 
        Module[{}, \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\< -> In \>", 
              functionName, "\<: Reached position \>", 
              BaseForm[currentPointer, 16], "\< = \>", 
              currentPointer, "\< in file\>"]; \[IndentingNewLine]Print["\<   \
 Chunk length: \>", BaseForm[chunkLength, 16], "\< = \>", 
              chunkLength]\[IndentingNewLine]]\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(PrintExitData[currentPointer_, chunkLength_, functionName_] := 
        Module[{absPosition}, \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]absPosition = 
              currentPointer + 
                chunkLength; \[IndentingNewLine]Print["\<    Read \>", 
              chunkLength, "\<*2 Bytes\>"]; \[IndentingNewLine]Print["\< <- \
Reached position: \>", BaseForm[absPosition, 16], "\< = \>", 
              absPosition, \ "\< in \>", 
              functionName]\[IndentingNewLine]]\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(PrintFoundChunk[chunkName_, chunkId_] := 
        Module[{}, \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\< Found \>", 
              chunkName, "\< chunk id: \>", 
              BaseForm[chunkId, 
                16]]\[IndentingNewLine]]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(PrintFalseItem[functionName_, intCounter_, tempint_] := 
        If[DebugFlag, \[IndentingNewLine]Print["\<*** Error in \>", 
            functionName, "\< found tempint: \>", 
            BaseForm[tempint, 16], "\< = \>", 
            tempint, "\< at intCounter: \>", 
            BaseForm[intCounter, 16], "\< = \>", 
            intCounter]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(PrintSkippedItem[functionName_, intCounter_, tempint_] := 
        If[DebugFlag, \[IndentingNewLine]Print["\<    In \>", 
            functionName, "\< Skipping tempint: \>", 
            BaseForm[tempint, 16], "\< = \>", 
            tempint, "\< at intCounter: \>", 
            BaseForm[intCounter, 16], "\< = \>", 
            intCounter]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(PrintOverShoot[chunkName_, intCounter_, limit_] := 
        If[intCounter > limit, \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<Error in \>", 
              chunkName, "\< intCounter: \>", intCounter, "\< > \>", 
              limit]\[IndentingNewLine]]; \[IndentingNewLine]Abort[]\
\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Read the Key Frame Chunk KEYF3DS and its Components", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
Read the Key Frame Chunk
KEYF3DS: KEYFUNKNWN01, KEYFUNKNWN02, KEYFFRAMES, KEYFOBJDES, EDITVIEW1\
\>", \
"Subsubsection"],

Cell[BoxData[
    \(\(ReadKeyfChunk[] := 
        Module[{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength\ \ \  = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadKeyfChunk]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine] (*\[IndentingNewLine]\(While[\ \((foundEnd \[Equal] 
                    False)\), \[IndentingNewLine]tempint = 
                  ReadInt[]; \[IndentingNewLine]intCounter += 
                  2; \[IndentingNewLine]\[IndentingNewLine]Switch\ [
                  tempint, \
\[IndentingNewLine]\[IndentingNewLine]KEYFUNKNWN01, \
\[IndentingNewLine]PrintFoundChunk["\<KEYFUNKNWN01\>", 
                    tempint]; \[IndentingNewLine]intCounter += 
                    ReadUnknownChunk[
                      tempint], \
\[IndentingNewLine]\[IndentingNewLine]KEYFUNKNWN02, \
\[IndentingNewLine]PrintFoundChunk["\<KEYFUNKNWN02\>", 
                    tempint]; \[IndentingNewLine]intCounter += 
                    ReadUnknownChunk[
                      tempint], \
\[IndentingNewLine]\[IndentingNewLine]KEYFFRAMES, \
\[IndentingNewLine]PrintFoundChunk["\<KEYFFRAMES Keyframer\>", 
                    tempint]; \[IndentingNewLine]intCounter += 
                    ReadUnknownChunk[
                      tempint], \
\[IndentingNewLine]\[IndentingNewLine]KEYFOBJDES, \
\[IndentingNewLine]PrintFoundChunk["\<KEYFOBJDES Keyframer object description\
\>", tempint]; \[IndentingNewLine]intCounter += 
                    ReadUnknownChunk\ \((tempint)\), \[IndentingNewLine]\
\[IndentingNewLine]EDITVIEW1, \[IndentingNewLine]PrintFoundChunk["\<EDITVIEW1 \
View main def\>", tempint]; \[IndentingNewLine]intCounter += 
                    ReadViewChunk[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadKeyfChunk], intCounter, 
                    tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]If[
                  intCounter == chunkLength, \[IndentingNewLine]foundEnd = 
                    True\[IndentingNewLine]]\[IndentingNewLine]];\)\
\[IndentingNewLine]*) \[IndentingNewLine]\[IndentingNewLine]PrintExitData[
            currentPointer, chunkLength, 
            SymbolName[ReadKeyfChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine] (*\ 
            move\ to\ the\ new\ chunk\ position\ *) \[IndentingNewLine]Return\
\ [chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Read the Edit Chunk EDIT3DS and its Components", "Subsection"],

Cell[CellGroupData[{

Cell["\<\
Read the Spot chunk
LITSPOT:\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(\(\n\)\(ReadSpotChunk[] := 
        Module[{currentPointer, chunkLength, target, hotspot, 
            falloff}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength\ \ \  = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadSpotChunk]]; \[IndentingNewLine]\[IndentingNewLine]target = \
{ReadReal[], ReadReal[], ReadReal[]}; \[IndentingNewLine]hotspot = 
            ReadReal[]; \[IndentingNewLine]falloff = 
            ReadReal[]; \[IndentingNewLine]If[DebugFlag, 
            Print["\<      The target of the spot is at: X: \>", 
              target[\([1]\)], "\< Y: \>", target[\([2]\)], "\< Y: \>", 
              target[\([3]\)]]; \[IndentingNewLine]Print["\<      The hotspot \
of this light is : \>", 
              hotspot]; \[IndentingNewLine]Print["\<      The falloff of this \
light is : \>", 
              falloff]\[IndentingNewLine]]; \n\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[ReadSpotChunk]]; 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \ \[IndentingNewLine]Return[
            chunkLength];\[IndentingNewLine]];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Smoothing chunk
TRISMOOTH: \
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadSmoothingChunk[] := 
        Module[{currentPointer, chunkLength, 
            smoothing}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadSmoothingChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]smoothing = 
            Table[ReadLong[], {numbfaces}]; \[IndentingNewLine]If[DebugFlag, 
            Print["\<      The smoothing group is \>", 
              TableForm[
                smoothing]]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[ReadSmoothingChunk]]; 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \ \[IndentingNewLine]Return[
            chunkLength];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read an unknown chunk
The unknown chunks are simply skipped.\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadUnknownChunk[chunkid_] := 
        Module[{currentPointer, 
            chunkLength}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadUnknownChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, 
            SymbolName[
              ReadUnknownChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Material Definition chunk
MATNAME01:\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadMatDefChunk[] := 
        Module[{currentPointer, 
            chunkLength}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadMatDefChunk]]; \[IndentingNewLine]\[IndentingNewLine]If[
            ReadLongName[] \[Equal] 0, \[IndentingNewLine]If[DebugFlag, 
              Print[\ \(("\<* No Material name found\>")\)]]\
\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]PrintExitData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadMatDefChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Material chunk
EDITMATERIAL: MATNAME01\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadMaterialChunk[] := 
        Module[{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadMaterialChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[
              tempint, \[IndentingNewLine]MATNAME01, \
\[IndentingNewLine]PrintFoundChunk["\<MATNAME01 Material Name\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadMatDefChunk[]\[IndentingNewLine]]; \ \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadMaterialChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If\ [
              intCounter == chunkLength, \ 
              foundEnd = 
                True\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, 
            SymbolName[
              ReadMaterialChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Find the Camera chunk
CAMERA: \
\>", "Subsubsection"],

Cell[BoxData[
    \(\(FindCameraChunk[] := 
        Module[{chunkLength = 0, tmp}, \[IndentingNewLine]Table[
            ReadInt[], {12}]; \[IndentingNewLine]chunkLength = 
            12*2; \[IndentingNewLine]chunkLength += \((tmp = 
                ReadName[])\); \[IndentingNewLine]If[
            tmp \[Equal] 0, \[IndentingNewLine]If[DebugFlag, 
              Print[\(("\<* No Camera name found\>")\)]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Viewport chunk
EDITVIEWP1: CAMERA\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadViewPortChunk[] := 
        Module[{\ currentPointer, chunkLength, port, 
            attribs}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadViewPortChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]\(viewsread++\); \
\[IndentingNewLine]attribs = ReadInt[]; \[IndentingNewLine]If[DebugFlag, 
            if[\ \((attribs \[Equal] 
                  3)\), \[IndentingNewLine]Print["\<<Snap> active in viewport\
\>"]\[IndentingNewLine]]; \[IndentingNewLine]if[\((attribs \[Equal] 
                  5)\), \[IndentingNewLine]Print["\<<Grid> active in viewport\
\>"]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]Table[
            ReadInt[], {5}]; \[IndentingNewLine] (*\ 
            read\ 5\ ints\ to\ get\ to\ the\ viewport\ \
*) \[IndentingNewLine]port = 
            ReadInt[]; \[IndentingNewLine]if[\((\((port \[Equal] 
                    16^^FFFF)\) || \((port \[Equal] 
                    0)\))\), \[IndentingNewLine]FindCameraChunk[]; \
\[IndentingNewLine]port = CAMERA;\[IndentingNewLine]]; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<Reading [\>", 
              viewports[\([port]\)], "\<] information with id: \>", \ 
              BaseForm[port, 
                16]]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[
              ReadViewPortChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the View chunk
EDITVIEW1: EDITVIEWP1, EDITVIEWP2, EDITVIEWP3\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadViewChunk[] := 
        Module[{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadViewChunk]]; \[IndentingNewLine]\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]\ 
            intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[\ \
\((tempint)\), \[IndentingNewLine]\[IndentingNewLine]EDITVIEWP1, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEWP1 Viewport\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadViewPortChunk[], \
\[IndentingNewLine]\[IndentingNewLine]EDITVIEWP2, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEWP2 Viewport\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITVIEWP2], \
\[IndentingNewLine]\[IndentingNewLine]EDITVIEWP3, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEWP3 Viewport\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadViewPortChunk[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadViewChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadViewChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If\ [
              intCounter \[Equal] chunkLength, \ 
              foundEnd = True\[IndentingNewLine]]; \[IndentingNewLine]If\ [
              viewsread \[Equal] 3, \ 
              foundEnd = 
                True\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, 
            SymbolName[ReadViewChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine] (*\ 
            move\ to\ the\ new\ chunk\ position\ *) \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Background chunk
EDITBACKGR: COLRGB, COLTRU\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadBackgrChunk[] := 
        Module[\n{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4}, \[IndentingNewLine] (*\ 
            2\ id + 4\ pointer\ *) \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadBackgrChunk]]; \[IndentingNewLine]\[IndentingNewLine]While\ \
[foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[
              tempint, \[IndentingNewLine]\[IndentingNewLine]COLRGB, \
\[IndentingNewLine]PrintFoundChunk["\<COLRGB Color def (RGB)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadRGBColor[], \[IndentingNewLine]\[IndentingNewLine]COLTRU, \
\[IndentingNewLine]PrintFoundChunk["\<COLRGB Color def (RGB)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadTrueColor[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadBackgrChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadBackgrChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If[intCounter == chunkLength, 
              foundEnd = 
                True\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, 
            SymbolName[
              ReadBackgrChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine] (*\ 
            move\ to\ the\ new\ chunk\ position\ *) \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Ambient chunk
EDITAMBIENT: COLRGB, COLTRU\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadAmbientChunk[] := 
        Module[\n{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4}, \[IndentingNewLine] (*\ 
            2\ id + 4\ pointer\ *) \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadAmbientChunk]]; \[IndentingNewLine]\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[\ 
              tempint, \[IndentingNewLine]\[IndentingNewLine]COLRGB, \
\[IndentingNewLine]PrintFoundChunk["\<COLRGB Color def (RGB)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadRGBColor[], \[IndentingNewLine]\[IndentingNewLine]COLTRU, \
\[IndentingNewLine]PrintFoundChunk["\<COLTRU Color def (24bit)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadTrueColor[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadAmbientChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadAmbientChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If[intCounter == chunkLength, 
              foundEnd = 
                True\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, SymbolName[ReadAmbientChunk]]; 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine] (*\ 
            move\ to\ the\ new\ chunk\ position\ *) \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Vertices chunk
TRIVERTEXL:\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadVerticesChunk[] := 
        Module[{currentPointer, chunkLength, vertices, \ 
            numbv}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadVerticesChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]numbvertices = 
            ReadInt[]; \[IndentingNewLine]vertices = 
            Table[{ReadReal[], ReadReal[], 
                ReadReal[]}, {numbvertices}]; \[IndentingNewLine]verticesList \
= {verticesList, Nodes[vertices]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<      Found (\>", 
              numbvertices, "\<) vertices:\>"]; \[IndentingNewLine]Print["\<  \
    \>", TableForm[
                vertices]];\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[ReadVerticesChunk]]; \ 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Faces chunk
TRIFACEL1: TRIMATERIAL, TRISMOOTH\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadFacesChunk[] := 
        Module[{foundEnd = False, currentPointer, chunkLength, tempdiff, 
            faces, intCounter = 4, tempint}, \  (*\ a, b, c, 
            Diff\ \((Diff = \ 
                  AB : \ \(BC : \ \(\(CA\)\(:\)\)\)\ )\)\ \
*) \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength\ \ \  = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadFacesChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]numbfaces\  = 
            ReadInt[]; \[IndentingNewLine]intCounter += 
            2; \[IndentingNewLine]\[IndentingNewLine]faces = 
            Table[\[IndentingNewLine]{ReadInt[], ReadInt[], ReadInt[], 
                tempdiff = BitAnd[ReadInt[], 16^^000F]; 
                BitAnd[tempdiff, 16^^0004]/4, BitAnd[tempdiff, 16^^0002]/2, 
                BitAnd[tempdiff, 
                  16^^0001]}, {numbfaces}]; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<      Found (\>", 
              numbfaces, "\<) faces\>"]; \[IndentingNewLine]Print["\<      \
\>", TableForm[faces]]\[IndentingNewLine]]; \[IndentingNewLine]intCounter += 
            numbfaces*8; \[IndentingNewLine]facesList = {facesList, 
              Panel[faces]}; \[IndentingNewLine]\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[
              tempint, \[IndentingNewLine]\[IndentingNewLine]TRIMATERIAL, \
\[IndentingNewLine]PrintFoundChunk["\<TRIMATERIAL\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  TRIMATERIAL], \
\[IndentingNewLine]\[IndentingNewLine]TRISMOOTH, \
\[IndentingNewLine]PrintFoundChunk["\<TRISMOOTH\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadSmoothingChunk[], \
\[IndentingNewLine]\[IndentingNewLine]_, \[IndentingNewLine]PrintFalseItem[
                SymbolName[ReadFacesChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadFacesChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If[
              intCounter == chunkLength, \ 
              foundEnd = 
                True]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[ReadFacesChunk]]; 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return\ [
            chunkLength];\n];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Translation chunk
TRILOCAL:\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadTranslationChunk[] := 
        Module[{currentPointer, 
            chunkLength}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength\ \ \  = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadTranslationChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]transmat = {{ReadReal[], ReadReal[], 
                ReadReal[], 0. }, {ReadReal[], ReadReal[], ReadReal[], 
                0. }, {ReadReal[], ReadReal[], ReadReal[], 0. }, {ReadReal[], 
                ReadReal[], ReadReal[], 
                1. }}; \[IndentingNewLine]transmatList = {transmatList, \ 
              TRANS[transmat]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     The translation \
matrix is: \>", 
              MatrixForm[
                transmat]]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[
              ReadTranslationChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Boolean chunk
TRIVISIBLE:\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadBooleanChunk[] := 
        Module[\[IndentingNewLine]{currentPointer, chunkLength, 
            boolean}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadBooleanChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]boolean = 
            ReadChar[]; \[IndentingNewLine]If[boolean \[Equal] 0, 
            boolean = False, 
            boolean = 
              True]; \[IndentingNewLine]\[IndentingNewLine]PrintExitData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadBooleanChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + 
              chunkLength]; \[IndentingNewLine]Return[{chunkLength, 
              boolean}]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Obj chunk
OBJTRIMESH: TRIVERTEXL, TRIFACEL1, TRIFACEL2, TRILOCAL, TRIVISIBLE\
\>", \
"Subsubsection"],

Cell[BoxData[
    \(\(ReadObjChunk[] := 
        Module[{foundEnd = False, boolean = True, tempint, currentPointer, 
            chunkLength, intCounter = 4, tmp}, \[IndentingNewLine] (*\ 
            2\ id + 4\ pointer\ *) \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadObjChunk]]; \[IndentingNewLine]\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[
              tempint, \[IndentingNewLine]\[IndentingNewLine]TRIVERTEXL, \
\[IndentingNewLine]PrintFoundChunk["\<TRIVERTEXL Object vertices\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadVerticesChunk[], \
\[IndentingNewLine]\[IndentingNewLine]TRIFACEL1, \
\[IndentingNewLine]PrintFoundChunk["\<TRIFACEL1 Object faces (1)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadFacesChunk[], \
\[IndentingNewLine]\[IndentingNewLine]TRIFACEL2, \
\[IndentingNewLine]PrintFoundChunk["\<TRIFACEL2 Object faces (2)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  tempint], \[IndentingNewLine]\[IndentingNewLine]TRILOCAL, \
\[IndentingNewLine]PrintFoundChunk["\<TRILOCAL Object translation\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadTranslationChunk[], \
\[IndentingNewLine]\[IndentingNewLine]TRIVISIBLE, \
\[IndentingNewLine]PrintFoundChunk["\<TRIVISIBLE Object vis/invis\>", 
                tempint]; \[IndentingNewLine]{tmp, boolean} = 
                ReadBooleanChunk[]; \[IndentingNewLine]intCounter += 
                tmp, \[IndentingNewLine]\[IndentingNewLine]TRIUNKNWN01, \
\[IndentingNewLine]PrintFoundChunk["\<TRIUNKNWN01 Object faces (2)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  tempint], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadObjChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadObjChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If[
              intCounter == chunkLength, \ 
              foundEnd = 
                True]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintExitData[currentPointer, chunkLength, 
            SymbolName[ReadObjChunk]]; \[IndentingNewLine]ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Light chunk
OBJLIGHT: LITUNKNWN01, LITOFF, LITSPOT, COLRGB, COLTRU\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadLightChunk[] := 
        Module[{foundEnd = False, boolean, \[IndentingNewLine]tempint, 
            currentPointer, chunkLength, intCounter = 4, lightcoors, 
            tmp}, \  (*\ 
            2\ id + 4\ pointer\ *) \ \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadLightChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]lightcoors = {ReadReal[], ReadReal[], 
              ReadReal[]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found light at \
coordinates: X: \>", lightcoors[\([1]\)], "\<, Y: \>", 
              lightcoors[\([2]\)], "\<, Z: \>", 
              lightcoors[\([3]\)]]\[IndentingNewLine]]; \
\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              0; \[IndentingNewLine]\[IndentingNewLine]Switch[
              tempint, \[IndentingNewLine]LITUNKNWN01, \
\[IndentingNewLine]PrintFoundChunk["\<LITUNKNWN01 Light\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  LITUNKNWN01], \[IndentingNewLine]\[IndentingNewLine]LITOFF, \
\[IndentingNewLine]PrintFoundChunk["\<LITOFF Light is (on/off)\>", 
                tempint]; \[IndentingNewLine]{tmp, boolean} = 
                ReadBooleanChunk[]; \[IndentingNewLine]intCounter += 
                tmp; \[IndentingNewLine]If[
                DebugFlag, \[IndentingNewLine]If[\ \((boolean \[Equal] 
                      True)\)\ , \[IndentingNewLine]Print["\<      Light is \
on\>"], \[IndentingNewLine]Print["\<      Light is \
off\>"]\[IndentingNewLine]]\[IndentingNewLine]], \[IndentingNewLine]\
\[IndentingNewLine]LITSPOT, \[IndentingNewLine]PrintFoundChunk["\<LITSPOT \
SpotLight\>", tempint]; \[IndentingNewLine]intCounter += 
                ReadSpotChunk[], \
\[IndentingNewLine]\[IndentingNewLine]COLRGB, \
\[IndentingNewLine]PrintFoundChunk["\<COLRGB Color def (RGB)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadRGBColor[], \[IndentingNewLine]\[IndentingNewLine]COLTRU, \
\[IndentingNewLine]PrintFoundChunk["\<COLTRU Color def (24bit)\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadTrueColor[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadLightChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadLightChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]if[intCounter == chunkLength, 
              foundEnd = 
                True\[IndentingNewLine]];\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, SymbolName[ReadLightChunk]]; \ 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Camera chunk
OBJCAMERA: CAMUNKNWN01, CAMUNKNWN02\
\>", "Subsubsection"],

Cell[BoxData[
    \(\(ReadCameraChunk[] := \n
        Module[{currentPointer, chunkLength, cameraeye, camerafocus, 
            rotation, lens}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength\ \ \  = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadCameraChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]cameraeye = {ReadReal[], ReadReal[], 
              ReadReal[]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found Camera \
viewpoint at coordinates: X: \>", cameraeye[\([1]\)], "\<, Y: \>", 
              cameraeye[\([2]\)], "\<, Z: \>", 
              cameraeye[\([3]\)]]\[IndentingNewLine]]; \
\[IndentingNewLine]camerafocus = {ReadReal[], ReadReal[], 
              ReadReal[]}; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Found Camera focus \
coors at coordinates: X: \>", camerafocus\ [\([1]\)], "\<, Y: \>", 
              camerafocus\ [\([2]\)], "\<,Z: \>", 
              camerafocus\ [\([3]\)]]\[IndentingNewLine]]; \
\[IndentingNewLine]rotation = ReadReal[]; \[IndentingNewLine]lens = 
            ReadReal[]; \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]Print["\<     Rotation of camera \
is:  \>", 
              rotation]; \[IndentingNewLine]Print["\<     Lens in used camera \
is: \>", lens, "\<mm\>"]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]If[\((chunkLength - 38)\) > 0, \  (*\ 
              this\ means\ more\ chunks\ are\ to\ follow\ \
*) \[IndentingNewLine]If[
              DebugFlag, \[IndentingNewLine]Print["\<     **** found extra \
cam chunks ****\>"]\[IndentingNewLine]]; \[IndentingNewLine]If[
              ReadInt[] == CAMUNKNWN01, \[IndentingNewLine]If[
                DebugFlag, \
\[IndentingNewLine]PrintFoundChunk["\<CAMUNKNWN01\>", 
                  tempint]; \[IndentingNewLine]Print["\<     **** Found cam 1 \
type ch ****\>"]\[IndentingNewLine]]; \[IndentingNewLine]ReadUnknownChunk[
                CAMUNKNWN01]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]If[
              ReadInt[] == CAMUNKNWN02, \[IndentingNewLine]If[
                
                DebugFlag, \
\[IndentingNewLine]PrintFoundChunk["\<CAMUNKNWN02\>", 
                  tempint]; \[IndentingNewLine]Print["\<     **** Found cam 2 \
type ch ****\>"]\[IndentingNewLine]]; \[IndentingNewLine]ReadUnknownChunk[
                CAMUNKNWN02]\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, SymbolName[ReadCameraChunk]]; \ 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine]Return[
            chunkLength];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Read the Object chunk
EDITOBJECT: OBJUNKNWN01, OBJUNKNWN02, OBJTRIMESH, OBJLIGHT, OBJCAMERA\
\>", \
"Subsubsection"],

Cell[BoxData[
    \(\(ReadObjectChunk[] := 
        Module[{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4, tmp}, \[IndentingNewLine] (*\ 
            2\ id + 4\ pointer\ *) \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadObjectChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]intCounter += \((tmp = 
                ReadName[])\); \[IndentingNewLine]If[
            DebugFlag, \[IndentingNewLine]If[
              tmp \[Equal] 
                0, \[IndentingNewLine]Print["\<* Dummy Object found\>"]\
\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]While[\ 
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch\ [
              tempint, \[IndentingNewLine]\[IndentingNewLine]OBJUNKNWN01, \
\[IndentingNewLine]PrintFoundChunk["\<OBJUNKNWN01\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  OBJUNKNWN01], \
\[IndentingNewLine]\[IndentingNewLine]OBJUNKNWN02, \
\[IndentingNewLine]PrintFoundChunk["\<OBJUNKNWN02\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  OBJUNKNWN02], \
\[IndentingNewLine]\[IndentingNewLine]OBJTRIMESH, \
\[IndentingNewLine]PrintFoundChunk["\<OBJTRIMESH Obj/Mesh\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadObjChunk[], \
\[IndentingNewLine]\[IndentingNewLine]OBJLIGHT, \
\[IndentingNewLine]PrintFoundChunk["\<OBJLIGHT Light\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadLightChunk[], \
\[IndentingNewLine]\[IndentingNewLine]OBJCAMERA, \
\[IndentingNewLine]PrintFoundChunk["\<OBJCAMERA Camera\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadCameraChunk[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadObjectChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadObjectChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If[
              intCounter == chunkLength, \[IndentingNewLine]foundEnd = 
                True\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, SymbolName[ReadObjectChunk]]; 
          ChangeChunkPointer[
            currentPointer + chunkLength]; \[IndentingNewLine] (*\ 
            move\ to\ the\ new\ chunk\ position\ *) \[IndentingNewLine]Return[
            chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Read the edit chunk\nEDIT3DS ",
  Cell[BoxData[
      \("3d3d"\_"16"\)]],
  ": \nEDITUNKNW01, EDITUNKNW02, EDITUNKNW03, EDITUNKNW04, EDITUNKNW05, \
EDITUNKNW06, EDITUNKNW07, EDITUNKNW08, EDITUNKNW09, EDITUNKNW10, EDITUNKNW11, \
EDITUNKNW12, EDITUNKNW13, EDITUNKNW14, EDITUNKNW15, EDITMATERIAL, EDITVIEW1, \
EDITBACKGR, EDITAMBIENT, EDITOBJECT"
}], "Subsubsection"],

Cell[BoxData[
    \(\(ReadEditChunk[] := 
        Module[{foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4}, \[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadEditChunk]]; \[IndentingNewLine]\[IndentingNewLine]While[
            foundEnd \[Equal] False, \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch[
              tempint, \[IndentingNewLine]\[IndentingNewLine]EDITUNKNW01, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW01\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW01], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW02, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW02\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW02], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW03, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW03\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW03], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW04, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW04\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW04], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW05, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW05\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW05], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW06, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW06\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW06], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW07, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW07\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW07], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW08, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW08\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW08], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW09, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW09\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW09], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW10, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW10\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW10], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW11, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW11\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW11], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW12, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW12\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW12], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW13, \
\[IndentingNewLine]\(PrintFoundChunk["\<EDITUNKNW13\>", 
                    tempint];\)\[IndentingNewLine]\(intCounter += 
                  ReadUnknownChunk[
                    EDITUNKNW13]\), \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW14, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW14\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW14], \
\[IndentingNewLine]\[IndentingNewLine]EDITUNKNW15, \
\[IndentingNewLine]PrintFoundChunk["\<EDITUNKNW15\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITUNKNW15], \
\[IndentingNewLine]\[IndentingNewLine]EDITCONFIG1, \
\[IndentingNewLine]PrintFoundChunk["\<EDITCONFIG1\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITCONFIG1], \
\[IndentingNewLine]\[IndentingNewLine]EDITCONFIG2, \
\[IndentingNewLine]PrintFoundChunk["\<EDITCONFIG2\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITCONFIG2], \
\[IndentingNewLine]\[IndentingNewLine]EDITVIEWP1, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEWP1\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  
                  EDITVIEWP1], \
\[IndentingNewLine]\[IndentingNewLine]EDITVIEWP2, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEWP2\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITVIEWP2], \
\[IndentingNewLine]\[IndentingNewLine]EDITVIEWP3, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEWP3\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadUnknownChunk[
                  EDITVIEWP3], \
\[IndentingNewLine]\[IndentingNewLine]EDITMATERIAL, \
\[IndentingNewLine]PrintFoundChunk["\<EDITMATERIAL Materials\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadMaterialChunk[], \
\[IndentingNewLine]\[IndentingNewLine]EDITVIEW1, \
\[IndentingNewLine]PrintFoundChunk["\<EDITVIEW1 View main def.\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadViewChunk[], \
\[IndentingNewLine]\[IndentingNewLine]EDITBACKGR, \
\[IndentingNewLine]PrintFoundChunk["\<EDITBACKGR Background\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadBackgrChunk[], \
\[IndentingNewLine]\[IndentingNewLine]EDITAMBIENT, \
\[IndentingNewLine]PrintFoundChunk["\<EDITAMBIENT Ambient\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadAmbientChunk[], \
\[IndentingNewLine]\[IndentingNewLine]EDITOBJECT, \
\[IndentingNewLine]PrintFoundChunk["\<EDITOBJECT Object\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadObjectChunk[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintFalseItem[SymbolName[ReadEditChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \
\[IndentingNewLine]PrintOverShoot[SymbolName[ReadEditChunk], intCounter, 
              chunkLength]; \[IndentingNewLine]If[
              intCounter == chunkLength, \[IndentingNewLine]foundEnd = 
                True\[IndentingNewLine]]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]PrintExitData[currentPointer, 
            chunkLength, SymbolName[ReadEditChunk]]; 
          ChangeChunkPointer[currentPointer + chunkLength]; 
          Return\ [chunkLength]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Read the Primary and Main Chunk MAIN3DS and its components", \
"Subsection"],

Cell[CellGroupData[{

Cell[TextData[{
  "Read the main chunk\nMAIN3DS ",
  Cell[BoxData[
      \("4d4d"\_"16"\)]],
  ":\nKEYF3DS ",
  Cell[BoxData[
      \("b000"\_"16"\)]],
  " & EDIT3DS ",
  Cell[BoxData[
      \("3d3d"\_"16"\)]]
}], "Subsubsection"],

Cell[BoxData[
    \(\(ReadMainChunk[] := 
        Module[\n{\ foundEnd = False, tempint, currentPointer, chunkLength, 
            intCounter = 4\  (*\ 
              Skip\ the\ header\ data\ *) }, \
\[IndentingNewLine]currentPointer = 
            GetChunkFilePointer[]; \[IndentingNewLine]chunkLength = 
            ReadChunkLength[]; \[IndentingNewLine]PrintEntryData[
            currentPointer, chunkLength, 
            SymbolName[
              ReadMainChunk]]; \
\[IndentingNewLine]\[IndentingNewLine]While[\((foundEnd \[Equal] 
                False)\), \[IndentingNewLine]tempint = 
              ReadInt[]; \[IndentingNewLine]intCounter += 
              2; \[IndentingNewLine]\[IndentingNewLine]Switch\ [
              tempint, \[IndentingNewLine]KEYF3DS, \
\[IndentingNewLine]PrintFoundChunk["\<KEYF3DS Keyframer\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadKeyfChunk[], \
\[IndentingNewLine]\[IndentingNewLine]EDIT3DS, \
\[IndentingNewLine]PrintFoundChunk["\<EDIT3DS Editor\>", 
                tempint]; \[IndentingNewLine]intCounter += 
                ReadEditChunk[], \[IndentingNewLine]\[IndentingNewLine]_, \
\[IndentingNewLine]PrintSkippedItem[SymbolName[ReadMainChunk], intCounter, 
                tempint]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]If[
              intCounter == chunkLength, \ \[IndentingNewLine]foundEnd = 
                True; \[IndentingNewLine]PrintExitData[currentPointer, 
                chunkLength, 
                SymbolName[
                  ReadMainChunk]]\[IndentingNewLine]]\[IndentingNewLine]]\
\[IndentingNewLine]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Read the primary chunk\nMAIN3DS ",
  Cell[BoxData[
      \("4d4d"\_"16"\)]]
}], "Subsubsection"],

Cell["\<\
The primary chunk MAIN3DS, the file, consists of the main \
chunk\
\>", "Text"],

Cell[BoxData[
    \(\(ReadPrimaryChunk[] := 
        Module[{version}, \[IndentingNewLine]If[
            ReadInt[] \[Equal] 
              MAIN3DS, \[IndentingNewLine]PrintFoundChunk["\<MAIN3DS Main\>", 
              MAIN3DS]; \[IndentingNewLine] (*\ 
              find\ version\ number\ *) \[IndentingNewLine]fseek[bin3ds, 28, 
              SEEKSET]; \[IndentingNewLine]version = 
              ReadChar[]; \[IndentingNewLine]If\ [
              version < 
                3, \[IndentingNewLine]Print["\<Sorry this lib can only read \
3ds files of version 3.0 and higher\>"]; \[IndentingNewLine]Print\ ["\<The \
version of the file you want to read is: \>", 
                version]; \[IndentingNewLine]Abort[]\[IndentingNewLine]]; \
\[IndentingNewLine]fseek[bin3ds, 2, 
              SEEKSET]; \[IndentingNewLine]ReadMainChunk[]; \
\[IndentingNewLine]Return\ [
              True]\[IndentingNewLine], \[IndentingNewLine]Return\ [
              True]\[IndentingNewLine]]; \[IndentingNewLine]Return\ [
            False]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Public Function", "Subsection"],

Cell[CellGroupData[{

Cell["Read the file: Only this function and its option is exported", \
"Subsubsection"],

Cell[BoxData[{
    \(\(Options[imsRead3DS] = {imsRead3DSDebug \[Rule] False, 
          imsWireframe \[Rule] True};\)\), "\[IndentingNewLine]", 
    \(\(imsRead3DS[fileName_String, myOptions___] := 
        Module[{data, drawWireframe, 
            drawHead}, \[IndentingNewLine]verticesList = {}; \
\[IndentingNewLine]facesList = {}; \[IndentingNewLine]transmatList = {}; \
\[IndentingNewLine]DebugFlag = \(imsRead3DSDebug /. {myOptions}\) /. 
              Options[imsRead3DS]; \[IndentingNewLine]drawWireframe = \
\(imsWireframe /. {myOptions}\) /. Options[imsRead3DS]; \[IndentingNewLine]If[
            drawWireframe \[Equal] True, \[IndentingNewLine]drawHead = Line, 
            drawHead = 
              Polygon]; \[IndentingNewLine]\[IndentingNewLine]bin3ds = 
            OpenRead[fileName, 
              BinaryFormat \[Rule] 
                True]; \[IndentingNewLine]imsClearStatus[]; \
\[IndentingNewLine]imsShowStatus[\ "\<Loading 3ds binary file: \>"\  <> \ 
              fileName\ ]; \[IndentingNewLine]While[\(! \
ReadPrimaryChunk[]\)]; \[IndentingNewLine]Close[
            bin3ds]; \[IndentingNewLine]\[IndentingNewLine]verticesList = 
            Flatten[verticesList]; \[IndentingNewLine]facesList = 
            Flatten[facesList]; \[IndentingNewLine]transmatList = 
            Flatten[transmatList]; \
\[IndentingNewLine]\[IndentingNewLine]imsShowStatus[\ "\<Finished loading 3ds \
binary file: \>"\  <> \ fileName\ ]; \[IndentingNewLine]\[IndentingNewLine]If[
            Length[verticesList] \[NotEqual] 
              Length[facesList], \[IndentingNewLine]Print["\<FILE (READ) \
ERROR: Number of node and face packets not equal.\>"], \
\[IndentingNewLine]data = 
              Table[\[IndentingNewLine]\(drawHead[\((verticesList\
\[LeftDoubleBracket]i, 
                            1\[RightDoubleBracket])\)[\([#]\)]] &\) /@ \
\((\(\((Drop[#, \(-3\)] + 1)\) &\) /@ \((facesList\[LeftDoubleBracket]i, 
                          1\[RightDoubleBracket])\))\), \
\[IndentingNewLine]{i, 1, 
                  Length[verticesList]}\[IndentingNewLine]]\[IndentingNewLine]\
]; \[IndentingNewLine]If[
            drawWireframe \[Equal] True, \[IndentingNewLine]Return[
              Graphics3D[{data}]], \[IndentingNewLine]Return[
              Graphics3D[{EdgeForm[], 
                  data}]]\[IndentingNewLine]];\[IndentingNewLine]\
\[IndentingNewLine]];\)\)}], "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["End Private", "Section"],

Cell[BoxData[
    \(\(\(End[]\)\(\ \)\( (*\ of\ Begin\ Private\ *) \)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["End Package", "Section"],

Cell[BoxData[
    \(\(\( (*\ 
      Protect[]\  (*\ 
        anything\ *) \ *) \)\(\[IndentingNewLine]\)\(EndPackage[]\)\(\ \
\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["The original text and C program by van Velsen and \
Fercoq",
  FontColor->RGBColor[1, 0, 0]]], "Section"],

Cell["\<\
3D Studio File Format (3ds).
Autodesk Ltd.
Document Revision 0.93 - January 1997 


                          3D-Studio File Format (.3ds)
                                 Autodesk Ltd.


                   Document Revision 0.93 - January 1997

   Rewritten by Martin van Velsen (email: vvelsen@ronix.ptf.hro.nl )
   and Robin Fercoq ( 3ds-bin + mli )(email: robin@msrwww.fc-net.fr)
   Based on documentation by Jim Pitts ( email: jim@micronetics.com )
   Source update provided by: 
         Albert Szilvasy (email: szilvasy@almos.vein.hu )

A lot of the chunks are still undocumented if you know what they do  please \
email me Martin van Velsen, Robin Feroq or Jimm Pitts. As I get more \
information on the file format, I will document it for  everyone to see. I \
will post this regurlarly to alt.3d and alt.3d-studio and I can be contacted \
there if my email does not work.

   (Also see the 3d-studio material .mli documentation by Robin Feroq.)

Disclaimer.
This document describes the file format of the 3ds files generated by \
3d-studio by Autodesk. By using the information contained within, you  agree \
not to hold any of the authors liable if, from its use, you  f^Hmuck \
something up. OK?

Autodesk has at not yet released the offical specifications of the 3d-studio \
formats. You will therefor receive NO support from Autodesk or any company \
related to Autodesk concerning the nature and contents of the 3d-studio \
binary .3ds and .mli formats.

A warning beforehand. This docs describes the format of 3ds files produced by \
version 3.0 and higher of 3d-studio. You can find this version information at \
byte 29 in the binary file.

This document can be found on the regular newsgroups: alt.3d and \
alt.3d-studio It can also be found at: \"http://www.mediatel.lu\"

Contents 

   1. Introduction
   2. Chunks anyone ?
   3. 3D Editor chunks
   4. Keyframer chunks
   5. CODE\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell[CellGroupData[{

Cell["1. Introduction", "Subsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
The 3ds file format is made up of chunks. They describe what \
information is to follow and what it is made up of, it's ID and the location \
of the next block. If you don't understand a chunk you can quite simply skip \
it. The next chunk pointer is relative to the start of the current chunk and \
in bytes. The binary information in the 3ds file is written in a special kind \
of way. Namely the lest significant byte comes first in an int. For example: \
4A 5C  (2 bytes in hex) would be 5C high byte and 4A low  byte. In a long it \
is: 4A 5C 3B 8F where 5C4A is the low word and 8F 3B is the high word. And \
now for the chunks. A chunk is defined as:

start end size name
0     1   2    Chunk ID
2     5   4    Pointer to next chunk relative to the place where
                  Chunk ID is, in other words the length of the chunk

Chunks have a hierarchy imposed on them that is identified byt it's ID. A 3ds \
file has the Primary chunk ID 4D4Dh. This is always the first chunk of the \
file. Within the primary chunk are the main chunks.

To give you a preview and a reference to the hierarchy of chunks, below is a \
diagram to show the diffrent chunk ID's and their place in the file. The \
chunks are given a name because below the diagram is a list which defines the \
names to the actual chunk id's. This makes it easier to put it in some source \
code ( how convenient that some sample code is included )\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
Reformatted and extended by Korvink

                  +--MAIN3DS (0x4D4D)
                  |  |
                  |  +--EDIT3DS (0x3D3D)
                  |  |
                  |  +--EDIT_MATERIAL (0xAFFF)
                  |  |  |
                  |  |  +--MAT_NAME01 (0xA000) (See mli Doc)
                  |  |
                  |  +--EDIT_CONFIG1 (0x0100)
                  |  |
                  |  +--EDIT_CONFIG2 (0x3E3D)
                  |  |
                  |  +--EDIT_VIEW_P1 (0x7012)
                  |  |  |
                  |  |  +--TOP (0x0001)
                  |  |  |
                  |  |  +--BOTTOM (0x0002)
                  |  |  |
                  |  |  +--LEFT (0x0003)
                  |  |  |
                  |  |  +--RIGHT (0x0004)
                  |  |  |
                  |  |  +--FRONT (0x0005)
                  |  |  |
                  |  |  +--BACK (0x0006)
                  |  |  |
                  |  |  +--USER (0x0007)
                  |  |  |
                  |  |  +--CAMERA (0xFFFF)
                  |  |  |
                  |  |  +--LIGHT (0x0009)
                  |  |  |
                  |  |  +--DISABLED (0x0010)
                  |  |  |
                  |  |  +--BOGUS (0x0011)
                  |  |
                  |  +--EDIT_VIEW_P2 (0x7011)
                  |  |  |
                  |  |  +--TOP (0x0001)
                  |  |  |
                  |  |  +--BOTTOM (0x0002)
                  |  |  |
                  |  |  +--LEFT (0x0003)
                  |  |  |
                  |  |  +--RIGHT (0x0004)
                  |  |  |
                  |  |  +--FRONT (0x0005)
                  |  |  |
                  |  |  +--BACK (0x0006)
                  |  |  |
                  |  |  +--USER (0x0007)
                  |  |  |
                  |  |  +--CAMERA (0xFFFF)
                  |  |  |
                  |  |  +--LIGHT (0x0009)
                  |  |  |
                  |  |  +--DISABLED (0x0010)
                  |  |  |
                  |  |  +--BOGUS (0x0011)
                  |  |
                  |  +--EDIT_VIEW_P3 (0x7020)
                  |  |
                  |  +--EDIT_VIEW1 (0x7001)
                  |  |
                  |  +--EDIT_BACKGR (0x1200)
                  |  |
                  |  +--EDIT_AMBIENT (0x2100)
                  |  |
                  |  +--EDIT_OBJECT (0x4000)
                  |  |  |
                  |  |  +--OBJ_TRIMESH (0x4100)
                  |  |  |  |
                  |  |  |  +--TRI_VERTEXL (0x4110)
                  |  |  |  |
                  |  |  |  +--TRI_VERTEXOPTIONS (0x4111)
                  |  |  |  |
                  |  |  |  +--TRI_MAPPINGCOORS (0x4140)
                  |  |  |  |
                  |  |  |  +--TRI_MAPPINGSTANDARD (0x4170)
                  |  |  |  |
                  |  |  |  +--TRI_FACEL1 (0x4120)
                  |  |  |  |  |
                  |  |  |  |  +--TRI_SMOOTH (0x4150)
                  |  |  |  |  |
                  |  |  |  |  +--TRI_MATERIAL (0x4130)
                  |  |  |  |
                  |  |  |  +--TRI_LOCAL (0x4160)
                  |  |  |  |
                  |  |  |  +--TRI_VISIBLE (0x4165)
                  |  |  |
                  |  |  +--OBJ_LIGHT (0x4600)
                  |  |  |  |
                  |  |  |  +--LIT_OFF (0x4620)
                  |  |  |  |
                  |  |  |  +--LIT_SPOT (0x4610)
                  |  |  |  |
                  |  |  |  +--LIT_UNKNWN01 (0x465A)
                  |  |  |
                  |  |  +--OBJ_CAMERA (0x4700)
                  |  |  |  |
                  |  |  |  +--CAM_UNKNWN01 (0x4710)
                  |  |  |  |
                  |  |  |  +--CAM_UNKNWN02 (0x4720)
                  |  |  |
                  |  |  +--OBJ_UNKNWN01 (0x4710)
                  |  |  |
                  |  |  +--OBJ_UNKNWN02 (0x4720)
                  |  |
                  |  +--EDIT_UNKNW01 (0x1100)
                  |  |
                  |  +--EDIT_UNKNW02 (0x1201)
                  |  |
                  |  +--EDIT_UNKNW03 (0x1300)
                  |  |
                  |  +--EDIT_UNKNW04 (0x1400)
                  |  |
                  |  +--EDIT_UNKNW05 (0x1420)
                  |  |
                  |  +--EDIT_UNKNW06 (0x1450)
                  |  |
                  |  +--EDIT_UNKNW07 (0x1500)
                  |  |
                  |  +--EDIT_UNKNW08 (0x2200)
                  |  |
                  |  +--EDIT_UNKNW09 (0x2201)
                  |  |
                  |  +--EDIT_UNKNW10 (0x2210)
                  |  |
                  |  +--EDIT_UNKNW11 (0x2300)
                  |  |
                  |  +--EDIT_UNKNW12 (0x2302)
                  |  |
                  |  +--EDIT_UNKNW13 (0x2000)
                  |  |
                  |  +--EDIT_UNKNW14 (0xAFFF)
                  |  |
                  |  +--KEYF3DS (0xB000)
\
\>", "Input",
  Evaluatable->False],

Cell["\<\
Original as delivered

                  MAIN3DS  (0x4D4D)
                  |
                  +--EDIT3DS  (0x3D3D)
                  |  |
                  |  +--EDIT_MATERIAL (0xAFFF)
                  |  |  |
                  |  |  +--MAT_NAME01 (0xA000) (See mli Doc) 
                  |  |
                  |  +--EDIT_CONFIG1  (0x0100)
                  |  +--EDIT_CONFIG2  (0x3E3D) 
                  |  +--EDIT_VIEW_P1  (0x7012)
                  |  |  |
                  |  |  +--TOP            (0x0001)
                  |  |  +--BOTTOM         (0x0002)
                  |  |  +--LEFT           (0x0003)
                  |  |  +--RIGHT          (0x0004)
                  |  |  +--FRONT          (0x0005) 
                  |  |  +--BACK           (0x0006)
                  |  |  +--USER           (0x0007)
                  |  |  +--CAMERA         (0xFFFF)
                  |  |  +--LIGHT          (0x0009)
                  |  |  +--DISABLED       (0x0010)  
                  |  |  +--BOGUS          (0x0011)
                  |  |
                  |  +--EDIT_VIEW_P2  (0x7011)
                  |  |  |
                  |  |  +--TOP            (0x0001)
                  |  |  +--BOTTOM         (0x0002)
                  |  |  +--LEFT           (0x0003)
                  |  |  +--RIGHT          (0x0004)
                  |  |  +--FRONT          (0x0005) 
                  |  |  +--BACK           (0x0006)
                  |  |  +--USER           (0x0007)
                  |  |  +--CAMERA         (0xFFFF)
                  |  |  +--LIGHT          (0x0009)
                  |  |  +--DISABLED       (0x0010)  
                  |  |  +--BOGUS          (0x0011)
                  |  |
                  |  +--EDIT_VIEW_P3  (0x7020)
                  |  +--EDIT_VIEW1    (0x7001) 
                  |  +--EDIT_BACKGR   (0x1200) 
                  |  +--EDIT_AMBIENT  (0x2100)
                  |  +--EDIT_OBJECT   (0x4000)
                  |  |  |
                  |  |  +--OBJ_TRIMESH   (0x4100)      
                  |  |  |  |
                  |  |  |  +--TRI_VERTEXL          (0x4110) 
                  |  |  |  +--TRI_VERTEXOPTIONS    (0x4111)
                  |  |  |  +--TRI_MAPPINGCOORS     (0x4140) 
                  |  |  |  +--TRI_MAPPINGSTANDARD  (0x4170)
                  |  |  |  +--TRI_FACEL1           (0x4120)
                  |  |  |  |  |
                  |  |  |  |  +--TRI_SMOOTH            (0x4150)   
                  |  |  |  |  +--TRI_MATERIAL          (0x4130)
                  |  |  |  |
                  |  |  |  +--TRI_LOCAL            (0x4160)
                  |  |  |  +--TRI_VISIBLE          (0x4165)
                  |  |  |
                  |  |  +--OBJ_LIGHT    (0x4600)
                  |  |  |  |
                  |  |  |  +--LIT_OFF              (0x4620)
                  |  |  |  +--LIT_SPOT             (0x4610) 
                  |  |  |  +--LIT_UNKNWN01         (0x465A) 
                  |  |  | 
                  |  |  +--OBJ_CAMERA   (0x4700)
                  |  |  |  |
                  |  |  |  +--CAM_UNKNWN01         (0x4710)
                  |  |  |  +--CAM_UNKNWN02         (0x4720)  
                  |  |  |
                  |  |  +--OBJ_UNKNWN01 (0x4710)
                  |  |  +--OBJ_UNKNWN02 (0x4720)
                  |  |
                  |  +--EDIT_UNKNW01  (0x1100)
                  |  +--EDIT_UNKNW02  (0x1201) 
                  |  +--EDIT_UNKNW03  (0x1300)
                  |  +--EDIT_UNKNW04  (0x1400)
                  |  +--EDIT_UNKNW05  (0x1420)
                  |  +--EDIT_UNKNW06  (0x1450)
                  |  +--EDIT_UNKNW07  (0x1500)
                  |  +--EDIT_UNKNW08  (0x2200)
                  |  +--EDIT_UNKNW09  (0x2201)
                  |  +--EDIT_UNKNW10  (0x2210)
                  |  +--EDIT_UNKNW11  (0x2300)
                  |  +--EDIT_UNKNW12  (0x2302)
                  |  +--EDIT_UNKNW13  (0x2000)
                  |  +--EDIT_UNKNW14  (0xAFFF)
                  |
                  +--KEYF3DS (0xB000)
                     |
                     +--KEYF_UNKNWN01 (0xB00A)
                     +--............. (0x7001) ( viewport, same as editor )
                     +--KEYF_FRAMES   (0xB008)
                     +--KEYF_UNKNWN02 (0xB009)
                     +--KEYF_OBJDES   (0xB002)
                        |
                        +--KEYF_OBJHIERARCH  (0xB010)
                        +--KEYF_OBJDUMMYNAME (0xB011)
                        +--KEYF_OBJUNKNWN01  (0xB013)
                        +--KEYF_OBJUNKNWN02  (0xB014)
                        +--KEYF_OBJUNKNWN03  (0xB015)  
                        +--KEYF_OBJPIVOT     (0xB020)  
                        +--KEYF_OBJUNKNWN04  (0xB021)  
                        +--KEYF_OBJUNKNWN05  (0xB022)  \
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
 A chunk type which you can find all through the file are the color \
chunks
 which are called:

 COL_RGB
 COL_TRU
 COL_UNK\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Open  ]],

Cell[CellGroupData[{

Cell["2. Chunks anyone ?", "Subsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
Now for the actual numbers, as you will see I used the define, \
because I ripped that part right out of my code. Be carefull however because \
there are a lot of new chunk types which were not documented in the original \
paper by Jim Pitts.\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
//------Primary chunk
\\[IndentingNewLine]#define MAIN3DS 0x4D4D
\\[IndentingNewLine] //------Main Chunks
\\[IndentingNewLine]#define EDIT3DS 0x3D3D//this is the start of the editor \
config
#define KEYF3DS 0xB000//this is the start of the keyframer config
\\[IndentingNewLine] //------sub defines of EDIT3DS
\\[IndentingNewLine]#define EDIT_MATERIAL 0xAFFF
#define EDIT_CONFIG1 0x0100
#define EDIT_CONFIG2 0x3E3D
#define EDIT_VIEW_P1 0x7012
#define EDIT_VIEW_P2 0x7011
#define EDIT_VIEW_P3 0x7020
#define EDIT_VIEW1 0x7001
#define EDIT_BACKGR 0x1200
#define EDIT_AMBIENT 0x2100
#define EDIT_OBJECT 0x4000
\\[IndentingNewLine]#define EDIT_UNKNW01 0x1100
#define EDIT_UNKNW02 0x1201
#define EDIT_UNKNW03 0x1300
#define EDIT_UNKNW04 0x1400
#define EDIT_UNKNW05 0x1420
#define EDIT_UNKNW06 0x1450
#define EDIT_UNKNW07 0x1500
#define EDIT_UNKNW08 0x2200
#define EDIT_UNKNW09 0x2201
#define EDIT_UNKNW10 0x2210
#define EDIT_UNKNW11 0x2300
#define EDIT_UNKNW12 0x2302
#define EDIT_UNKNW13 0x3000
#define EDIT_UNKNW14 0xAFFF
\\[IndentingNewLine] //------sub defines of EDIT_OBJECT
#define OBJ_TRIMESH 0x4100
#define OBJ_LIGHT 0x4600
#define OBJ_CAMERA 0x4700
\\[IndentingNewLine]#define OBJ_UNKNWN01 0x4010
#define OBJ_UNKNWN02 0x4012//----Could be shadow
\\[IndentingNewLine] //------sub defines of OBJ_CAMERA
#define CAM_UNKNWN01 0x4710
#define CAM_UNKNWN02 0x4720
\\[IndentingNewLine] //------sub defines of OBJ_LIGHT
#define LIT_OFF 0x4620
#define LIT_SPOT 0x4610
#define LIT_UNKNWN01 0x465A
\\[IndentingNewLine] //------sub defines of OBJ_TRIMESH
#define TRI_VERTEXL 0x4110
#define TRI_FACEL2 0x4111
#define TRI_FACEL1 0x4120
#define TRI_SMOOTH 0x4150
#define TRI_LOCAL 0x4160
#define TRI_VISIBLE 0x4165
\\[IndentingNewLine] //------sub defs of KEYF3DS
\\[IndentingNewLine]#define KEYF_UNKNWN01 0xB009
#define KEYF_UNKNWN02 0xB00A
#define KEYF_FRAMES 0xB008
#define KEYF_OBJDES 0xB002
\\[IndentingNewLine] //------these define the different color chunk types
#define COL_RGB 0x0010
#define COL_TRU 0x0011
#define COL_UNK 0x0013
\\[IndentingNewLine] //------defines for viewport chunks
\\[IndentingNewLine]#define TOP 0x0001
#define BOTTOM 0x0002
#define LEFT 0x0003
#define RIGHT 0x0004
#define FRONT 0x0005
#define BACK 0x0006
#define USER 0x0007
#define CAMERA 0x0008//0xFFFF is the actual code read from file
#define LIGHT 0x0009
#define DISABLED 0x0010
#define BOGUS 0x0011\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" 3. 3D Editor Chunks", "Subsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
 So far for the quick stuff now the more detailed info.
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell[CellGroupData[{

Cell[" * Main chunks", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
The main chunk ( the primary chunk of 0x4D4D that is ) is actually \
the complete file. So the size of this chunk is the size of the file minus \
the main chunk header.

There are two more main chunks, the 3d-editor chunk and the keyframer chunk:

  id
  3D3D Start of Editor data  ( this is also the place where the objects are )
  B000 Start of Keyframer data

Directly after a Main chunk is another chunk. This could be any other type of \
chunk allowable within its main chunks scope. ( see diagram )\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * Subchunks of 3D3D", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
  id   Description
 0100  Part of configuration
 1100  unknown
 1200  Background Color
 1201  unknown
 1300  unknown
 1400  unknown
 1420  unknown
 1450  unknown
 1500  unknown
 2100  Ambient Color Block
 2200  fog ?
 2201  fog ?
 2210  fog ?
 2300  unknown
 3000  unknown
 3D3E  Editor configuration main block
 4000  Definition of an Object
 AFFF  Start of material list\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * Subchunks of AFFF - Start of material list", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
 * A000 - material name
 - This chunk contains the name of the material which is an ASCIIZ string

(More material chunks are explained in the doc about 3d-studio .mli files. \
The chunk types mentioned in that doc are exactly the same as in the .3ds \
file)\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * Subchunks of 3D3E - Editor configuration", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
  id   Description
 7001  Start of viewport indicator
 7011  Viewport definition ( type 2 )
 7012  Viewport definition ( type 1 )
 7020  Viewport definition ( type 3 )

 The 3D3E chunk is a curious one because it contains a lot of redundant  \
data. ( or so it seems ) The most important chunk is 7020. this chunk  \
describes the 4 viewports wich are active in the editor. I assume that  U are \
using the 4 normal viewport layout, because I have not tested it  with other \
configurations. The editor confid will contain 5x chunk 7020  and 5x chunk \
7011. only the first 4 7020 chunks are important for how the viewports look \
like. I guess that the other chunks only give additional info, but I am not \
sure. The things you are looking for in these chunks is at byte: 6 & 7 ( as \
offset from the first 6 bytes chunk header and pointer ) these bytes ( \
unsigned int ) contain the info at to what view is used, with the following \
id's:

  id    Description
 0001   Top
 0002   Bottom
 0003   Left
 0004   Right
 0005   Front
 0006   Back
 0007   User
 FFFF   Camera
 0009   Light
 0010   Disabled\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * Subchunks of 4000 - Object description Block", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
First item of Subchunk 4000 is an ASCIIZ string of the objects \
name. ASCIIZ means a string of charakters ended by a zero.

 Remember an Object can be a Camera a Light or a mesh
  id      Description
 4010     unknown
 4012     shadow ?
 4100     Triangular Polygon List ( Contains only subchunks )
 4600     Light
 4700     Camera

 ( Mapping: These chunks are optional. They stand just after the vertex list \
when the object is mapped. )\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * Subchunks of 4100 - Triangular Polygon List", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
  id      Description
 4110     Vertex List
 4111     Vertex Options
 4120     Face List
 4130     Face Material
 4140     Mapping Coordinates
 4150     Face smoothing group
 4160     Translation Matrix
 4165     Object visible/invisble
 4170     Standard Mapping\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4110 - Vertex List", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

   start end size type          name
   0     1    2   unsigned int  Total vertices in object
   2     5    4   float         X-value
   6     9    4   float         Y-value
  10    13    4   float         Z-value

 bytes 2..13 are repeated times the total amount of vertices in the object
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4111 - Vertex Options", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
First 2 bytes: number of vertices.

Then a short int for each vertex:

 bit 0-7    0
 bit 8-10   x
 bit 11-12  0
 bit 13   vertex selected in selection 3
 bit 14   vertex selected in selection 2
 bit 15   vertex selected in selection 1

bit 8-10 are just like random. From a save to another of the same scene it \
may change.
 
 Other bits (0-7 and 11-12) have effects on visibility of vertex.

 The 4111 chunk can be deleted without much influence, 3ds will still load \
the file all right.\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4120 - Face list", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

 start end size type          name
 0     1    2   unsigned int  total polygons in object (numpoly)

 2     3    2   unsigned int  number of vertex A
 4     5    2   unsigned int  number of vertex B
 6     7    2   unsigned int  number of vertex C
 8     9    2   unsigned int  face info (*) 

repeats 'numpoly' times for each polygon.

The first three ints are the three vertices of the face. 0 stands for the \
first vertex defined in the vertex list. The order has a purpose: to give the \
direction for the normal of each face. If you turn a screw (standard screw) \
in the way the vertices indicate you will find the normal. If vertices given \
in order are A B C:

               C
               ^
               |
        A-----B

 This means unscrewing = the normal points out of the screen.

 (*) this number is is a binary number which expands to 3 values. for example \
0x0006 would expand to 110 binary. The value should be read as 1 1 0 .This \
value can be found in 3d-studio ascii files as AB:1 BC:1 AC:0 .Which probably \
indicated the order of the vertices. For example AB:1 would be a normal line \
from A to B. But AB:0 would mean a line from B to A.

     bit 0       AC visibility
     bit 1       BC visibility
     bit 2       AB visibility
     bit 3       Mapping (if there is mapping for this face)
     bit 4-8   0 (not used ?)
     bit 9-10  x (chaotic ???)
     bit 11-12 0 (not used ?)
     bit 13      face selected in selection 3
     bit 14      face selected in selection 2
     bit 15      face selected in selection 1
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Open  ]],

Cell[CellGroupData[{

Cell[" * 4130 - Face Material Chunk ", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

If the object is all default material there is no 4130 chunk. In fact, there \
is one 4130 chunk for each material present on the object.

Each 4130 face material chunks begins with an asciiz of a material, then \
after the null character is a short int that gives the number of faces of the \
object concerned by this material, then there is the list itself of these \
faces. 0000 means the first face of the (4120) face list.

   ************ Read the Doc on MLI files for more info on **************
   ************ Mapping and Materials                                  \
**************
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4140 Mapping coordinates.", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

   First 2 bytes: number of vertices.

Then, for each vertex 2 floats that give the mapping coordinates. That is, if \
a point is at the center of the map it will have 0.5 0.5 as mapping \
coordinates.
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4150 - Face Smoothing Group", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

   nfaces*4bytes

If read as long int, the nth bit indicate if the face belongs or not to the \
nth smoothing group.
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4160 Local axis", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

   Local axis info.
The three first blocks of three floats are the definition (in the absolute \
axis) of the local axis X Y Z of the object. And the last block of three \
floats is the local center of the object.
 
 \
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * 4170 Standard mapping", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

   First 2 bytes: type of mapping
   0 = plannar or specific (in this case, like mapping from the lofter, the \
information of this chunk is irrelevant)
   1 = cylindrical
   2 = spherical

   then come 21 floats that describe the mapping.
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell["* 4600 - Light", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

   start end size type   name
   0      3    4  float  Light pos X
   4      7    4  float  Light pos Y
   8     11    4  float  Light pos Z

   after this structure check for more chunks.

   id      Description ( full description later )
  0010     RGB color
  0011     24 bit color
  4610     Light is a Spot light
  4620     Light is off/on ( Boolean )
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell["* 4610 - Spot Light", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

  start end size type   name
   0     3    4  float  Target pos X
   4     7    4  float  Target pos X
   8    11    4  float  Target pos X
  12    15    4  float  Hotspot
  16    19    4  float  Falloff
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell["* 0010 - RGB Color", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

  start end size type   name
   0     3   4   float  Red
   4     7   4   float  Green
   8    11   4   float  Blue
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell["* 0011 - RGB Color - 24 bit", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

  start end size type   name
   0    1    1   byte   Red
   1    1    1   byte   Green
   2    2    1   byte   Blue
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell["* 4700 - Camera", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

 Describes the details of the camera in the scene

 start end size type   name
  0     3   4   float  Camera pos X
  4     7   4   float  Camera pos Y
  8    11   4   float  Camera pos Z
 12    15   4   float  Camera target X
 16    19   4   float  Camera target X
 20    23   4   float  Camera target X
 24    27   4   float  Camera bank ( rotation angle )
 28    31   4   float  Camera lens\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["4. Keyframer Chunks", "Subsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell[CellGroupData[{

Cell[" * Keyframer chunk", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
  id         Description
 B00A        unknown
 7001        See first description of this chunk
 B008        Frames
 B009        unknown
 B002        Start object description\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * B008 - Frame information", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
 simple structure describing frame info

 start end size type            name
   0    3    4  unsigned long   start frame
   4    7    4  unsigned long   end frame\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" *B002 - Start of Object info", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
 Subhunks

  id     Description
 B010    Name & Hierarchy
 B011*   Name Dummy Object
 B013    unknown
 B014*   unknown
 B015    unknown
 B020    Objects pivot point ?
 B021    unknown
 B022    unknown\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * B010 - Name & Hierarchy descriptor", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\

 start end  size type          name
 0      ?    ?   ASCIIZ        Object name
 ?      ?    2   unsigned int  unknown
 ?      ?    2   unsigned int  unknown
 ?      ?    2   unsigned int  Hierarchy of Object

 The object hierarchy is a bit complex but works like this.
 Each Object in the scene is given a number to identify its
 order in the tree. Also each object is orddered in the 3ds
 file as it would appear in the tree.
 The root object is given the number -1 ( FFFF ).
 As the file is read a counter of the object number is kept.
 Is the counter increments the objects are children of the
 previous objects. But when the pattern is broken by a number
 what will be less than the current counter the hierarchy returns
 to that level.

 for example.

    object   hierarchy
    name

        A      -1
        B       0                 This example is taken
        C       1                 from 50pman.3ds
        D       2
        E       1                 I would really reccomend
        F       4                 having a look at one of the
        G       5                 examples with the hierarchy
        H       1                 numbers to help work it out.
        I       7
        J       8
        K       0
        L      10
        M      11
        N       0
        O      13
        P      14


                           A
         +-----------------+----------------+
         B                 K                N
    +----+----+            |                |
    C    E    H            L                O
    |    |    |            |                |
    D    F    I            M                P
         |    |
         G    J

 Still not done with this chunk yet !
 If the object name is $$$DUMMY then it is a dummy object
 and therefore you should expect a few extra chunks.
\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * B011 - Dummy objects name.", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["    Names a dummy object. ASCIIZ string.", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]],

Cell[CellGroupData[{

Cell[" * B020 - Pivot Point ?", "Subsubsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
The Objects pivot point. Not quite sure what the first five floats \
do yet
 ( ideas ?).

 start end size type   name
   0    3    4  float  unknown
   4    7    4  float  unknown
   8   11    4  float  unknown
  12   16    4  float  unknown
  16   19    4  float  unknown
  20   23    4  float  unknown
  24   27    4  float  Pivot Y
  28   32    4  float  Pivot X\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["5. CODE", "Subsection",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell["\<\
 !!!!!!!!!!! The source code is not UP-TO-DATE it is written after \
rev 0.9 of this Doc It will be updated when I can find the time ( or maybe \
YOU can) If the code looks like it has been written by a a twelve year old, \
then  looks do decieve, I like very simple and easy to read source code. All \
that matters is that it does the trick.\
\>", "Text",
  PageWidth->WindowWidth,
  ShowSpecialCharacters->False,
  TextJustification->1],

Cell[CellGroupData[{

Cell[TextData[{
  "Header file",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\


/*----------------------------------------------------------------------------\
*\\
     This is a lib which reads 3d-studio binary files from version 3.0
     and higher
     (v1.05)
     author: Martin van Velsen
             ( and some great help by Gert van der Spoel )
     email:  vvelsen@ronix.ptf.hro.nl

     If you happen to come across some variables with strange names, then
     that will possible be Dutch names, sorry for that :)
\\*---------------------------------------------------------------------------\
-*/
#ifndef __3DSBIN_H__
#define __3DSBIN_H__

#include <stdio.h
#include <string.h
#include <stdlib.h
#include <conio.h   // IF you are on a dos system
#include <dos.h     // IF you are on a dos system

//------ tools

#define __DEBUG__          0

#define TRUE               0
#define FALSE              1

//------ Id Chunk

#define MAIN3DS       0x4D4D

//------ Main Chunks

#define EDIT3DS       0x3D3D  // this is the start of the editor config
#define KEYF3DS       0xB000  // this is the start of the keyframer config

//------ sub defines of EDIT3DS

#define EDIT_MATERIAL 0xAFFF
#define EDIT_CONFIG1  0x0100
#define EDIT_CONFIG2  0x3E3D
#define EDIT_VIEW_P1  0x7012
#define EDIT_VIEW_P2  0x7011
#define EDIT_VIEW_P3  0x7020
#define EDIT_VIEW1    0x7001
#define EDIT_BACKGR   0x1200
#define EDIT_AMBIENT  0x2100
#define EDIT_OBJECT   0x4000

#define EDIT_UNKNW01  0x1100
#define EDIT_UNKNW02  0x1201
#define EDIT_UNKNW03  0x1300
#define EDIT_UNKNW04  0x1400
#define EDIT_UNKNW05  0x1420
#define EDIT_UNKNW06  0x1450
#define EDIT_UNKNW07  0x1500
#define EDIT_UNKNW08  0x2200
#define EDIT_UNKNW09  0x2201
#define EDIT_UNKNW10  0x2210
#define EDIT_UNKNW11  0x2300
#define EDIT_UNKNW12  0x2302 // new chunk type
#define EDIT_UNKNW13  0x3000
#define EDIT_UNKNW14  0xAFFF

//------ sub defines of EDIT_MATERIAL
#define MAT_NAME01    0xA000  // includes name (see mli doc for materials)

//------ sub defines of EDIT_OBJECT

#define OBJ_TRIMESH   0x4100
#define OBJ_LIGHT     0x4600
#define OBJ_CAMERA    0x4700

#define OBJ_UNKNWN01  0x4010
#define OBJ_UNKNWN02  0x4012 //---- Could be shadow

//------ sub defines of OBJ_CAMERA
#define CAM_UNKNWN01  0x4710 // new chunk type
#define CAM_UNKNWN02  0x4720 // new chunk type

//------ sub defines of OBJ_LIGHT
#define LIT_OFF       0x4620
#define LIT_SPOT      0x4610
#define LIT_UNKNWN01  0x465A

//------ sub defines of OBJ_TRIMESH
#define TRI_VERTEXL   0x4110
#define TRI_FACEL2    0x4111 // unknown yet
#define TRI_FACEL1    0x4120
#define TRI_SMOOTH    0x4150
#define TRI_LOCAL     0x4160
#define TRI_VISIBLE   0x4165

//------ sub defs of KEYF3DS

#define KEYF_UNKNWN01 0xB009
#define KEYF_UNKNWN02 0xB00A
#define KEYF_FRAMES   0xB008
#define KEYF_OBJDES   0xB002

#define KEYF_OBJHIERARCH  0xB010
#define KEYF_OBJDUMMYNAME 0xB011
#define KEYF_OBJUNKNWN01  0xB013
#define KEYF_OBJUNKNWN02  0xB014
#define KEYF_OBJUNKNWN03  0xB015  
#define KEYF_OBJPIVOT     0xB020  
#define KEYF_OBJUNKNWN04  0xB021  
#define KEYF_OBJUNKNWN05  0xB022  

//------  these define the different color chunk types
#define COL_RGB  0x0010
#define COL_TRU  0x0011
#define COL_UNK  0x0013 // unknown

//------ defines for viewport chunks

#define TOP           0x0001
#define BOTTOM        0x0002
#define LEFT          0x0003
#define RIGHT         0x0004
#define FRONT         0x0005
#define BACK          0x0006
#define USER          0x0007
#define CAMERA        0x0008 // 0xFFFF is the code read from file
#define LIGHT         0x0009
#define DISABLED      0x0010
#define BOGUS         0x0011

//------ global vars

char *viewports [11]={
                      \"Bogus\",
                      \"Top\",
                      \"Bottom\",
                      \"Left\",
                      \"Right\",
                      \"Front\",
                      \"Back\",
                      \"User\",
                      \"Camera\",
                      \"Light\",
                      \"Disabled\"
                     };

FILE *bin3ds;
unsigned long current_chunk=0L;
unsigned char views_read=0;
unsigned int numb_faces=0,numb_vertices=0;
char temp_name [100];
float trans_mat [4][4]; // translation matrix for objects

#endif



-----------------------------8< cut here  >8-------------------------------
\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
  "Declaration, author, include",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\

/*----------------------------------------------------------------------------\
*\\
     This is a lib which reads 3d-studio binary files from version 3.0
     and higher
     (v1.05)
     author: Martin van Velsen
             ( and some great help by Gert van der Spoel )
     email:  vvelsen@ronix.ptf.hro.nl
 
     If you happen to come across some variables with strange names, then
     that will possible be Dutch names, sorry for that :)

\\*---------------------------------------------------------------------------\
-*/
#ifndef __3DSBIN_C__
#define __3DSBIN_C__

#include \"3ds_bin.h\"
\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
  "1 ReadChar ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned char ReadChar (void)
{
 return (fgetc (bin3ds));

 //------ if you want to add some code to create a progress bar, then
 //------ I suggest you do it here. This is the only function which
 //------ reads from disk
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "2 ReadInt",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned int ReadInt (void)
{
 unsigned int temp = ReadChar();
 return ( temp | (ReadChar () << 8));
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "3 ReadLong",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadLong (void)
{
 unsigned long temp1,temp2;
 unsigned long temp3,temp4;

 temp1=ReadInt ();
 temp2=ReadInt ();

 return (temp3+(temp4*0x10000L));
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "4 ReadChunkPointer",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadChunkPointer (void)
{
 return (ReadLong ());
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "5 GetChunkPointer",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long GetChunkPointer (void)
{
 return (ftell (bin3ds)-2); // compensate for the already read Marker
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "6 ChangeChunkPointer",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
void ChangeChunkPointer (unsigned long temp_pointer)
{
 fseek (bin3ds,temp_pointer,SEEK_SET);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
  "7 ReadName",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
int ReadName (void)
{
 unsigned int teller=0;
 unsigned char letter;

 strcpy (temp_name,\"Default name\");

 letter=ReadChar ();
 if (letter==0) return (-1); // dummy object
 temp_name [teller]=letter;
 teller++;

 do
 {
  letter=ReadChar ();
  temp_name [teller]=letter;
  teller++;
 }
 while ((letter!=0) && (teller<12));

 temp_name [teller-1]=0;

 #ifdef __DEBUG__
  printf (\"     Found name : %s\\n\",temp_name);
 #endif
 return (0);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "8 ReadLongName",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
int ReadLongName (void)
{
 unsigned int teller=0;
 unsigned char letter;

 strcpy (temp_name,\"Default name\");

 letter=ReadChar ();
 if (letter==0) return (-1); // dummy object
 temp_name [teller]=letter;
 teller++;

 do
 {
  letter=ReadChar ();
  temp_name [teller]=letter;
  teller++;
 }
 while (letter!=0);

 temp_name [teller-1]=0;

 #ifdef __DEBUG__
   printf (\"Found name : %s\\n\",temp_name);
 #endif
 return (0);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "9 ReadUnknownChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadUnknownChunk (unsigned int chunk_id)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;

 chunk_id=chunk_id;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "10 ReadRGBColor",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadRGBColor (void)
{
 float rgb_val [3];

 for (int i=0;i<3;i++)
  fread (&(rgb_val [i]),sizeof (float),1,bin3ds);

 #ifdef __DEBUG__
 printf (\"     Found Color (RGB) def of: R:%5.2f,G:%5.2f,B:%5.2f\\n\",
          rgb_val [0],
          rgb_val [1],
          rgb_val [2]);
 #endif

 return (12L);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "11 ReadTrueColor",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadTrueColor (void)
{
 unsigned char true_c_val [3];

 for (int i=0;i<3;i++)
  true_c_val [i]=ReadChar ();

 #ifdef __DEBUG__
 printf (\"     Found Color (24bit) def of: R:%d,G:%d,B:%d\\n\",
          true_c_val [0],
          true_c_val [1],
          true_c_val [2]);
 #endif

 return (3L);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "12 ReadBooleanChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadBooleanChunk (unsigned char *boolean)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 *boolean=ReadChar ();

 ChangeChunkPointer (current_pointer+temp_pointer); // move to the new chunk \
position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "13 ReadSpotChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadSpotChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 float target [4];
 float hotspot,falloff;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 fread (&(target [0]),sizeof (float),1,bin3ds);
 fread (&(target [1]),sizeof (float),1,bin3ds);
 fread (&(target [2]),sizeof (float),1,bin3ds);
 fread (&hotspot,sizeof (float),1,bin3ds);
 fread (&falloff,sizeof (float),1,bin3ds);

 #ifdef __DEBUG__
 printf (\"      The target of the spot is at: X:%5.2f Y:%5.2f Y:%5.2f\\n\",
          target [0],
          target [1],
          target [2]);
 printf (\"      The hotspot of this light is : %5.2f\\n\",hotspot);
 printf (\"      The falloff of this light is : %5.2f\\n\",falloff);
 #endif

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "14 ReadLightChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadLightChunk (void)
{
 unsigned char end_found=FALSE,boolean;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L; // 2 id + 4 pointer
 float light_coors [3];

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 fread (&(light_coors [0]),sizeof (float),1,bin3ds);
 fread (&(light_coors [1]),sizeof (float),1,bin3ds);
 fread (&(light_coors [2]),sizeof (float),1,bin3ds);

 #ifdef __DEBUG__
 printf (\"     Found light at coordinates: X: %5.2f, Y: %5.2f,Z: %5.2f\\n\",
          light_coors [0],
          light_coors [1],
          light_coors [2]);
 #endif

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case LIT_UNKNWN01 :
                           #ifdef __DEBUG__
                           printf (\" Found Light unknown chunk id of \
%0X\\n\",LIT_UNKNWN01);
                           #endif
                           tellertje+=ReadUnknownChunk (LIT_UNKNWN01);
                           break;
        case LIT_OFF      :
                           #ifdef __DEBUG__
                           printf (\" Light is (on/off) chunk: \
%0X\\n\",LIT_OFF);
                           #endif
                           tellertje+=ReadBooleanChunk (&boolean);
                           #ifdef __DEBUG__
                           if (boolean==TRUE)
                             printf (\"      Light is on\\n\");
                           else
                             printf (\"      Light is off\\n\");
                           #endif
                           break;
        case LIT_SPOT     :
                           #ifdef __DEBUG__
                           printf (\" Light is SpotLight: \
%0X\\n\",TRI_VERTEXL);
                           #endif
                           tellertje+=ReadSpotChunk ();
                           break;
        case COL_RGB      :
                           #ifdef __DEBUG__
                           printf (\" Found Color def (RGB) chunk id of \
%0X\\n\",temp_int);
                           #endif
                           tellertje+=ReadRGBColor ();
                           break;
        case COL_TRU      :
                           #ifdef __DEBUG__
                           printf (\" Found Color def (24bit) chunk id of %0X\
\\n\",temp_int);
                           #endif
                           tellertje+=ReadTrueColor ();
                           break;
        default           :break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "15 ReadCameraChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadCameraChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 float camera_eye [3];
 float camera_focus [3];
 float rotation,lens;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 fread (&(camera_eye [0]),sizeof (float),1,bin3ds);
 fread (&(camera_eye [1]),sizeof (float),1,bin3ds);
 fread (&(camera_eye [2]),sizeof (float),1,bin3ds);

 #ifdef __DEBUG__
 printf (\"     Found Camera viewpoint at coordinates: X: %5.2f, Y: %5.2f,Z: \
%5.2f\\n\",
          camera_eye [0],
          camera_eye [1],
          camera_eye [2]);
 #endif

 fread (&(camera_focus [0]),sizeof (float),1,bin3ds);
 fread (&(camera_focus [1]),sizeof (float),1,bin3ds);
 fread (&(camera_focus [2]),sizeof (float),1,bin3ds);

 #ifdef __DEBUG__
 printf (\"     Found Camera focus coors at coordinates: X: %5.2f, Y: \
%5.2f,Z: %5.2f\\n\",
          camera_focus [0],
          camera_focus [1],
          camera_focus [2]);
 #endif

 fread (&rotation,sizeof (float),1,bin3ds);
 fread (&lens,sizeof (float),1,bin3ds);
 #ifdef __DEBUG__
 printf (\"     Rotation of camera is:  %5.4f\\n\",rotation);
 printf (\"     Lens in used camera is: %5.4fmm\\n\",lens);
 #endif

 if ((temp_pointer-38)0) // this means more chunks are to follow
 {
  #ifdef __DEBUG__
  printf (\"     **** found extra cam chunks ****\\n\");
  #endif
  if (ReadInt ()==CAM_UNKNWN01)
  {
   #ifdef __DEBUG__
   printf (\"     **** Found cam 1 type ch ****\\n\");
   #endif
   ReadUnknownChunk (CAM_UNKNWN01);
  }
  if (ReadInt ()==CAM_UNKNWN02)
  {
   #ifdef __DEBUG__
   printf (\"     **** Found cam 2 type ch ****\\n\");
   #endif
   ReadUnknownChunk (CAM_UNKNWN02);
  }
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "16 ReadVerticesChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadVerticesChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 float vertices [3]; // x,y,z
 unsigned int numb_v;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();
 numb_vertices  =ReadInt ();

 #ifdef __DEBUG__
 printf (\"      Found (%d) number of vertices\\n\",numb_vertices);
 #endif

 for (int i=0;i<numb_vertices;i++)
 {
  fread (&(vertices [0]),sizeof (float),1,bin3ds);
  fread (&(vertices [1]),sizeof (float),1,bin3ds);
  fread (&(vertices [2]),sizeof (float),1,bin3ds);

  #ifdef __DEBUG__
  printf (\"      Vertex nr%4d: X: %5.2f  Y: %5.2f  Z:%5.2f\\n\",
           i,
           vertices [0],
           vertices [1],
           vertices [2]);
  #endif
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "17 ReadSmoothingChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/ 
unsigned long ReadSmoothingChunk ()
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long smoothing;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 for (int i=0;i<numb_faces;i++)
 {
  smoothing=ReadLong();
  smoothing=smoothing; // compiler warnig depressor *:)
  #ifdef __DEBUG__
  printf (\"      The smoothing group for face [%5d] is %d\\n\",i,smoothing);
  #endif
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "18 ReadFacesChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadFacesChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned int temp_diff;
 unsigned int faces [6]; // a,b,c,Diff (Diff= AB: BC: CA: )

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();
 numb_faces     =ReadInt ();
 #ifdef __DEBUG__
 printf (\"      Found (%d) number of faces\\n\",numb_faces);
 #endif

 for (int i=0;i<numb_faces;i++)
 {
  faces [0]=ReadInt ();
  faces [1]=ReadInt ();
  faces [2]=ReadInt ();
  temp_diff=ReadInt () & 0x000F;
  faces [3]=(temp_diff & 0x0004)  2;
  faces [4]=(temp_diff & 0x0002)  1;
  faces [5]=(temp_diff & 0x0001);

  #ifdef __DEBUG__
  printf (\"      Face nr:%d, A: %d  B: %d  C:%d , AB:%d  BC:%d  CA:%d\\n\",
           i,
           faces [0],
           faces [1],
           faces [2],
           faces [3],
           faces [4],
           faces [5]);
  #endif
 }

 if (ReadInt ()==TRI_SMOOTH)
  ReadSmoothingChunk ();
 #ifdef __DEBUG__
 else
  printf (\"      No smoothing groups found, assuming autosmooth\\n\");
 #endif

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "19 ReadTranslationChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadTranslationChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 for (int j=0;j<4;j++)
 {
   for (int i=0;i<3;i++)
    fread (&(trans_mat [j][i]),sizeof (float),1,bin3ds);
 }

 trans_mat [0][3]=0;
 trans_mat [1][3]=0;
 trans_mat [2][3]=0;
 trans_mat [3][3]=1;

 #ifdef __DEBUG__
 printf (\"     The translation matrix is:\\n\");
 for (int i=0;i<4;i++)
     printf (\"      | %5.2f %5.2f %5.2f %5.2f |\\n\",
              trans_mat [i][0],
              trans_mat [i][1],
              trans_mat [i][2],
              trans_mat [i][3]);
 #endif

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "20 ReadObjChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadObjChunk (void)
{
 unsigned char end_found=FALSE,boolean=TRUE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L; // 2 id + 4 pointer

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case TRI_VERTEXL :
                          #ifdef __DEBUG__
                          printf (\" Found Object vertices chunk id of %0X\\n\
\",
                                  temp_int);
                          #endif
                          tellertje+=ReadVerticesChunk ();
                          break;
        case TRI_FACEL1  :
                          #ifdef __DEBUG__
                          printf (\" Found Object faces (1) chunk id of \
%0X\\n\",
                                  temp_int);
                          #endif
                          tellertje+=ReadFacesChunk ();
                          break;
        case TRI_FACEL2  :
                          #ifdef __DEBUG__
                          printf (\" Found Object faces (2) chunk id of \
%0X\\n\",
                                  temp_int);
                          #endif
                          tellertje+=ReadUnknownChunk (temp_int);
                          break;
        case TRI_LOCAL  :
                          #ifdef __DEBUG__
                          printf (\" Found Object translation chunk id of %0X\
\\n\",
                                  temp_int);
                          #endif
                          tellertje+=ReadTranslationChunk ();
                          break;
        case TRI_VISIBLE :
                          #ifdef __DEBUG__
                          printf (\" Found Object vis/invis chunk id of \
%0X\\n\",
                                  temp_int);
                          #endif
                          tellertje+=ReadBooleanChunk (&boolean);

                          #ifdef __DEBUG__
                          if (boolean==TRUE)
                             printf (\"      Object is (visible)\\n\");
                          else
                             printf (\"      Object is (not visible)\\n\");
                          #endif
                          break;
        default:          break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "21 ReadObjectChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadObjectChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L; // 2 id + 4 pointer

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 if (ReadName ()==-1)
 {
  #ifdef __DEBUG__
  printf (\"* Dummy Object found\\n\");
  #endif
 }

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case OBJ_UNKNWN01:tellertje+=ReadUnknownChunk (OBJ_UNKNWN01);break;
        case OBJ_UNKNWN02:tellertje+=ReadUnknownChunk (OBJ_UNKNWN02);break;
        case OBJ_TRIMESH :
                          #ifdef __DEBUG__
                          printf (\" Found Obj/Mesh chunk id of %0X\\n\",
                                  OBJ_TRIMESH);
                          #endif
                          tellertje+=ReadObjChunk ();
                          break;
        case OBJ_LIGHT   :
                          #ifdef __DEBUG__
                          printf (\" Found Light chunk id of %0X\\n\",
                                  OBJ_LIGHT);
                          #endif
                          tellertje+=ReadLightChunk ();
                          break;
        case OBJ_CAMERA  :
                          #ifdef __DEBUG__
                          printf (\" Found Camera chunk id of %0X\\n\",
                                  OBJ_CAMERA);
                          #endif
                          tellertje+=ReadCameraChunk ();
                          break;
        default:          break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "22 ReadBackgrChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadBackgrChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L; // 2 id + 4 pointer

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case COL_RGB :
                      #ifdef __DEBUG__
                      printf (\" Found Color def (RGB) chunk id of %0X\\n\",
                              temp_int);
                      #endif
                      tellertje+=ReadRGBColor ();
                      break;
        case COL_TRU :
                      #ifdef __DEBUG__
                      printf (\" Found Color def (24bit) chunk id of \
%0X\\n\",
                              temp_int);
                      #endif
                      tellertje+=ReadTrueColor ();
                      break;
        default:      break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "23 ReadAmbientChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadAmbientChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L; // 2 id + 4 pointer

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case COL_RGB :
                      #ifdef __DEBUG__
                      printf (\" Found Color def (RGB) chunk id of %0X\\n\",
                              temp_int);
                      #endif
                      tellertje+=ReadRGBColor ();
                      break;
        case COL_TRU :
                      #ifdef __DEBUG__
                      printf (\" Found Color def (24bit) chunk id of \
%0X\\n\",
                              temp_int);
                      #endif
                      tellertje+=ReadTrueColor ();
                      break;
        default:      break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "24 FindCameraChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long FindCameraChunk (void)
{
 long temp_pointer=0L;

 for (int i=0;i<12;i++)
  ReadInt ();

 temp_pointer=11L;
 temp_pointer=ReadName ();

 #ifdef __DEBUG__
 if (temp_pointer==-1)
   printf (\"* No Camera name found\\n\");
 #endif

 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "25 ReadViewPortChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadViewPortChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned int port,attribs;

 views_read++;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 attribs=ReadInt ();
 if (attribs==3)
 {
  #ifdef __DEBUG__
  printf (\"<Snap> active in viewport\\n\");
  #endif
 }
 if (attribs==5)
 {
  #ifdef __DEBUG__
  printf (\"<Grid> active in viewport\\n\");
  #endif
 }

 for (int i=1;i<6;i++) ReadInt (); // read 5 ints to get to the viewport

 port=ReadInt ();
 if ((port==0xFFFF) || (port==0))
 {
   FindCameraChunk ();
   port=CAMERA;
 }

 #ifdef __DEBUG__
 printf (\"Reading [%s] information with id:%d\\n\",viewports [port],port);
 #endif

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "26 ReadViewChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadViewChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case EDIT_VIEW_P1 :
                           #ifdef __DEBUG__
                           printf (\" Found Viewport1 chunk id of %0X\\n\",
                                   temp_int);
                           #endif
                           tellertje+=ReadViewPortChunk ();
                           break;
        case EDIT_VIEW_P2 :
                           #ifdef __DEBUG__
                           printf (\" Found Viewport2 (bogus) chunk id of %0X\
\\n\",
                                   temp_int);
                           #endif
                           tellertje+=ReadUnknownChunk (EDIT_VIEW_P2);
                           break;
       case EDIT_VIEW_P3 :
                           #ifdef __DEBUG__
                           printf (\" Found Viewport chunk id of %0X\\n\",
                                   temp_int);
                           #endif
                           tellertje+=ReadViewPortChunk ();
                           break;
        default           :break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;

   if (views_read3)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "27 ReadMatDefChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadMatDefChunk (void)
{
 unsigned long current_pointer;
 unsigned long temp_pointer;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 if (ReadLongName ()==-1)
 {
   #ifdef __DEBUG__
   printf (\"* No Material name found\\n\");
   #endif
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "28 ReadMaterialChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadMaterialChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case MAT_NAME01  :
                          #ifdef __DEBUG__
                          printf (\" Found Material def chunk id of %0X\\n\",
                                  temp_int);
                          #endif
                          tellertje+=ReadMatDefChunk ();
                          break;
        default:break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "29 ReadEditChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadEditChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case EDIT_UNKNW01:tellertje+=ReadUnknownChunk (EDIT_UNKNW01);break;
        case EDIT_UNKNW02:tellertje+=ReadUnknownChunk (EDIT_UNKNW02);break;
        case EDIT_UNKNW03:tellertje+=ReadUnknownChunk (EDIT_UNKNW03);break;
        case EDIT_UNKNW04:tellertje+=ReadUnknownChunk (EDIT_UNKNW04);break;
        case EDIT_UNKNW05:tellertje+=ReadUnknownChunk (EDIT_UNKNW05);break;
        case EDIT_UNKNW06:tellertje+=ReadUnknownChunk (EDIT_UNKNW06);break;
        case EDIT_UNKNW07:tellertje+=ReadUnknownChunk (EDIT_UNKNW07);break;
        case EDIT_UNKNW08:tellertje+=ReadUnknownChunk (EDIT_UNKNW08);break;
        case EDIT_UNKNW09:tellertje+=ReadUnknownChunk (EDIT_UNKNW09);break;
        case EDIT_UNKNW10:tellertje+=ReadUnknownChunk (EDIT_UNKNW10);break;
        case EDIT_UNKNW11:tellertje+=ReadUnknownChunk (EDIT_UNKNW11);break;
        case EDIT_UNKNW12:tellertje+=ReadUnknownChunk (EDIT_UNKNW12);break;
        case EDIT_UNKNW13:tellertje+=ReadUnknownChunk (EDIT_UNKNW13);break;

        case EDIT_MATERIAL :
                            #ifdef __DEBUG__
                            printf (\" Found Materials chunk id of %0X\\n\",
                                    temp_int);
                            #endif
                            tellertje+=ReadMaterialChunk ();
                            break;
        case EDIT_VIEW1    :
                            #ifdef __DEBUG__
                            printf (\" Found View main def chunk id of %0X\\n\
\",
                                    temp_int);
                            #endif
                            tellertje+=ReadViewChunk ();
                            break;
        case EDIT_BACKGR   :
                            #ifdef __DEBUG__
                            printf (\" Found Backgr chunk id of %0X\\n\",
                                    temp_int);
                            #endif
                            tellertje+=ReadBackgrChunk ();
                            break;
        case EDIT_AMBIENT  :
                            #ifdef __DEBUG__
                            printf (\" Found Ambient chunk id of %0X\\n\",
                                    temp_int);
                            #endif
                            tellertje+=ReadAmbientChunk ();
                            break;
        case EDIT_OBJECT   :
                            #ifdef __DEBUG__
                            printf (\" Found Object chunk id of %0X\\n\",
                                    temp_int);
                            #endif
                            tellertje+=ReadObjectChunk ();
                            break;
        default:            break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "30 ReadKeyfChunk ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadKeyfChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case KEYF_UNKNWN01 :tellertje+=ReadUnknownChunk (temp_int);break;
        case KEYF_UNKNWN02 :tellertje+=ReadUnknownChunk (temp_int);break;
        case KEYF_FRAMES   :
                            #ifdef __DEBUG__
                            printf (\" Found Keyframer frames chunk id of %0X\
\\n\",
                                    temp_int);
                            #endif
                            tellertje+=ReadUnknownChunk (temp_int);
                            break;
        case KEYF_OBJDES   :
                            #ifdef __DEBUG__
                            printf (\" Found Keyframer object description \
chunk id of %0X\\n\",
                                    temp_int);
                            #endif
                            tellertje+=ReadUnknownChunk (temp_int);
                            break;
        case EDIT_VIEW1    :
                            #ifdef __DEBUG__
                            printf (\" Found View main def chunk id of %0X\\n\
\",
                                    temp_int);
                            #endif
                            tellertje+=ReadViewChunk ();
                            break;
        default:            break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
     end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "31 ReadMainChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
unsigned long ReadMainChunk (void)
{
 unsigned char end_found=FALSE;
 unsigned int temp_int;
 unsigned long current_pointer;
 unsigned long temp_pointer;
 unsigned long tellertje=6L;

 current_pointer=GetChunkPointer ();
 temp_pointer   =ReadChunkPointer ();

 while (end_found==FALSE)
 {
   temp_int=ReadInt ();

       switch (temp_int)
       {
        case KEYF3DS :
                      #ifdef __DEBUG__
                      printf (\" Found *Keyframer* chunk id of \
%0X\\n\",KEYF3DS);
                      #endif
                      tellertje+=ReadKeyfChunk ();
                      break;
        case EDIT3DS :
                      #ifdef __DEBUG__
                      printf (\" Found *Editor* chunk id of \
%0X\\n\",EDIT3DS);
                      #endif
                      tellertje+=ReadEditChunk ();
                      break;
        default:      break;
       }

   tellertje+=2;
   if (tellertje=temp_pointer)
    end_found=TRUE;
 }

 ChangeChunkPointer (current_pointer+temp_pointer); 
 // move to the new chunk position
 return (temp_pointer);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "32 ReadPrimaryChunk",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
int ReadPrimaryChunk (void)
{
 unsigned char version;

 if (ReadInt ()==MAIN3DS)
 {
  #ifdef __DEBUG__
  printf (\" Found Main chunk id of %0X\\n\",MAIN3DS);
  #endif
  //---------- find version number
  fseek (bin3ds,28L,SEEK_SET);
  version=ReadChar ();
  if (version<3)
  {
   #ifdef __DEBUG__
   printf (\"Sorry this lib can only read 3ds files of version 3.0 and higher\
\\n\");
   printf (\"The version of the file you want to read is: %d\\n\",version);
   #endif
   return (1);
  }
  fseek (bin3ds,2,SEEK_SET);
  ReadMainChunk ();
 }
 else
  return (1);

 return (0);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
  "33 main",
  " ",
  StyleBox["Done",
    FontColor->RGBColor[1, 0, 0]]
}], "Subsubsection"],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
/*                      Test Main for the 3ds-bin lib                         \
*/
/*----------------------------------------------------------------------------\
*/
int main (int argc,char **argv)
{
 argc=argc;

 bin3ds=fopen (argv [1],\"rb\");
 if (bin3ds==NULL)
  return (-1);

 #ifdef __DEBUG__
  printf (\"\\nLoading 3ds binary file : %s\\n\",argv [1]);
 #endif
 while (ReadPrimaryChunk ()==0);

 return (0);
}\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False],

Cell["\<\
/*------------------------------------------------------------------\
----------*/
#endif

\
\>", "Input",
  PageWidth->Infinity,
  Evaluatable->False,
  InitializationCell->True,
  ShowSpecialCharacters->False]
}, Open  ]]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["IEEE Floating Format",
  FontColor->RGBColor[1, 0, 0]]], "Section"],

Cell[CellGroupData[{

Cell["Single Precision", "Subsection",
  Evaluatable->False],

Cell["\<\
The IEEE single precision floating point standard representation \
requires a 32 bit word,which may be represented as numbered from 0 to 31, \
left to right. The first bit is the sign bit,S,the next eight bits are the \
exponent bits,'E',and the final 23 bits are the fraction'F':S EEEEEEEE \
FFFFFFFFFFFFFFFFFFFFFFF
0 1 8 9 31\
\>", "Text",
  Evaluatable->False],

Cell["\<\
The value V represented by the word may be determined as follows:
 * If E=255 and F is nonzero,then V=NaN (\"Not a number\")
 * If E=255 and F is zero and S is 1,then V=-Infinity
 * If E=255 and F is zero and S is 0,then V=Infinity
 * If 0<E<255 then V=(-1)**S*2**(E-127)*(1.F) where \"1.F\" is intended to \
represent the binary number created by prefixing F with an implicit leading 1 \
and a binary point.
 * If E=0 and F is nonzero,then V=(-1)**S*2**(-126)*(0.F) These are \
\"unnormalized\" values.
 * If E=0 and F is zero and S is 1,then V=-0
 * If E=0 and F is zero and S is 0,then V=0\
\>", "Text",
  Evaluatable->False],

Cell["In particular", "Text",
  Evaluatable->False],

Cell["\<\
0 00000000 00000000000000000000000=0
1 00000000 00000000000000000000000=-0\
\>", "Text",
  Evaluatable->False],

Cell["\<\
0 11111111 00000000000000000000000=Infinity
1 11111111 00000000000000000000000=-Infinity\
\>", "Text",
  Evaluatable->False],

Cell["\<\
0 11111111 00000100000000000000000=NaN
1 11111111 00100010001001010101010=NaN\
\>", "Text",
  Evaluatable->False],

Cell["\<\
0 10000000 00000000000000000000000=+1*2**(128-127)*1.0=2
0 10000001 10100000000000000000000=+1*2**(129-127)*1.101=6.5
1 10000001 10100000000000000000000=-1*2**(129-127)*1.101=-6.5\
\>", "Text",
  Evaluatable->False],

Cell["\<\
0 00000001 00000000000000000000000=+1*2**(1-127)*1.0=2**(-126)
0 00000000 10000000000000000000000=+1*2**(-126)*0.1=2**(-127)
0 00000000 \
00000000000000000000001=+1*2**(-126)*0.00000000000000000000001=2**(-149) \
(Smallest positive value)\
\>", "Text",
  Evaluatable->False]
}, Open  ]],

Cell[CellGroupData[{

Cell["Double Precision", "Subsection",
  Evaluatable->False],

Cell["\<\
The IEEE double precision floating point standard representation \
requires a 64 bit word,which may be represented as numbered from 0 to 63,left \
to right.The first bit is the sign bit,S,the next eleven bits are the \
exponent bits,'E',and the final 52 bits are the fraction'F':S EEEEEEEEEEE \
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
0 1 11 12 63\
\>", "Text",
  Evaluatable->False],

Cell["\<\
The value V represented by the word may be determined as follows:
 * If E=2047 and F is nonzero,then V=NaN (\"Not a number\")
 * If E=2047 and F is zero and S is 1,then V=-Infinity
 * If E=2047 and F is zero and S is 0,then V=Infinity
 * If 0<E<2047 then V=(-1)**S*2**(E-1023)*(1.F) where \"1.F\" is intended to \
represent the binary number created by prefixing F with an implicit leading 1 \
and a binary point.
 * If E=0 and F is nonzero,then V=(-1)**S*2**(-1022)*(0.F) These are \
\"unnormalized\" values.
 * If E=0 and F is zero and S is 1,then V=-0
 * If E=0 and F is zero and S is 0,then V=0\
\>", "Text",
  Evaluatable->False],

Cell["\<\
Reference:ANSI/IEEE Standard 754-1985,Standard for Binary Floating \
Point Arithmetic\
\>", "Text",
  Evaluatable->False]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[StyleBox["Implementation Notes",
  FontColor->RGBColor[1, 0, 0]]], "Section"],

Cell["\<\
A good strategy:

skip all chunks that do not describe vertices, transformations or incidences.
Use the mask to capture subblocks generically (ReadUnknownChunk[ ]), and so \
simply pass over them.
Put the code developed to date into comment blocks, so that if we need them \
later, we can reinvoke them.
Currently this type of data is ignored anyway.\
\>", "Text"]
}, Closed]]
}, Open  ]]
},
FrontEndVersion->"5.2 for X",
ScreenRectangle->{{0, 1024}, {0, 768}},
AutoGeneratedPackage->Automatic,
WindowSize->{765, 740},
WindowMargins->{{102, Automatic}, {Automatic, 0}}
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{

Cell[CellGroupData[{
Cell[1776, 53, 160, 3, 80, "Subtitle"],

Cell[CellGroupData[{
Cell[1961, 60, 31, 0, 74, "Section"],
Cell[1995, 62, 1242, 21, 331, "Input",
  InitializationCell->True],

Cell[CellGroupData[{
Cell[3262, 87, 35, 0, 28, "Subsubsection"],
Cell[3300, 89, 534, 8, 107, "Input",
  InitializationCell->True],
Cell[3837, 99, 1784, 31, 427, "Input",
  InitializationCell->True],
Cell[5624, 132, 1286, 25, 294, "Author"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[6959, 163, 32, 0, 44, "Section"],
Cell[6994, 165, 179, 5, 43, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[7210, 175, 52, 0, 44, "Section"],

Cell[CellGroupData[{
Cell[7287, 179, 26, 0, 38, "Subsection"],
Cell[7316, 181, 1269, 19, 347, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[8622, 205, 34, 0, 30, "Subsection"],
Cell[8659, 207, 569, 10, 187, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[9265, 222, 36, 0, 30, "Subsection"],
Cell[9304, 224, 173, 4, 59, "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[9526, 234, 32, 0, 44, "Section"],
Cell[9561, 236, 88, 2, 27, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[9686, 243, 42, 0, 44, "Section"],
Cell[9731, 245, 293, 5, 75, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[10061, 255, 41, 0, 44, "Section"],

Cell[CellGroupData[{
Cell[10127, 259, 33, 0, 38, "Subsection"],
Cell[10163, 261, 4404, 95, 1627, "Input",
  InitializationCell->True],
Cell[14570, 358, 854, 17, 267, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[15461, 380, 51, 0, 30, "Subsection"],
Cell[15515, 382, 254, 6, 104, "Text"],
Cell[15772, 390, 641, 12, 171, "Input",
  InitializationCell->True],
Cell[16416, 404, 57, 0, 32, "Text"],
Cell[16476, 406, 624, 15, 219, "Input"],
Cell[17103, 423, 539, 12, 139, "Input",
  InitializationCell->True],
Cell[17645, 437, 855, 16, 235, "Input",
  InitializationCell->True],
Cell[18503, 455, 228, 5, 43, "Input",
  InitializationCell->True],
Cell[18734, 462, 101, 2, 27, "Input",
  InitializationCell->True],
Cell[18838, 466, 146, 3, 43, "Input",
  InitializationCell->True],
Cell[18987, 471, 127, 2, 43, "Input"],
Cell[19117, 475, 1146, 21, 347, "Input",
  InitializationCell->True],
Cell[20266, 498, 1116, 20, 347, "Input",
  InitializationCell->True],
Cell[21385, 520, 567, 10, 187, "Input",
  InitializationCell->True],
Cell[21955, 532, 579, 10, 187, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[22571, 547, 44, 0, 30, "Subsection"],
Cell[22618, 549, 556, 10, 203, "Input",
  InitializationCell->True],
Cell[23177, 561, 595, 11, 187, "Input",
  InitializationCell->True],
Cell[23775, 574, 352, 7, 123, "Input",
  InitializationCell->True],
Cell[24130, 583, 429, 8, 123, "Input",
  InitializationCell->True],
Cell[24562, 593, 428, 8, 139, "Input",
  InitializationCell->True],
Cell[24993, 603, 398, 7, 139, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[25428, 615, 73, 0, 30, "Subsection"],

Cell[CellGroupData[{
Cell[25526, 619, 130, 4, 44, "Subsubsection"],
Cell[25659, 625, 2708, 47, 923, "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[28416, 678, 68, 0, 30, "Subsection"],

Cell[CellGroupData[{
Cell[28509, 682, 61, 3, 44, "Subsubsection"],
Cell[28573, 687, 1325, 24, 348, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[29935, 716, 69, 3, 38, "Subsubsection"],
Cell[30007, 721, 973, 19, 268, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[31017, 745, 93, 3, 38, "Subsubsection"],
Cell[31113, 750, 736, 15, 204, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[31886, 770, 78, 3, 38, "Subsubsection"],
Cell[31967, 775, 922, 17, 252, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[32926, 797, 80, 3, 38, "Subsubsection"],
Cell[33009, 802, 1533, 28, 476, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[34579, 835, 63, 3, 38, "Subsubsection"],
Cell[34645, 840, 565, 10, 172, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[35247, 855, 75, 3, 38, "Subsubsection"],
Cell[35325, 860, 1821, 32, 524, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[37183, 897, 98, 3, 38, "Subsubsection"],
Cell[37284, 902, 2323, 41, 684, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[39644, 948, 85, 3, 38, "Subsubsection"],
Cell[39732, 953, 1996, 33, 604, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[41765, 991, 83, 3, 38, "Subsubsection"],
Cell[41851, 996, 1978, 32, 604, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[43866, 1033, 68, 3, 38, "Subsubsection"],
Cell[43937, 1038, 1227, 23, 427, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[45201, 1066, 87, 3, 38, "Subsubsection"],
Cell[45291, 1071, 2770, 50, 764, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[48098, 1126, 69, 3, 38, "Subsubsection"],
Cell[48170, 1131, 1298, 24, 332, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[49505, 1160, 67, 3, 38, "Subsubsection"],
Cell[49575, 1165, 974, 20, 252, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[50586, 1190, 120, 4, 54, "Subsubsection"],
Cell[50709, 1196, 2917, 49, 828, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[53663, 1250, 108, 3, 54, "Subsubsection"],
Cell[53774, 1255, 3235, 55, 940, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[57046, 1315, 90, 3, 38, "Subsubsection"],
Cell[57139, 1320, 2899, 51, 812, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[60075, 1376, 126, 4, 54, "Subsubsection"],
Cell[60204, 1382, 2982, 54, 924, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[63223, 1441, 383, 8, 150, "Subsubsection"],
Cell[63609, 1451, 7189, 143, 2028, "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[70847, 1600, 82, 1, 30, "Subsection"],

Cell[CellGroupData[{
Cell[70954, 1605, 230, 10, 60, "Subsubsection"],
Cell[71187, 1617, 1697, 32, 524, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[72921, 1654, 115, 4, 38, "Subsubsection"],
Cell[73039, 1660, 89, 3, 30, "Text"],
Cell[73131, 1665, 1089, 20, 347, "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[74269, 1691, 37, 0, 30, "Subsection"],

Cell[CellGroupData[{
Cell[74331, 1695, 87, 1, 28, "Subsubsection"],
Cell[74421, 1698, 2422, 42, 587, "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[76904, 1747, 30, 0, 44, "Section"],
Cell[76937, 1749, 112, 2, 27, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[77086, 1756, 30, 0, 44, "Section"],
Cell[77119, 1758, 171, 5, 43, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[77327, 1768, 129, 2, 44, "Section"],
Cell[77459, 1772, 2007, 54, 896, "Text"],

Cell[CellGroupData[{
Cell[79491, 1830, 119, 3, 38, "Subsection"],
Cell[79613, 1835, 1526, 28, 446, "Text"],
Cell[81142, 1865, 4999, 142, 2157, "Input",
  Evaluatable->False],
Cell[86144, 2009, 4911, 109, 1904, "Text"],
Cell[91058, 2120, 229, 11, 110, "Text"]
}, Open  ]],

Cell[CellGroupData[{
Cell[91324, 2136, 122, 3, 38, "Subsection"],
Cell[91449, 2141, 348, 8, 62, "Text"],
Cell[91800, 2151, 2481, 76, 1150, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[94318, 2232, 124, 3, 30, "Subsection"],
Cell[94445, 2237, 162, 6, 46, "Text"],

Cell[CellGroupData[{
Cell[94632, 2247, 121, 3, 28, "Subsubsection"],
Cell[94756, 2252, 610, 16, 186, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[95403, 2273, 127, 3, 22, "Subsubsection"],
Cell[95533, 2278, 478, 23, 314, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[96048, 2306, 152, 3, 22, "Subsubsection"],
Cell[96203, 2311, 363, 10, 90, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[96603, 2326, 150, 3, 22, "Subsubsection"],
Cell[96756, 2331, 1210, 33, 394, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[98003, 2369, 154, 3, 22, "Subsubsection"],
Cell[98160, 2374, 547, 17, 186, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[98744, 2396, 153, 3, 22, "Subsubsection"],
Cell[98900, 2401, 369, 14, 170, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[99306, 2420, 128, 3, 22, "Subsubsection"],
Cell[99437, 2425, 397, 13, 154, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[99871, 2443, 131, 3, 22, "Subsubsection"],
Cell[100005, 2448, 597, 22, 266, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[100639, 2475, 126, 3, 22, "Subsubsection"],
Cell[100768, 2480, 1662, 45, 654, "Text"]
}, Open  ]],

Cell[CellGroupData[{
Cell[102467, 2530, 137, 3, 28, "Subsubsection"],
Cell[102607, 2535, 698, 17, 154, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[103342, 2557, 135, 3, 22, "Subsubsection"],
Cell[103480, 2562, 309, 11, 106, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[103826, 2578, 137, 3, 22, "Subsubsection"],
Cell[103966, 2583, 224, 10, 90, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[104227, 2598, 125, 3, 22, "Subsubsection"],
Cell[104355, 2603, 324, 11, 106, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[104716, 2619, 131, 3, 22, "Subsubsection"],
Cell[104850, 2624, 347, 13, 138, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[105234, 2642, 121, 3, 22, "Subsubsection"],
Cell[105358, 2647, 464, 18, 234, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[105859, 2670, 126, 3, 22, "Subsubsection"],
Cell[105988, 2675, 311, 12, 138, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[106336, 2692, 125, 3, 22, "Subsubsection"],
Cell[106464, 2697, 223, 10, 106, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[106724, 2712, 134, 3, 22, "Subsubsection"],
Cell[106861, 2717, 223, 10, 106, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[107121, 2732, 122, 3, 22, "Subsubsection"],
Cell[107246, 2737, 499, 16, 202, "Text"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{
Cell[107794, 2759, 123, 3, 38, "Subsection"],

Cell[CellGroupData[{
Cell[107942, 2766, 125, 3, 32, "Subsubsection"],
Cell[108070, 2771, 279, 10, 106, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[108386, 2786, 134, 3, 24, "Subsubsection"],
Cell[108523, 2791, 269, 9, 90, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[108829, 2805, 136, 3, 24, "Subsubsection"],
Cell[108968, 2810, 306, 15, 186, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[109311, 2830, 144, 3, 24, "Subsubsection"],
Cell[109458, 2835, 1918, 59, 890, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[111413, 2899, 136, 3, 24, "Subsubsection"],
Cell[111552, 2904, 138, 3, 26, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[111727, 2912, 130, 3, 24, "Subsubsection"],
Cell[111860, 2917, 471, 17, 202, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[112380, 2940, 111, 3, 30, "Subsection"],
Cell[112494, 2945, 448, 9, 78, "Text"],

Cell[CellGroupData[{
Cell[112967, 2958, 113, 5, 28, "Subsubsection"],
Cell[113083, 2965, 4403, 166, 2397, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Open  ]],

Cell[CellGroupData[{
Cell[117523, 3136, 130, 5, 28, "Subsubsection"],
Cell[117656, 3143, 728, 25, 282, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Open  ]],

Cell[CellGroupData[{
Cell[118421, 3173, 106, 4, 28, "Subsubsection"],
Cell[118530, 3179, 437, 15, 148, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[119004, 3199, 111, 5, 22, "Subsubsection"],
Cell[119118, 3206, 315, 12, 103, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[119470, 3223, 112, 5, 22, "Subsubsection"],
Cell[119585, 3230, 376, 17, 178, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[119998, 3252, 120, 5, 22, "Subsubsection"],
Cell[120121, 3259, 277, 11, 88, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[120435, 3275, 119, 5, 22, "Subsubsection"],
Cell[120557, 3282, 323, 11, 88, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[120917, 3298, 122, 5, 22, "Subsubsection"],
Cell[121042, 3305, 308, 11, 87, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Open  ]],

Cell[CellGroupData[{
Cell[121387, 3321, 112, 5, 28, "Subsubsection"],
Cell[121502, 3328, 655, 34, 433, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[122194, 3367, 116, 5, 22, "Subsubsection"],
Cell[122313, 3374, 638, 34, 433, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[122988, 3413, 120, 5, 22, "Subsubsection"],
Cell[123111, 3420, 542, 21, 238, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[123690, 3446, 117, 5, 22, "Subsubsection"],
Cell[123810, 3453, 529, 23, 268, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[124376, 3481, 118, 5, 22, "Subsubsection"],
Cell[124497, 3488, 522, 23, 268, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[125056, 3516, 121, 5, 22, "Subsubsection"],
Cell[125180, 3523, 546, 21, 223, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[125763, 3549, 112, 4, 22, "Subsubsection"],
Cell[125878, 3555, 1084, 36, 463, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[126999, 3596, 113, 4, 22, "Subsubsection"],
Cell[127115, 3602, 2934, 89, 1183, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[130086, 3696, 114, 4, 22, "Subsubsection"],
Cell[130203, 3702, 2007, 74, 1003, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[132247, 3781, 122, 5, 22, "Subsubsection"],
Cell[132372, 3788, 1061, 41, 538, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[133470, 3834, 117, 4, 22, "Subsubsection"],
Cell[133590, 3840, 754, 29, 358, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[134381, 3874, 113, 4, 22, "Subsubsection"],
Cell[134497, 3880, 1368, 54, 733, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[135902, 3939, 119, 4, 22, "Subsubsection"],
Cell[136024, 3945, 988, 39, 508, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[137049, 3989, 117, 5, 22, "Subsubsection"],
Cell[137169, 3996, 2757, 83, 1093, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[139963, 4084, 120, 5, 22, "Subsubsection"],
Cell[140086, 4091, 1994, 66, 913, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[142117, 4162, 120, 5, 22, "Subsubsection"],
Cell[142240, 4169, 1389, 51, 673, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[143666, 4225, 121, 5, 22, "Subsubsection"],
Cell[143790, 4232, 1390, 51, 673, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[145217, 4288, 120, 5, 22, "Subsubsection"],
Cell[145340, 4295, 480, 24, 283, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[145857, 4324, 122, 5, 22, "Subsubsection"],
Cell[145982, 4331, 1038, 49, 658, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[147057, 4385, 118, 5, 22, "Subsubsection"],
Cell[147178, 4392, 1818, 61, 823, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[149033, 4458, 120, 5, 22, "Subsubsection"],
Cell[149156, 4465, 611, 26, 313, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[149804, 4496, 122, 5, 22, "Subsubsection"],
Cell[149929, 4503, 1100, 43, 568, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[151066, 4551, 118, 5, 22, "Subsubsection"],
Cell[151187, 4558, 3415, 86, 1198, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[154639, 4649, 112, 4, 22, "Subsubsection"],
Cell[154754, 4655, 1973, 62, 808, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[156764, 4722, 118, 5, 22, "Subsubsection"],
Cell[156885, 4729, 1292, 50, 643, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[158214, 4784, 121, 5, 22, "Subsubsection"],
Cell[158338, 4791, 789, 36, 447, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Open  ]],

Cell[CellGroupData[{
Cell[159164, 4832, 109, 5, 28, "Subsubsection"],
Cell[159276, 4839, 628, 26, 282, "Input",
  Evaluatable->False,
  InitializationCell->True],
Cell[159907, 4867, 221, 10, 72, "Input",
  Evaluatable->False,
  InitializationCell->True]
}, Open  ]]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[160189, 4884, 91, 1, 44, "Section"],

Cell[CellGroupData[{
Cell[160305, 4889, 60, 1, 38, "Subsection",
  Evaluatable->False],
Cell[160368, 4892, 373, 8, 122, "Text",
  Evaluatable->False],
Cell[160744, 4902, 638, 13, 212, "Text",
  Evaluatable->False],
Cell[161385, 4917, 51, 1, 32, "Text",
  Evaluatable->False],
Cell[161439, 4920, 120, 4, 50, "Text",
  Evaluatable->False],
Cell[161562, 4926, 134, 4, 50, "Text",
  Evaluatable->False],
Cell[161699, 4932, 123, 4, 50, "Text",
  Evaluatable->False],
Cell[161825, 4938, 225, 5, 68, "Text",
  Evaluatable->False],
Cell[162053, 4945, 284, 7, 104, "Text",
  Evaluatable->False]
}, Open  ]],

Cell[CellGroupData[{
Cell[162374, 4957, 60, 1, 38, "Subsection",
  Evaluatable->False],
Cell[162437, 4960, 406, 8, 122, "Text",
  Evaluatable->False],
Cell[162846, 4970, 644, 13, 212, "Text",
  Evaluatable->False],
Cell[163493, 4985, 131, 4, 50, "Text",
  Evaluatable->False]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{
Cell[163673, 4995, 91, 1, 44, "Section"],
Cell[163767, 4998, 374, 9, 158, "Text"]
}, Closed]]
}, Open  ]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

