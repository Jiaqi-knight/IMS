(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: VTK.m *)
(* Context: *)
(* 
  Author:Christian Moosmann + Christian Bretthauer *)
(* 
  Date: 7.2.2006, Freiburg *)
(* 
  Summary: This package provides an interface to export to and read from VTK \
files *)
(* Package Copyright: GNU GPL *)
(* Package Version: 0.3.2 *)
(* 
  Mathematica Version: 5.2 *)
(* History: 
     7.2.06  * Hexahedron numbering changes
      2.2.06  * added support for quadratic elements
               * automatic conversion form 2D coordinates to 3D coords
               * documentation changes
      12.4.06  * added imsVTKRead
  *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* 
  Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* VTK is a Mathematica Package to provide export functions to VTK *)

(* Copyright (C) <year> <name of author> *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)



(* Start Package *)
BeginPackage["Imtek`Interfaces`VTK`"];
Needs["Imtek`Maintenance`"]

imsCreateObsoleteFunctionInterface[ VTKScript, $Context ]
imsCreateObsoleteFunctionInterface[ ParaView, $Context ]

imsCreateObsoleteFunctionInterface[ VTKFileName, $Context ]
imsCreateObsoleteFunctionInterface[ VTKTitle, $Context ]
imsCreateObsoleteFunctionInterface[ VTKVarName, $Context ]
imsCreateObsoleteFunctionInterface[ PVFileName, $Context ]
imsCreateObsoleteFunctionInterface[ PVClip, $Context ]
imsCreateObsoleteFunctionInterface[ PVBackground, $Context ]
imsCreateObsoleteFunctionInterface[ PVImageSize, $Context ]
imsCreateObsoleteFunctionInterface[ PVCamera, $Context ]
imsCreateObsoleteFunctionInterface[ VTKVarName, $Context ]
imsCreateObsoleteFunctionInterface[ VTKVarRange, $Context ]





(* *)
(* documentation *)
(* *)

(* functions *)
imsVTKScript::usage = 
  "imsVTKScript[nodes,elements,options] generates a VTK-file (filename specified with the imsVTKFileName option). In this file  the mesh as well as the nodal solution is spezified. It can be used with e.g. ParaView to perform postprocessing of a simulation"

imsParaView::usage="imsParaView[imsVTKfileName,ModelDimensions,VariableValueRange,options] generates a ParaView batch script for use with a VTK-file generated with imsVTKScript." \

imsReadVTK::usage = 
  "imsReadVTK[filePath] reads unstructured as well as structured-grid VTK files returning an imsNexus. For unstructured grids only imsElements are supported. Point data will be returned as an imsNexus without elements. Structured grid data is returned as points in the center of the structured grid boxes."



imsVTKFileName::usage \
="imsVTKFileName->String, the name of the file that is generated";
imsVTKTitle::usage="imsVTKTitle->String, the title that is printed in the VTK-File";\

imsVTKVarName::usage= \
"imsVTKVarName\[Rule]String, a string that identifies the variable at the nodes";\


imsPVFileName::usage="imsPVFileName->String, the name of the file that is generated. No Tilde!";\

imsPVClip::usage="Define a clipping plane.";
imsPVBackground::usage="Define the background color"
imsPVImageSize::usage="Define the image size"

imsPVImageName::usage="Define the image base-name. No Tilde!"

imsPVCamera::usage="Define the camera viewpoint"
imsVTKVarName::usage="Define a different variable name. It has to be the same as defined in imsVTKScript. Both functions use the same default."

imsVTKVarRange::usage="For transient results, define the number of steps."




(* *)
(* Error Messages *)
(* *)

imsVTKScript::"NumVar"="Too many variable components, VTK can only handle 4!";



Begin["`Private`"];



Needs["Imtek`MeshElementLibrary`"]
Needs["Imtek`Interfaces`EasyMesh`"]
Needs["Imtek`Nodes`"]
Needs["Imtek`Graph`"]



(* *)
(* implementation part *)
(* *)

(* constructor *)




(* *)
(* define your options *)
(* *)

Options[imsVTKScript]={imsVTKFileName\[Rule]"MathExport.vtk",
      imsVTKTitle\[Rule]"VTK-File generated by VTKWrite, IMS, Mathematica",
      imsVTKVarName\[Rule]"Variable"};
Options[imsParaView]={imsPVFileName\[Rule]"MathExport.pvb",imsPVClip\[Rule]{},
      imsPVBackground\[Rule]{0.5,0.5,0.5},imsPVImageSize\[Rule]{600,600},
      imsPVImageName\[Rule]"MathExport",imsPVCamera->Automatic,
      imsVTKVarName\[Rule]"Variable",imsVTKVarRange\[Rule]1};



(* selector *)



(* predicates *)
(*
  Unprotect[ Line ];
  Line /: LineQ[ Line[ a_, b_ ] ] := True;
  Protect[ Line ];
  LineQ[ ___ ] := False;
  *)



(* *)
(* public functions *)
(* *)

imsVTKScript[nodes_List,elements_List,opts___]:=
    Module[{myFileName,myTitle,numVars,myVarName,stream},
      myFileName=imsVTKFileName/.{opts}/.Options[imsVTKScript];
      myTitle=imsVTKTitle/.{opts}/.Options[imsVTKScript];
      myVarName=imsVTKVarName/.{opts}/.Options[imsVTKScript];
      numVars=Last[Dimensions[imsGetValues[nodes]]];
      If[numVars>4,Message[imsVTKScript::"NumVar"]];
      stream=OpenWrite[myFileName];
      WriteVTKHeader[stream,myTitle];
      WriteVTKGrid[stream,nodes,elements];
      WriteVTKValues[stream,nodes, myVarName];
      Return[Close[stream]];
      ];

imsParaView[VTKfileName_String,ModelDimensions_List,VariableValueRange_List,
      opts___]:=Module[{myFileName,stream,pvclip,pvbackground,pvimageSize,
        pvcamera,pvcamPos,pvcamTarget,pvVTKVarName,pvVTKVarRange,
        myimagename},
      myFileName=imsPVFileName/.{opts}/.Options[imsParaView];
      pvclip=imsPVClip/.{opts}/.Options[imsParaView];
      pvbackground=imsPVBackground/.{opts}/.Options[imsParaView];
      pvimageSize=imsPVImageSize/.{opts}/.Options[imsParaView];
      pvcamera=imsPVCamera/.{opts}/.Options[imsParaView];
      pvVTKVarName=imsVTKVarName/.{opts}/.Options[imsParaView];
      pvVTKVarRange=imsVTKVarRange/.{opts}/.Options[imsParaView];
      myimagename=imsPVImageName/.{opts}/.Options[imsParaView];
      
      If[pvcamera===Automatic,
        Which[
          Length[ModelDimensions]\[Equal]2,
          	
          pvcamPos={0.5*(ModelDimensions[[1,2]]-ModelDimensions[[1,1]]),
              0.5*(ModelDimensions[[2,2]]-ModelDimensions[[2,1]]),
              2.*Max[{0.5*(ModelDimensions[[1,2]]-ModelDimensions[[1,1]]),
                    0.5*(ModelDimensions[[2,2]]-ModelDimensions[[2,1]])}]};
          	
          pvcamTarget={0.5*(ModelDimensions[[1,2]]-ModelDimensions[[1,1]]),
              0.5*(ModelDimensions[[2,2]]-ModelDimensions[[2,1]]),0},
          Length[ModelDimensions]\[Equal]3, 
          pvcamPos={2*Max[{ModelDimensions[[1,2]],ModelDimensions[[1,1]]}],
              2*Max[{ModelDimensions[[2,2]],ModelDimensions[[2,1]]}],
              2*Max[{ModelDimensions[[3,2]],ModelDimensions[[3,1]]}]};
          	
          pvcamTarget={Max[{ModelDimensions[[1,2]],ModelDimensions[[1,1]]}],
              Max[{ModelDimensions[[2,2]],ModelDimensions[[2,1]]}],
              Max[{ModelDimensions[[3,2]],ModelDimensions[[3,1]]}]}
          	],
        {pvcamPos,pvcamTarget}=pvcamera];
      stream=OpenWrite[myFileName];
      WritePVHeader[stream];
      WritePVRead[stream,VTKfileName];
      WritePVRendering[stream,ToString[pvVTKVarName],
        IntegerPart[pvVTKVarRange],myimagename,pvbackground,pvimageSize,
        pvcamPos,pvcamTarget];
      WritePVLookupTable[stream,ToString[pvVTKVarName],VariableValueRange];
      
      Which[
        pvclip\[Equal]{},WritePVExport[stream,"pvReader"],
        True,
        WritePVClip[stream,pvclip[[1]],pvclip[[2]]];
        WritePVExport[stream,"pvClip"];
        ];
      Return[Close[stream]];
      ];

imsReadVTK[VTKFile_]:=Module[{},
      VTKData=imsImportVTK [VTKFile];
      Return[
        If[imsGetGridTypeVTK[VTKData]=="UNSTRUCTURED_GRID",
          imsReadUnstructuredVTK[VTKData],imsReadStructuredVTK[VTKData]]
        ]
      ];


(* *)
(* private functions *)
(* *)

WriteVTKHeader[stream_OutputStream,title_String]:=
  WriteString[stream,"# vtk DataFile Version 2.3\n",title,"\nASCII \n\n"]

WriteVTKGrid[stream_OutputStream,nodes_List,elements_List]:=
    Module[{numPoints,numIncidentsList,newElements,CellTable ,numCellInts,
        numElements,elementTypeList,dims,coords},
      numPoints=Length[nodes];
      dims=Length[imsGetCoords[nodes[[1]]]];
      If[dims\[Equal]3,coords=imsGetCoords[nodes],
        coords=Transpose[
            Join[ Transpose[
                imsGetCoords[nodes]  ] , {Table[0, {numPoints} ]}]]];
      
      WriteString[stream,"DATASET UNSTRUCTURED_GRID","\n","POINTS ",
        ToString[numPoints]," float\n"];
      imsMatrixToStream[stream,coords];
      
      numIncidentsList=Length/@imsGetIncidentsIds[elements];
      newElements=Which[ 
          
          Head[elements[[1]]]===
            imsTetrahedronQuadratic1DOFSerendipity,#-1&/@(imsGetIncidentsIds[
                  elements])[[All,{1,2,3,4,5,6,7,10,8,9}]]   , 
          
          Head[elements[[1]]]===
            imsHexahedronLinear1DOF,#-1&/@(imsGetIncidentsIds[
                  elements])[[All,{ 8,5,6,7,4,1,2,3}]]   ,
          
          Head[elements[[1]]]===
            imsHexahedronQuadratic1DOFSerendipity,#-1&/@(imsGetIncidentsIds[
                  elements])[[All,{ 8,5,6,7,4,1,2,3,16,13,14,15,12,9,10,11,20,
                  17,18,19}]]   ,
          True,#-1&/@imsGetIncidentsIds[elements]];
      CellTable=Transpose[Prepend[Transpose[newElements],numIncidentsList]];
      numCellInts=Length[Flatten[CellTable]];
      numElements=Length[elements];
      WriteString[stream,"\n","CELLS ",ToString[numElements]," ",
        ToString[numCellInts],"\n"];
      imsMatrixToStream[stream,CellTable];
      
      elementTypeList=
        Head/@elements/.{imsTriangleLinear1DOF\[Rule]5,
            imsTriangleQuadratic1DOFSerendipity\[Rule]22,
            imsQuadLinear1DOF\[Rule]9,
            imsQuadQuadratic1DOFSerendipity\[Rule]23,
            imsTetrahedronLinear1DOF\[Rule]10,
            imsTetrahedronQuadratic1DOFSerendipity\[Rule]24,
            imsHexahedronLinear1DOF\[Rule]12,
            imsHexahedronQuadratic1DOFSerendipity\[Rule]25};
      WriteString[stream,"\n","CELL_TYPES ",ToString[numElements],"\n"];
      imsMatrixToStream[stream,Partition[elementTypeList,1]];
      
      WriteString[stream,"\n"]
      ];

WriteVTKValues[stream_OutputStream,nodes_List, name_String]:=
    Module[{dataLength,varNum,dofNum},
      dataLength=Length[nodes];
      varNum=Dimensions[imsGetValues[nodes]][[2]];
      dofNum=Dimensions[imsGetValues[nodes]][[3]];
      WriteString[stream,"POINT_DATA ",ToString[dataLength],"\n"];
      Which[
        varNum\[Equal]1,
        	WriteString[stream,"SCALARS ",name," float ",ToString[dofNum]," \n",
          "LOOKUP_TABLE default \n"];
        	imsMatrixToStream[stream,imsGetValues[nodes][[ All, 1 ]] ],
        varNum>1,
        	Do[
          	
          WriteString[stream,"SCALARS ",name,ToString[i]," float  ",
            ToString[dofNum]," \n","LOOKUP_TABLE default \n"];
          	imsMatrixToStream[stream,imsGetValues[nodes][[All,i]]];
          	WriteString[stream,"\n"],{i,1,varNum}]
        ];
      
      ];


WritePVHeader[stream_OutputStream]:=WriteString[stream,"# ParaView Version 1.6\n\n
      \n#Initialization\n
      \nvtkSMObject foo 
      \nset proxyManager [foo GetProxyManager] 
      \nfoo Delete  
      \nvtkSMProperty foo 
      \nfoo SetCheckDomains 0 
      \nfoo Delete  \n \n"];

WritePVRendering[stream_OutputStream,VTKvariableBasename_,VTKvariableNum_,
      ImageBasename_,bgColor_List,picSize_List,CamPos_List,CamFocus_List]:=
  
      WriteString[stream,"for {set i 1} {$i < ",
      ToString[IntegerPart[VTKvariableNum+1]],"} {incr i} {\n
      set VarName \"",VTKvariableBasename,"$i\" \n
      set PicName \"", ImageBasename,"$i.jpg\" \n
      \nset Ren1 [$proxyManager NewProxy rendering DefaultDisplayWindow] \n
      $proxyManager RegisterProxy rendering Ren1 $Ren1 \n
      $Ren1 UnRegister {} \n
      [$Ren1 GetProperty BackgroundColor] SetElements3 ",ToString[
        bgColor[[1]]]," ",ToString[bgColor[[2]]]," ",ToString[bgColor[[3]]] ,"\n
      [$Ren1 GetProperty Size] SetElements2 ",ToString[picSize[[1]]]," ",
      ToString[picSize[[2]]],"\n
      [$Ren1 GetProperty CameraPosition] SetElements3 ",ToString[CamPos[[1]]],
      " ",ToString[CamPos[[2]]]," ",ToString[CamPos[[3]]] ,"\n
      [$Ren1 GetProperty CameraFocalPoint] SetElements3 ",ToString[
        CamFocus[[1]]]," ",ToString[CamFocus[[2]]]," ",
      ToString[CamFocus[[3]]] ,"\n
      [$Ren1 GetProperty CameraViewUp] SetElements3 0 0 0 \n
      [$Ren1 GetProperty CameraViewAngle] SetElements1 53 \n
      [$Ren1 GetProperty CameraClippingRange] SetElements2 0.0 100.0\n \n"];

WritePVRead[stream_OutputStream,VTKfileName_String]:=
    WriteString[stream,"set pvReader [$proxyManager NewProxy sources legacyreader] \n
      $proxyManager RegisterProxy sources pvReader $pvReader \n
      $pvReader UnRegister {} \n
      [$pvReader GetProperty FileName] SetElement 0 {",VTKfileName,"} \n
      $pvReader UpdateVTKObjects \n \n"];

WritePVLookupTable[stream_OutputStream,VTKvariableBasename_,scalarRange_]:=
  
      WriteString[stream,"set pvLookupTable [$proxyManager NewProxy lookup_tables LookupTable] \n
      $proxyManager RegisterProxy lookup_tables pvLookupTable $pvLookupTable \n
      $pvLookupTable UnRegister {} \n
      [$pvLookupTable GetProperty NumberOfTableValues] SetElements1 256 \n
      [$pvLookupTable GetProperty HueRange] SetElements2 0.667 0 \n
      [$pvLookupTable GetProperty SaturationRange] SetElements2 1 1 \n
      [$pvLookupTable GetProperty ValueRange] SetElements2 1 1 \n
      [$pvLookupTable GetProperty ScalarRange] SetElements2 ",ToString[
        scalarRange[[1]]]," ",ToString[scalarRange[[2]]],"\n
      [$pvLookupTable GetProperty VectorComponent] SetElements1 0 \n
      [$pvLookupTable GetProperty VectorMode] SetElements1 0 \n
      $pvLookupTable UpdateVTKObjects \n
      $pvLookupTable Build \n 
      
      \nset pvTitle [$proxyManager NewProxy text_properties TextProperty] \n
      $proxyManager RegisterProxy text_properties pvTitle $pvTitle \n
      $pvTitle UnRegister {} \n
      [$pvTitle GetProperty Color] SetElements3 1 1 1 \n
      [$pvTitle GetProperty FontFamily] SetElements1 0 \n
      [$pvTitle GetProperty Bold] SetElements1 1 \n
      [$pvTitle GetProperty Italic] SetElements1 1 \n
      [$pvTitle GetProperty Shadow] SetElements1 1 \n
      [$pvTitle GetProperty Opacity] SetElements1 1 \n
      $pvTitle UpdateVTKObjects \n
      
      \nset pvLabel [$proxyManager NewProxy text_properties TextProperty] \n
      $proxyManager RegisterProxy text_properties pvLabel $pvLabel \n
      $pvLabel UnRegister {} \n
      [$pvLabel GetProperty Color] SetElements3 1 1 1 \n
      [$pvLabel GetProperty FontFamily] SetElements1 0 \n
      [$pvLabel GetProperty Bold] SetElements1 1 \n
      [$pvLabel GetProperty Italic] SetElements1 1 \n
      [$pvLabel GetProperty Shadow] SetElements1 1 \n
      [$pvLabel GetProperty Opacity] SetElements1 1 \n
      $pvLabel UpdateVTKObjects \n
      
      \nset pvBar [$proxyManager NewProxy rendering ScalarBarActor] \n
      $proxyManager RegisterProxy scalar_bar pvBar $pvBar \n
      $pvBar UnRegister {} \n
      [$pvBar GetProperty LookupTable] AddProxy $pvLookupTable \n
      [$pvBar GetProperty TitleTextProperty] AddProxy $pvTitle \n
      [$pvBar GetProperty LabelTextProperty] AddProxy $pvLabel \n
      [$pvBar GetProperty Orientation] SetElements1 1 \n
      [$pvBar GetProperty Width] SetElements1 0.13 \n
      [$pvBar GetProperty Height] SetElements1 0.5 \n
      [$pvBar GetProperty Position] SetElements2 0.87 0.25 \n
      [$pvBar GetProperty Title] SetElement 0 {",VTKvariableBasename,"} \n
      [$pvBar GetProperty LabelFormat] SetElement 0 {%-#6.3g} \n
      [$Ren1 GetProperty Displayers] AddProxy $pvBar \n
      $pvBar UpdateVTKObjects \n \n"];

WritePVClip[stream_OutputStream,pvClipOrigin_,pvClipNormal_]:=
    
    WriteString[stream,"set pvClip [$proxyManager NewProxy filters Clip]\n
      $proxyManager RegisterProxy filters pvClip $pvClip\n
      $pvClip UnRegister {}\n
      [$pvClip GetProperty Input] AddProxy $pvReader \n
      \nset pvPlane [$proxyManager NewProxy implicit_functions Plane]\n
      $proxyManager RegisterProxy implicit_functions pvPlane $pvPlane\n
      $pvPlane UnRegister {}\n
      [$pvPlane GetProperty Origin] SetElements3 ",ToString[
        pvClipOrigin[[1]]]," ",ToString[pvClipOrigin[[2]]]," ",
      ToString[pvClipOrigin[[3]]],"\n
      [$pvPlane GetProperty Normal] SetElements3 ",ToString[
        pvClipNormal[[1]]]," ",ToString[pvClipNormal[[2]]]," ",
      ToString[pvClipNormal[[3]]],"\n
      $pvPlane UpdateVTKObjects\n \n
      [$pvClip GetProperty ClipFunction] AddProxy $pvPlane\n
      [$pvClip GetProperty InsideOut] SetElement 0 1\n
      $pvClip UpdateVTKObjects\n \n"];

WritePVExport[stream_OutputStream,Input_]:=
    WriteString[stream,"set pvDisplay [$proxyManager NewProxy rendering DefaultDisplayer] \n
      $proxyManager RegisterProxy rendering pvDisplay $pvDisplay \n
      $pvDisplay UnRegister {}\n
      [$pvDisplay GetProperty Input] AddProxy $",Input,"\n
      [$Ren1 GetProperty Displayers] AddProxy $pvDisplay\n
      [$pvDisplay GetProperty DisplayAsOutline] SetElements1 0\n
      [$pvDisplay GetProperty ImmediateModeRendering] SetElements1 1\n
      [$pvDisplay GetProperty ScalarVisibility] SetElements1 1\n
      [$pvDisplay GetProperty ColorMode] SetElements1 1\n
      [$pvDisplay GetProperty InterpolateColorsBeforeMapping] SetElements1 1\n
      [$pvDisplay GetProperty Representation] SetElements1 2\n
      [$pvDisplay GetProperty Interpolation] SetElements1 1\n
      [$pvDisplay GetProperty LineWidth] SetElements1 1\n
      [$pvDisplay GetProperty PointSize] SetElements1 1\n
      [$pvDisplay GetProperty Position] SetElements3 0 0 0\n
      [$pvDisplay GetProperty Scale] SetElements3 1 1 1\n
      [$pvDisplay GetProperty Orientation] SetElements3 0 0 0\n
      [$pvDisplay GetProperty Origin] SetElements3 0 0 0\n
      [$pvDisplay GetProperty Opacity] SetElements1 1\n
      [$pvDisplay GetProperty Color] SetElements3 1 1 1\n
      [$pvDisplay GetProperty LookupTable] AddProxy $pvLookupTable\n
      [$pvDisplay GetProperty ScalarMode] SetElement 0 3\n
      [$pvDisplay GetProperty ColorArray] SetElement 0 $VarName \n
      $pvDisplay UpdateVTKObjects \n
      $Ren1 UpdateVTKObjects \n
      \n$Ren1 WriteImage $PicName vtkJPEGWriter
      \n}
      \n$proxyManager UnRegisterProxies"];


imsImportVTK[VTKFileName_]:=Import[VTKFileName,"Table"];

imsGetTitleVTK[VTKData_]:=VTKData[[2]];

imsGetContentVTK[VTKData_List]:=
    Select[Select[#,StringQ]&/@VTKData,#\[NotEqual]{}&];

imsGetGridTypeVTK[VTKData_List]:=
    VTKData[[Position[VTKData,"DATASET"][[1,1]]]][[2]];

imsGetNumberOfPointsVTK[VTKData_List]:=If[
      imsGetGridTypeVTK[VTKData]=="UNSTRUCTURED_GRID",
      VTKData[[Position[VTKData,"POINTS"][[1,1]]]][[2]],
      imsGetDimensionsVTK[VTKData][[1]]*imsGetDimensionsVTK[VTKData][[2]]*
        imsGetDimensionsVTK[VTKData][[3]]
      ];

imsGetNumberOfCellsVTK[VTKData_List]:=
    VTKData[[Position[VTKData,"CELLS"][[1,1]]]][[2]];

imsGetCellTypesVTK[VTKData_List]:=
    Flatten[Take[
        VTKData,{Position[VTKData,"CELL_TYPES"][[1,1]]+1,
          Position[VTKData,"CELL_TYPES"][[1,1]]+
            imsGetNumberOfCellsVTK[VTKData]}]];

imsElementLookUpTable={{"Point",{1}},0,{"imsMakeLineLinear1DOF",{1,2}},
      0,{"imsMakeTriangleLinear1DOF",{1,2,3}},0,0,
      0,{"imsMakeQuadLinear1DOF",{1,2,3,
          4}},{"imsMakeTetrahedronLinear1DOF",{1,2,3,4}},
      0,{"imsMakeHexahedronLinear1DOF",{1,2,3,4,5,6,7,8}},0,0,0,0,0,0,0,
      0,{"imsMakeLineQuadratic1DOF",{1,2,
          3}},{"imsMakeTriangleQuadratic1DOFSerendipity",{1,2,3,4,5,
          6}},{"imsMakeQuadQuadratic1DOFSerendipity",{1,2,3,4,5,6,7,
          8}},{"imsMakeTetrahedronQuadratic1DOFSerendipity",{1,2,3,4,5,6,7,9,
          10,8}},{"imsMakeHexahedronQuadratic1DOFSerendipity",{3,4,1,2,7,8,5,
          6,11,12,9,10,15,16,13,14,19,20,17,18}}};

imsGetNodesVTK[VTKData_]:=
    Take[VTKData,{Position[VTKData,"POINTS"][[1,1]]+1,
        Position[VTKData,"POINTS"][[1,1]]+imsGetNumberOfPointsVTK[VTKData]}];

imsGetCellsVTK[VTKData_]:=
    Take[VTKData+1,{Position[VTKData,"CELLS"][[1,1]]+1,
        Position[VTKData,"CELLS"][[1,1]]+imsGetNumberOfCellsVTK[VTKData]}];

imsGetScalarsVTK[VTKData_]:=Module[{ScalarStarts},
      ScalarStarts=Position[VTKData,"SCALARS"][[All,1]];
      Return[
        Table[{VTKData[[ScalarStarts[[j]]]][[2]]<>":",
            VTKData[[ScalarStarts[[j]]+i]]},{j,1,Length[ScalarStarts]},{i,2,
            imsGetNumberOfPointsVTK[VTKData]+1}]]
      ];

imsGetVectorsVTK[VTKData_]:=Module[{VectorStarts},
      VectorStarts=Position[VTKData,"VECTORS"][[All,1]];
      Return[
        Table[{VTKData[[VectorStarts[[j]]]][[2]]<>":",
            VTKData[[VectorStarts[[j]]+i]]},{j,1,Length[VectorStarts]},{i,1,
            imsGetNumberOfPointsVTK[VTKData]}]]
      ];

imsGetTensorsVTK[VTKData_]:=Module[{TensorStarts},
      TensorStarts=Position[VTKData,"TENSORS"][[All,1]];
      Return[
        Table[{VTKData[[TensorStarts[[j]]]][[2]]<>
              ":",{VTKData[[TensorStarts[[j]]+i]],
              VTKData[[TensorStarts[[j]]+i+1]],
              VTKData[[TensorStarts[[j]]+i+2]]}},{j,1,
            Length[TensorStarts]},{i,1,3*imsGetNumberOfPointsVTK[VTKData],
            3}]]
      ];

imsGetDimensionsVTK[VTKData_List]:=
    VTKData[[Position[VTKData,"DIMENSIONS"][[1,1]]]][[{2,3,4}]]-1;

imsGetOriginVTK[VTKData_List]:=
    VTKData[[Position[VTKData,"ORIGIN"][[1,1]]]][[{2,3,4}]];

imsGetSpacingVTK[VTKData_List]:=
    VTKData[[Position[VTKData,"SPACING"][[1,1]]]][[{2,3,4}]];

imsMakeStructuredNodesVTK[VTKData_]:=
    Module[{VTKNodes,Origin,Dimension,Spacing,Scalars,Vectors,Tensors},
      Origin=imsGetOriginVTK[VTKData];
      Dimension=imsGetDimensionsVTK[VTKData];
      Spacing=imsGetSpacingVTK[VTKData];
      Scalars=imsGetScalarsVTK[VTKData];
      Vectors=imsGetVectorsVTK[VTKData];
      Tensors=imsGetTensorsVTK[VTKData];
      VTKNodes=
        Flatten[Table[{Origin[[1]]+i*Spacing[[1]],Origin[[2]]+j*Spacing[[2]],
              Origin[[3]]+k*Spacing[[3]]},{k,1,Dimension[[3]]},{j,1,
              Dimension[[2]]},{i,1,Dimension[[1]]}],2];
      Return[
        Table[imsMakeNode[i,VTKNodes[[i]],
            Flatten[{Scalars[[All,i]],Vectors[[All,i]],Tensors[[All,i]]},
              1]],{i,1,Length[VTKNodes]}]];
      ];

imsReadUnstructuredVTK[VTKData_]:=
    Module[{VTKNodes,VTKCellTypes,Incidences,Scalars,Vectors,Tensors,
        AllNodesIMSStyle,AllElementsIMSStyle},
      VTKNodes=imsGetNodesVTK[VTKData];
      VTKCellTypes=imsElementLookUpTable[[#]]&/@imsGetCellTypesVTK[VTKData];
      Incidences=imsGetCellsVTK[VTKData];
      Scalars=imsGetScalarsVTK[VTKData];
      Vectors=imsGetVectorsVTK[VTKData];
      Tensors=imsGetTensorsVTK[VTKData];
      AllNodesIMSStyle=
        Table[imsMakeNode[i,VTKNodes[[i]],
            Flatten[{Scalars[[All,i]],Vectors[[All,i]],Tensors[[All,i]]},
              1]],{i,1,Length[VTKNodes]}];
      AllElementsIMSStyle=
        If[VTKCellTypes[[1]][[1]]=="Point",{},
          
          Table[ToExpression[VTKCellTypes[[i]][[1]]][1,
              Drop[Incidences[[i]],1][[VTKCellTypes[[i]][[2]]]]],{i,1,
              Length[VTKCellTypes]}]
          ];
      Return[imsMakeNexus[ {},AllNodesIMSStyle, AllElementsIMSStyle]]
      ];

imsReadStructuredVTK[VTKData_]:=Module[{AllNodesIMSStyle},
      AllNodesIMSStyle=imsMakeStructuredNodesVTK[VTKData];
      Return[imsMakeNexus[ {},AllNodesIMSStyle, {}]]
      ];




(* representors *)
(*
  Unprotect[ Graphics ];
  
  Graphics[ aLineList:{_Line ..} , options___ ]:=
     Graphics[ Line[ 
        Through[ List[ GetPointX, GetPointY ][ # ] ] & /@Flatten[ 
            Through[ List[GetLineStart, GetLineEnd][ # ] ] & /@ aLineList
            ]
         ], options
      ] ;
  
  Protect[ Graphics ];
  *)



End[] (* of Begin Private *)





(* Protect[] (* anything *) *)
EndPackage[] 
