(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.2'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[    792272,      26638]*)
(*NotebookOutlinePosition[    815708,      27312]*)
(*  CellTagsIndexPosition[    810237,      27158]*)
(*WindowFrame->Normal*)



Notebook[{

Cell[CellGroupData[{
Cell[TextData[{
  StyleBox["Supplementary Mathematica Help Browser\n",
    FontSize->24],
  "by Ted Ersek  ",
  ButtonBox[" ted.ersek@navy.mil",
    ButtonData:>{
      URL[ "mailto:ted.ersek@navy.mil"], None},
    ButtonStyle->"Hyperlink"]
}], "Title",
  FontSize->12,
  Background->RGBColor[1, 0.975998, 0.949996]],

Cell[CellGroupData[{

Cell["What you will find here and won't find here", "Section",
  CellFrame->False],

Cell["\<\
What I try to provide through this resource is additional material to help \
people get over the Mathematica learning curve. More specifically I try to \
demonstrate features that are hard to master from the Wolfram Research \
documentation. I also try to explain nuances that lots of users would \
otherwise never know about.\
\>", "Text"],

Cell[TextData[{
  "This resource isn't intended for people who never used Mathematica and \
want to start learning how to use it. I suggest that users in that position \
get a copy of The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book and read sections 1.0 through 1.10,  sections 2.1 through 2.4 (260 \
pages of light reading). After that one should read any sections in Part III \
(Advanced ",
  StyleBox["Mathematics in Mathematica",
    FontSlant->"Italic"],
  ") in the same book that are of interest. At that point one should have a \
working knowledge of ",
  StyleBox["Mathematica.",
    FontSlant->"Italic"],
  "  One can then use The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book, and of course this resource as reference material.\n\nBecause I \
don't intend to teach ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " from the ground up, a lot of principles fundamental to ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " aren't explained here. I figured there is no need to explain features \
that are explained very well in The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book.\n\nYou also won't find discussion of certain features that even I \
haven't used (ie. working with Files and Streams)."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["New or revised areas", "Section",
  CellFrame->False],

Cell[CellGroupData[{

Cell["New or Revised in May 2000", "Subsection",
  ShowGroupOpenCloseIcon->True],

Cell[TextData[{
  ButtonBox["FoldList",
    ButtonData:>"FoldList",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Insert",
    ButtonData:>"Insert",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Part",
    ButtonData:>"Part",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Together",
    ButtonData:>"Together",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ToString",
    ButtonData:>"ToString",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Simplify & FullSimplify",
    ButtonData:>"Simplify_FullSimplify",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Split",
    ButtonData:>"Split",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Sort",
    ButtonData:>"Sort",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Pure functions with no arguments",
    ButtonData:>"No_Argument_Functions",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Controlling Memory Usage",
    ButtonData:>"Controlling Memory Usage",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Programming For Speed",
    ButtonData:>"Speedy_Programming",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Tech Support Secrets",
    ButtonData:>"Tech Support",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Working with a List or Table of data",
    ButtonData:>"Lists_Tables",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["An Algebraic Transformation",
    ButtonData:>"Algebra_Transformation",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Making a Tensor into a Matrix",
    ButtonData:>"Tensor_to_Matrix",
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["New or Revised in Oct 2002 ", "Subsection",
  ShowGroupOpenCloseIcon->True],

Cell[TextData[{
  ButtonBox["Apply",
    ButtonData:>"Apply",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ButtonProgramming",
    ButtonData:>"ButtonProgramming",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ButtonStyles",
    ButtonData:>"ButtonStyles",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["CoefficientsToPolynomial",
    ButtonData:>"CoefficientsToPolynomial",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Condition",
    ButtonData:>"Condition",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Complement",
    ButtonData:>"Complement",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Count",
    ButtonData:>"Count",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["DeleteCases",
    ButtonData:>"DeleteCases",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Distribute, an application",
    ButtonData:>"Distribute - Application",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Dot",
    ButtonData:>"Dot",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["EvaluateAt",
    ButtonData:>"Evaluate At",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["EvaluatePattern",
    ButtonData:>"Evaluate Pattern",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ExactNumberQ, InexactNumberQ, NumberQ, NumericQ",
    ButtonData:>"ExactNumberQ",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["FreeQ",
    ButtonData:>"FreeQ",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Inner",
    ButtonData:>"Inner",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Launching an email message",
    ButtonData:>"Email",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Level",
    ButtonData:>"Level",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["MemberQ",
    ButtonData:>"MemberQ",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Message",
    ButtonData:>"Message",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Options, OptionQ",
    ButtonData:>"Options",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Outer",
    ButtonData:>"Outer",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Position",
    ButtonData:>"Position",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Replace",
    ButtonData:>"Replace",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Scan",
    ButtonData:>"Scan",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["(s_Symbol) may not be specific enough",
    ButtonData:>"s_Symbol",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["TagBox",
    ButtonData:>"TagBox",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Tr",
    ButtonData:>"Tr",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Trig option",
    ButtonData:>"Trig option",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Union without sorting",
    ButtonData:>"DeleteRepititions",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Update",
    ButtonData:>"Update",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Where definitions are stored",
    ButtonData:>"Definition-Storage",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["$OutputForms",
    ButtonData:>"$OutputForms",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["$PreRead, $Pre, $Post, $PrePrint",
    ButtonData:>"$Pre;$Post",
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["New or Revised in May 2004", "Subsection"],

Cell[TextData[{
  ButtonBox["Alternatives",
    ButtonData:>"Alternatives",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Clear, ClearAll, Remove",
    ButtonData:>"Clear",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Condition",
    ButtonData:>"Condition",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Blank(_), BlankSequence(_), BlankNullSequence(___)",
    ButtonData:>"Blank",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Button Programming",
    ButtonData:>"ButtonProgramming",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Evaluate",
    ButtonData:>"Evaluate",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["The Evaluation Process",
    ButtonData:>"Evaluation-Process",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Flatten",
    ButtonData:>"Flatten",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["HoldAll, HoldFirst, HoldRest",
    ButtonData:>"HoldAll",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["HoldAllComplete",
    ButtonData:>"HoldAllComplete",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ListConvolve",
    ButtonData:>"ListConvolve",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ListCorrelate",
    ButtonData:>"ListCorrelate",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["NHoldAll, NHoldRest, NHoldFirst",
    ButtonData:>"NHoldAll",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Optional",
    ButtonData:>"Optional",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Ordering",
    ButtonData:>"Ordering",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Pattern",
    ButtonData:>"Pattern",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Pattern Matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["PatternTest",
    ButtonData:>"PatternTest",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Random",
    ButtonData:>"Random",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Repeated (..), RepeatedNull (...)",
    ButtonData:>"Repeated RepeatedNull",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Replace",
    ButtonData:>"Replace",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ReplaceAll, ReplaceRepeated",
    ButtonData:>"ReplaceAll;ReplaceRepeated",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Tech Support Secrets",
    ButtonData:>"Tech Support",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Unevaluated",
    ButtonData:>"Unevaluated",
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Verbatim",
    ButtonData:>"Verbatim",
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Alternatives", "Section",
  CellFrame->{{0, 0}, {0, 4}}],

Cell["\<\
Alternatives as in (p1 | p2 | p3) are used when you want to refer to one of \
multiple patterns.  So in the next cell ( _Sin | _Cos | _Tan ) represents an \
expression with the with the head Sin, Cos, or Tan. \
\>", "Text",
  CellTags->"Alternatives"],

Cell[CellGroupData[{

Cell[BoxData[
    \({\[ExponentialE]\^2, 2, Sin[1] + x, Cos[1] - 1/2, 3.4, 
        Tan[x + 1]} /. \((_Sin | _Cos | _Tan)\) \[Rule] 
        Trigonometric\)], "Input"],

Cell[BoxData[
    \({\[ExponentialE]\^2, 2, 
      Trigonometric + x, \(-\(1\/2\)\) + Trigonometric, 3.4`, 
      Trigonometric}\)], "Output"]
}, Closed]],

Cell["\<\
in the next cell (f) is defined when given one argument with the head Real or \
Integer.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x_Real | x_Integer] := x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[2.4], f[2, 4], f[s]}\)}], "Input"],

Cell[BoxData[
    \({3, 3.4`, f[2, 4], f[s]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell (f) is defined when given one or more real arguments or \
one or more integer arguments.  However, this definition isn't used when (f) \
is given a sequence of arguments where some are real and others are integer.  \
Allowing a mix of different patterns requires is demonstrated in the section \
on ",
  ButtonBox["Repeated, RepeatedNull",
    ButtonData:>"Repeated RepeatedNull",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x__Real | x__Integer] := x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[2.4], f[2, 4], f[2.4, 2.1], f[2, 2.4], f[s]}\)}], "Input"],

Cell[BoxData[
    \({3, 3.4`, 7, 5.5`, f[2, 2.4`], f[s]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Instead of using  (x_Real  x_Integer) we can use  ",
  Cell[BoxData[
      \(TraditionalForm\`x : \((_Real | _Integer)\)\)]],
  ".  \nAnd instead of using (x__Real | x_Integer) we can use  ",
  Cell[BoxData[
      \(TraditionalForm\`x(__Real | __Integer)\)]],
  ".  \n\nIn addition any other combination of pattern matching constructs \
can be used with Alternatives.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section.\n\nA common place to use Alternatives \
is in the second argument of ",
  ButtonBox["MakeBoxes",
    ButtonData:>"MakeBoxes",
    ButtonStyle->"Hyperlink"],
  " when you want to use a MakeBoxes rule for StandardForm, and \
TraditionalForm, but not for  InputForm, TableForm, etc.  In that case use  \
form:(StandardForm|TraditionalForm)  as the second argument in the MakeBoxes \
definition as in the next cell.  You can see below that this MakeBoxes rule \
is used for StandardForm, TraditionalForm, but not InputForm."
}], "Text"],

Cell[BoxData[
    \(MakeBoxes[foo[expr_], form : \((StandardForm | TraditionalForm)\)] := 
      RowBox[{"\<{\>", MakeBoxes[expr, form], "\<}\>"}]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Apply", "Section"],

Cell["\<\
First I define (lst) which will be used to demonstrate Apply.\
\>", "Text",
  CellTags->"Apply"],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst = 
      Table[Random[Integer, {0, 9}], \ \ \ {3}, {2}, {2}, {2}]\)], "Input"],

Cell[BoxData[
    \({{{{3, 8}, {0, 4}}, {{3, 6}, {5, 8}}}, {{{3, 8}, {7, 2}}, {{8, 3}, {8, 
            2}}}, {{{6, 3}, {3, 6}}, {{2, 6}, {6, 2}}}}\)], "Output"]
}, Closed]],

Cell["(h@@lst) simply changes the head of list to h. ", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[h, g1, g2, g3, g4];\)\), "\[IndentingNewLine]", 
    \(h @@ lst\)}], "Input"],

Cell[BoxData[
    \(h[{{{3, 8}, {0, 4}}, {{3, 6}, {5, 8}}}, {{{3, 8}, {7, 2}}, {{8, 3}, {8, 
            2}}}, {{{6, 3}, {3, 6}}, {{2, 6}, {6, 2}}}]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Starting with ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 4.0 we could use  (h@@@lst)  to apply a head to all sub-expressions at a \
specific level."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(h @@@ lst\)], "Input"],

Cell[BoxData[
    \({h[{{3, 8}, {0, 4}}, {{3, 6}, {5, 8}}], 
      h[{{3, 8}, {7, 2}}, {{8, 3}, {8, 2}}], 
      h[{{6, 3}, {3, 6}}, {{2, 6}, {6, 2}}]}\)], "Output"]
}, Closed]],

Cell["\<\
(h@@lst)  is normally equivalent to Apply[h, expr] and  (h@@@lst)  is \
normally equivalent to Apply[h, lst, 1] as demonstrated in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({h @@ lst === Apply[h, lst], \ \ h @@@ lst === 
        Apply[h, lst, 1]}\)], "Input"],

Cell[BoxData[
    \({True, True}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "If you use Apply in packages you write and you need to make the package \
highly reliable you should be completely explicit by using things like\n\
Apply[h, expr, Heads\[Rule]False]  or  Apply[h, expr, 1, Heads->False]  since \
the user of your package may have changed the default option using  \
SetOptions[Apply, Heads\[Rule]True].",
  StyleBox["\n",
    FontWeight->"Bold"],
  "\nThe next example changes the heads at levels 1 and 2 to h."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Apply[h, lst, 2]\)], "Input"],

Cell[BoxData[
    \({h[h[{3, 8}, {0, 4}], h[{3, 6}, {5, 8}]], 
      h[h[{3, 8}, {7, 2}], h[{8, 3}, {8, 2}]], 
      h[h[{6, 3}, {3, 6}], h[{2, 6}, {6, 2}]]}\)], "Output"]
}, Closed]],

Cell["\<\
The next example changes the heads at all levels from 0 down to level 2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Apply[h, lst, {0, 2}]\)], "Input"],

Cell[BoxData[
    \(h[h[h[{3, 8}, {0, 4}], h[{3, 6}, {5, 8}]], 
      h[h[{3, 8}, {7, 2}], h[{8, 3}, {8, 2}]], 
      h[h[{6, 3}, {3, 6}], h[{2, 6}, {6, 2}]]]\)], "Output"]
}, Closed]],

Cell["\<\
Fortunately we can Apply a function to an atomic expression without getting \
an error message.  In that case we simply get the atom back.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({h @@ 2, h @@@ 3}\)], "Input"],

Cell[BoxData[
    \({2, 3}\)], "Output"]
}, Closed]],

Cell["\<\
The heads we are changing don't have to be lists and they don't have to be \
the same.  Here I make a more general expression to demonstrate this.\
\>", "Text"],

Cell[BoxData[
    \(\(expr = 
        g1[{2, 3}, {3, 4}] g2[{4, 5}, {5, 6}] + 
          g3[{6, 7}, {7, 8}] g4[{8, 9}, {9, 10}];\)\)], "Input"],

Cell["This changes the head Plus to h.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(h @@ expr\)], "Input"],

Cell[BoxData[
    \(h[g1[{2, 3}, {3, 4}]\ g2[{4, 5}, {5, 6}], 
      g3[{6, 7}, {7, 8}]\ g4[{8, 9}, {9, 10}]]\)], "Output"]
}, Closed]],

Cell["This changes the head Times to h.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(h @@@ expr\)], "Input"],

Cell[BoxData[
    \(h[g1[{2, 3}, {3, 4}], g2[{4, 5}, {5, 6}]] + 
      h[g3[{6, 7}, {7, 8}], g4[{8, 9}, {9, 10}]]\)], "Output"]
}, Closed]],

Cell["This changes the heads g1, g2, g3, and g4 to (h).", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Apply[h, expr, {2}]\)], "Input"],

Cell[BoxData[
    \(h[{2, 3}, {3, 4}]\ h[{4, 5}, {5, 6}] + 
      h[{6, 7}, {7, 8}]\ h[{8, 9}, {9, 10}]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
Apply has a Heads option with the default setting (Heads\[Rule]False).  I \
needed help from David Park to come up with some examples here.  In the next \
input Apply is used with the default setting (Heads\[Rule]False), and the \
only sub-expression whose head is changed are \
Part[expr,1]\[LongRightArrow]g1[2] and Part[expr,2]\[LongRightArrow]g2[3].  \
Not including heads these are the only sub-expressions at level 1.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g1, g2, h, y];\)\), "\[IndentingNewLine]", 
    \(\(expr = \(f[y]\)[g1[2], g2[3]];\)\), "\[IndentingNewLine]", 
    \(Apply[h, expr, 1]\)}], "Input"],

Cell[BoxData[
    \(\(f[y]\)[h[2], h[3]]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Part[expr, 0]\)], "Input"],

Cell[BoxData[
    \(f[y]\)], "Output"]
}, Closed]],

Cell["\<\
Now the previous example is repeated using (Heads\[Rule]True) and (h) is \
applied to the sub-expression Part[expr,0]\[LongRightArrow]f[y]. The \
expression f[y] is the head of (expr) and Apply only affects the heads when \
the setting (Heads\[Rule]True) is used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Apply[h, expr, 1, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(\(h[y]\)[h[2], h[3]]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[TextData[{
  "Also read  \"Further Examples\" at the end of the  ",
  ButtonBox["Apply",
    ButtonStyle->"RefGuideLink"],
  "  documentation in the Help Browser."
}], "Subsection",
  FontSize->12]
}, Closed]],

Cell[CellGroupData[{

Cell["Array", "Section"],

Cell[TextData[{
  "In the first line below we get a list of Cos[x/4] sampled at \nx={1, 2, 3, \
... 12}.  You can get the same result using Cos[Range[1/4,3,1/4]], and timing \
tests show it's faster to do this using Range.  If you are concerned about \
speed, you should use Range whenever possible.  The #& notation is explained \
under ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Array[Cos[#/4] &, \ \ 12]\)], "Input"],

Cell[BoxData[
    \({Cos[1\/4], Cos[1\/2], Cos[3\/4], Cos[1], Cos[5\/4], Cos[3\/2], 
      Cos[7\/4], Cos[2], Cos[9\/4], Cos[5\/2], Cos[11\/4], 
      Cos[3]}\)], "Output"]
}, Closed]],

Cell["\<\
The next line gives 12 samples of Cos[x/4] starting at (x=4).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Array[Cos[#/4] &, \ \ 12, 4]\)], "Input"],

Cell[BoxData[
    \({Cos[1], Cos[5\/4], Cos[3\/2], Cos[7\/4], Cos[2], Cos[9\/4], Cos[5\/2], 
      Cos[11\/4], Cos[3], Cos[13\/4], Cos[7\/2], Cos[15\/4]}\)], "Output"]
}, Closed]],

Cell["\<\
Array can take a fourth argument which should be applied to the result \
instead of list.  The next line finds the minimum of the samples given in the \
previous line.  Notice the function to be applied must be the fourth \
argument, so you must provide an starting value as a third argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Array[Cos[#/4] &, 12, 4, Min]\)], "Input"],

Cell[BoxData[
    \(Cos[13\/4]\)], "Output"]
}, Closed]],

Cell["\<\
The starting place for Array doesn't have to be an integer.  In the next line \
Array starts at the symbol (t) and samples Cos[_] at 11 points.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, t];\)\), "\[IndentingNewLine]", 
    \(Array[Cos, 11, t]\)}], "Input"],

Cell[BoxData[
    \({Cos[t], Cos[1 + t], Cos[2 + t], Cos[3 + t], Cos[4 + t], Cos[5 + t], 
      Cos[6 + t], Cos[7 + t], Cos[8 + t], Cos[9 + t], 
      Cos[10 + t]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next line Array is used to make a matrix.  ",
  ButtonBox["Range",
    ButtonData:>"Range",
    ButtonStyle->"Hyperlink"],
  " can do many things Array can do very efficiently.  However, Array is the \
method of choice for making matrices such as the following."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Array[f, {5, 3}] // MatrixForm\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {\(f[1, 1]\), \(f[1, 2]\), \(f[1, 3]\)},
            {\(f[2, 1]\), \(f[2, 2]\), \(f[2, 3]\)},
            {\(f[3, 1]\), \(f[3, 2]\), \(f[3, 3]\)},
            {\(f[4, 1]\), \(f[4, 2]\), \(f[4, 3]\)},
            {\(f[5, 1]\), \(f[5, 2]\), \(f[5, 3]\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the line above  both arguments of (f) start at one (the default).  
Using the next line both arguments of (f) start at 10.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Array[f, {5, 3}, 10] // MatrixForm\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {\(f[10, 10]\), \(f[10, 11]\), \(f[10, 12]\)},
            {\(f[11, 10]\), \(f[11, 11]\), \(f[11, 12]\)},
            {\(f[12, 10]\), \(f[12, 11]\), \(f[12, 12]\)},
            {\(f[13, 10]\), \(f[13, 11]\), \(f[13, 12]\)},
            {\(f[14, 10]\), \(f[14, 11]\), \(f[14, 12]\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the next line the array starts with 4 in the first argument and 10 in the \
second argument and counts from there\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Array[f, {5, 3}, {4, 10}] // MatrixForm\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {\(f[4, 10]\), \(f[4, 11]\), \(f[4, 12]\)},
            {\(f[5, 10]\), \(f[5, 11]\), \(f[5, 12]\)},
            {\(f[6, 10]\), \(f[6, 11]\), \(f[6, 12]\)},
            {\(f[7, 10]\), \(f[7, 11]\), \(f[7, 12]\)},
            {\(f[8, 10]\), \(f[8, 11]\), \(f[8, 12]\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Blank (_), BlankSequence (__), BlankNullSequence (___)", "Section"],

Cell["\<\
Blank (_), BlankSequence (__) and BlankNullSequence (___) are the most \
primative of Mathematica's pattern matching features.\
\>", "Text",
  CellTags->"Blank"],

Cell[CellGroupData[{

Cell["Basic Blank (_) usage", "Subsection"],

Cell["\<\
In the first example Blank (_) is used for individual arguments.  In this \
case (f) is only defined when it's given two arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[x_, y_] := {x + 1, y + 1}\), "\[IndentingNewLine]", 
    \({f[t, 3], f[t, 3, 5], f[]}\)}], "Input"],

Cell[BoxData[
    \({{1 + t, 4}, f[t, 3, 5], f[]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Basic BlankSequence (__) usage", "Subsection"],

Cell["\<\
In the next example BlankSequence (__) is used and (x___) represents a \
sequence of one or more arguments.  So in this case (f) is defined when it's \
given one or more argument, but undefined when given no arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[x__] := {0, x, 0}\), "\[IndentingNewLine]", 
    \({f[t], f[t, 3, 5], f[]}\)}], "Input"],

Cell[BoxData[
    \({{0, t, 0}, {0, t, 3, 5, 0}, f[]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Basic BlankNullSequence (___) usage ", "Subsection"],

Cell["\<\
In the next example BlankNullSequence(___) is used and (x___) refers to a \
sequence of any number of arguments, or an empty set of arguments.  In this \
case f[] returns {0,0} while (f) was undefined in the previous example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[x___] := {0, x, 0}\), "\[IndentingNewLine]", 
    \({f[t], f[t, 3, 5], f[]}\)}], "Input"],

Cell[BoxData[
    \({{0, t, 0}, {0, t, 3, 5, 0}, {0, 0}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Use of Blanks without naming a variable", "Subsection"],

Cell["\<\
If a function doesn't use some of the arguments, it's more efficient to not \
name them. 
In the following example I define a function that returns True when given any \
single argument.  Often times we will give a function other definitions to \
use in other cases, and make it use a catch all definition such as this in \
all other cases.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[_] := True\), "\[IndentingNewLine]", 
    \({f[t], f[t, 3, 5], f[]}\)}], "Input"],

Cell[BoxData[
    \({True, f[t, 3, 5], f[]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell (f) returns True when given one or more argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[__] := True\), "\[IndentingNewLine]", 
    \({f[t], f[t, 3, 5], f[]}\)}], "Input"],

Cell[BoxData[
    \({True, True, f[]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell (f) returns True when given any number of arguments or no \
arguments at all.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[___] := True\), "\[IndentingNewLine]", 
    \({f[t], f[t, 3, 5], f[]}\)}], "Input"],

Cell[BoxData[
    \({True, True, True}\)], "Output"]
}, Closed]],

Cell["\<\
A more common use of an unamed BlankNullSequence is in the next cell.  In \
this case (f) is defined when it gets two or more arguments.  The first \
argument goes with (x_), the second argument goes with (y_), and all other \
arguments go with (___).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[x_, y_, ___] := {x + 1, y + 1}\), "\[IndentingNewLine]", 
    \({f[t], f[t, 3], f[u, 4, v, b, n, m]}\)}], "Input"],

Cell[BoxData[
    \({f[t], {1 + t, 4}, {1 + u, 5}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Use of named Blanks with a specified head", "Subsection"],

Cell["\<\
In the next example (f) is only defined when given two arguments that are \
symbols.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f, s, t];\)\), "\[IndentingNewLine]", 
    \(f[x_Symbol, y_Symbol] := {x + 1, y + 1}\), "\[IndentingNewLine]", 
    \({f[s, t], f[s, 3], f[s, s + t]}\)}], "Input"],

Cell[BoxData[
    \({{1 + s, 1 + t}, f[s, 3], f[s, s + t]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example (x__Real) represents a sequence of one or more arguments \
that are symbols.  If any argument of (f) is not a symbol, (f) is not \
defined.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f, s, t];\)\), "\[IndentingNewLine]", 
    \(f[x__Symbol] := Plus[x, 1]\), "\[IndentingNewLine]", 
    \({f[s], f[s, t], f[], f[s, t, x + y]}\)}], "Input"],

Cell[BoxData[
    \({1 + s, 1 + s + t, f[], f[s, t, x + y]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example BlankNullSequence(___) is used and (x___Symbol) refers to \
a sequence of any number of arguments with the head symbol, or an empty set \
of arguments. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f, s, t];\)\), "\[IndentingNewLine]", 
    \(f[x___Symbol] := Plus[x, 1]\), "\[IndentingNewLine]", 
    \({f[s], f[s, t], f[], f[s, t, x + y]}\)}], "Input"],

Cell[BoxData[
    \({1 + s, 1 + s + t, 1, f[s, t, x + y]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Use of unamed Blanks with a specified head", "Subsection"],

Cell["\<\
In the next few examples there is no advantage in naming the arguments, and \
the definition evaluated faster than one where the argument is named.  In the \
next cell (f) returns True when given a single argument with the Head Real.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[_Real] := True\), "\[IndentingNewLine]", 
    \({f[2.3], f[2.3, 4.5], f[2.3, 3.4, 4.5], f[], f[4]}\)}], "Input"],

Cell[BoxData[
    \({True, f[2.3`, 4.5`], f[2.3`, 3.4`, 4.5`], f[], f[4]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell (f) returns True when given one or more argument and all the \
arguments have the Head Real.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[__Real] := True\), "\[IndentingNewLine]", 
    \({f[2.3], f[2.3, 4.5], f[2.3, 3.4, 4.5], f[], f[4]}\)}], "Input"],

Cell[BoxData[
    \({True, True, True, f[], f[4]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell (f) returns True when given any number of arguments or no \
arguments at all, but only when all arguments given have the Head Real.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(f[___Real] := True\), "\[IndentingNewLine]", 
    \({f[2.3], f[2.3, 4.5], f[2.3, 3.4, 4.5], f[], f[4]}\)}], "Input"],

Cell[BoxData[
    \({True, True, True, True, f[4]}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Block", "Section"],

Cell["\<\
Block[{x, y}, ....] is normally used to make the kernel to temporarily forget \
about any values that symbols (x,y) may have.  Contrary to what Module does \
the variables (x,y) inside Block are the same variables (x,y) outside the \
Block.  The only thing Block does is temporarily change or clear the values \
of these variables. Some applications are given in the grouped cells below. 

The next cell clears any previous definitions that might interfere with the \
examples below.\
\>", "Text"],

Cell[BoxData[
    \(Clear["\<Global`*\>"]\)], "Input"],

Cell[CellGroupData[{

Cell["Temporarily clear the meaning of built in functions", "Subsection"],

Cell["\<\
If you need to write a program that you know may post messages you can \
suppress the display of messages during intermediate steps of your program.  \
As a specific example the expression in the next cell causes the kernel to \
evaluate Message[Prime::intpp, 2.25] inside the Block.  The head Message has \
no meaning while inside the Block, so the message is never printed.  Try \
evaluating Prime[2.25] without using  Block and a message will be printed \
(unless you turned off the message earlier). \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Message}, Prime[2.25]]\)], "Input"],

Cell[BoxData[
    \(Prime[2.25`]\)], "Output"]
}, Closed]],

Cell["\<\
For another example of making the kernel forget what a built-in function does \
consider the expression below which is wrapped in HoldForm.\
\>", "Text",
  CellTags->"Partial evaluation1"],

Cell[BoxData[
    \(\(expr = 
        HoldForm[{{Cos[\[Pi]], \@8, 
              Cos[\[Pi]], \((x\ y\ z)\)\^2}, \[IndentingNewLine]{\@12, 
              Sin[ArcCos[x]], 2, 0}}];\)\)], "Input"],

Cell["\<\
First we use ReleaseHold to see what the expression evaluates to without \
HoldForm.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ReleaseHold[expr]\)], "Input"],

Cell[BoxData[
    \({{\(-1\), 2\ \@2, \(-1\), x\^2\ y\^2\ z\^2}, {2\ \@3, \@\(1 - x\^2\), 
        2, 0}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Suppose you want to evaluate this expression, but you don't want to \
evaluate ",
  Cell[BoxData[
      \(TraditionalForm\`\(\@8\)\[LongRightArrow]2 \@ 2\)]],
  " or ",
  Cell[BoxData[
      \(TraditionalForm\`\(\@12\)\[LongRightArrow]2 \@ 3\)]],
  ". This can be done by using Block to make the kernel temporarily forget \
what Power does!  Recall ",
  Cell[BoxData[
      \(TraditionalForm\`\@n\)]],
  "has the FullForm Power[n, 1/2].  Once inside Block we change the head of \
(expr) from HoldForm to List, and let it evaluate.  After evaluation is \
finished we change the head back to HoldForm so that ",
  Cell[BoxData[
      \(TraditionalForm\`\@8\)]],
  "and ",
  Cell[BoxData[
      \(TraditionalForm\`\@12\)]],
  " don't evaluate after we get out of the Block.  The curious thing about \
this trick is that we didn't have to Unprotect Power.  Another method of \
allowing only certain parts of an expression to evaluate is given in the \
discussion of ",
  ButtonBox["Fold",
    ButtonData:>"Partial evaluation 2",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{Power}, HoldForm @@ \(List @@ expr\)]\)], "Input"],

Cell[BoxData[
    TagBox[\({{\(-1\), \@8, \(-1\), \((x\ y\ z)\)\^2}, {\@12, \@\(1 - x\^2\), 
          2, 0}}\),
      HoldForm]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Temporarily change the value of $DisplayFunction", "Subsection"],

Cell["\<\
The following line indicates the Default value Plot uses for the \
DisplayFunction option. \
\>", "Text",
  CellTags->"$DisplayFunction"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Options[Plot, DisplayFunction]\)], "Input"],

Cell[BoxData[
    \({DisplayFunction \[RuleDelayed] $DisplayFunction}\)], "Output"]
}, Closed]],

Cell["\<\
Besides making the kernel forget that a symbol has values you can use Block \
to temporarily use a new value for symbols. We can use Block to temporarily \
change the value of $DisplayFunction as in the cell below.  This creates the \
satisfying result of presenting only a single graphic, without typing  \
(DisplayFunction->Identity) four times!\
\>", "Text"],

Cell[BoxData[{
    \(\(Block[{$DisplayFunction = Identity}, \n\ \ \ \ \ p1 = 
          Plot[Sin[t], {t, 0, \[Pi]/2}]; \n\ \ \ \ \ p2 = 
          Plot[Sin[2\ t], {t, 0, \[Pi]/2}]; \n\ \ \ \ \ p3 = 
          Plot[Sin[3\ t], {t, 0, \[Pi]/2}]; \n\ \ \ \ \ p4 = 
          Plot[Sin[4\ t], {t, 0, \[Pi]/2}];\n];\)\), "\n", 
    \(\(Show[
        GraphicsArray[{{p1, p2}, {p3, p4}}], \n\ \ \ ImageSize -> {400, 
            260}\n];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Temporarily decrease $RecursionLimit  and/or  $IterationLimit\
\>", "Subsection"],

Cell["\<\
When you are writing preliminary drafts of a program you might want to use a \
lower value of $RecursionLimit and/or Iteration limit.  Using the code below \
you can make this change only take effect inside the Block.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(\(f[n_] := 2\ f[n - 1];\)\n\ \), "\n", 
    \(Block[{$RecursionLimit = 25, \ $IterationLimit = 100}, \n\ \ f[
        3]\n]\)}], "Input"],

Cell[BoxData[
    \(8388608\ Hold[f[\(-19\) - 1]]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({$RecursionLimit, $IterationLimit}\)], "Input"],

Cell[BoxData[
    \({256, 4096}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Temporarily clear the numeric value of a symbol", "Subsection"],

Cell["\<\
In the first cell below (demo) is an expression in (x).  In the second cell \
(x) has a numeric value is assigned and demo will turn out to be a constant \
if evaluated.  Since demo is a constant (provided x has a numeric value) the \
derivative of demo is zero.   Worse than that we see below that D[demo,x] \
doesn't even evaluate as we would like.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[x];\)\), "\n", 
    \(\(demo = x\ Exp[x];\)\)}], "Input"],

Cell[BoxData[
    \(\(x = 3;\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(D[demo, x]\)], "Input"],

Cell[BoxData[
    \(\[PartialD]\_3\((3\ \[ExponentialE]\^3)\)\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we can evaluate the derivative of (demo) as if (x) had no \
numeric value.  This was possible because Block[{x}, ....] ensured that (x) \
had no values.  Apply[HoldForm,....] had to be used to prevent evaluating the \
result with numeric values for (x).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Dx = Block[{x}, Apply[HoldForm, {D[demo, x]}]]\)], "Input"],

Cell[BoxData[
    TagBox[\(\[ExponentialE]\^x + \[ExponentialE]\^x\ x\),
      HoldForm]], "Output"]
}, Closed]],

Cell["\<\
In the next cell ReleaseHold is used to allow complete evaluation of the \
above derivative. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ReleaseHold[Dx]\)], "Input"],

Cell[BoxData[
    \(4\ \[ExponentialE]\^3\)], "Output"]
}, Closed]],

Cell["\<\
Finally in the next cell Block[{x=a}, ....] causes (x) to temporarily \
evaluate to (a), and then evaluate the derivative of demo.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a];\)\), "\n", 
    \(Block[{x = a}, D[demo, x]]\)}], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^a + a\ \[ExponentialE]\^a\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Modify a built-in function", "Subsection"],

Cell[TextData[{
  "Block can be used to modify the way built-in kernel functions evaluate in \
ways that are not otherwise possible.  For example suppose you wanted to \
change 'D' so that ",
  StyleBox["D[expr,x]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " would Expand expr before using the built-in definition of 'D'.\n\nThe \
definition for 'D' in the next cell is only used when the symbol ",
  StyleBox["$DoThis",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " is True.  When this definition is used Block temporarily clears all \
values from the symbol ",
  StyleBox["$DoThis",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ", and then evaluates ",
  StyleBox["D[Expand[expr],x]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ".  If it were not for the use of ",
  StyleBox["Block{$DoThis},...]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " we would have infinite recursion since the new definition would call \
itself. However, once inside the Block ",
  StyleBox["$DoThis",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " is not True, so the built-in definition of 'D' is used instead."
}], "Text"],

Cell[BoxData[{
    \(\(Unprotect[D];\)\), "\[IndentingNewLine]", 
    \(\(\($DoThis = True;\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(D[expr_, x_] /; $DoThis := \[IndentingNewLine]Block[{$DoThis}, \ 
        D[Expand[expr], x]\ \ ]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(D[\((x + 5)\)\^3, x]\)], "Input"],

Cell[BoxData[
    \(\[PartialD]\_3 512\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Button Programming", "Section"],

Cell[TextData[{
  "A ",
  ButtonBox["hyperlink",
    ButtonData:>"Hyperlinks",
    ButtonStyle->"Hyperlink"],
  " is a special type of a button.  We can also make buttons with predefined \
",
  ButtonBox["ButtonStyles",
    ButtonData:>"ButtonStyles",
    ButtonStyle->"Hyperlink"],
  ", and most other buttons perform some sort of manipulation of a notebook. \
Such buttons that manipulate a notebook can usually be made by following the \
form in the next cell.  All you need to do is change \"Button Name\" and \"A \
Pure Function\" to suit you needs."
}], "Text",
  CellTags->"ButtonProgramming"],

Cell[BoxData[
    \(Cell[\[IndentingNewLine]BoxData[
          ButtonBox[
            RowBox[{"\<Button Name\>"}], \[IndentingNewLine]ButtonFunction \
\[Rule] \(("\<A Pure Function\>")\), \[IndentingNewLine]ButtonEvaluator \
\[Rule] Automatic, 
            Active \[Rule] 
              True\[IndentingNewLine]]], \[IndentingNewLine]"\<Input\>"] // 
      CellPrint\)], "Input"],

Cell["\<\
The next cell shows the form needed to make a palette of three buttons.\
\>", "Text"],

Cell[BoxData[
    \(Cell[
        BoxData[GridBox[{\[IndentingNewLine]{ButtonBox[
                  RowBox[{"\<Name 1\>"}], 
                  ButtonFunction \[Rule] \(("\<Pure Function 1\>")\), \
\[IndentingNewLine]ButtonEvaluator \[Rule] Automatic, 
                  Active \[Rule] True]}, \[IndentingNewLine]{ButtonBox[
                  RowBox[{"\<Name 2\>"}], 
                  ButtonFunction \[Rule] \(("\<Pure Function 2\>")\), \
\[IndentingNewLine]ButtonEvaluator \[Rule] Automatic, 
                  Active \[Rule] True]}, \[IndentingNewLine]{ButtonBox[
                  RowBox[{"\<Name 3\>"}], 
                  ButtonFunction \[Rule] \(("\<Pure Function 3\>")\), \
\[IndentingNewLine]ButtonEvaluator \[Rule] Automatic, 
                  Active \[Rule] True]}\[IndentingNewLine]}, 
            RowSpacings \[Rule] 0]]\[IndentingNewLine], "\<Input\>"] // 
      CellPrint\)], "Input"],

Cell[CellGroupData[{

Cell["\<\
Working example of a notebook manipulating button (made from scratch)\
\>", "Subsection"],

Cell["\<\
Suppose you want to make a button that will delete all the messages in the \
InputNotebook[].  The non-trivial part is writing and debuging the lines of \
code that are used for the ButtonFunction. This can be solved by having two \
notebooks open at once.  As an example open an empty notebook and evaluate in \
the new notebook ( nb=SelectedNotebook[] ).  Next in the new notebook \
evaluate an erronerous input expression such as  (3=t).  Then come back to \
this notebook and evaluate the next cell.  The next cell will deletes all \
messages in the notebook assigned to (nb).  This is most of the code for our \
ButtonFunction.  The only other thing we need is for our ButtonFunction to \
make the assignment ( nb = InputNotebook[] ) before evaluating the code in \
the next cell.\
\>", "Text"],

Cell[BoxData[{
    \(\(NotebookFind[nb, "\<Message\>", All, 
        CellStyle];\)\), "\[IndentingNewLine]", 
    \(\(NotebookDelete[nb];\)\)}], "Input"],

Cell[TextData[{
  "The next cell makes the desired button.  However, the button that is \
created should be converted to a palette by selecting the CellBracket for the \
button and making the menu selection (File \[RightTriangle] Generate Palette \
From Selection).  Notice  the ButtonFunction setting must be a function.  If \
you aren't familar with pure functions read my section on ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  ".  Notice if you use '&' in the ButtonFunction then you have to wrap the \
button function in parentheses.  As I said earlier we need to use \
(ButtonEvaluator\[Rule]Automatic) and (Active\[Rule]True)."
}], "Text",
  CellTags->"Pure_Function_Example"],

Cell[BoxData[
    \(Cell[\[IndentingNewLine]BoxData[
          ButtonBox[
            RowBox[{"\<Delete Messages\>"}], \
\[IndentingNewLine]ButtonFunction \[Rule] \((\[IndentingNewLine]Module[{nb = 
                        InputNotebook[]}, \[IndentingNewLine]NotebookFind[
                      nb, "\<Message\>", All, 
                      CellStyle]; \[IndentingNewLine]NotebookDelete[
                      nb]]\[IndentingNewLine] &\ )\), \
\[IndentingNewLine]ButtonEvaluator \[Rule] Automatic, 
            Active \[Rule] 
              True\[IndentingNewLine]]], \[IndentingNewLine]"\<Input\>"] // 
      CellPrint\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Other Button Tutorials", "Subsection"],

Cell["\<\
Links to all the tutorials about button programming that I know off are \
provided below.\
\>", "Text"],

Cell[TextData[{
  "See a tutorial by Paul Hinton at \n",
  ButtonBox["http://library.wolfram.com/infocenter/TechNotes/185",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/TechNotes/185"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[TextData[{
  "See several technical support pages on button programming at \n",
  ButtonBox["http://support.wolfram.com/mathematica/interface/buttons/",
    ButtonData:>{
      URL[ "http://support.wolfram.com/mathematica/interface/buttons/"], 
      None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[TextData[{
  "You might also find some helpful examples in this notebook under ",
  ButtonBox["Button Styles",
    ButtonData:>"ButtonStyles",
    ButtonStyle->"Hyperlink"],
  " or under ",
  ButtonBox["Hyperlinks",
    ButtonData:>"Hyperlinks",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[TextData[{
  "See ",
  StyleBox["How To Create Buttons",
    FontWeight->"Bold"],
  ", by Paul Hinton at\n",
  ButtonBox["http://library.wolfram.com/conferences/devconf99/#frontend",
    ButtonData:>{
      URL[ "http://library.wolfram.com/conferences/devconf99/#frontend"], 
      None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[TextData[{
  "See ",
  StyleBox["Programming the Front End",
    FontWeight->"Bold"],
  ", by John Novak at\n",
  ButtonBox["http://library.wolfram.com/conferences/devconf99/#frontend",
    ButtonData:>{
      URL[ "http://library.wolfram.com/conferences/devconf99/#frontend"], 
      None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[TextData[{
  "See ",
  StyleBox["Turning an Application into an Interface",
    FontWeight->"Bold"],
  ", Dale Horton at  \n",
  ButtonBox["http://library.wolfram.com/conferences/devconf2001/#development",
    
    ButtonData:>{
      URL[ "http://library.wolfram.com/conferences/devconf2001/#development"],
       None},
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ButtonStyle", "Section"],

Cell[TextData[{
  "From the menu selection (Input \[RightTriangle] CreateButton) you can make \
buttons with ButtonStyles Paste, Evaluate, EvaluateCell, CopyEvaluate and \
CopyEvaluateCell. Each of these ButtonStyles are intended to be used when \
something is selected in an Input or Output cell and they all do something \
with the selected expression and the input cell.  Making one of these buttons \
is simple. Suppose for example you want a button that will Simplify the \
selected expression. To do that you would do the following:\n\n(1)  Type \
Simplify[\[SelectionPlaceholder]] as I did in the next cell. \n       Note \
the \[SelectionPlaceholder] symbol can be entered as ",
  Cell[BoxData[
      FormBox[
        StyleBox[\(\(\ \)\(\\[SelectionPlaceHolder]\)\(\ \)\),
          ShowSpecialCharacters->False], TraditionalForm]]],
  " or using the alias  \[AliasDelimiter]",
  Cell[BoxData[
      \(TraditionalForm\`spl\)]],
  "\[AliasDelimiter]  or using the 'Complete Characters' palette.\n(2)  \
Select \"Simplify[\[SelectionPlaceholder]]\" in the input cell.\n(3)  Make \
the menu selection (Input \[RightTriangle] Create Button \[RightTriangle] \
Evaluate) \n(4)  Select the cell bracket for the input cell containing \
\"Simplify[\[SelectionPlaceholder]]\".\n(5)  Make the menu selection (File \
\[RightTriangle] Generate Palette from Selection).\n\nYou will then have a \
palette containing the button just describe and it will work like those in \
the Algebraic Manipulation palette."
}], "Text",
  CellTags->"ButtonStyles"],

Cell[BoxData[
    \(Simplify[\[SelectionPlaceholder]]\)], "Input"],

Cell["\<\
As far as I am aware you need to deal with lower level boxes if you want to \
make a palette of several buttons like the one I discuss above.  You can make \
such a palette by evaluating the next cell and doing the following:
(1)  Select the cell bracket for the cell created when the next cell is \
evaluated.
(2)  Make the menu selection (File \[RightTriangle] Generate Palette from \
Selection) and the palette will be displayed in it's own notebook.\
\>", "Text"],

Cell[BoxData[
    \(Cell[
        BoxData[GridBox[{\[IndentingNewLine]{ButtonBox[
                  RowBox[{"\<Factor\>", "\<[\>", \
"\<\[SelectionPlaceholder]\>", "\<]\>"}], 
                  ButtonStyle \[Rule] "\<Evaluate\>"]}, \
\[IndentingNewLine]{ButtonBox[
                  RowBox[{"\<Expand\>", "\<[\>", \
"\<\[SelectionPlaceholder]\>", "\<]\>"}], 
                  ButtonStyle \[Rule] "\<Evaluate\>"]}, \
\[IndentingNewLine]{ButtonBox[
                  RowBox[{"\<Together\>", "\<[\>", "\<\[SelectionPlaceholder]\
\>", "\<]\>"}], ButtonStyle \[Rule] "\<Evaluate\>"]}\[IndentingNewLine]}, 
            RowSpacings \[Rule] 0]]\[IndentingNewLine], "\<Input\>"] // 
      CellPrint\)], "Input"],

Cell["\<\
All buttons above above had ButtonStyle \"Evaluate\".  This and all other \
built-in ButtonStyles are explained below.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Built-in  ButtonStyles", "Subsection"],

Cell[TextData[{
  "E",
  StyleBox["valuating the next cell makes a sample palette containing a \
button with each of the built-in Button-Styles. Once the resulting palette is \
displayed, you can move your mouse pointer over one of the buttons and the \
ButtonStyle for that button will be shown in the bottom of the window. You \
can verify that each of the buttons works as I describe below. ",
    FontSize->12,
    FontVariations->{"CompatibilityType"->0}]
}], "Text"],

Cell[BoxData[{
    \(\(nb = NotebookCreate[Visible \[Rule] False];\)\n\ \), "\n", 
    \(NotebookWrite[
      nb, {Cell[
          BoxData[GridBox[{{ButtonBox[\\(\[SelectionPlaceholder] + 1\\), 
                    ButtonStyle \[Rule] "\<Paste\>", 
                    ButtonNote \[Rule] "\<Paste\>"]}, {ButtonBox[\
\\(\[SelectionPlaceholder] + 1\\), ButtonStyle \[Rule] "\<Evaluate\>", 
                    ButtonNote \[Rule] "\<Evaluate\>"]}, {ButtonBox[\
\\(\[SelectionPlaceholder] + 1\\), ButtonStyle \[Rule] "\<EvaluateCell\>", 
                    ButtonNote \[Rule] "\<EvaluateCell\>"]}, {ButtonBox[\
\\(\[SelectionPlaceholder] + 1\\), ButtonStyle \[Rule] "\<CopyEvaluate\>", 
                    ButtonNote \[Rule] "\<CopyEvaluate\>"]}, {ButtonBox[\
\\(\[SelectionPlaceholder] + 1\\), 
                    ButtonStyle \[Rule] "\<CopyEvaluateCell\>", 
                    ButtonNote \[Rule] "\<CopyEvaluateCell\>"]}}, 
              RowSpacings \[Rule] 0, ColumnWidths \[Rule] 10]], 
          NotebookDefault, Evaluatable \[Rule] True]}]; \n\ \), "\n", 
    \(\(SetOptions[nb, WindowSize \[Rule] {Fit, Fit}, 
        WindowFrame \[Rule] "\<Palette\>", 
        WindowElements \[Rule] "\<StatusArea\>", 
        WindowFrameElements \[Rule] "\<CloseBox\>", 
        WindowClickSelect \[Rule] False, ShowCellBracket \[Rule] False, 
        Active \[Rule] True, Visible \[Rule] True];\)\)}], "Input"],

Cell[BoxData[
    \(\(Clear[x];\)\)], "Input"],

Cell[CellGroupData[{

Cell["Paste  ButtonStyle", "Subsubsection"],

Cell["\<\
The top button in the sample palette has the \"Paste\" ButtonStyle.  If you \
select 15 in the next cell and depress the top button, the 15 is changed to \
(15+1) and nothing is selected after making the change.  The results are \
similar if a part of an output cell is selected.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@15 + x\)], "Input"],

Cell[BoxData[
    \(3 + \@15\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Evaluate  ButtonStyle", "Subsubsection"],

Cell["\<\
The second button in the sample palette has the \"Evaluate\" ButtonStyle.  If \
you select 15 in the next cell and press the second button, the 15 is changed \
to 16 (which is 15+1) and the number 16 is selected after making the change. \
The results are similar if a part of an output cell is selected.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@15 + x\)], "Input"],

Cell[BoxData[
    \(3 + \@15\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["EvaluateCell  ButtonStyle", "Subsubsection"],

Cell["\<\
The third button in the sample palette has the \"EvaluateCell\" ButtonStyle.  \
If you select the 15 in the next cell and press the third button, the 15 is \
changed to (15+1), the input cell evaluates, and the contents of the \
resulting output cell are selected once evaluation is finished. The results \
are similar if a part of an output cell is selected.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@15 + x\)], "Input"],

Cell[BoxData[
    \(3 + \@15\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["CopyEvaluate  ButtonStyle", "Subsubsection"],

Cell["\<\
The fourth button in the sample palette has the \"CopyEvaluate\" ButtonStyle. \
 If you select 15 in the next cell and press the fourth button, then a new \
input cell containing 16 (the result of 15+1) is inserted after the original \
input cell.  The expression in the new input cell is selected once evaluation \
is finished. The results are similar if a part of an output cell is selected.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@15 + x\)], "Input"],

Cell[BoxData[
    \(3 + \@15\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["CopyEvaluateCell  ButtonStyle", "Subsubsection"],

Cell["\<\
The bottom button in the sample palette has the \"CopyEvaluateCell\" \
ButtonStyle.  If you select 15 in the next cell and press the bottom button, \
a new input cell containing (15+1) will be inserted below the original input, \
and the new input cell will evaluate. After evaluation is finished the \
resulting output expression will be selected. The results are similar if a \
part of an output cell is selected.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@15 + x\)], "Input"],

Cell[BoxData[
    \(3 + \@15\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Make your own ButtonStyle", "Subsection"],

Cell["\<\
If you tried the sample button with setting  ButtonStyle\[Rule]EvaluateCell  \
you would have noticed that after the button is used the contents of the new \
output cell are selected.  I would prefer that after the button finishes \
nothing is selected, and the insertion point is after the new output cell, \
and I made a new ButtonStyle to do this.  To try this new ButtonStyle the \
\"Prototype for style: EvaluateCell2\" cell below should be pasted into your \
style sheet under \"Palatte Styles\".  You can open the Style Sheet with menu \
selection (Format \[RightTriangle] Edit Style Sheet ).\
\>", "Text"],

Cell[TextData[{
  StyleBox["\[WarningSign]",
    FontSize->18],
  "  Warning ",
  StyleBox["\[WarningSign]",
    FontSize->18],
  "\nI am using ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 4.1 under Windows 98, and the ButtonStyle wouldn't work when I added it \
to a private StyleSheet. However, the ButtonStyle would work when I pasted \
the prototype below in the style sheet (Default.nb).  You might have the same \
problem."
}], "Text"],

Cell["\<\
To see the details of the \"EvaluateCell2\" prototype in the next cell select \
the cell bracket and make the menu selection (Format \[RightTriangle] \
ShowExpression).\
\>", "Text"],

Cell[StyleData["EvaluateCell2"],
  StyleMenuListing->None,
  ButtonStyleMenuListing->Automatic,
  ButtonBoxOptions->{ButtonFunction:>(FrontEndExecute[ {
      FrontEnd`NotebookApply[ 
        FrontEnd`InputNotebook[ ], #, All], 
      FrontEnd`SelectionMove[ 
        FrontEnd`InputNotebook[ ], All, Cell, 1], 
      FrontEnd`SelectionEvaluateCreateCell[ 
        FrontEnd`InputNotebook[ ], After]}]&)}],

Cell["\<\
The \"EvaluateCell2\" prototype above is almost identical to the one for the \
\"EvaluateCell\" prototype  The only difference is in the ButtonFunction \
setting and the difference is colored red below.  The next cell shows the \
\"EvaluateCell\"  ButtonFunction setting.\
\>", "Text"],

Cell[BoxData[
    RowBox[{"ButtonFunction", "\[RuleDelayed]", 
      RowBox[{"(", 
        RowBox[{
          RowBox[{"FrontEndExecute", "[", 
            RowBox[{"{", 
              
              RowBox[{\(FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #, 
                  All]\), 
                ",", \(FrontEnd`SelectionMove[FrontEnd`InputNotebook[], All, 
                  Cell, 1]\), ",", 
                RowBox[{"FrontEnd`SelectionEvaluateCreateCell", "[", 
                  RowBox[{\(FrontEnd`InputNotebook[]\), ",", 
                    StyleBox["All",
                      FontColor->RGBColor[1, 0, 0]]}], "]"}]}], "}"}], "]"}], 
          "&"}], ")"}]}]], "DisplayFormula",
  CellFrame->True],

Cell["\<\
The next cell shows the ButtonFunction setting I made for the \"EvaluateCell2\
\"  prototype.\
\>", "Text"],

Cell[BoxData[
    RowBox[{"ButtonFunction", "\[RuleDelayed]", 
      RowBox[{"(", 
        RowBox[{
          RowBox[{"FrontEndExecute", "[", 
            RowBox[{"{", 
              
              RowBox[{\(FrontEnd`NotebookApply[FrontEnd`InputNotebook[], #, 
                  All]\), 
                ",", \(FrontEnd`SelectionMove[FrontEnd`InputNotebook[], All, 
                  Cell, 1]\), ",", 
                RowBox[{"FrontEnd`SelectionEvaluateCreateCell", "[", 
                  RowBox[{\(FrontEnd`InputNotebook[]\), ",", 
                    StyleBox["After",
                      FontColor->RGBColor[1, 0, 0]]}], "]"}]}], "}"}], "]"}], 
          "&"}], ")"}]}]], "DisplayFormula",
  CellFrame->True],

Cell[TextData[{
  StyleBox["If you want to learn more about FrontEndExecute, and the  \
FrontEnd`*  functions see chapter 56 of The Beginner's Guide To ",
    FontSize->12,
    FontVariations->{"CompatibilityType"->0}],
  StyleBox["Mathematica",
    FontSize->12,
    FontSlant->"Italic",
    FontVariations->{"CompatibilityType"->0}],
  StyleBox[", by Jerry Glynn and Theodore Gray.  \n\nYou will also notice \
that all of the built-in ButtonStyles do strange things to the selected \
notebook if nothing is selected.  If you are ambitious you could go into the \
shared style sheets and change the ButtonFunction for the built-in \
ButtonStyles to ensure they do nothing if a part of an input expression is \
not selected. \n\nThat covers most of this subject but you might want to also \
read   \n",
    FontSize->12,
    FontVariations->{"CompatibilityType"->0}],
  ButtonBox["http://support.wolfram.com/mathematica/interface/buttons/\
buttonstyle.html  ",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/interface/buttons/buttonstyle.\
html"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Cases", "Section"],

Cell["Consider the list of (x,y,z) coordinates below.", "Text"],

Cell[BoxData[{
    \(\(Clear[data, x];\)\), "\n", 
    \(\(data = {\n\t\t{12, 2, 4}, {3, 4, 6}, {2, 8, 5}, {7, 13, 12}, {3, 22, 
            5}, {11, 2, 7}, {10, 0, 14}, {6, 2, 23}, {8, 9, 4}, {6, 3, 
            7}};\)\)}], "Input"],

Cell["\<\
The line below picks out all elements of data where the second of three in a \
list is greater than 7.\
\>", "Text",
  CellTags->"Cases"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[data, {x_, y_, z_} /; y > 7]\)], "Input"],

Cell[BoxData[
    \({{2, 8, 5}, {7, 13, 12}, {3, 22, 5}, {8, 9, 4}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Now the next line will pick the points where y>7 and return the list {x, \
y, ",
  Cell[BoxData[
      \(TraditionalForm\`\@\(x\^2 + y\^2\)\)]],
  "}. "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[
      data, {x_, y_, z_} /; y > 7 \[Rule] {x, 
          y, \@\(x\^2 + y\^2\)}]\)], "Input"],

Cell[BoxData[
    \({{2, 8, 2\ \@17}, {7, 13, \@218}, {3, 22, \@493}, {8, 
        9, \@145}}\)], "Output"]
}, Closed]],

Cell["\<\
The method above works as long as (x) doesn't have a global value.  In the \
cell below (x) has a global value and one doesn't get the expected result.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x = \[Pi]/4;\)\), "\n", 
    \(Cases[
      data, {x_, y_, z_} /; y > 7 \[Rule] {x, 
          y, \@\(x\^2 + y\^2\)}]\)}], "Input"],

Cell[BoxData[
    \({{\[Pi]\/4, 8, \@\(64 + \[Pi]\^2\/16\)}, {\[Pi]\/4, 
        13, \@\(169 + \[Pi]\^2\/16\)}, {\[Pi]\/4, 
        22, \@\(484 + \[Pi]\^2\/16\)}, {\[Pi]\/4, 
        9, \@\(81 + \[Pi]\^2\/16\)}}\)], "Output"]
}, Closed]],

Cell["\<\
The problem above can be avoided by using the line below. The difference is \
the use of (expr \[RuleDelayed] x) instead of (expr \[Rule] x).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[
      data, {x_, y_, z_} /; y > 7 \[RuleDelayed] {x, 
          y, \@\(x\^2 + y\^2\)}]\)], "Input"],

Cell[BoxData[
    \({{2, 8, 2\ \@17}, {7, 13, \@218}, {3, 22, \@493}, {8, 
        9, \@145}}\)], "Output"]
}, Closed]],

Cell["Notice (x) still has a global variable.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(x\)], "Input"],

Cell[BoxData[
    \(\[Pi]\/4\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the previous examples involving Cases[data,{x_,y_,z_}....] all \
occurrences that met the pattern were returned.  Cases can take a fourth \
argument which indicates the maximum number of elements it should return.  In \
the next line the fourth argument is 1 so Cases only returns ",
  Cell[BoxData[
      \({x, y, \@\(x\^2 + y\^2\)}\)]],
  " for the first element where (y>7).  Notice that a third argument was \
necessary since we wanted to use the fourth argument.  In this example the \
third argument provided is the default level specification (1)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[
      data, {x_, y_, z_} /; y > 7 \[RuleDelayed] {x, y, \@\(x\^2 + y\^2\)}, 
      1, 1]\)], "Input"],

Cell[BoxData[
    \({{2, 8, 2\ \@17}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the previous examples Cases had only two arguments.  Cases can take a \
",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " as a third argument.  The default level specification is 1 or {1} (both \
are equivalent).  In the next line the default level specification is used, \
and Cases doesn't look inside each term of the sum."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, w, y, u, z];\)\), "\[IndentingNewLine]", 
    \(Cases[
      a + E\^\(-x\^2\) + Exp[y\^2] + w\^\(5\^x\) + u\^2 + 1\/z\^2 + 1\/4, 
      x_\^y_]\)}], "Input",
  CellTags->"Cases"],

Cell[BoxData[
    \({\[ExponentialE]\^\(-\(\[Pi]\^2\/16\)\), \[ExponentialE]\^\(y\^2\), 
      u\^2, w\^\(5\^\(\[Pi]/4\)\), 1\/z\^2}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next example is from the online Help Browser that comes with ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  ".  Here the level specification is {1,\[Infinity]} and Cases looks at \
every level (except level 0).  As a result the list returned by Cases \
includes ",
  Cell[BoxData[
      \(\(\(\ \)\(x\^2, \(\(y\^2\)\(\ \)\(or\)\(\ \ \)\(5\^x\)\(\ \
\)\)\)\)\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[
      a + E\^\(-x\^2\) + Exp[y\^2] + w\^\(5\^x\) + u\^2 + 1\/z\^2 + 1\/4, 
      x_\^y_, {1, \[Infinity]}]\)], "Input",
  CellTags->"Cases"],

Cell[BoxData[
    \({\[Pi]\^2, \[ExponentialE]\^\(-\(\[Pi]\^2\/16\)\), 
      y\^2, \[ExponentialE]\^\(y\^2\), u\^2, 5\^\(\[Pi]/4\), 
      w\^\(5\^\(\[Pi]/4\)\), 1\/z\^2}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any pattern matching constructs can \
be used in Cases. Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section. "
}], "Text"],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
Cases has a Heads option with the default setting (Heads\[Rule]False). This \
default setting almost always gives the desired effect.  In the next cell \
Derivative[_] is only used as a head and gives an example where the setting \
(Heads\[Rule]True) is needed to find the use of Derivative. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, x];\)\), "\[IndentingNewLine]", 
    \(Cases[f[x] + 2 \( f'\)[x] - 3 \( f''\)[x] + 4 \( g'\)[x], 
      Derivative[_], {0, \(-1\)}, Heads \[Rule] True]\)}], "Input"],

Cell[BoxData[
    \({Derivative[1], Derivative[1], Derivative[2]}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Clear, ClearAll, Remove", "Section"],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " has several places where it stores defintions, and I discuss this subject \
in ",
  ButtonBox["another section",
    ButtonData:>"Definition-Storage",
    ButtonStyle->"Hyperlink"],
  ".  Clear, ClearAll, and Remove are used to erase previous definitions."
}], "Text",
  CellTags->"Clear"],

Cell["The following clears symbols (f, h, g).", "Text"],

Cell[BoxData[
    \(Clear[f, h, g]\)], "Input"],

Cell["\<\
The following claers all symbols matching character strings \"MakeGraph*\" \
and \"MakeCurve*\"\
\>", "Text"],

Cell[BoxData[
    \(Clear["\<MakeGraph*\>", "\<MakeCurve*\>"]\)], "Input"],

Cell["The following clears all symbols in the Global context.", "Text"],

Cell[BoxData[
    \(Clear["\<Global`*\>"]\)], "Input"],

Cell["\<\
In each example above we could have used ClearAll or Remove and got similar \
results.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Clear[f]", "Subsection"],

Cell[TextData[{
  "Clear[f] clears all definitions associated with (f) except for:\n   (1)  \
Attributes of (f)\n   (2)  DefaultValues for (f)\n   (3)  Options[f]\n   (4)  \
Messages associated with (f)\n  \nAlso:\n   (1)  The Symbol (f) remains on \
the list of symbols in the appropriate context after evaluating Clear[f].\n   \
(2)  Assingments to In, and Out which are normally accessed using %,  %8, etc \
are not affected by evaluating Clear[f].\n   (3)  Assignments such as  ",
  Cell[BoxData[
      \(TraditionalForm\`\((g = f + 1)\)\)]],
  ",  and  ",
  Cell[BoxData[
      \(TraditionalForm\`\((h[f] = value)\)\)]],
  " are not affected by evaluating  Clear[f].\n   \nI have done experiments \
to check everything I can think of and all other definitions associated with \
(f) are erased by Clear[f].  In particular ",
  Cell[BoxData[
      \(TraditionalForm\`Clear[f]\)]],
  " erases ",
  Cell[BoxData[
      \(TraditionalForm\`DownValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`UpValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`OwnValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`SubValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`NValues[f]\)]],
  ", and ",
  Cell[BoxData[
      \(TraditionalForm\`FormatValues[f]\)]],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["ClearAll[f]", "Subsection"],

Cell[TextData[{
  "ClearAll[f] clears all definitions associated with (f):\nHowever, after \
evaluating  ClearAll[f]  \n   (1)  The Symbol (f) remains on the list of \
symbols in the appropriate context after evaluating ClearAll[f].\n   (2)  \
Assingments to In, and Out which are normally accessed using %,  %8, etc are \
not affected by evaluating ClearAll[f].\n   (3)  Assignments such as  ",
  Cell[BoxData[
      \(TraditionalForm\`\((g = f + 1)\)\)]],
  ",  and  ",
  Cell[BoxData[
      \(TraditionalForm\`\((h[f] = value)\)\)]],
  " are not affected by evaluating  ClearAll[f].\n   \nSpecifically  \
ClearAll[f]  erases  ",
  Cell[BoxData[
      \(TraditionalForm\`Attributes[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`DownValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`UpValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`OwnValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`SubValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`NValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`FormatValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`DefaultValues[f]\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`Options[f]\)]],
  " and \nMessages associated with (f)."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Remove[f]", "Subsection"],

Cell[TextData[{
  "For all practical purposes Remove[f]  deletes any previous use of the \
symbol (f) from the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " session.\nSpecifically Remove[f] does the following: \n    (1)  Clears \
all definitions associated with (f).\n    (2)  The symbol (f) is removed from \
the list of symbols in the appropriate context.\n    (2)  For all practical \
purposes assingments such as  ",
  Cell[BoxData[
      \(TraditionalForm\`\((h[f] = value)\)\)]],
  ",   ",
  Cell[BoxData[
      \(TraditionalForm\`\((g = f + 1)\)\)]],
  "  are erased.  \n    \n    This includes assingments to the In, and Out \
history which are normally accessed using %,  %8, etc.\n    Such assignments \
aren't actually erased.  Instead the symbol (f) in such assingments is \
changed to  Removed[\"f\"]."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Coefficient, CoefficientList", "Section"],

Cell[TextData[{
  "In the next cell Coefficient returns the coefficient of a particular term \
of a polynomial.  In this case ",
  Cell[BoxData[
      \(TraditionalForm\`\((\(-210\) \(c\^2\) \(x\^2\) y\ z\^2)\)\)]],
  " is a term of ",
  Cell[BoxData[
      \(TraditionalForm\`\((c\ x - 2  y + z)\)\^7\)]],
  "after it's expanded."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, b, c, d, x, y, z];\)\), "\[IndentingNewLine]", 
    \(\(poly = \((c\ x - 2\ y + z)\)\^7;\)\), "\n", 
    \(Coefficient[poly, x\^2\ y\ z\^4]\)}], "Input"],

Cell[BoxData[
    \(\(-210\)\ c\^2\)], "Output"]
}, Closed]],

Cell[TextData[{
  "We can get the same information from CoefficientList which returns a list \
of coefficients.  In the cell below Part[coeff, 3,2,5] returns the \
coefficient of x^(3-1)y^(2-1)z^(5-1).  In general if we say   ",
  StyleBox["lst=CoefficientList[poly,{x1,x2,x3,...}]", "InlineInput"],
  "  then  Part[lst,  n1, n2, ,n3, ...] will be the coefficient of x1^(n1-1) \
x2^(n2-1) x3^(n3-1). "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(coeff = CoefficientList[poly, {x, y, z}];\)\), "\n", 
    \(Part[coeff, 3, 2, 5]\)}], "Input"],

Cell[BoxData[
    \(\(-210\)\ c\^2\)], "Output"]
}, Closed]],

Cell["\<\
The next line gives the coefficient of x^5.  As expected there is more than \
one term of poly with x^5 as a factor. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Coefficient[poly, x\^5]\)], "Input"],

Cell[BoxData[
    \(84\ c\^5\ y\^2 - 84\ c\^5\ y\ z + 21\ c\^5\ z\^2\)], "Output"]
}, Closed]],

Cell["\<\
We can get the same result as the previous example if we use the next line.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Coefficient[poly, x, 5]\)], "Input"],

Cell[BoxData[
    \(84\ c\^5\ y\^2 - 84\ c\^5\ y\ z + 21\ c\^5\ z\^2\)], "Output"]
}, Closed]],

Cell["\<\
One can't get the result above directly from CoefficientList.  Instead pieces \
of the above result are included in the result of \
CoefficientList[poly,{x,y,z}].  The line below can be used to get pieces of \
the result above.  Specifically  coeff[[6]] contains all coefficients of x^5 \
(including those that are zero).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(coeff[\([6]\)]\)], "Input"],

Cell[BoxData[
    \({{0, 0, 21\ c\^5, 0, 0, 0, 0, 0}, {0, \(-84\)\ c\^5, 0, 0, 0, 0, 0, 
        0}, {84\ c\^5, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 
        0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 
        0}, {0, 0, 0, 0, 0, 0, 0, 0}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Part[coeff, 6, 1, 3] is ",
  Cell[BoxData[
      \(TraditionalForm\`\((\(-84\)\ c\^5)\)\)]],
  " the coefficient of ",
  Cell[BoxData[
      \(TraditionalForm\`\((x\^\(6 - 1\)*y\^\(2 - 1\)*
            z\^\(2 - 1\))\) = \((x\^6*y*z)\)\)]],
  " in poly. Part[coeff,6,3,1] is ",
  Cell[BoxData[
      \(TraditionalForm\`\((84  c\^5)\)\)]],
  " the coeficient of ",
  Cell[BoxData[
      \(TraditionalForm\`\((x\^\(6 - 1\)*y\^\(3 - 1\)*
            z\^\(1 - 1\))\) = \((x\^5*y\^2)\)\)]],
  " in poly.  All other coefficients under Coeff[[6]] are zero which agrees \
with the result of ",
  Cell[BoxData[
      \(TraditionalForm\`Coefficient[poly, x\^5]\)]],
  "."
}], "Text"],

Cell[TextData[{
  "The function defined in the next cell is a slight modification of a \
solution Roberto Colistete sent to the MathGroup. This function takes the \
coefficients from CoefficientList and returns the polynomial with those \
coefficients.  See the discussions of ",
  ButtonBox["MapIndexed",
    ButtonData:>"MapIndexed",
    ButtonStyle->"Hyperlink"],
  ", and ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  " for further explanation of some features used here."
}], "Text",
  CellTags->{"MapIndexedExample", "CoefficientsToPolynomial"}],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox[
            RowBox[{"Coefficients", 
              StyleBox["ToPolynomial",
                FormatType->StandardForm]}]], 
          StyleBox["[",
            FormatType->StandardForm], 
          StyleBox[\(coeffs_, \ vars_List\),
            FormatType->StandardForm], 
          StyleBox["]",
            FormatType->StandardForm]}], 
        StyleBox[" ",
          FormatType->StandardForm], 
        "/;", \((Length[Dimensions[coeffs]] === Length[vars])\)}], 
      StyleBox[":=",
        FormatType->StandardForm], 
      StyleBox[" ",
        FormatType->StandardForm], 
      StyleBox[\(\(Plus @@ 
          Flatten[\ 
            MapIndexed[#1\ Times @@ \((vars^\((#2\  - \ 1)\))\) &, \ 
              coeffs, \ {Length[vars]}]\ ]\)\(\ \)\),
        FormatType->StandardForm]}]], "Input"],

Cell["\<\
The next cell shows another implementation of the same function by Michael \
Trott of Wolfram Research.\
\>", "Text"],

Cell[BoxData[
    StyleBox[\(CoefficientsToPolynomial[coeffs_List, \ 
            vars_List] /; \((Length[Dimensions[coeffs]] === 
              Length[vars])\)\  := \ 
        Plus\  @@ \ Flatten[
            MapIndexed[\((#1\ Inner[Power, \ vars, \ #2\  - \ 1, \ 
                      Times])\) &, \ coeffs, \ {Length[vars]}]]\),
      FormatType->StandardForm]], "Input"],

Cell["\<\
A most elegant implementation of the same function is given in the next cell. \
This is a slight modification of a solution Alan Hayes sent to the MathGroup.\
\
\>", "Text"],

Cell[BoxData[
    \(CoefficientsToPolynomial[coeffs_, 
          vars_List] /; \((Length[Dimensions[coeffs]] === 
            Length[vars])\) := \[IndentingNewLine]Dot @@ 
        Reverse[Append[vars^\((Range[Dimensions[coeffs]] - 1)\), 
            coeffs]]\)], "Input"],

Cell["\<\
Either of the above definitions can be used on the examples below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst = 
        CoefficientList[\((3  x - 2  y + z + Exp[a])\)^3, {x, y, 
            z}];\)\), "\n", 
    \(poly = Factor@CoefficientsToPolynomial[lst, {a, b, c}]\)}], "Input"],

Cell[BoxData[
    \(\((3\ a - 2\ b + c + \[ExponentialE]\^a)\)\^3\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst2 = 
        CoefficientList[
          a\ x\^3 + c\ x\ y + b\ x\^4\ y + d\ y\^2 + Exp[t], {x, 
            y}];\)\), "\n", 
    \(CoefficientsToPolynomial[lst2, {a, b}]\)}], "Input"],

Cell[BoxData[
    \(a\^4 + a\^4\ b\^2 + a\ b\ c + b\^2\ d + \[ExponentialE]\^t\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Also this ",
  ButtonBox["hyperlink",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
Coefficient.html"], None},
    ButtonStyle->"Hyperlink"],
  " will take you to a Wolfram Research web site with more information."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Complement", "Section"],

Cell["\<\
In the cell below we get all elements that are in (lst1) but not in (lst2) or \
(lst3).  Of course this would work with lists of arbitrary expressions, not \
only numbers.\
\>", "Text",
  FontSize->12,
  CellTags->"Complement"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst1 = {3, 2, 7, 5, 2, 2, 3, 4, 5, 6, 1};\)\), "\n", 
    \(\(lst2 = {2, 3};\)\), "\n", 
    \(\(lst3 = {4, 6, 27, 23};\)\), "\[IndentingNewLine]", 
    \(Complement[lst1, lst2, lst3]\)}], "Input",
  FontSize->12],

Cell[BoxData[
    \({1, 5, 7}\)], "Output"]
}, Closed]],

Cell["\<\
In the cell above Complement gives a sorted list of all elements of (lst1), \
that are not in (lst2).  If you want to do this without having the result \
sorted, DeleteCases should be used as in the next line.\
\>", "Text",
  FontSize->12],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[lst1, Alternatives @@ Union[lst2, lst3]]\)], "Input",
  FontSize->12],

Cell[BoxData[
    \({7, 5, 5, 1}\)], "Output"]
}, Closed]],

Cell["\<\
In the previous example (Alternatives@@Union[lst2, lst3]) evaluates to (2 | 3 \
| 4 | 27 | 23).\
\>", "Text"],

Cell["\<\
Complement has the option SameTest with the default setting \
(SameTest\[Rule]Automatic).  It seems when the setting \
(SameTest\[Rule]Automatic) is used numeric values are compared using criteria \
equivalent to the built-in SameQ function. Notice in the next example 45 is \
not in the output because it is in (lst1) and (lst2). However, 164 is in the \
output and this is apparently because SameQ[164,164.0] returns False.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst1 = {12, 45, 67, 144, 164};\)\), "\[IndentingNewLine]", 
    \(\(lst2 = {13, 65, 88, 45, 90, 164.0};\)\), "\[IndentingNewLine]", 
    \(Complement[lst1, lst2, SameTest \[Rule] SameQ]\)}], "Input"],

Cell[BoxData[
    \({12, 67, 144, 164}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example the SameTest option is used to change the criteria for \
when to items should be considered \"the same\".  Here we get a list of \
numbers in (lst1) such that an element of (lst1) is discarded if an element \
of (lst2) differs from it by less than 0.2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Complement[lst1, lst2, 
      SameTest \[Rule] \((Abs[#1 - #2] < 0.2 &)\)]\)], "Input"],

Cell[BoxData[
    \({12, 67, 144}\)], "Output"]
}, Closed]],

Cell["\<\
Complement can work with expressions that have a head other than List. I \
demonstrate this point with Complement in the next cell.\t\t  \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[h];\)\), "\[IndentingNewLine]", 
    \(\(lst1 = h[3, 2, 7, 5, 2, 2, 3, 4, 5, 6, 1];\)\), "\n", 
    \(\(lst2 = h[2, 3];\)\), "\n", 
    \(\(lst3 = h[4, 6, 27, 23];\)\), "\[IndentingNewLine]", 
    \(Complement[lst1, lst2, lst3]\)}], "Input",
  FontSize->12],

Cell[BoxData[
    \(h[1, 5, 7]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Compile", "Section"],

Cell[TextData[{
  "You might want to download a related package posted on ",
  StyleBox["MathSource",
    FontSlant->"Italic"],
  ".  The package is posted at \n",
  ButtonBox["http://library.wolfram.com/database/MathSource/555/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/MathSource/555/"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[CellGroupData[{

Cell["\<\
Examples of compiled functions that take an arbitrary length vector and an \
arbitrary dimension matrix\
\>", "Subsection"],

Cell["\<\
Using Compile[{{x1,t1,n1},...},expr] indicates (x1) is a rank (n1) tensor \
where each element has the type (t1).  A vector is a rank 1 tensor,and a \
matrix is a rank 2 tensor.  A function (magnitude) is defined below which \
finds the magnitude of an arbitrary length vector.\
\>", "Text"],

Cell[BoxData[
    \(\(magnitude = \n
        Compile[{{vector, _Real, 
              1}}, \@\(\(Plus @@ \(vector\^2\)\)\(\ \)\)];\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(magnitude[{2.3, 4.5, 1.6, 6.7, 8.9}]\)], "Input"],

Cell[BoxData[
    \(12.336936410632909`\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Using Compile[{{x, _Real, 2}}, ...] indicates (x) is a matrix of real \
numbers.  The matrix can have any dimensions.  As an example a \
CompiledFunction (func) is defined below.  The function (func) takes two \
matrices of real numbers named (a) and (p) and computes ",
  Cell[BoxData[
      \(\((p\ a\ p\^\(-1\))\)\)]],
  "."
}], "Text"],

Cell[BoxData[
    \(\(func = \n\t
        Compile[{{a, _Real, 2}, {p, _Real, 2}}, \n\t\t\ \((p . a . 
              Inverse[p])\)];\)\)], "Input"],

Cell["A demonstration of (func) is given below.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    RowBox[{
      RowBox[{"x", "=", 
        RowBox[{"(", GridBox[{
              {"1.2", "4.3", "0.1"},
              {"0.2", "1.4", "0.2"},
              {"0.1", "0.3", "0.4"}
              }], ")"}]}], ";", "\n", 
      RowBox[{"y", "=", 
        RowBox[{"(", GridBox[{
              {"1.2", "0.2", "0.0"},
              {"0.3", "1.5", "2.3"},
              {"0.2", "2.2", "0.7"}
              }], ")"}]}], ";", "\n", \(result = func[x, y]\), ";", 
      "\n", \(MatrixForm[result]\)}]], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"0.9485930281394374`", \(-0.8287274254514907`\), 
              "2.951532969340612`"},
            {"0.44076018479630413`", \(-0.011045779084418178`\), 
              "1.8220075598488026`"},
            {"0.35774884502309967`", \(-0.3059638807223854`\), 
              "2.062452750944981`"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["How to make a compiled functions that run fast.", "Subsection"],

Cell[TextData[{
  "In version 3.0 Compile returns an expression with the form \
CompiledFunction[args, nregs, instr, func].  In version 4.0 Compile returns \
CompiledFunction[args, argregs, nregs, instr, func].  Either way the second \
from the last argument is (instr), a list of compiled function instructions.  \
Hence if (func) is a function defined using Compile func[[-2]] will return \
the list of instructions.  The compiled function instructions include low \
level operations such as 'store a real number in a particular register'.  You \
don't need to know what each instruction does, but you want make sure the \
instructions don't include something with the form Function[args, expr].  Any \
instructions with this form will probably cause the function to run much \
slower than it should because standard ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " evaluation instead of compiled evaluation will be used.\n\nThere are \
several reasons why the compiled function instructions would include the form \
Function[args,expr], and all reasons I know of are demonstrated below."
}], "Text",
  CellTags->"Compiled_Evaluation"],

Cell[CellGroupData[{

Cell["An important undocumented feature in Version 4", "Subsubsection",
  CellDingbat->None,
  FontSize->14,
  FontWeight->"Bold"],

Cell["\<\
Version 4.0 has an undocumented feature that will post useful messages when a \
function is defined using Compile and a portion of the function can't be \
computed with compiled evaluation.  Evaluating the next cell will enable the \
undocumented feature.\
\>", "Text"],

Cell[BoxData[
    \(\(Developer`SetSystemOptions["\<CompileReportExternal\>" -> 
          True];\)\)], "Input"],

Cell[TextData[{
  "Once the feature above is enabled (using ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Version 4) a message is displayed after the next cell is evaluated."
}], "Text"],

Cell[BoxData[
    \(\(f1 = 
        Compile[{{x, _Real}, {n, _Integer}}, 
          x^n/\ Factorial[n]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
(1)  Only a subset of kernel functions can be used in compiled evaluation.\
\>", "Subsubsection",
  FontWeight->"Plain",
  FontVariations->{"CompatibilityType"->0}],

Cell["\<\
One possible reason for having Function[args,expr] in the instructions is \
that (expr) may use one or more kernel functions that can't be represented as \
a low level op-code instruction (a list of integers).  As a rule of thumb \
functions that have a simple translation into C can be converted to op-code.  \
This is only a rule of thumb because Factorial has a simple translation into \
C, but can't be represented in op-code.  In fact that is why the compiled \
function instructions for (f1) below includes Function[{x,n},n!].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f1 = 
        Compile[{x, {n, _Integer}}, x^n/\(n!\)];\)\), "\[IndentingNewLine]", 
    \(f1[\([\(-2\)]\)]\)}], "Input"],

Cell[BoxData[
    \({{1, 4}, {91, 8, 3, 0, 0, 2, 0, 0, 3, 0, 1}, {21, 
        Function[{x, n}, \(n!\)], 3, 0, 0, 2, 0, 0, 2, 0, 1}, {14, 0, 1, 
        2}, {36, 2, 3}, {29, 1, 3, 1}, {2}}\)], "Output"]
}, Closed]],

Cell["\<\
The function (f2) in the next cell does the same thing as (f1) in the \
previous cell, and will evaluate using compiled evaluation because the \
compiled function instructions don't include the form Function[args,instr].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f2 = 
        Compile[{x, {n, _Integer}}, 
          x^n/Times @@ Range[n]];\)\), "\[IndentingNewLine]", 
    \(f2[\([\(-2\)]\)]\)}], "Input"],

Cell[BoxData[
    \({{1, 4}, {91, 8, 3, 0, 0, 2, 0, 0, 3, 0, 1}, {9, 0, 1}, {60, 1, 1, 2, 
        1}, {4, 0, 3}, {9, 3, 2}, {81, 2, 1, 3}, {61, 2, 
        1}, {44, \(-2\)}, {4, 1, 1}, {59, 1, 3}, {4, 0, 4}, {81, 4, 3, 
        5}, {66, 1, 0, 4, 0, 5}, {28, 1, 5, 6}, {9, 6, 1}, {44, \(-4\)}, {14, 
        0, 1, 2}, {36, 2, 3}, {29, 1, 3, 1}, {2}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "An alphabetical list of kernel features that can be converted to op-code \
can be found by searching for Compile at: ",
  ButtonBox["http://www.wolfram.com/support/Kernel/Symbols/",
    ButtonData:>{
      URL[ "http://www.wolfram.com/support/Kernel/Symbols/"], None},
    ButtonStyle->"Hyperlink"],
  ".   The same symbols are sorted below by category below."
}], "Text"],

Cell[TextData[StyleBox["Math functions and constants",
  FontSize->14,
  FontWeight->"Bold"]], "Text"],

Cell["\<\
Plus, Times, Power, Sqrt, 
Divide, Minus, Subtract, Quotient, 
Sign, Abs, Arg, Re, Im, Conjugate, 
Floor, Ceiling, Round, Mod, Min, Max, Log, Exp, 
Sin, Cos, Tan, ArcSin, ArcCos, ArcTan, 
Csc, Sec, Cot, ArcCsc, ArcSec, ArcCot, 
Sinh, Cosh, Tanh, ArcSinh, ArcCosh, ArcTanh, 
Csch, Sech, Coth, ArcCsch, ArcSech, ArcCoth, 
N, Chop, Random, IntegerDigits, Product, Sum, EulerE
E, Pi, Degree, GoldenRatio, Catalan

     Compile in Version 4 and later supports the following:
     UnitStep, Khinchin, Glaisher, BitAnd, BitOr, BitXor, BitNot
     \
\>", "Text"],

Cell[TextData[StyleBox["Vector, matrix and tensor mathematics",
  FontSize->14,
  FontWeight->"Bold"]], "Text"],

Cell["\<\
List, Det, Inverse, Dot, DiagonalMatrix, IdentityMatrix, 
Transpose, Dimensions, TensorRank
 \
\>", "Text"],

Cell[TextData[StyleBox["Boolean related features",
  FontSize->14,
  FontWeight->"Bold"]], "Text"],

Cell["\<\
True, False, Not, And, Or, Xor, Equal, Unequal, 
Greater, GreaterEqual, Less, LessEqual, Equal, Unequal, SameQ, UnsameQ, 
EvenQ, OddQ, Positive, Negative, NonNegative, FreeQ, MemberQ, OrderedQ, 
VectorQ, MatrixQ
 \
\>", "Text"],

Cell[TextData[StyleBox["Building and manipulating expressions and lists",
  FontSize->14,
  FontWeight->"Bold"]], "Text"],

Cell["\<\
Set, List, CompoundExpression, Length, 
Array, Table, Range, Count, Select, Cases, DeleteCases, 
Position, ReplacePart, Join, Intersection, Complement, Union, 
Append, AppendTo, Prepend, PrependTo, 
Part, Take, Insert, Delete, Drop, Rest, First, Last, 
Flatten, Sort, Reverse, RotateLeft, RotateRight, Partition, Permutations 
 \
\>", "Text"],

Cell[TextData[StyleBox["Functional programming",
  FontSize->14,
  FontWeight->"Bold"]], "Text"],

Cell["\<\
Apply, Map, MapAll, MapAt, MapIndexed, MapThread, 
Scan, FixedPoint, FixedPointList, Nest, NestList, 
Fold, FoldList, Array, Outer, ComposeList, Function, Slot, SlotSequence 
 \
\>", "Text"],

Cell[TextData[StyleBox["Scoping and procedural programming",
  FontSize->14,
  FontWeight->"Bold"]], "Text"],

Cell["\<\
Module, With, Block, Do, While, For, 
Set, If, Switch, Which, Implies, 
Break, Continue, Catch, Throw, Goto, Label, Return, 
Increment, Decrement, PreIncrement, PreDecrement, 
AddTo, SubtractFrom, TimesBy, DivideBy, Null, $Failed
 \
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["(2)  Compiled evaluation can't use global variables.", "Subsubsection",
  FontWeight->"Plain",
  FontVariations->{"CompatibilityType"->0}],

Cell["\<\
In the next cell a compiled function uses a global variable (width).  Later \
we see that the function works, but timing tests will show that it's no \
faster than if the function was defined without using Compile.\
\>", "Text"],

Cell[BoxData[{
    \(\(width = 2.5;\)\), "\[IndentingNewLine]", 
    \(\(g2 = Compile[{x}, x + width];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g2[0.3]\)], "Input"],

Cell[BoxData[
    \(2.8`\)], "Output"]
}, Closed]],

Cell["\<\
The next cell defines the same function as the previous example and takes the \
global variable as an argument. This is the way global variables should be \
used in a compiled function.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(g2 = Compile[{x, y}, x + y];\)\), "\[IndentingNewLine]", 
    \(g2[0.3, width]\)}], "Input"],

Cell[BoxData[
    \(2.8`\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows what happens if we try to set the value of a global \
variable inside a compiled function.  Here again the function works, but \
timing tests show that the function is no faster than the same function \
defined without using Compile.\
\>", "Text"],

Cell[BoxData[
    \(\(h2 = Compile[{x}, \((temp = 2.5; x + temp)\)];\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(h2[0.3]\)], "Input"],

Cell[BoxData[
    \(2.8`\)], "Output"]
}, Closed]],

Cell["\<\
In the last example the value of (temp) was set inside Compile.  When \
something like this is needed Block, Module, or With should be used to make \
(temp) a local variable.  Compiled functions are defined below that do the \
same thing as the last example using Block, Module, With and they all use \
compiled evaluation which runs much faster.  Besides the advantage in speed \
the approach below ensures that evaluating say (ha[1.5], hb[1.5], hc[1.5]) \
will not change the value (temp) might have outside the compiled function.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ha = 
        Compile[{x}, 
          Block[{temp = 2.5}, x + temp]];\)\), "\[IndentingNewLine]", 
    \(\(hb = 
        Compile[{x}, 
          Module[{temp = 2.5}, x + temp]];\)\), "\[IndentingNewLine]", 
    \(\(hc = 
        Compile[{x}, 
          With[{temp = 2.5}, x + temp]];\)\), "\[IndentingNewLine]", 
    \({ha[0.3], hb[0.3], hb[0.3]}\)}], "Input"],

Cell[BoxData[
    \({2.8`, 2.8`, 2.8`}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["(3)  Compiled evaluation can't work with patterns.", "Subsubsection",
  FontWeight->"Plain",
  FontVariations->{"CompatibilityType"->0}],

Cell["\<\
The function in the next cell takes a list of real numbers, and determines if \
(0.5) is in the list.  This function will use compiled evaluation.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f4 = 
        Compile[{{lst, _Real, 1}}, 
          FreeQ[lst, 0.5]];\)\), "\[IndentingNewLine]", 
    \(f4[{0.2, 0.3, 0.3}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The function in the next cell also takes a list of real numbers, and \
determines if the list is free of negative numbers.  This function works, but \
timing tests will show that it's no faster than the same function defined \
without using Compile.  The problem in this case is that the compiled \
function uses the pattern (_?Negative).  Compiled evaluation isn't used if \
the second argument in Compile includes patterns of any kind.  When faced \
with a problem like this we should use an algorithm that doesn't require \
patterns, or define a function without using Compile.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f4 = Compile[{{lst, _Real, 1}}, FreeQ[lst, _?Negative]];\)\), "\n", 
    \(f4[{0.2, 0.3, 0.3}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows one way the function from the last example can be written \
to avoid the use of patterns.  This version will use compiled evaluation.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f4 = 
        Compile[{{lst, _Real, 1}}, \ 
          FreeQ[Sign[lst], \(-1\)]\ \ ];\)\), "\n", 
    \(f4[{0.2, 0.3, \(-0.4\), 0.5}]\)}], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
(4)  Local variables in compiled evaluation must always have the same type.\
\>", "Subsubsection",
  FontWeight->"Plain",
  FontVariations->{"CompatibilityType"->0}],

Cell["\<\
The next cell defines a function which uses a local variable (temp) where \
temp starts with an integer value.  Later in the function (temp) is changed \
to a real number.  In this case the function works, but timing tests will \
show it's no faster than the same function defined without using Compile.  \
Local variables used in a compiled function should always have the same type \
(Real, Integer, Complex, True|False) to ensure compiled evaluation is used.\
\>", "Text"],

Cell[BoxData[
    \(\(f6 = 
        Compile[{x}, 
          Module[{temp = 5}, \((temp = temp + x; 
              Round[temp])\)]];\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f6[2.2]\)], "Input"],

Cell[BoxData[
    \(7\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
(5)  A compiled function can't change the value of it's argument.\
\>", "Subsubsection",
  FontWeight->"Plain",
  FontVariations->{"CompatibilityType"->0}],

Cell["\<\
The next cell shows an attempt to define a function.  If you try to use this \
function you will see it doesn't work.  The problem here is that the function \
tries to change the value of it's argument, but a compiled function can't \
change the value of it's argument for the same reason we can't evaluate \
(3=5).\
\>", "Text"],

Cell[BoxData[
    \(\(f7 = 
        Compile[{x}, \[IndentingNewLine]Do[
            x = Cos[x], {4}]; \[IndentingNewLine]x];\)\)], "Input"],

Cell["\<\
Some times we want to use an algorithm that starts with some value and \
replaces it with another value.  If we want to do this in a compiled function \
we should initialize a local variable to the value of the functions argument, \
and then change the value of the local variable.  The function in the next \
cell does this and uses compiled evaluation.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f7 = 
        Compile[{x}, \[IndentingNewLine]Module[{temp = 
                x}, \[IndentingNewLine]Do[
              temp = Cos[
                  temp], {4}]; \
\[IndentingNewLine]temp\[IndentingNewLine]]];\)\), "\[IndentingNewLine]", 
    \(f7[0.2]\)}], "Input"],

Cell[BoxData[
    \(0.660837551116615`\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
(6)  Compiled evaluation can't work with all possible list structures.\
\>", "Subsubsection",
  FontWeight->"Plain",
  FontVariations->{"CompatibilityType"->0}],

Cell["\<\
The only list structures compiled evaluation can work with are vectors, \
matrices, and other tensors with (rank<101).  The function defined in the \
next cell returns a list structure that doesn't meet these restrictions so \
compiled evaluation can't be used.  In a case like this there is no advantage \
to using Compile to define the function.\
\>", "Text"],

Cell[BoxData[
    \(\(f5 = Compile[{x}, {x, {2  x, 3  x}}];\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f5[2.1]\)], "Input"],

Cell[BoxData[
    \({2.1`, {4.2`, 6.300000000000001`}}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Condition  (Pattn/;Test)", "Section"],

Cell[TextData[{
  "Condition is closely related to ",
  ButtonBox["PatternTest",
    ButtonData:>"PatternTest",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"Condition"],

Cell[CellGroupData[{

Cell["Typical use of Condition", "Subsection"],

Cell["\<\
Condition is used to put a restriction on when a pattern is used and the \
syntax is forgiving.  Below I give three ways to use Condition to define a \
function that takes a positive number and return the square of the number.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[foo];\)\), "\[IndentingNewLine]", 
    \(foo[x_ /; Positive[x]] := x^2\), "\[IndentingNewLine]", 
    \(foo[3]\)}], "Input"],

Cell[BoxData[
    \(9\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[foo];\)\), "\[IndentingNewLine]", 
    \(foo[x_] /; Positive[x] := x^2\), "\[IndentingNewLine]", 
    \(foo[4]\)}], "Input"],

Cell[BoxData[
    \(16\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[foo];\)\), "\[IndentingNewLine]", 
    \(foo[x_] := x^2 /; Positive[x]\), "\[IndentingNewLine]", 
    \(foo[5]\)}], "Input"],

Cell[BoxData[
    \(25\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell I show ho the same function can be defined using \
PatternTest.  It doesn't make much difference which style is used.  If you \
want to optimize running time, some experimenting is recommended.\
\>", "Text"],

Cell[BoxData[
    \(foo[x_?Positive] := x^2\)], "Input"],

Cell["\<\
The next cell defines a function that takes a list of numbers and returns a \
list where each number is squared.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[g1, g2];\)\), "\n", 
    \(g1[lst : {x_, y_} /; \((x < y)\)] := lst^2\), "\n", 
    \(g1[{2, 4}]\)}], "Input"],

Cell[BoxData[
    \({4, 16}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows an unsuccessful attempt to define the function that was \
defined in the previous input.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[g2, x];\)\), "\[IndentingNewLine]", 
    \(g2[lst : {x_, y_ /; \((x < y)\)}] := lst^2\), "\n", 
    \(g2[{2, 4}]\)}], "Input"],

Cell[BoxData[
    \(g2[{2, 4}]\)], "Output"]
}, Closed]],

Cell["\<\
The definition above failed because the global value of (x) was used in \
(y_/;(x<y)) instead of the value associated with (x_).  The definition that \
worked used the condition ({x_,y_}/;(x<y)) in which case all pattern \
variables used were in the pattern we had a condition on.  Notice the \
\"broken\" definition from the previous input is used when (x) has a suitable \
value.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x = 0;\)\), "\n", 
    \(g2[{2, 4}]\)}], "Input"],

Cell[BoxData[
    \({4, 16}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A Subtle Point", "Subsection"],

Cell["\<\
David Park noted that using Condition in the definition of a function can \
give surprising results as demonstrated below.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[g, a, UseDefinition];\)\), "\[IndentingNewLine]", 
    \(g[a] /; UseDefinition := 2\)}], "Input"],

Cell["\<\
In the next cell the definition of g[a] isn't used and this is what we \
expect.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(UseDefinition = False;\)\), "\[IndentingNewLine]", 
    \(expr = g[a]\)}], "Input"],

Cell[BoxData[
    \(g[a]\)], "Output"]
}, Closed]],

Cell["\<\
Then in the next cell the definition of g[a] is used as we expect.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(UseDefinition = True;\)\), "\[IndentingNewLine]", 
    \(g[a]\)}], "Input"],

Cell[BoxData[
    \(2\)], "Output"]
}, Closed]],

Cell["\<\
Earlier the expression g[a] was assigned to expr, and one might expect that \
the following would evaluate to 2 since g[a]=2, but that isn't the case.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr\)], "Input"],

Cell[BoxData[
    \(g[a]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Allan Hayes indicated this seems to stem from internal optimization \
procedures and he reminds us that section ",
  ButtonBox["2.5.12",
    ButtonData:>{"2.5.12", "12.14"},
    ButtonStyle->"MainBookLink"],
  "  of The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book says the following. Some of the trickiest cases occur when you have \
rules that depend on complicated /; conditions (see Section ",
  ButtonBox["2.3.5",
    ButtonStyle->"MainBookLink"],
  "). One particularly awkward case is when the condition involves a global \
variable. ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " may think that the evaluation is finished because the expression did not \
change. However, a side effect of some other operation could change the value \
of the global variable, and so should lead to a new result in the evaluation. \
The best way to avoid this kind of difficulty is not to use global variables \
in /; conditions. If all else fails, you can type Update[s] to tell ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " to update all expressions involving s.\n\nBelow Allan Hayes shows how we \
can define  expr  to ensure we get the expected result. \nHere  ",
  ButtonBox["Update",
    ButtonStyle->"RefGuideLink"],
  "  and  (lhs := rhs)  are used instead of  (lhs = rhs)."
}], "Text"],

Cell[BoxData[{
    \(\(Clear[expr];\)\), "\[IndentingNewLine]", 
    \(\(UseDefinition = False;\)\), "\[IndentingNewLine]", 
    \(expr := \((Update[g]; g[a])\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr\)], "Input"],

Cell[BoxData[
    \(g[a]\)], "Output"]
}, Closed]],

Cell["\<\
In the last cell g[a] is returned when we had (UseDefinition = False).  In \
the next cell  we get  (expr\[LongRightArrow]g[a]\[LongRightArrow]2)  when \
(UseDefinition = True).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(UseDefinition = True;\)\), "\n", 
    \(expr\)}], "Input"],

Cell[BoxData[
    \(2\)], "Output"]
}, Closed]],

Cell["\<\
Allan Hayes also gave the next solution which is slightly different from the \
one above, but gives the same result.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[expr];\)\), "\[IndentingNewLine]", 
    \(\(UseDefinition = False;\)\), "\[IndentingNewLine]", 
    \(\(expr /; \((Update[g]; True)\) = g[a];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr\)], "Input"],

Cell[BoxData[
    \(g[a]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(UseDefinition = True;\)\), "\n", 
    \(expr\)}], "Input"],

Cell[BoxData[
    \(2\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Count", "Section"],

Cell["\<\
First I define (lst) which will be used to demonstrate Count.\
\>", "Text",
  CellTags->"Count"],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst = 
      Table[Random[Integer, {0, 9}], \ \ \ {3}, {2}, {2}, {2}]\)], "Input"],

Cell[BoxData[
    \({{{{7, 1}, {3, 7}}, {{9, 5}, {4, 3}}}, {{{6, 6}, {1, 6}}, {{3, 6}, {3, 
            3}}}, {{{9, 7}, {3, 9}}, {{1, 3}, {4, 6}}}}\)], "Output"]
}, Closed]],

Cell["\<\
The following returns 3 because lst has three elements and each has the form \
(_List).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Count[lst, _List]\)], "Input"],

Cell[BoxData[
    \(3\)], "Output"]
}, Closed]],

Cell["\<\
The three lists found with the example from the previous cell are returned by \
evaluating the next input.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Part[lst, 1]\), "\[IndentingNewLine]", 
    \(Part[lst, 2]\), "\[IndentingNewLine]", 
    \(Part[lst, 3]\)}], "Input"],

Cell[BoxData[
    \({{{7, 1}, {3, 7}}, {{9, 5}, {4, 3}}}\)], "Output"],

Cell[BoxData[
    \({{{6, 6}, {1, 6}}, {{3, 6}, {3, 3}}}\)], "Output"],

Cell[BoxData[
    \({{{9, 7}, {3, 9}}, {{1, 3}, {4, 6}}}\)], "Output"]
}, Closed]],

Cell["The next input counts six lists at level 2.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Count[lst, _List, {2}]\)], "Input"],

Cell[BoxData[
    \(6\)], "Output"]
}, Closed]],

Cell["\<\
The six lists found with the example from the previous cell are returned by \
evaluating the next input.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Part[lst, 1, 1]\), "\[IndentingNewLine]", 
    \(Part[lst, 1, 2]\), "\[IndentingNewLine]", 
    \(Part[lst, 2, 1]\), "\[IndentingNewLine]", 
    \(Part[lst, 2, 2]\), "\[IndentingNewLine]", 
    \(Part[lst, 3, 1]\), "\[IndentingNewLine]", 
    \(Part[lst, 3, 2]\)}], "Input"],

Cell[BoxData[
    \({{7, 1}, {3, 7}}\)], "Output"],

Cell[BoxData[
    \({{9, 5}, {4, 3}}\)], "Output"],

Cell[BoxData[
    \({{6, 6}, {1, 6}}\)], "Output"],

Cell[BoxData[
    \({{3, 6}, {3, 3}}\)], "Output"],

Cell[BoxData[
    \({{9, 7}, {3, 9}}\)], "Output"],

Cell[BoxData[
    \({{1, 3}, {4, 6}}\)], "Output"]
}, Closed]],

Cell["The next input counts ten lists at levels zero through 2.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Count[lst, _List, {0, 2}]\)], "Input"],

Cell[BoxData[
    \(10\)], "Output"]
}, Closed]],

Cell["\<\
The ten lists found with the example from the previous cell are returned by \
evaluating the next input.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(lst\), "\[IndentingNewLine]", 
    \(Part[lst, 1]\), "\n", 
    \(Part[lst, 2]\), "\n", 
    \(Part[lst, 3]\), "\n", 
    \(Part[lst, 1, 1]\), "\n", 
    \(Part[lst, 1, 2]\), "\n", 
    \(Part[lst, 2, 1]\), "\n", 
    \(Part[lst, 2, 2]\), "\n", 
    \(Part[lst, 3, 1]\), "\n", 
    \(Part[lst, 3, 2]\)}], "Input"],

Cell[BoxData[
    \({{{{7, 1}, {3, 7}}, {{9, 5}, {4, 3}}}, {{{6, 6}, {1, 6}}, {{3, 6}, {3, 
            3}}}, {{{9, 7}, {3, 9}}, {{1, 3}, {4, 6}}}}\)], "Output"],

Cell[BoxData[
    \({{{7, 1}, {3, 7}}, {{9, 5}, {4, 3}}}\)], "Output"],

Cell[BoxData[
    \({{{6, 6}, {1, 6}}, {{3, 6}, {3, 3}}}\)], "Output"],

Cell[BoxData[
    \({{{9, 7}, {3, 9}}, {{1, 3}, {4, 6}}}\)], "Output"],

Cell[BoxData[
    \({{7, 1}, {3, 7}}\)], "Output"],

Cell[BoxData[
    \({{9, 5}, {4, 3}}\)], "Output"],

Cell[BoxData[
    \({{6, 6}, {1, 6}}\)], "Output"],

Cell[BoxData[
    \({{3, 6}, {3, 3}}\)], "Output"],

Cell[BoxData[
    \({{9, 7}, {3, 9}}\)], "Output"],

Cell[BoxData[
    \({{1, 3}, {4, 6}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used with Count.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell["Heads Option", "Subsubsection"],

Cell["\<\
Count has a Heads option with the default setting (Heads\[Rule]False).  First \
I define (expr) which will be used to demonstrate this option.  In the first \
example Count ignores the (h) in h[x,y] because of the default setting for \
Heads.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[h];\)\), "\[IndentingNewLine]", 
    \(\(expr = {h[x, y], {h, 0}, {h, 3}, {3, 
            4}};\)\), "\[IndentingNewLine]", 
    \(Count[expr, h, {2}]\)}], "Input"],

Cell[BoxData[
    \(2\)], "Output"]
}, Closed]],

Cell["\<\
When the last example is repeated using (Heads\[Rule]True) the (h) in h[x,y] \
is accounted for.  \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = {h[x, y], {h, 0}, {h, 3}, {3, 
            4}};\)\), "\[IndentingNewLine]", 
    \(Count[expr, h, {2}, Heads \[Rule] True]\)}], "Input"],

Cell[BoxData[
    \(3\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["DeleteCases", "Section"],

Cell["\<\
First I define (lst) which will be used to demonstrate DeleteCases.\
\>", "Text",
  CellTags->"DeleteCases"],

Cell[BoxData[
    \(\(expr = {1, 1.2, {2, 1.3, {3, 1.4}, {4, {1.5}}}};\)\)], "Input"],

Cell["\<\
The first example deletes all real numbers at level 1 and the only one at \
that level was 1.2.  Recall 1, 2, 3, ... have the head Integer not Real.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[expr, _Real]\)], "Input"],

Cell[BoxData[
    \({1, {2, 1.3`, {3, 1.4`}, {4, {1.5`}}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next example deletes all Real numbers at levels 1 through 3.  The \
integers deleted were 1.2, 1.3, 1.4.  More discussion on ",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " is given in another section."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[expr, _Real, {1, 3}]\)], "Input"],

Cell[BoxData[
    \({1, {2, {3}, {4, {1.5`}}}}\)], "Output"]
}, Closed]],

Cell["\<\
The next example deletes Real numbers at level 3.  The only Real number at \
level 3 was 1.4.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[expr, _Real, {3}]\)], "Input"],

Cell[BoxData[
    \({1, 1.2`, {2, 1.3`, {3}, {4, {1.5`}}}}\)], "Output"]
}, Closed]],

Cell["The next example deletes all Real numbers at any level.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[expr, _Real, {0, \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({1, {2, {3}, {4, {}}}}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example I give an alternate way to delete Real numbers at any \
level.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. _Real \[Rule] Sequence[]\)], "Input"],

Cell[BoxData[
    \({1, {2, {3}, {4, {}}}}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example I give an alternate way to delete Real numbers at levels \
1 through 3.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[expr, _Real \[Rule] Sequence[], {1, 3}]\)], "Input"],

Cell[BoxData[
    \({1, {2, {3}, {4, {1.5`}}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used with Count.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
DeleteCases has a Heads option with the default setting (Heads\[Rule]False).  \
First I define (expr) which will be used to demonstrate this option. \
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[h, x, y];\)\), "\[IndentingNewLine]", 
    \(\(expr = {h[x, y], {6, h, 7}};\)\)}], "Input"],

Cell["\<\
In the next cell DeleteCases ignores the (h) in h[x,y] because of the default \
setting for Heads.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[expr, h, {0, \(-1\)}, Heads \[Rule] False]\)], "Input"],

Cell[BoxData[
    \({h[x, y], {6, 7}}\)], "Output"]
}, Closed]],

Cell["\<\
When the previous example is repeated with the option (Heads\[Rule]True) the \
(h) in h[x,y] is deleted.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[expr, h, {0, \(-1\)}, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \({x, y, {6, 7}}\)], "Output"]
}, Closed]],

Cell["\<\
Below I give alternate methods of getting the same results as the last two \
examples.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[expr, h \[RuleDelayed] Sequence[], {0, \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({h[x, y], {6, 7}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(expr /. h[args__] \[RuleDelayed] args\) /. 
      h \[Rule] Sequence[]\)], "Input"],

Cell[BoxData[
    \({x, y, {6, 7}}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Default", "Section"],

Cell["\<\
Default can be used with one two or three arguments, and each form is \
discussed below.\
\>", "Text",
  CellTags->"Default details"],

Cell[CellGroupData[{

Cell["Default[f]", "Subsection"],

Cell[TextData[{
  "In the next cell (f) has the default value 0.  Depending on the pattern \
used f[e] can be treated as f[e,0] or  f[0,e].  If the second argument in the \
pattern is optional f[e] is treated as f[e,0].  If the first argument in the \
pattern is optional f[e] is treated as f[0,e].  All throughout this \
discussion on Default details the functions that are given default values \
will have no attributes. However, the values assigned to Default[f] have a \
different effect when (f) has the OneIdentity attribute.  This is covered in \
the discussion of ",
  ButtonBox["OneIdentity",
    ButtonData:>"OneIdentity-Default",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g, e];\)\), "\[IndentingNewLine]", 
    \(\(Default[f] = 0;\)\), "\[IndentingNewLine]", 
    \(f[e] /. f[a_, b_. ] \[RuleDelayed] g[a, b]\)}], "Input"],

Cell[BoxData[
    \(g[e, 0]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[e] /. f[a_. , b_] \[RuleDelayed] g[a, b]\)], "Input"],

Cell[BoxData[
    \(g[0, e]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Default[f,i]", "Subsection"],

Cell["\<\
In the cell below values are given for Default[f,2],  Default[f,3] and \
definitions for evaluating (f) are given.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(Default[f, 2] = 4;\)\), "\[IndentingNewLine]", 
    \(\(Default[f, 3] = 1/8;\)\), "\[IndentingNewLine]", 
    \(f[a_Integer, b_. , c_] := {a, b, c}\), "\[IndentingNewLine]", 
    \(f[a_Rational, b_Rational, c_. ] := {a, b, c}\)}], "Input"],

Cell["\<\
The definitions for (f) above are used in the input cells below.  For the \
cells below the default values are not needed because the definitions for (f) \
could be used directly.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[10, 11, 12]\)], "Input"],

Cell[BoxData[
    \({10, 11, 12}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1/2, 1/2, 1/2]\)], "Input"],

Cell[BoxData[
    \({1\/2, 1\/2, 1\/2}\)], "Output"]
}, Closed]],

Cell["\<\
Now for the next input (f) has only two arguments, and the definition for \
integer arguments is used.  However, the definition can only be used if a \
default value is inserted for the optional argument.  The applicable \
definition indicates that the second argument is optional.  The default value \
for the second argument of (f) is 4 so the value 4 is used for the second \
argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[10, 11]\)], "Input"],

Cell[BoxData[
    \({10, 4, 11}\)], "Output"]
}, Closed]],

Cell["\<\
Then another input is evaluated where (f) has three arguments,and the \
definition for rational arguments is used.Again the definition can only be \
used if a default value is inserted for the optional argument.The applicable \
definition indicates the third argument is optional.The default value for the \
third argument of (f) is 1/8 so the value 1/8 is used for the third argument.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1/2, 1/2]\)], "Input"],

Cell[BoxData[
    \({1\/2, 1\/2, 1\/8}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell an attempt to make a rule for (f) with the first argument \
optional is not permitted.  That's because (f) only has default values for \
the second and third arguments.\
\>", "Text"],

Cell[BoxData[
    \(f[a_. , b_Real, c_Real] := {a, b, c}\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Default[f,i,n]", "Subsection"],

Cell["\<\
We can also use Default[f,i,n] to specify the default value to use when \
argument (i) out of (n) arguments is optional.  New default values and \
definitions for (f) are given below to demonstrate this.  The input below \
uses definitions for (f) with integer arguments and rational arguments.  \
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(\(Default[f, 2, 3] = 8;\)\), "\n", 
    \(\(Default[f, 2, 4] = 1/16;\)\), "\n", 
    \(f[a_Integer, b_. , c_Integer] := {a, b, c}\), "\n", 
    \(f[a_Rational, b_. , c_Rational, d_Rational] := {a, b, c, d}\)}], "Input"],

Cell["\<\
In each case below the use of a default values were not needed because the \
definitions for (f) could be used directly.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[11, 12, 13]\)], "Input"],

Cell[BoxData[
    \({11, 12, 13}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1/2, 1/2, 1/2, 1/2]\)], "Input"],

Cell[BoxData[
    \({1\/2, 1\/2, 1\/2, 1\/2}\)], "Output"]
}, Closed]],

Cell["\<\
Now in the next input (f) has two integer arguments.  The definition can only \
be used when a default value is inserted for the optional (second) argument.  \
Once a default value is inserted for the optional argument we will have three \
arguments.  The default value for the second of three arguments in (f) is 8 \
so a value of 8 is inserted as the second argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[11, 12]\)], "Input"],

Cell[BoxData[
    \({11, 8, 12}\)], "Output"]
}, Closed]],

Cell["\<\
Then for another input (f) has three rational arguments.  Again the \
definition for rational arguments can only be used if a default value is \
inserted for the optional (second) argument.  Once a value is inserted for \
the second argument we will have four arguments.  The default value for the \
second of four arguments for (f) is 1/16 so a value of 1/16 is inserted as \
the second argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1/2, 1/2, 1/2]\)], "Input"],

Cell[BoxData[
    \({1\/2, 1\/16, 1\/2, 1\/2}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we can't give a rule where the second of two arguments is \
optional.  That is not permitted because we don't have a value assigned to \
Default[f, 2]  or  Default[f, 2, 2].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[a_, b_. ] := {a, b}\)], "Input"],

Cell[BoxData[
    \(Pattern::"nodef" \(\(:\)\(\ \)\) 
      "No default setting found for \!\(f\) in position \!\(2\) when length \
is \!\(2\)."\)], "Message"],

Cell[BoxData[
    \(Pattern::"nodef" \(\(:\)\(\ \)\) 
      "No default setting found for \!\(f\) in position \!\(2\) when length \
is \!\(2\)."\)], "Message"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Distribute", "Section"],

Cell[TextData[{
  "Use of Distribute is well explained in the documentation.  However, I \
provide a hyperlink to an elegant program that uses ",
  ButtonBox["Distribute",
    ButtonData:>"Distribute - Application",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Dot", "Section"],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " computes the dot product of two vectors exactly as we do in Linear \
Algebra. In the next cell we get the Dot product of two 3-D vectors."
}], "Text",
  CellTags->"Dot"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \({a, b, c} . {x, y, z}\)}], "Input"],

Cell[BoxData[
    \(a\ x + b\ y + c\ z\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we try to compute the Dot product of things that aren't \
litsts, and we see it doesn't work.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Dot[h[a, b, c], h[x, y, z]]\)], "Input"],

Cell[BoxData[
    \(h[a, b, c] . h[x, y, z]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "One of the advantages of ",
  ButtonBox["Inner",
    ButtonData:>"Inner",
    ButtonStyle->"Hyperlink"],
  " is that it can do what we tried to do in the previous cell as we see with \
the next cell.  "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[Times, h[a, b, c], h[x, y, z], Plus]\)], "Input"],

Cell[BoxData[
    \(a\ x + b\ y + c\ z\)], "Output"]
}, Closed]],

Cell["\<\
Below we see that matrix multiplication is also implemented using Dot.\
\>", "Text"],

Cell[CellGroupData[{

Cell["The Dot product of a vector and a matrix", "Subsection"],

Cell["\<\
We can compute the Dot product of a vector and a matrix.  In the next cell we \
get the Dot product of (vector A) with each column of (matrix B).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {a1, b1, c1};\)\), "\[IndentingNewLine]", 
    \(\(B = {{x1, x2}, {y1, y2}, {z1, z2}};\)\), "\[IndentingNewLine]", 
    \(A . B\), "\[IndentingNewLine]", 
    \(A . B === Map[A . # &, Transpose[B]]\)}], "Input"],

Cell[BoxData[
    \({a1\ x1 + b1\ y1 + c1\ z1, a1\ x2 + b1\ y2 + c1\ z2}\)], "Output"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
However, in the next example we get the Dot product of each row of (matrix A) \
with (vector B).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {{x1, x2, x3}, {y1, y2, y3}};\)\), "\[IndentingNewLine]", 
    \(\(B = {a1, b1, c1};\)\), "\[IndentingNewLine]", 
    \(A . B\), "\[IndentingNewLine]", 
    \(A . B === Map[# . B &, A]\)}], "Input"],

Cell[BoxData[
    \({a1\ x1 + b1\ x2 + c1\ x3, a1\ y1 + b1\ y2 + c1\ y3}\)], "Output"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["The Dot product of two matrices", "Subsection"],

Cell[TextData[{
  "When ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " computes the Dot product of matrices you essentially get the product of \
the matrices as defined in Linear Algebra. Hence if A is a (m \[Cross] n) \
matrix and B is a (n \[Cross] j) matrix then ",
  Cell[BoxData[
      \(TraditionalForm\`Dot[A, B]\)]],
  " is a ",
  Cell[BoxData[
      \(TraditionalForm\`\((m\ \[Cross]\ \ j)\)\)]],
  " matrix. A generic example is given in the next cell."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {{a1, a2}, {b1, b2}};\)\), "\[IndentingNewLine]", 
    \(\(B = {{x1, x2, x3}, {y1, y2, y3}};\)\), "\[IndentingNewLine]", 
    \(A . B\)}], "Input"],

Cell[BoxData[
    \({{a1\ x1 + a2\ y1, a1\ x2 + a2\ y2, a1\ x3 + a2\ y3}, {b1\ x1 + b2\ y1, 
        b1\ x2 + b2\ y2, b1\ x3 + b2\ y3}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["The Dot product of two tensors", "Subsection"],

Cell["\<\
Mathematica can compute the Dot product of tensors with compatible \
dimensions. In the next cell the Dot product of tensors A and B is \
computed.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {{{a1, a2}, {b1, b2}}, {{c1, c2}, {d1, d2}}};\)\), "\n", 
    \(\(B = {\ \ {{w1, w2, w3}, {x1, x2, x3}}, {{y1, y2, y3}, {z1, z2, 
              z3}}\ \ };\)\), "\n", 
    \(A . B\)}], "Input"],

Cell[BoxData[
    \({{{{a1\ w1 + a2\ y1, a1\ w2 + a2\ y2, 
            a1\ w3 + a2\ y3}, {a1\ x1 + a2\ z1, a1\ x2 + a2\ z2, 
            a1\ x3 + a2\ z3}}, {{b1\ w1 + b2\ y1, b1\ w2 + b2\ y2, 
            b1\ w3 + b2\ y3}, {b1\ x1 + b2\ z1, b1\ x2 + b2\ z2, 
            b1\ x3 + b2\ z3}}}, {{{c1\ w1 + c2\ y1, c1\ w2 + c2\ y2, 
            c1\ w3 + c2\ y3}, {c1\ x1 + c2\ z1, c1\ x2 + c2\ z2, 
            c1\ x3 + c2\ z3}}, {{d1\ w1 + d2\ y1, d1\ w2 + d2\ y2, 
            d1\ w3 + d2\ y3}, {d1\ x1 + d2\ z1, d1\ x2 + d2\ z2, 
            d1\ x3 + d2\ z3}}}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell helps explain how parts of the dot product above are \
computed.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(A . B === {A[\([1]\)] . B, A[\([2]\)] . B}\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the cell above A[[1]] is a matrix, but B is a tensor. The next cell \
shows how parts of ",
  Cell[BoxData[
      \(TraditionalForm\`\((A[\([1]\)]\  . \ B)\)\)]],
  " are computed. The parts of ",
  Cell[BoxData[
      \(TraditionalForm\`\((A[\([2]\)]\  . \ B)\)\)]],
  " are computed in a similar manner. All the Dot products below involve \
vectors and matrices and are computed as explained above."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(A[\([1]\)] . 
        B === {\[IndentingNewLine]{A[\([1, 1]\)] . First[Transpose[B]], 
          A[\([1, 1]\)] . 
            Last[Transpose[B]]}, \[IndentingNewLine]{A[\([1, 2]\)] . 
            First[Transpose[B]], 
          A[\([1, 2]\)] . Last[Transpose[B]]}\[IndentingNewLine]}\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["The Dot product of three or more arguments", "Subsection"],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " can also compute Dot[A1, A2, A3,  ... ]  provided  (A1, A2, A3, ...) have \
suitable dimensions.\nDot[A1, A2, A3 ]  can be considered a concise way or \
writing Dot[A1, Dot[A2, A3] ] or  \nDot[Dot[A1, A2], A3]].  An example of the \
Dot product of three arguments is given in the next cell."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A1 = {a, b, c};\)\), "\[IndentingNewLine]", 
    \(\(B1 = {{x1, x1}, {y1, y2}, {z3, z3}};\)\), "\[IndentingNewLine]", 
    \(\(C1 = {2, 3};\)\), "\[IndentingNewLine]", 
    \(Dot[A1, B1, C1]\)}], "Input"],

Cell[BoxData[
    \(2\ \((a\ x1 + b\ y1 + c\ z3)\) + 
      3\ \((a\ x1 + b\ y2 + c\ z3)\)\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Evaluate", "Section"],

Cell["\<\
Evaluate is used to ensure that one or more argument of a function evaluates \
even if the argument(s) would have not evaluated due to one of the attributes \
HoldAll, HoldRest, HoldFirst.  As an example consider the definitions in the \
next cell.\
\>", "Text",
  CellTags->"Evaluate"],

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \(\(Attributes[f] = {HoldRest};\)\), "\n", 
    \(f[x__] := Hold[x]\), "\n", 
    \(\({s, t, u, v, w} = {12, 15, 23, vv, 37};\)\), "\[IndentingNewLine]", 
    \(\(vv = 28;\)\)}], "Input"],

Cell["\<\
Because  f  has the HoldRest attribute only the first argument of  f  \
evaluates before the definition of  f  is used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[s, t, u, v, w]\)], "Input"],

Cell[BoxData[
    \(Hold[12, t, u, v, w]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell Evaluate is used to ensure the ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument evaluates when it would have been held.  Notice (v) evaluated to \
(vv), and then (vv)  evaluated to 28.  It would be very difficult to make (v) \
evaluate to (vv), but prevent evaluation of (vv) to 28."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[s, t, u, Evaluate[v], w]\)], "Input"],

Cell[BoxData[
    \(Hold[12, t, u, 28, w]\)], "Output"]
}, Closed]],

Cell["\<\
We can give Evaluate multiple arguments and they evaluate to a sequence as in \
the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[s, t, Evaluate[u, v], w]\)], "Input"],

Cell[BoxData[
    \(Hold[12, t, 23, 28, w]\)], "Output"]
}, Closed]],

Cell["\<\
You might expect the following to evaluate the (v) in {u,v}, but it doesn't \
work. That is because in order for Evaluate to have an effect, the expression \
of which it is an argument must be evaluated.  In this example Evaluate[v]  \
is an argument of {u,Evaluate[v]}, and this list doesn't evaluate because (f) \
has the HoldRest attribute.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[s, t, {u, Evaluate[v]}, w]\)], "Input"],

Cell[BoxData[
    \(Hold[12, t, {u, Evaluate[v]}, w]\)], "Output"]
}, Closed]],

Cell["\<\
In order to evaluate something deep inside a held expression you have to do \
something like the following.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = f[s, t, {u, v}, w];\)\), "\[IndentingNewLine]", 
    \(ReplacePart[expr, Part[expr, 3, 2], {3, 2}]\)}], "Input"],

Cell[BoxData[
    \(Hold[12, t, {u, 28}, w]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Common applications for Evaluate", "Subsection"],

Cell[TextData[{
  "The first argument of  ",
  StyleBox["Plot[f, {x,xmin,xmax}]",
    FontWeight->"Bold"],
  "  must evaluate to a machine size real number when (x) is substituted fro \
a value between (xmin) and (xmax).  Plot also allows the form  ",
  StyleBox["Plot[{f1,f2,f3}, {x,xmin,xmax}]",
    FontWeight->"Bold"],
  " but this only works when the first argument of Plot has the head List \
before the Plot algorithm is called.  Sometimes we need to Evaluate the first \
argument of Plot to give it what it needs.  Several examples of this are \
given below.\n\nIn the first three examples Evaluate is needed to ensure the \
first argument has the head List."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \(\(f2 = {x\^2, x\^3};\)\), "\n", 
    \(\(Plot[Evaluate[f2], {x, 0, 1.3}];\)\)}], "Input"],

Cell[BoxData[
    \(\(\(\ \)\(Plot[
        Evaluate[{x^2 - c1, x^2 + c1} /. c1 -> 2], {x, \(-2\), 
          2}];\)\)\)], "Input"],

Cell[BoxData[
    \(\(Plot[
        Evaluate[Table[BesselJ[n, x], {n, 4}]], {x, 0, 10}];\)\)], "Input"],

Cell[TextData[{
  "If Evaluate isn't used in the next example the Plot algorithm tries to \
take the derivative with respect to numeric values such as \n",
  Cell[BoxData[
      \(TraditionalForm\`D[Sin[\(\[Pi]\ 2.53\)\/20] 400\/\[Pi], \ 2.53]\)]],
  " but this is nonsense.  The solution is to use Evaluate to ensure the \
derivative is computed before the Plot algorithm is called."
}], "Text"],

Cell[BoxData[
    \(\(\(\ \)\(Plot[
        Evaluate[D[Sin[\(\[Pi]\ x\)\/20] 400/\[Pi], x]], {x, 0, 
          50}];\)\)\)], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ExactNumberQ, InexactNumberQ, NumberQ, NumericQ", "Section"],

Cell[TextData[{
  "ExactNumberQ is undocumented, but as far as I can tell it returns True if \
it's argument has the head Integer, Rational, or if the argument is complex \
with infinite precision.  It seems ExactNumberQ returns False in every other \
case as demonstrated with the next input.  You may not be familiar with the \
feature Root that I use below, but it's well documented in the Help Browser \
and The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book.  I suggest you refer to this documentation if you are confused with \
the use of Root below."
}], "Text",
  CellTags->"ExactNumberQ"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(ExactNumberQ /@ {3, 5/3, 
        2 + 3  \[ImaginaryI]}\), "\[IndentingNewLine]", 
    \(ExactNumberQ /@ {\[Pi], 3.2, 2.3 + 1.25  \[ImaginaryI], 
        2 + 1.25  \[ImaginaryI], 2.3 + \[ImaginaryI], N[\[Pi], 50], 
        N[\[Pi] \((1 + \[ImaginaryI])\), 50], \@3, \[Pi]/4, 
        Root[\(-7\) - #1 + #1\^3 &, 1], \[Infinity], x}\)}], "Input"],

Cell[BoxData[
    \({True, True, True}\)], "Output"],

Cell[BoxData[
    \({False, False, False, False, False, False, False, False, False, False, 
      False, False}\)], "Output"]
}, Closed]],

Cell["\<\
InexactNumberQ is also undocumented it seems InexactNumberQ returns True if \
it's argument is an approximate number (real or complex), and returns False \
in every other case.\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(InexactNumberQ /@ {3.2, 2.3 + 1.25  \[ImaginaryI], 
        2.3 + 5  \[ImaginaryI], 2 + 1.25  \[ImaginaryI], N[\[Pi], 50], 
        N[\[Pi] \((1 + \[ImaginaryI])\), 50]}\), "\[IndentingNewLine]", 
    \(InexactNumberQ /@ {3, 5/3, 
        2 + 3  \[ImaginaryI], \[Infinity], \@3, \[Pi]/4, 
        Root[\(-7\) - #1 + #1\^3 &, 1], \[Infinity], x}\)}], "Input"],

Cell[BoxData[
    \({True, True, True, True, True, True}\)], "Output"],

Cell[BoxData[
    \({False, False, False, False, False, False, False, False, 
      False}\)], "Output"]
}, Closed]],

Cell["NumberQ is documented and it's usage message is given below", \
"Commentary"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?NumberQ\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"NumberQ[expr] gives True if expr is a number, and False \
otherwise.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"NumberQ",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3292238823-5325569"]
}, Closed]],

Cell["\<\
It seems NumberQ  returns True whenever it's argument has the head Integer, \
Rational, Real, or Complex and False in every other case.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(NumberQ /@ {3.2, 2.3 + 1.25  \[ImaginaryI], 3, 5/3, 
        2/3 + 3  \[ImaginaryI], 3\^300, \((3/5)\)\^300, 
        3\^300 + 5\^200\ \[ImaginaryI], N[\[Pi], 50], 
        N[\[Pi] \((1 + \[ImaginaryI])\), 50]}\), "\n", 
    \(NumberQ /@ {\[Infinity], \@3, \[Pi]/4, Root[\(-7\) - #1 + #1\^3 &, 1], 
        x}\)}], "Input"],

Cell[BoxData[
    \({True, True, True, True, True, True, True, True, True, 
      True}\)], "Output"],

Cell[BoxData[
    \({False, False, False, False, False}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "NumericQ is also documented and it's usage message is given below.  \
NumericQ  recognizes things like ",
  Cell[BoxData[
      \(TraditionalForm\`\@3\)]],
  " as numeric values as demonstrated below.  Infinity and Indeterminate are \
not considered numeric."
}], "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?NumericQ\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"NumericQ[expr] gives True if expr is a numeric quantity, and \
False otherwise.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"NumericQ",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242392617-9633741"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(NumericQ /@ {3.2, 2.3 + 1.25  \[ImaginaryI], 3, 5/3, 
        2 + 3  \[ImaginaryI], \@3, \[Pi]/4, Root[\(-7\) - #1 + #1\^3 &, 1], 
        N[\[Pi], 50], 
        N[\[Pi] \((1 + \[ImaginaryI])\), 50]}\), "\[IndentingNewLine]", 
    \(NumericQ /@ {\[Infinity], 1/0, 0. /0, \[Infinity], x}\)}], "Input"],

Cell[BoxData[
    \({True, True, True, True, True, True, True, True, True, 
      True}\)], "Output"],

Cell[BoxData[
    \({False, False, False, False, False}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Flat", "Section"],

Cell[TextData[{
  "If a function has the Flat attribute nested layers are ",
  StyleBox["automatically",
    FontFamily->"Times New Roman"],
  " flattened during evaluation.  This aspect of how Flat works is understood \
by many ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " users, and is demonstrated in the cell below."
}], "Text",
  CellTags->"Flat"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[f[f[f[1, 2, 3]]]]\)}], "Input"],

Cell[BoxData[
    \(f[1, 2, 3]\)], "Output"]
}, Closed]],

Cell[TextData[{
  StyleBox["I was only able to understanding many of the subtle ways that \
Flat works after getting Technical Support from Dave Withoff.  One subtle \
point many users don't ",
    FontWeight->"Plain"],
  "understand is the effect the Flat attribute has on pattern matching.  In \
the cell below (f) still has the Flat attribute and no other attributes.  In \
the example below the pattern matcher tries to find a way to make the \
expression match the pattern.  The pattern matcher finds that the pattern \
matches when the f[1,2,3,4] is treated as f[f[1],f[2,3,4]] and the two are \
considered equivalent to when (f) has the Flat attribute.  When the \
definition is applied f[f[1],f[2,3,4]] evaluates to {f[1],f[2,3,4]}.  Then \
f[2,3,4] is treated as f[f[2],f[3,4]] which evaluates to {f[2],f[3,4]}.  Then \
f[3,4] evaluates to {f[3],f[4]}.  When this is all put together we get   (  \
{f[1]{f[2]{f[3],f[4]}}}  )."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(f[x_, y_] := {x, y}\), "\n", 
    \(f[1, 2, 3, 4]\)}], "Input"],

Cell[BoxData[
    \({f[1], {f[2], {f[3], f[4]}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The result above would be different if (f) had the attributes Flat and \
OneIdentity.  For further discussion of this see the details of ",
  ButtonBox["OneIdentity, Flat",
    ButtonData:>"OneIdentity-Flat",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell["A warning about attributes and pattern matching", "Subsection",
  CellTags->"Attributes warning"],

Cell["\<\
The attributes Flat, Orderless, and OneIdentity effect pattern matching.  If \
a user defined function needs either of these attributes, they should be set \
before any definitions are entered, and not changed after the definitions are \
made.  This way the given attributes effects both pattern matching and the \
evaluation process (usually the desired effect).  This point is demonstrated \
for the Flat attribute in the cells below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[x_, y_] := {x, y}\), "\n", 
    \(f[1, 2, 
      3]\ \ \ \ \  (*\ \ The\ head\ f\ is\ Flat\ for\ pattern\ \(\(matching\)\
\(.\)\)\ \ *) \)}], "Input"],

Cell[BoxData[
    \({f[1], {f[2], f[3]}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(f[
      f[f[1]]]\)\(\ \ \ \ \)\( (*\ \ Nested\ layers\ of\ f\ are\ \
\(\(flattened\)\(.\)\)\ \ *) \)\)\)], "Input"],

Cell[BoxData[
    \(f[1]\)], "Output"]
}, Closed]],

Cell["\<\
If definition(s) are given before the attributes are set then the attribute \
effects evaluation, but not pattern matching.  This is demonstrated in the \
next few cells.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(f[x_, y_] := {x, \ y}\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[1, 2, 
      3]\ \  (*\ \ The\ head\ f\ is\ not\ Flat\ for\ pattern\ \
\(\(matching\)\(.\)\)\ \ *) \)}], "Input"],

Cell[BoxData[
    \(f[1, 2, 3]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(f[
      f[f[1]]]\)\(\ \ \)\( (*\ \ Nested\ layers\ of\ f\ are\ \
\(\(flattened\)\(.\)\)\ \ *) \)\)\)], "Input"],

Cell[BoxData[
    \(f[1]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
When the next input cell is evaluated (f) is Flat for pattern matching, but \
not for evaluation.\
\>", "Subsubsection"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[x_, y_] := {x, y}\), "\n", 
    \(\(Attributes[f] = {};\)\), "\n", 
    \(\(f[x_, y_] := {x, y};\)\), "\n", 
    \(f[1, 2, 
      3]\ \ \  (*\ \ The\ head\ f\ is\ Flat\ for\ pattern\ \
\(\(matching\)\(.\)\)\ \ *) \)}], "Input"],

Cell[BoxData[
    \({f[1], {f[2], f[3]}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(f[
      f[f[1]]]\)\(\ \ \)\( (*\ \ Nested\ layers\ of\ f\ are\ not\ \
\(\(Flattened\)\(.\)\)\ \ *) \)\)\)], "Input"],

Cell[BoxData[
    \(f[f[f[1]]]\)], "Output"]
}, Closed]],

Cell["\<\
It now seems like (f) has the same definition twice.  We can evaluate ( \
f[x_,y_]=. ) once to get rid of one definition, but we need to use ( \
f[x_,y_]=. ) again to get rid of the second definition.  Alternatively we \
could use Clear[f] and all definitions for (f) would be removed in one \
step.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?f\)\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242392618-3366990"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[x_, y_] := {x, y}\)},
                {" "},
                {\(f[x_, y_] := {x, y}\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242392618-3366990"]
}, Closed]],

Cell[BoxData[
    \(f[x_, y_] =. \)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?f\)\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242392618-7584819"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[x_, y_] := {x, y}\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242392618-7584819"]
}, Closed]],

Cell[BoxData[
    \(f[x_, y_] =. \)], "Input"],

Cell["Now (f) has no definitions.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242392618-6169565"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({f[1, 2], f[f[1]]}\)], "Input"],

Cell[BoxData[
    \({f[1, 2], f[f[1]]}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A problem with the Flat attribute and how to solve it", "Subsection"],

Cell["\<\
A Wolfram Research Technical Support web page points out that one should \
avoid definitions such as (f[p_]:=p) for functions that have the Flat \
attribute. In the cell below this was attempted,and the kernel would have \
gone into infinite iteration if it didn't bail out when the iteration limit \
was exceeded. The reason this leads to infinite iteration is that the pattern \
matcher tries to rewrite f[1,2] so (f) has only one argument so the \
expression will match the pattern (f[p_]). The pattern matcher is able to fit \
the expression to the pattern by treating f[1,2] as f[f[1,2]].The outer (f) \
is evaluated and results in f[1,2] which has to be evaluated.However,this is \
exactly where we started. Then the kernel does this over and over until the \
iteration limit is exceeded.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[p_] := p\), "\n", 
    \(f[1, 2]\)}], "Input"],

Cell[BoxData[
    \(Hold[f[1, 2]]\)], "Output"]
}, Closed]],

Cell["\<\
Plus and Times have the Flat attribute. At first glance it seems Plus and \
Times have the definitions 
( Plus[p_]:=p; Times[p_]:=p ) but it isn't that simple. Something special had \
to be done because Plus[a,b] and Times[a,b] don't cause an $IterationLimit \
message. Allan Hayes indicated the following definition can be used to allow \
a user defined function to work like Plus and Times in this regard. I suspect \
this works because the definition for f[a__]  is only used after pattern \
matching is finished.\
\>", "Text"],

Cell[BoxData[{\(ClearAll[f]\), "\n", \(SetAttributes[
      f, {Flat, OneIdentity}]\), "\n", 
    StyleBox[\(f[a__]\  /; \((\ Length[{a}] === 1\ )\) := \ a\),
      FormatType->StandardForm,
      FontFamily->"Courier New",
      FontSize->10], "\n", \(f[x_Real, y_] := {x, y}\)}], "Input"],

Cell["\<\
In the next output cell we see nested layers of (f) are flattened.  In \
addition the result is f[1,2] which does not lead to infinite iteration.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(f[f[f[f[1, 2]]]]\)\(\ \)\)\)], "Input"],

Cell[BoxData[
    \(f[1, 2]\)], "Output"]
}, Closed]],

Cell["\<\
Next we see (f) is flat for pattern matching. In this case f[1.5, 2.5, 3.5] \
was treated as the equivalent expression f[1.5,f[2.5,3.5]] which evaluated to \
{1.5, {2.5, 3.5}}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1.5, 2.5, 3.5]\)], "Input"],

Cell[BoxData[
    \({1.5`, {2.5`, 3.5`}}\)], "Output"]
}, Closed]],

Cell["\<\
Finally we verify that when (f) is evaluated with only one argument it \
returns the argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Clear[p]; \ f[p]\)], "Input"],

Cell[BoxData[
    \(p\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Flatten", "Section"],

Cell["\<\
The basic use of Flatten is demonstrated in the next cell.  Lots of users \
know about the basic use of Flatten, but there is much more to the story.\
\>", "Text",
  CellTags->"Flatten"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Flatten[{{1, {2, {3, 4}}, 5, {6}}}]\)], "Input"],

Cell[BoxData[
    \({1, 2, 3, 4, 5, 6}\)], "Output"]
}, Closed]],

Cell["\<\
First of all Flatten will flatten nested layers of any head as demonsrated in \
the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Flatten[h[h[1, h[2, h[3, 4]], 5, h[6]]]]\)], "Input"],

Cell[BoxData[
    \(h[1, 2, 3, 4, 5, 6]\)], "Output"]
}, Closed]],

Cell["\<\
When Flatten is given only one argument, it checks the head of the expression \
and flattens nested layers of that head.  Notice the nested lists in the next \
example aren't flattened.  Also in  this example we are flattening layers of \
(h), starting with the arguments of (expr) and going down to deeper levels.  \
When Flatten gets to a subexpression that doesn't have the head (h) it \
decides not to look inside this subexpression for nested layers of (h).  \
Hence the output has nested layers of (h) in {h[h[7],h[8]]}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = 
        h[h[1, h[2, h[3, 4]], 5, 
            h[6]], {h[h[h[7]], h[8]]}, {9, {10}, {11, {12}, 
              13}}];\)\), "\[IndentingNewLine]", 
    \(Flatten[expr]\)}], "Input"],

Cell[BoxData[
    \(h[1, 2, 3, 4, 5, 
      6, {h[h[h[7]], h[8]]}, {9, {10}, {11, {12}, 13}}]\)], "Output"]
}, Closed]],

Cell["\<\
In the next input we give Flatten (2) as a second argument and only two \
layers of (h) are flattened.  Here too the subexpression g[h[8,h[9,10]]] \
doesn't have the head (h), so Flatten doesn't flatten layers of (h) in this \
subexpression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = 
        h[1, 2, h[3, 
            h[4, h[h[h[5]], 6], 
              g[h[8, h[9, 10]]]]]];\)\), "\[IndentingNewLine]", 
    \(Flatten[expr, 2]\)}], "Input"],

Cell[BoxData[
    \(h[1, 2, 3, 4, h[h[h[5]], 6], g[h[8, h[9, 10]]]]\)], "Output"]
}, Closed]],

Cell["\<\
We can give Flatten a third argument to indicate that layers with a certain \
head should be flattened. This is needed in the next cell to ensure layers of \
(h) are flattened.  If Flatten was given one or two arguments it would try to \
flatten layers of (g).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = 
        g[1, h[2, 
            h[3, 4, h[5, h[6, h[7, h[8]]]]]]];\)\), "\[IndentingNewLine]", 
    \(Flatten[expr, \[Infinity], h]\)}], "Input"],

Cell[BoxData[
    \(g[1, 2, 3, 4, 5, 6, 7, 8]\)], "Output"]
}, Closed]],

Cell["\<\
In the next example Flatten is trying to flatten layers of (h).  Flatten \
finds that the subexpression g[h[9,h[10,11]]] doesn't have the head (h) so it \
doesn't flatten layers of (h) in that subexpression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = 
        g[1, h[2, h[3, 4, h[5, h[6, h[7, h[8]]]]]], 
          g[h[9, h[10, 11]]]];\)\), "\[IndentingNewLine]", 
    \(Flatten[expr, \[Infinity], h]\)}], "Input"],

Cell[BoxData[
    \(g[1, 2, 3, 4, 5, 6, 7, 8, g[h[9, h[10, 11]]]]\)], "Output"]
}, Closed]],

Cell["\<\
If we want to flatten all nested layers of (h), the replacement rule in the \
next cell should be used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = 
        g[1, h[2, h[3, 4, h[5, h[6, h[7, h[8]]]]]], 
          g[h[9, h[10, 11]]]];\)\), "\[IndentingNewLine]", 
    \(expr //. h[e1___, h[e2___], e3___] :> h[e1, e2, e3]\)}], "Input"],

Cell[BoxData[
    \(g[1, h[2, 3, 4, 5, 6, 7, 8], g[h[9, 10, 11]]]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Fold", "Section"],

Cell["\<\
The basic example of Fold is given below, but first I clear values from all \
variables.\
\>", "Text",
  CellTags->"Fold"],

Cell[CellGroupData[{

Cell["\<\
ClearAll[\"Global`*\"];
Fold[f,x,{a,b,c}]\
\>", "Input"],

Cell[BoxData[
    \(f[f[f[x, a], b], c]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The basic example above doesn't do much to help one understand how to make \
a useful program using Fold.  Some more illuminating examples are given \
below.  If you don't understand the #& notation see the discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  ". The three examples below aren't very useful, but they demonstrate the \
form that is normally needed when using Fold.\n\nFrom these examples we get:\n\
((((a+b)+c)+d)+e)\n\n((((a b)c)d)e)\n\n",
  StyleBox["StringJoin[StringJoin[StringJoin[StringJoin[StringJoin[\n  \
\"\",\"a\"],\"b\"],\"c\"],\"d\"],\"e\"]", "Input",
    FontWeight->"Plain",
    Background->None,
    FontVariations->{"CompatibilityType"->0}],
  "\n"
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Fold[\((#1 + #2)\) &, 0, {a, b, c, d, e}]\)], "Input"],

Cell[BoxData[
    \(a + b + c + d + e\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Fold[\((#1*\ #2)\) &, 1, {a, \ b, \ c, d, e}]\)], "Input"],

Cell[BoxData[
    \(a\ b\ c\ d\ e\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Fold[
      StringJoin[#1, #2] &, "\<\>", {"\<a\>", "\<b\>", "\<c\>", "\<d\>", "\<e\
\>"}]\)], "Input"],

Cell[BoxData[
    \("abcde"\)], "Output"]
}, Closed]],

Cell["\<\
A more useful application of Fold is given in the next cell.  Here we have a \
function that expresses a polynomial using Horner's rule.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(HornerForm[poly_?PolynomialQ, 
        x_Symbol] := \[IndentingNewLine]Fold[\((x\ #1 + #2)\) &, 0, 
        Reverse[CoefficientList[poly, x]]]\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(HornerForm[2 + 3  x + x\^2 - 4  x\^3 + 2  x\^4, x]\)}], "Input"],

Cell[BoxData[
    \(2 + x\ \((3 + x\ \((1 + x\ \((\(-4\) + 2\ x)\))\))\)\)], "Output"]
}, Closed]],

Cell["\<\
In the Cell below Fold is used to make an Alternating Series.  If ( lst ) was \
used instead of (Reverse[lst] ),  the first term would be multiplied by (-1) \
when the Length of ( lst ) is even.  Jerry Keiper posted this solution to the \
MathGroup.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(alternate[lst_List] := 
      Fold[\((#2 - #1)\) &, 0, Reverse[lst]]\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(Clear[a1, a2, a3, a4, a5, a6, a7, a8];\)\), "\n", 
    \(alternate[{a1, a2, a3, a4, a5, a6, a7, a8}]\)}], "Input"],

Cell[BoxData[
    \(a1 - a2 + a3 - a4 + a5 - a6 + a7 - a8\)], "Output"]
}, Closed]],

Cell["\<\
Another application of Fold is shown below (copied from the Help Browser).  \
This function (EvaluateAt) takes an expression and a list of positions, and \
evaluates in place only the parts at the specified positions.\
\>", "Text",
  CellTags->"Partial evaluation 2"],

Cell[BoxData[
    \(EvaluateAt[expr_, positions_] := 
      Fold[ReplacePart[#1, Part[#1, Sequence @@ #2], #2] &, expr, 
        positions]\)], "Input"],

Cell["\<\
To demonstrate this function consider the expression below which is wrapped \
in HoldForm to prevent evaluation.\
\>", "Text"],

Cell[BoxData[
    \(\(expr = 
        HoldForm[{{Cos[\[Pi]], \@8, 
              Cos[\[Pi]], \((x\ y\ z)\)\^2}, \[IndentingNewLine]{\@12, 
              Sin[ArcCos[x]], 2, 0}}];\)\)], "Input"],

Cell["\<\
First we use ReleaseHold to see what the expression evaluates to without \
HoldForm.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ReleaseHold[expr]\)], "Input"],

Cell[BoxData[
    \({{\(-1\), 2\ \@2, \(-1\), x\^2\ y\^2\ z\^2}, {2\ \@3, \@\(1 - x\^2\), 
        2, 0}}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell EvaluateAt (defined above) is used to evaluate only the \
parts of (expr) that contain trigonometric functions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(EvaluateAt[expr, {{1, 1, 1}, {1, 1, 3}, {1, 2, 2}}]\)], "Input"],

Cell[BoxData[
    TagBox[\({{\(-1\), \@8, \(-1\), \((x\ y\ z)\)\^2}, {\@12, \@\(1 - x\^2\), 
          2, 0}}\),
      HoldForm]], "Output"]
}, Closed]],

Cell[TextData[{
  "If you have trouble figuring out the position of a portion of a \
sub-expression you are interested in you might want to down load a package \
Called (ExpressionManipulation.m) from ",
  ButtonBox["http://home.earthlink.net/~djmp/Mathematica.html",
    ButtonData:>{
      URL[ "http://home.earthlink.net/~djmp/Mathematica.html"], None},
    ButtonStyle->"Hyperlink"],
  " .\n\nAn alternate method of getting the same result in this example is \
given in the discussion of ",
  ButtonBox["Block",
    ButtonData:>"Partial evaluation1",
    ButtonStyle->"Hyperlink"],
  ".\n\nFor another elegant application of Fold see the program Alan Hayes \
wrote which quickly finds the integers ",
  ButtonBox["Relatively Prime to an integer n",
    ButtonData:>"RelativePrimes_Fold",
    ButtonStyle->"Hyperlink"],
  " using Fold."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["FoldList", "Section"],

Cell["\<\
The usage message of FoldList is shown below, and of course it's closely \
related to Fold. For a long time I wondered where something like this would \
have useful applications.\
\>", "Text",
  CellTags->"FoldList"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?FoldList\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"FoldList[f, x, {a, b, ... }] gives {x, f[x, a], f[f[x, a], \
b], ... }.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"FoldList",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242392636-8498059"]
}, Closed]],

Cell[TextData[{
  "J\[UDoubleDot]rgen Tischer used FoldList to solve a common problem in the \
MathGroup. The solution is given below which takes a list of angles and adds \
to, or subtracts from, each element a multiple of 360\[Degree]  to minimize \
the jump from the previous element. This trick forms the heart of the \
SmoothPhase package that I have posted on ",
  StyleBox["MathSource",
    FontSlant->"Italic"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{\(lst = {5, 35, 65, 95, 125, 
          155, \(-175\), \(-145\), \(-115\), \(-85\), \(-55\), \(-25\)};\), "\
\[IndentingNewLine]", 
    StyleBox[\(FoldList[\((Round[\((#1 - #2)\)/360] 360 + #2)\) &, 
        First[lst], Rest[lst]]\),
      FormatType->StandardForm,
      FontFamily->"Courier New",
      FontSize->10]}], "Input"],

Cell[BoxData[
    \({5, 35, 65, 95, 125, 155, 185, 215, 245, 275, 305, 335}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Another elegant ",
  ButtonBox["application of FoldList",
    ButtonData:>"FoldList_Example1",
    ButtonStyle->"Hyperlink"],
  " is given in the section on Clever little programs."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Format", "Section"],

Cell["\<\
The lines below ensure a polynomial is written in the opposite order from the \
usual Format.\
\>", "Text",
  CellTags->"Format"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(Unprotect[Plus];\)\(\n\)
    \)\), "\n", 
    \(\(\(Format[HoldPattern[Plus[p__]]] := 
        Module[{s1, s2}, \ns1 = Hold[p]; \ns2 = Reverse[s1]; \n
          ReplacePart[HoldForm[Evaluate[s2]], Plus, {1, 0}] /; \n
            OrderedQ[s1] && \((s1 =!= s2)\)];\)\(\n\)
    \)\), "\n", 
    \(\(Clear[x];\)\ \ \), "\[IndentingNewLine]", 
    \(Expand[\((2 + x)\)\^4]\)}], "Input"],

Cell[BoxData[
    TagBox[\(x\^4 + 8\ x\^3 + 24\ x\^2 + 32\ x + 16\),
      HoldForm]], "Output"]
}, Closed]],

Cell["Before moving on the normal convention is restored.", "Text"],

Cell[BoxData[{
    \(\(Format[HoldPattern[Plus[p__]]] =. \ \ \ ;\)\), "\n", 
    \(\(Protect[Plus];\)\)}], "Input"],

Cell["\<\
Another application of Format is given below. A user once wrote to the \
MathGroup asking how one could ensure rational numbers greater than one are \
displayed as improper fractions.  P.J. Hinton of Wolfram Research gave the \
solution below to change the way rational numbers are formatted.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Unprotect[Rational];\)\), "\n", 
    \(Format[
        Rational[num_Integer, 
          den_Integer]] \
:= \[IndentingNewLine]DisplayForm[\[IndentingNewLine]RowBox[{ToString[
              Quotient[num, den]], \[IndentingNewLine]FractionBox[
              ToString[Mod[num, den]], 
              ToString[
                den]]\[IndentingNewLine]}\[IndentingNewLine]]\
\[IndentingNewLine]]\), "\n", 
    \(\(\(Protect[Rational];\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(14/3\  - 1\)}], "Input"],

Cell[BoxData[
    TagBox[\(3  2\/3\),
      DisplayForm]], "Output"]
}, Closed]],

Cell["\<\
Before continuing we the next cell should be evaluated to remove the above \
formatting rule.\
\>", "Text"],

Cell[BoxData[{
    \(\(Unprotect[Rational];\)\), "\n", 
    \(\(FormatValues[Rational] = {};\)\), "\n", 
    \(\(Protect[Rational];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["FreeQ", "Section"],

Cell[TextData[{
  "FreeQ is like MemberQ in that is also takes a ",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  ".  By default FreeQ looks at all levels, so in the next example FreeQ \
returns False because it see the 2 in ",
  Cell[BoxData[
      \(TraditionalForm\`x\^2\)]],
  "."
}], "Text",
  CellTags->"FreeQ"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FreeQ[y + x + x\^2, _Integer]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell["\<\
Next I tell FreeQ to only look at level 1 and it says there are no \
Integers.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FreeQ[y + x + x\^2, _Integer, 1]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
Next FreeQ returns False because the whole expression matches the pattern \
(_List).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FreeQ[{1, 0}, _List]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used with FreeQ.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
FreeQ has a Heads option like several other functions, and it has the default \
setting (Heads\[Rule]True).  So in the next example FreeQ checks the heads of \
subexpressions and determines that there is one with the head Plus.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FreeQ[{{x, y}, {1 + x + x\^2, y}}, Plus]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell["\<\
In the next example the setting (Heads\[Rule]False) is used and FreeQ doesn't \
check the heads of subexpressions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FreeQ[{{x, y}, {1 + x + x\^2, y}}, Plus, 
      Heads \[Rule] False]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Function", "Section"],

Cell["Why use pure functions?", "Text",
  FontSize->14,
  FontWeight->"Bold",
  CellTags->"Function"],

Cell["\<\
\[Bullet] If a function is used many times over it can run 15 times faster if \
it's implemented as a pure function.
\[Bullet] Programming with pure functions is often more concise.  
   For example the following line uses a pure function in Select to return \
all elements of data with a magnitude less than 50.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(data = {\(-4\), 34, \(-98\), \(-23\), 68, 
          31};\)\), "\[IndentingNewLine]", 
    \(Select[data, \ Abs[#] < 50 &]\)}], "Input"],

Cell[BoxData[
    \({\(-4\), 34, \(-23\), 31}\)], "Output"]
}, Closed]],

Cell["\<\
The following line also returns all elements of data with a magnitude less \
than 50.  This version doesn't use pure functions. Notice the version using a \
pure function is more concise but seems cryptic until you get used to pure \
functions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Small[x_] := Abs[x] < 50;\)\), "\[IndentingNewLine]", 
    \(Select[data, Small]\)}], "Input"],

Cell[BoxData[
    \({\(-4\), 34, \(-23\), 31}\)], "Output"]
}, Closed]],

Cell["\<\
Before looking at examples below it might help to clear definitions from all \
global symbols with the next cell.\
\>", "Text"],

Cell[BoxData[
    \(ClearAll["\<Global`*\>"]\)], "Input"],

Cell[CellGroupData[{

Cell["Pure functions that use only one argument", "Subsection"],

Cell["\<\
The next cell defines a function (f) which returns 3 plus it's argument.\
\>", "Text"],

Cell[BoxData[
    \(f[x_] := 3 + x\)], "Input"],

Cell["\<\
In the next cell I give four different ways to define a pure function (g) \
which returns 3 plus it's first argument. The expression used to define the \
function varies depending which version is used, but as far as I can tell \
there is no meaningful difference between the different versions.
The Symbol (#) is short hand for Slot[1] and it refers to the first argument \
given to a pure function.\
\>", "Text"],

Cell[BoxData[{
    \(\(g = 3 + # &;\)\), "\n", 
    \(\(g = Function[3 + #];\)\), "\n", 
    \(\(g = Function[x, 3 + x];\)\), "\n", 
    \(\(g = Function[{x}, 3 + x];\)\)}], "Input"],

Cell["In the next cell we see f[t] returns the same thing as g[t].", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({f[t], g[t]}\)], "Input"],

Cell[BoxData[
    \({3 + t, 3 + t}\)], "Output"]
}, Closed]],

Cell["\<\
Functions (f) and (g) don't always do the same thing.  Function (f) is only \
defined when given one argument, but the pure function (g) is defined when \
given one or more arguments.  The pure function (g) uses the first argument \
and ignores all other arguments. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({f[t1, t2], g[t1, t2]}\)], "Input"],

Cell[BoxData[
    \({f[t1, t2], 3 + t1}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Pure functions that use an  ",
  Cell[BoxData[
      \(TraditionalForm\`n\^th\)]],
  " argument"
}], "Subsection"],

Cell[BoxData[
    \(ClearAll[f, g]\)], "Input"],

Cell["\<\
In the next cell I define a function (f) that takes three arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f[x_, y_, z_] := {x - y, x - z};\)\), "\[IndentingNewLine]", 
    \(f[a, b, c]\)}], "Input"],

Cell[BoxData[
    \({a - b, a - c}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell I give three ways to define a pure function that does \
essentially the same thing as (f) in the previous cell.  The FullForm of (#n) \
 is Slot[n], and we use (#2, and  #3) refer to the second and third arguments \
of a pure function. The third way of defining the pure function results in \
differnt form of storing the functions definition that the first two \
solutions, but as far as I can tell there is no meaningful difference between \
the different versions.\
\>", "Text"],

Cell[BoxData[{
    \(\(g = {#1 - #2, #1 - #3} &;\)\), "\n", 
    \(\(g = Function[{#1 - #2, #1 - #3}];\)\), "\n", 
    \(\(g = Function[{x, y, z}, {x - y, x - z}];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g[a, b, c]\)], "Input"],

Cell[BoxData[
    \({a - b, a - c}\)], "Output"]
}, Closed]],

Cell["\<\
Notice the previous definition for (g) will complain if it's given an \
insufficient number of arguments.  Because of this you shouldn't use pure \
functions to define a function an end user will use.  However, pure functions \
are a good choice for private functions in a package since the end user will \
not be using the private functions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g[x, y]\)], "Input"],

Cell[BoxData[
    \(\(Function[{x, y, z}, {x - y, x - z}]\)[x, y]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Notice it's perfectly legal for a pure function to ignore some arguments \
before the ",
  Cell[BoxData[
      \(TraditionalForm\`n\^th\)]],
  " argument.  To demonstrate this point I define (g) below which returns the \
sum of it's ",
  Cell[BoxData[
      \(TraditionalForm\`2\^nd\)]],
  " and ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  "arguments. In this case all other arguments are ignored."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[g, x2, x4];\)\), "\[IndentingNewLine]", 
    \(\(g = #2 + #4 &;\)\), "\[IndentingNewLine]", 
    \(g[x1, x2, x3, x4, x5, x6]\)}], "Input"],

Cell[BoxData[
    \(x2 + x4\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pure functions that use an arbitrary number of arguments", "Subsection"],

Cell[BoxData[
    \(ClearAll[f, g]\)], "Input"],

Cell["\<\
The following cell defines a function (f) that puts all it's arguments in a \
list and squares each element.  The squaring operation is mapped to each \
element because Power has the Listable attribute, but that's another subject.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(f[x__] := {x}\^2\), "\[IndentingNewLine]", 
    \(f[x, y, 5, 3\/\@2]\)}], "Input"],

Cell[BoxData[
    \({x\^2, y\^2, 25, 9\/2}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell I give two ways to define a pure function that puts all its \
elements in a list and square each element.  The FullForm of ## is \
SlotSequence[1] and is used to refer to all the arguments passed to a pure \
function.  The two styles used here result in exactly the same definition for \
the function.\
\>", "Text"],

Cell[BoxData[{
    \(\(g = {##}\^2 &;\)\), "\[IndentingNewLine]", 
    \(\(g = Function[{##}\^2];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g[x, y, 5, 3\/\@2]\)], "Input"],

Cell[BoxData[
    \({x\^2, y\^2, 25, 9\/2}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Use of ##n", "Subsubsection"],

Cell[BoxData[
    \(ClearAll[f, g]\)], "Input"],

Cell["\<\
The next cell defines a pure function (g) that puts all it's arguments \
starting with the third argument in a list and squares each element. The \
FullForm of  (##3)  is SlotSequence[3] and it refers to all arguments of a \
pure function from the third argument on.  The two styles used here result in \
exactly the same definition for the function.\
\>", "Text"],

Cell[BoxData[{
    \(\(g = {##3}\^2 &;\)\), "\[IndentingNewLine]", 
    \(\(g = Function[{##3}\^2];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g[v, x, y, 5, 3\/\@2]\)], "Input"],

Cell[BoxData[
    \({y\^2, 25, 9\/2}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Earlier I demonstrated that ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " will complain if a pure function uses #3 and is given less than three \
arguments.  So it's curious that ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " doesn't complain below when (g) tries to use ##3, but is given only two \
arguments."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g[x, y]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pure functions with one attribute", "Subsection"],

Cell[BoxData[
    \(ClearAll[f, g]\)], "Input"],

Cell["\<\
In the next cell I define a function (f) that returns True if it's argument \
is a Symbol before evaluating and otherwise returns False.  Programming this \
function is slightly tricky because evaluation is prevented in two places.  \
First we give (f) the HoldAll attribute to prevent it's argument from \
evaluating before using the definition of (f).  In addition we use \
Unevaluated[x] to prevent the argument (x) from evaluating before getting \
it's head.\
\>", "Text"],

Cell[BoxData[{
    \(\(Attributes[f] = {HoldAll};\)\), "\[IndentingNewLine]", 
    \(f[x_] := \((Head[Unevaluated[x]] === Symbol)\)\)}], "Input"],

Cell["\<\
In the next cell we see f[t] returns True even when (t) evaluates to a number \
rather than a symbol.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t = 1.4;\)\), "\[IndentingNewLine]", 
    \({f[t], f[1.4]}\)}], "Input"],

Cell[BoxData[
    \({True, False}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell I give four ways to define a pure function (f) that does \
essentially the same thing as (f) defined above.\
\>", "Text"],

Cell[BoxData[{
    \(\(g = 
        Function[\ \ x, \ \ Head[Unevaluated[x]] === Symbol, 
          HoldAll];\)\), "\[IndentingNewLine]", 
    \(\(g = 
        Function[{x}, Head[Unevaluated[x]] === Symbol, 
          HoldAll];\)\), "\[IndentingNewLine]", 
    \(\(g = 
        Function[\ \ x, \ \ Head[Unevaluated[x]] === 
            Symbol, {HoldAll}];\)\), "\[IndentingNewLine]", 
    \(\(g = 
        Function[{x}, 
          Head[Unevaluated[x]] === Symbol, {HoldAll}];\)\)}], "Input"],

Cell["\<\
In the next cell we see (g) does the same thing as (f).  I have found useful \
applications for this pure function.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t = 1.4;\)\), "\[IndentingNewLine]", 
    \({g[t], g[1.4]}\)}], "Input"],

Cell[BoxData[
    \({True, False}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pure functions with multiple attributes", "Subsection"],

Cell[BoxData[
    \(ClearAll[f, g]\)], "Input"],

Cell["\<\
The next cell defines a function (f) which prevents it's arguments from \
evaluating, puts the arguments in canonical order, converts the arguments to \
strings and concatenates the sorted strings with another string.\
\>", "Text"],

Cell[BoxData[{
    \(\(Attributes[f] = {HoldAll, Orderless};\)\), "\[IndentingNewLine]", 
    \(\(f[x_, 
          y_] := \((ToString@\(Unevaluated@x\) <> "\<...\>" <> 
            ToString@\(Unevaluated@y\))\);\)\)}], "Input"],

Cell["\<\
In the next cell we see (f) in action.  You will find f[t,s] returns the same \
thing as f[s,t].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(s = 6; t = 9;\), "\[IndentingNewLine]", 
    \(f[t, s]\)}], "Input"],

Cell[BoxData[
    \("s...t"\)], "Output"]
}, Closed]],

Cell["\<\
The next cell defines a pure function (g) that does essentially the same \
thing as (f) above.\
\>", "Text"],

Cell[BoxData[
    \(\(g = 
        Function[{x, y}, 
          ToString@\(Unevaluated@x\) <> "\<...\>" <> 
            ToString@\(Unevaluated@y\), {HoldAll, Orderless}];\)\)], "Input"],

Cell["In the next cell we see (g) in action.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(s = 6; t = 9;\), "\[IndentingNewLine]", 
    \(g[t, s]\)}], "Input"],

Cell[BoxData[
    \("s...t"\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pure functions that use no arguments", "Subsection"],

Cell[BoxData[
    \(\(ClearAll[f1, f2, x];\)\)], "Input"],

Cell[TextData[{
  "(h&) is a pure function with no arguments which always returns (h). An \
occasion where this is needed is in the PolygonTessellation package available \
at ",
  ButtonBox["http://library.wolfram.com/packages/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/packages/"], None},
    ButtonStyle->"Hyperlink"],
  ". This package includes a function called TessellatePolygon3D with a \
WindingRule option. The WindingRule setting should be a function that returns \
True or False. A typical setting of this option is WindingRule\[Rule]OddQ, \
but in some cases you want a test that always comes out True. In that case \
the setting WindingRule\[Rule](True &) should be used.\n\nOften times the \
ButtonFunction for buttons is a pure function with no arguments.  I give such \
an example in my section on ",
  ButtonBox["ButtonProgramming",
    ButtonData:>"Pure_Function_Example",
    ButtonStyle->"Hyperlink"],
  ".\n\nConsider f1, f2 in the next cell. Here the function f1 returns True \
no matter what argument(s) it has, and f2 returns a random number between 0 \
and 1 no matter what argument(s) it has."
}], "Text",
  CellTags->"No_Argument_Functions"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f1 = True &;\)\), "\[IndentingNewLine]", 
    \(\(f2 = Random[] &;\)\), "\[IndentingNewLine]", 
    \({f1[x], f1[24.5], f1[4], f1[1, 2, 3], f2[x], f2[10^7], 
      f2[1, 2, 3]}\)}], "Input"],

Cell[BoxData[
    \({True, True, True, True, 0.8913304573631929`, 0.1930429850356227`, 
      0.7352159650313722`}\)], "Output"]
}, Closed]],

Cell["\<\
Keep in mind (f1) isn't True it's a function that always returns True and \
that explains why the first element of the next list is False.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({f1 === True, f1[] === True, f1[x] === True}\)], "Input"],

Cell[BoxData[
    \({False, True, True}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Use of  #0  (rarely useful)", "Subsection"],

Cell[BoxData[
    \(\(ClearAll[f];\)\)], "Input"],

Cell["\<\
When used in a pure function (#0) represents the pure function itself.  I \
can't imagine when this would be useful, but I demonstrate it in with the \
pure function (f) in the next cell.  This pure function prints (The second \
argument is ...) and returns the entire pure function as an expression.\
\>", "Text"],

Cell[BoxData[
    \(\(f = \((\((Print["\<The second argument = \>" <> 
                  ToString[#2]]; #0)\) &)\);\)\)], "Input"],

Cell["In the next cell we see (f) in action.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[wx1, wx2, wx3, wx4]\)], "Input"],

Cell[BoxData[
    \("The second argument = wx2"\)], "Print"],

Cell[BoxData[
    \(\((Print["The second argument = " <> ToString[#2]]; #0)\) &\)], "Output"]
}, Closed]]
}, Closed]],

Cell[TextData[{
  "Also read  \"Further Examples\" at the end of the  ",
  ButtonBox["Function",
    ButtonStyle->"RefGuideLink"],
  "  documentation in the Help Browser."
}], "Subsection",
  FontSize->12]
}, Closed]],

Cell[CellGroupData[{

Cell["HoldAll, HoldFirst, HoldRest", "Section"],

Cell["\<\
If a function (f) has the HoldAll attribute (f) does it's work before it's \
arguments evaluate.
It's easy to see why Clear must have the HoldAll attribute.  Consider the \
cell where values are assigned to (x,y,z).\
\>", "Text",
  CellTags->{"Hold", "HoldAll"}],

Cell[BoxData[{
    \(\(x = 2;\)\), "\[IndentingNewLine]", 
    \(\(y = 3;\)\), "\[IndentingNewLine]", 
    \(\(z = 6;\)\)}], "Input"],

Cell["\<\
If Clear didn't have the HoldAll attribute the following would evaluate to \
Clear[2,3,6] which is nonsense.\
\>", "Text"],

Cell[BoxData[
    \(Clear[x, y, z]\)], "Input"],

Cell[TextData[{
  "The example in the next cell is from Power Programming With ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " by David Wagner."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f, g]\), "\[IndentingNewLine]", 
    \(\(SetAttributes[f, HoldAll];\)\), "\[IndentingNewLine]", 
    \(f[x_] := g[x]\), "\[IndentingNewLine]", 
    \(Trace[f[2 + 2]]\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        TagBox[\(f[2 + 2]\),
          HoldForm], ",", 
        TagBox[\(g[2 + 2]\),
          HoldForm], ",", 
        RowBox[{"{", 
          RowBox[{
            TagBox[\(2 + 2\),
              HoldForm], ",", 
            TagBox["4",
              HoldForm]}], "}"}], ",", 
        TagBox[\(g[4]\),
          HoldForm]}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
In the example above the unevaluated sum (2+2) is substituted for (x) on the \
right side of the definition  f[x_]:=g[x].  The sum is only evaluated when \
it's time for (g) to evaluate it's arguments.  If (g) also held it's \
arguments the sum wouldn't evaluate at all.

The FullForm of (x=2) is Set[x,2].  Set has the HoldFirst attribute and it's \
important that is does.  If Set didn't hold it's first argument the second \
assignment in the next cell would evaluate to (2=5) which is nonsense.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x = 2;\)\), "\[IndentingNewLine]", 
    \(x = 5\)}], "Input"],

Cell[BoxData[
    \(5\)], "Output"]
}, Closed]],

Cell["\<\
Also it's easy to see why the symbol If has the attribute HoldRest.  Whe \
given an expression such as  
If[ Test, T, F]  we want to only evaluate 'T' when the Test is True, and we \
only want to evaluate 'F' when the Test is False.  If the Test is neither \
True or False we want neither 'T' or 'F' to evaluate. \
\>", "Text"],

Cell[CellGroupData[{

Cell["\<\
Built-in Symbols with attributes HoldAll, HoldFirst, HoldRest\
\>", "Subsection"],

Cell["The next cell makes a list of all built-in symbols.", "Text"],

Cell[BoxData[
    \(\(symbs = 
        Cases[ToExpression /@ Names["\<System`*\>"], _Symbol];\)\)], "Input"],

Cell["\<\
The next cell gives a list of all built-in symbols with the HoldAll \
attribute.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], HoldAll] &]\)], "Input"],

Cell[BoxData[
    \({AbortProtect, Alias, And, Attributes, Block, Check, CheckAbort, 
      CheckAll, Clear, ClearAll, Compile, CompiledFunction, 
      CompoundExpression, Condition, ConsoleMessage, ConsolePrint, 
      ContourPlot, DefaultValues, Definition, DensityPlot, Dialog, Do, 
      DownValues, EditDefinition, Exists, FileName, FindMinimum, FindRoot, 
      For, ForAll, FormatValues, FullDefinition, Function, 
      FunctionInterpolation, Hold, HoldForm, HoldPattern, Information, 
      Literal, MatchLocalNameQ, MemoryConstrained, Messages, Module, Nand, 
      NIntegrate, Nor, NProduct, NSum, NValues, Off, On, Or, OwnValues, 
      ParametricPlot, ParametricPlot3D, Play, Plot, Plot3D, Product, Protect, 
      Remove, SampledSoundFunction, SetDelayed, StackBegin, StackComplete, 
      StackInhibit, SubValues, Sum, Table, TagSet, TagSetDelayed, TagUnset, 
      TimeConstrained, Timing, Trace, TraceDialog, TracePrint, TraceScan, 
      UnAlias, Unprotect, UpSetDelayed, UpValues, ValueQ, Which, While, 
      With, $ConditionHold, $Failed}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell gives a list of all built-in symbols with the HoldFirst \
attribute.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], HoldFirst] &]\)], "Input"],

Cell[BoxData[
    \({AddTo, AppendTo, Catch, ClearAttributes, Context, Debug, Decrement, 
      DivideBy, Increment, Message, MessageName, MessagePacket, Pattern, 
      PreDecrement, PreIncrement, PrependTo, RuleCondition, Set, 
      SetAttributes, Stack, SubtractFrom, TimesBy, Unset, UpSet}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell gives a list of all built-in symbols with the HoldRest \
attribute.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], HoldRest] &]\)], "Input"],

Cell[BoxData[
    \({DumpSave, If, PatternTest, RuleDelayed, Save, Switch}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["HoldAllComplete", "Section"],

Cell["\<\
Consider the following expression wrapped in Hold.  Hold has the HoldAll \
attribute, but we can still force evaluation of arguments and sequences are \
automatically spliced together.  However, nested layers of Plus aren't \
flattened, and the arguments of Plus aren't sorted.\
\>", "Text",
  CellTags->"HoldAllComplete"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(f[x_] := x^2;\)\), "\[IndentingNewLine]", 
    \(Hold[Evaluate[2 + 3^2], Sequence[v, w], Sequence[x, y], 
      Plus[d, s, Plus[z, a, Plus[u, u]]], f[5]]\)}], "Input"],

Cell[BoxData[
    \(Hold[11, v, w, x, y, d + s + \((z + a + \((u + u)\))\), 
      f[5]]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we use HoldAllComplete.  In this case Evaluate is ignored \
and sequences are not spliced together.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(HoldComplete[\[IndentingNewLine]Evaluate[2 + 3^2], Sequence[v, w], 
      Sequence[x, y], Plus[d, s, Plus[z, a, Plus[u, u]]], 
      f[5]\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(HoldComplete[Evaluate[2 + 3\^2], Sequence[v, w], Sequence[x, y], 
      d + s + \((z + a + \((u + u)\))\), f[5]]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Built-in Symbols with the HoldAllComplete attribute", "Subsection"],

Cell["The next cell makes a list of all built-in symbols.", "Text"],

Cell[BoxData[
    \(\(symbs = 
        Cases[ToExpression /@ Names["\<System`*\>"], _Symbol];\)\)], "Input"],

Cell["\<\
Very few buit-in symbols have the HoldAllComplete attribute and they are all \
listed below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], HoldAllComplete] &]\)], "Input"],

Cell[BoxData[
    \({HoldComplete, InterpretationBox, MakeBoxes, Parenthesize, 
      Unevaluated}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["HoldForm", "Section"],

Cell["The next line gives a sum of integers squared.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sum[\(HoldForm[#^2] &\)[i], {i, 1, 9}]\)], "Input"],

Cell[BoxData[
    RowBox[{
      TagBox[\(1\^2\),
        HoldForm], "+", 
      TagBox[\(2\^2\),
        HoldForm], "+", 
      TagBox[\(3\^2\),
        HoldForm], "+", 
      TagBox[\(4\^2\),
        HoldForm], "+", 
      TagBox[\(5\^2\),
        HoldForm], "+", 
      TagBox[\(6\^2\),
        HoldForm], "+", 
      TagBox[\(7\^2\),
        HoldForm], "+", 
      TagBox[\(8\^2\),
        HoldForm], "+", 
      TagBox[\(9\^2\),
        HoldForm]}]], "Output"]
}, Closed]],

Cell["We can use ReleaseHold to complete the calculation.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ReleaseHold[%]\)], "Input"],

Cell[BoxData[
    \(285\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["HoldPattern", "Section"],

Cell["\<\
You might be very surprised that the following evaluates to True!\
\>", "Text",
  CellTags->"HoldPattern"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MatchQ[And[x, y, z], Times[p__]]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
When the cell above is evaluated  Times[p__] evaluates to (p__) before the \
kernel checks to see if the pattern matches.  MatchQ then determines if \
And[x,y,z] matches the pattern (p__) and it does because And[x,y,z] is itself \
a sequence of one.

Now the next cell also evaluates to True because both ( And[p__] ) and ( \
Times[p__] ) evaluate to ( p__ ).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Times[p__] === And[p__]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
We can prevent patterns in the examples above from evaluating by wrapping \
them with HoldPattern as in the following lines.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MatchQ[And[x, y, z], HoldPattern[Times[p__]]]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(HoldPattern[Times[p__]] === HoldPattern[And[p__]]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell["\<\
With the next line one might expect to have the head (And) changed to (List), \
but it doesn't work.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, y, z, prod, a];\)\), "\[IndentingNewLine]", 
    \(And[x, y, z] /. And[x__] -> List[x]\)}], "Input"],

Cell[BoxData[
    \({x && y && z}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell HoldPattern is used to ensure the head (And) is changed to \
(List).  The two examples that follow have the same effect, but the use of \
HoldPattern isn't needed.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(And[x, y, z] /. HoldPattern[And[a__]] -> List[a]\)], "Input"],

Cell[BoxData[
    \({x, y, z}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(And[x, y, z] /. And -> List\)], "Input"],

Cell[BoxData[
    \({x, y, z}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(And[x, y, z] /. And[a_, b___] -> List[a, b]\)], "Input"],

Cell[BoxData[
    \({x, y, z}\)], "Output"]
}, Closed]],

Cell["\<\
HoldPattern wasn't needed in the last example because ( And[a_,b__] ) \
evaluates to itself.\
\>", "Text"],

Cell["\<\
Sometimes we need to use HoldPattern with care.  Suppose we wanted to replace \
a product of terms to the (1/3) power with (prod).  We can attempt to do this \
on (expr) below.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[x, y, z, expr, prod];\)\), "\n", 
    \(\(expr = \((x*y*z)\)\^\(1/3\) + \((x + y + z)\)\^\(1/3\);\)\)}], "Input"],

Cell[TextData[{
  "In the next line HoldPattern isn't used, and ",
  Cell[BoxData[
      \(TraditionalForm\`Times[__]\^\(1/3\)\)]],
  " evaluates to ",
  Cell[BoxData[
      \(TraditionalForm\`\((__\^\(1/3\))\)\)]],
  ".  Then both terms of expr match the evaluated pattern.  We then get \
(prod+prod)\[LongRightArrow](2 prod)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. Times[__]\^\(1/3\) -> prod\)], "Input"],

Cell[BoxData[
    \(2\ prod\)], "Output"]
}, Closed]],

Cell["\<\
Now if the entire pattern is wrapped in HoldPattern, the exponent in the \
pattern is held in the form 
(Times[1,Power[3,-1]] )  instead of  ( Rational[1,3] ), and neither term \
matches the pattern.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. HoldPattern[\ \((\ Times[__])\)\^\(1/3\)\ ] -> prod\)], "Input"],

Cell[BoxData[
    \(\((x\ y\ z)\)\^\(1/3\) + \((x + y + z)\)\^\(1/3\)\)], "Output"]
}, Closed]],

Cell["\<\
The desired result is given when the expression HoldPattern[Times[__]] is \
raised to the (1/3) power.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. \((HoldPattern[Times[__]])\)\^\(1/3\) -> prod\)], "Input"],

Cell[BoxData[
    \(prod + \((x + y + z)\)\^\(1/3\)\)], "Output"]
}, Closed]],

Cell["\<\
An easier way to get the desired result is to use  (_Times)^(1/3)  as a \
pattern.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. _Times\^\(1/3\) -> prod\)], "Input"],

Cell[BoxData[
    \(prod + \((x + y + z)\)\^\(1/3\)\)], "Output"]
}, Closed]],

Cell["\<\
Alan Hayes explained that HoldPattern[_] is also needed to ensure that the \
rule below is used.  Similar to the other examples HoldPattern is needed \
because Dt[x_] evaluates to something other than itself.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, b];\)\), "\n", 
    \(a\^2 + 2  a + Dt[a] /. Dt[x_] :> 1\)}], "Input"],

Cell[BoxData[
    \(2\ a + a\^2 + Dt[a]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(a\^2 + 2  a + Dt[a] /. HoldPattern[Dt[x_]] :> 1\)], "Input"],

Cell[BoxData[
    \(1 + 2\ a + a\^2\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Hyperlinks", "Section"],

Cell[CellGroupData[{

Cell["How to make a hyperlink to a part of the Help Browser", "Subsection",
  CellTags->"Hyperlinks"],

Cell[TextData[{
  "Here is how you make hyperlinks to some portion of the Help Browser with \
",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " under MS-Windows.   The procedure should be similar on other platforms.\n\
\nStep 1:\nFind the part of the Help Browser that you want the hyperlink to \
jump to.  Don't use the MasterIndex radio button, because other radio buttons \
can access the same stuff, and I don't know how to make a link to the \
MasterIndex.  Once you have the right help page displayed make a note of the \
radio button selected, and the title of the Help Browser topic (to the right \
of the GoTo button).\n\nStep 2:\nType the title of the Help Browser topic in \
a cell, and select the topic.  It doesn't matter what type of cell the \
hyperlink is in (Text, Section, Title, etc.), but one doesn't normally \
include a hyperlink in an Input cell.\n\nStep 3:\nMake the menu selection \
(Input \[RightTriangle] Create Button), then from the pull down menu select \
the radio button you want to link to.  The choices listed should include:\n   \
 MainBookLink\n    AddOnsLink\n    RefGuideLink\n    Getting StartedLink\n    \
OtherInformationLink\nThe selection (RefGuideLink) reefers to the (Built-in \
Functions) button in the Help Browser.  The other selections refer to a Help \
Browser radio button by the same name.  After making the appropriate menu \
selection you should have your hyperlink to the Help Browser."
}], "Text"],

Cell["\<\
As an example we make a hyperlink to section 3.2.4 of the Main Book portion \
of the Help Browser.\
\>", "Text"],

Cell[TextData[{
  "A hyperlink to ",
  ButtonBox["3.2.4",
    ButtonStyle->"MainBookLink"],
  " in the Help Browser"
}], "Text",
  CellFrame->False],

Cell[TextData[{
  "You simply type in the appropriate text, select the cell bracket, and make \
the menu selection ",
  Cell[BoxData[
      \(TraditionalForm\`Format\  \[RightTriangle] Style \[RightTriangle] 
        Text\)]],
  ".  Next select \"3.2.4\" and make the menu selection  ",
  Cell[BoxData[
      \(TraditionalForm\`Input\  \[RightTriangle] 
        CreateButton\  \[RightTriangle] MainBookLink\)]],
  ".  The text \"3.2.4\" is now a hyperlink to section 3.2.4 of the main \
book."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
How to make a hyperlink to a part of the Help Browser, and control the way it \
looks.\
\>", "Subsection"],

Cell["\<\
Suppose you want to make the hyperlink in the next cell.  In this case the \
hyperlink will jump to section 3.2.4 of the Main Book, but the text for the \
hyperlink isn't  \"3.2.4\" as when the procedure from above is used.\
\>", "Text"],

Cell[TextData[{
  "A hyperlink to ",
  ButtonBox["Number theory functions",
    ButtonData:>"3.2.4",
    ButtonStyle->"MainBookLink"],
  " in the Help Browser"
}], "Text"],

Cell["\<\
Steps 1-3:
Make an hyperlink to section 3.2.4 of the Main Book using the procedure \
above.  That will give you the hyperlink and text in the next cell.\
\>", "Text"],

Cell[TextData[{
  "A hyperlink to ",
  ButtonBox["3.2.4",
    ButtonStyle->"MainBookLink"],
  " in the HelpBrowser"
}], "Text"],

Cell["\<\
Step 4:
Put the insertion point (place where keyboard input would go) in the cell \
containing the hyperlink you are making and make the menu selection (Format \
\[RightTriangle] Show Expression) and you get the full expression of the cell \
as shown below.\
\>", "Text"],

Cell[RawData["\<\
Cell[TextData[{
  \"A hyperlink to \",
  ButtonBox[\"3.2.4\",
    ButtonStyle->\"MainBookLink\"],
  \" in the Help Browser\"
}], \"Commentary\"]\
\>"], "Text"],

Cell[TextData[{
  "Step 5:\nEdit the cell expression to look like the cell below.  Notice the \
cell is changed to include ",
  StyleBox["ButtonData\[Rule]\"3.2.4\"",
    FontColor->RGBColor[0.839857, 0.0273442, 0.00781262],
    FontVariations->{"CompatibilityType"->0}],
  "."
}], "Text"],

Cell[RawData["\<\
Cell[TextData[{
  \"A hyperlink to \",
  ButtonBox[\"3.2.4\",ButtonData->\"3.2.4\",
    ButtonStyle->\"MainBookLink\"],
  \" in the HelpBrowser\"
}], \"Commentary\"]\
\>"], "Text"],

Cell["\<\
Step 6:
Make the menu selection (Format \[RightTriangle] Show Expression) and the \
cell looks the same as it did before.  Now that you use the ButtonData option \
of ButtonBox you can change what the hyperlink looks like without changing \
what it does!

Step 7:
Use the keyboard arrows (not the mouse) to move the insertion point into the \
text for the hyperlink, and change the text of the hyperlink from \"3.2.4\" \
to \"Number theory functions\".  You should then have the cell below.\
\>", "Text"],

Cell[TextData[{
  "A hyperlink to ",
  ButtonBox["Number theory functions",
    ButtonData:>"3.2.4",
    ButtonStyle->"MainBookLink"],
  " in the Help Browser"
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
How to make a hyperlink to a specific cell in the Help Browser.\
\>", "Subsection"],

Cell[TextData[{
  "The entire contents of The Mathematica Book is included in the Help \
Browser, and some hyperlinks in the Help Browser take you to specific \
paragraphs (cells) in the book. How can you make your own hyperlinks that do \
this?  I will explain how you can make \nthis button \[LongRightArrow] ",
  ButtonBox["Options in Show",
    ButtonData:>{"1.9.4", "4.15"},
    ButtonStyle->"MainBookLink"],
  " \[LongLeftArrow].\n\nIf you click on the above button you will see that \
it takes you to a specific paragraph in The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book, and the top of the Help Browser will show that you are in section \
1.9.4.  Now select the paragraph in the Help Browser that the button jumped \
to, and make the menu selection (Format \[RightTriangle] ShowExpression).  \
Scroll to the bottom of the expression for this cell, and you should see that \
the cell expression has option \nCellTags \
\[RuleDelayed]{\"S1.9.4\",\"4.15\"}.  You then need to make a button with the \
options \n       ButtonData\[RuleDelayed]{\"1.9.4\",\"4.15\"}, \
ButtonStyle->\"MainBookLink\".  \nThe setting of the ButtonData option is the \
same as the CellTags setting except the 'S' in the first string was removed. \
The same button is shown below, and you can Show the expression of this cell \
to see what it should look like.\n\nNow to make the desired button type '",
  StyleBox["A button to Options in Show in the Help Browser",
    FontColor->RGBColor[0.8, 0, 0]],
  "' in a text cell.  Then select '",
  StyleBox["Options in Show",
    FontColor->RGBColor[0.8, 0, 0]],
  "', and make the menu selection (Input \[RightTriangle] Create Button \
\[RightTriangle] Custom). Select 'Main Book Link' for ButtonStyle, check the \
box for ButtonData and enter ",
  StyleBox["{\"1.9.4\",\"4.15\"}",
    FontColor->RGBColor[0.8, 0, 0]],
  " in the box below the ButtonData check. Next select OK and you should have \
the cell below."
}], "Text"],

Cell[TextData[{
  "A button to ",
  ButtonBox["Options in Show",
    ButtonData:>{"1.9.4", "4.15"},
    ButtonStyle->"MainBookLink"],
  " in the Help Browser."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["How to make a hyperlink to a web page ", "Subsection"],

Cell[TextData[{
  "This is how you make a hyperlink to a web page using ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " under Windows 95/98.  The procedure should be similar under other \
operating systems.\n\nStep 1:\nIn a text cell type the text that will be a \
link to a web page.\n\nStep 2:\nSelect the text that will be the hyperlink.\n\
\nStep 3:\nMake the menu selection (Input \[RightTriangle] Create Hyperlink).\
\n\nStep 4:\nA dialog box will come up.  Type the URL of the web page in the \
blank space next to \"Other notebook or URL\".  Click on the OK button and \
the selected text is a hyperlink to the URL you entered."
}], "Text"],

Cell[TextData[{
  "As an example I give a hyperlink to the Wolfram Research ",
  ButtonBox["web page",
    ButtonData:>{
      URL[ "http://www.wolfram.com"], None},
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["How to make a hyperlink that launches an email message", "Subsection"],

Cell["\<\
My computer uses Windows 98 and has Microsoft Outlook installed.  With my \
configuration I can follow the steps below to make a button which launches an \
email to message to (ersektr@navair.navy.mil).  I suspect the steps are \
similar with other confugurations.

Step 1:
In a text cell I type the text that I want to use for the hyperlink.

Step 2:
Select that portion of the above text cell which will be the hyperlink.

Step 3:
Make the menu selection (Input | Create Hyperlink).

Step 4:
In the field for \"Other Notebook or URL\" type
   mailto:ersektr@navair.navy.mil

Step 5:
Click on OK and the text that was selected is now a button that launches an \
email to 
(ersektr@navair.navy.mil)

You might also like to know that the evaluating the next input cell will also \
launch an email message to 
   ersektr@navair.navy.mil.\
\>", "Text",
  CellTags->"Email"],

Cell[BoxData[
    StyleBox[\(FrontEndExecute[{FrontEnd`NotebookLocate[{URL["\<mailto:\
ersektr@navair.navy.mil\>"], None}]}]\),
      FormatType->StandardForm,
      FontFamily->"Arial",
      FontSize->10]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Still More", "Subsection"],

Cell[TextData[{
  "If you still don't see what you're looking try these links to ",
  ButtonBox["Button Styles",
    ButtonData:>"ButtonStyles",
    ButtonStyle->"Hyperlink"],
  " and ",
  ButtonBox["Button Programming",
    ButtonData:>"ButtonProgramming",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Inner", "Section"],

Cell[TextData[{
  "Inner is a generalization of Dot in that other functions can be used in \
place of Times and Plus. In the next two cells we see ",
  StyleBox["Inner[Times, list1, list2, Plus]",
    FontVariations->{"CompatibilityType"->0}],
  " is equivalent to  Dot[list1, list2] .  Before demonstrating Dot I clear \
the values from any symbols."
}], "Text",
  CellTags->"Inner"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(Dot[{a, b, c}, {x, y, z}]\)}], "Input"],

Cell[BoxData[
    \(a\ x + b\ y + c\ z\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[Times, {a, b, c}, {x, y, z}, Plus]\)], "Input"],

Cell[BoxData[
    \(a\ x + b\ y + c\ z\)], "Output"]
}, Closed]],

Cell["The next cell shows a generic application of Inner. ", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[f, {a, b, c}, {x, y, z}, g]\)], "Input"],

Cell[BoxData[
    \(g[f[a, x], f[b, y], f[c, z]]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see that when Inner is given only three arguments Plus is \
used in place of a fourth argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[f, {a, b, c}, {x, y, z}]\)], "Input"],

Cell[BoxData[
    \(f[a, x] + f[b, y] + f[c, z]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see Inner can handle things other than lists. Inner only \
requires that the objects have the same Head and compatible dimensions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[f, h[a, b, c], h[x, y, z], g]\)], "Input"],

Cell[BoxData[
    \(g[f[a, x], f[b, y], f[c, z]]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Inner product with Matrices and Tensors", "Subsection"],

Cell[TextData[{
  "In the section on ",
  ButtonBox["Dot",
    ButtonData:>"Dot",
    ButtonStyle->"Hyperlink"],
  " we saw that Dot can be used on lists, matrices and tensors. Inner does \
the same thing with Lists, matrices and tensors except other functions can be \
used in place of Times and Plus."
}], "Text"],

Cell[TextData[{
  "In the next cell (A) and (B) are matrices and ",
  Cell[BoxData[
      \(TraditionalForm\`Inner[Times, A, B, Plus]\)]],
  " is the same as ",
  Cell[BoxData[
      \(TraditionalForm\`Dot[A, B]\)]],
  ". "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {{a1, a2}, {b1, b2}};\)\), "\[IndentingNewLine]", 
    \(\(\(B = {{x1, x2, x3}, {y1, y2, y3}};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(Inner[Times, A, B, Plus] === Dot[A, B]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we evaluate  ",
  Cell[BoxData[
      \(TraditionalForm\`Inner[f, A, B, g]\)]],
  "  and we get somthing like matrix multiplication except (f) is used in \
place of multiplication, and (g) is used in place of addition. "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[f, A, B, g]\)], "Input"],

Cell[BoxData[
    \({{g[f[a1, x1], f[a2, y1]], g[f[a1, x2], f[a2, y2]], 
        g[f[a1, x3], f[a2, y3]]}, {g[f[b1, x1], f[b2, y1]], 
        g[f[b1, x2], f[b2, y2]], g[f[b1, x3], f[b2, y3]]}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't give examples of using Inner on tensors, but I think you will find \
it's very much like the ",
  ButtonBox["Dot",
    ButtonData:>"Dot",
    ButtonStyle->"Hyperlink"],
  " product of tensors."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Giving Inner a ",
  Cell[BoxData[
      \(TraditionalForm\`5\^th\)]],
  " argument"
}], "Subsection"],

Cell[TextData[{
  "In the next example Inner is given (1) as a fifth argument and, (at least \
in this example) Inner[Times,A,B,Plus,1] is equivalent to ",
  Cell[BoxData[
      \(TraditionalForm\`Dot[Transpose[A], B]\)]],
  ". "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {{a1, a2}, {b1, b2}};\)\), "\[IndentingNewLine]", 
    \(\(\(B = {{x1, x2, x3}, {y1, y2, y3}};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(Inner[Times, A, B, Plus, 1] === Dot[Transpose[A], B]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The next example shows that (at least in this example) the default value of \
the fifth argument is 2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Inner[f, A, B, g] === Inner[f, A, B, g, 2]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Insert", "Section"],

Cell["Consider the list of ordered pairs (lst) below.", "Text",
  CellTags->"Insert"],

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(lst = {{x1, y1}, {x2, y2}, {x3, y3}, {x4, y4}, {x5, 
            y5}};\)\)}], "Input"],

Cell[TextData[{
  "Now suppose you want to insert ",
  StyleBox["{a1,b1},{a2,b2},{a3,b3}", "Input"],
  "\nbetween the third and fourth ordered pairs. The line below does the \
trick nicely."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Insert[lst, Unevaluated[Sequence @@ {{a1, b1}, {a2, b2}, {a3, b3}}], 
      4]\)], "Input"],

Cell[BoxData[
    \({{x1, y1}, {x2, y2}, {x3, y3}, {a1, b1}, {a2, b2}, {a3, b3}, {x4, 
        y4}, {x5, y5}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Here Unevaluated is needed since Insert doesn't have a Hold attribute, and \
we don't want ",
  StyleBox["Sequence@@{...}",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " to evaluate until after Insert does it's job.  The use of ",
  StyleBox["(Sequence@@)",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " simply strips the head List from the list of ordered pairs."
}], "Text"],

Cell[TextData[{
  "Notice you can use ",
  StyleBox["Insert[expr, elem, {{i1,j1, ...},{i2,j2, ...}, ...}]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  "  to inset an expression at more than one position, but this is very slow \
if you are inserting at lots (>100) of positions."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Level", "Section"],

Cell[TextData[{
  "Lots of examples using Level can be found in the discussion of ",
  ButtonBox["Level Specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  ". Below I explain some of the subtle details. \n\nIn the next cell we get \
a list of all subexpressions at level 2 in expr.  Notice x1 and  x7  each \
appear twice in expr and twice in the result returned by Level."
}], "Text",
  CellTags->"Level"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(expr = {g[x1], {x1, x2}, {x3, x4}, g[x6], \(h[1]\)[x7], 
          g[x7]};\)\), "\[IndentingNewLine]", 
    \(Level[expr, {2}]\)}], "Input"],

Cell[BoxData[
    \({x1, x1, x2, x3, x4, x6, x7, x7}\)], "Output"]
}, Closed]],

Cell["\<\
It seems Level gives a result such that the elements are sorted according to \
their position in the original expression.  This is demonstrated in the next \
cell where a sorted list of positions is used to get the same result we got \
above and the positions are in canonical order.  Notice each list of \
positions has length 2 and this is what we expect since we asked for all \
expressions at level 2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(posn = 
        Sort[{{1, 1}, {2, 1}, {2, 2}, {3, 1}, {3, 2}, {4, 1}, {5, 1}, {6, 
              1}}];\)\), "\n", 
    \(Extract[expr, posn]\)}], "Input"],

Cell[BoxData[
    \({x1, x1, x2, x3, x4, x6, x7, x7}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
By default Level uses the setting (Heads\[Rule]False).  In the next cell we \
use (Heads\[Rule]True) and get the heads at level 2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[expr, {2}, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \({g, x1, List, x1, x2, List, x3, x4, g, x6, h[1], x7, g, x7}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Using the third argument in Level", "Subsection"],

Cell["\<\
Finally Level can be given a third argument that can be applied to the list \
returned.  To demonstrate this feature consider the next cell which gives a \
list of all subexpressions at level 3 and deeper.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(demo = 
        x + Cos[\(\[Pi] \@\( 2 + x/3\)\)\/3] + 
          Sin[\(\[Pi] \@ x\)\/6];\)\), "\[IndentingNewLine]", 
    \(Level[demo, {3, \[Infinity]}]\)}], "Input"],

Cell[BoxData[
    \({1\/3, \[Pi], 2, 1\/3, x, x\/3, 2 + x\/3, 1\/2, \@\(2 + x\/3\), 
      1\/6, \[Pi], x, 1\/2, \@x}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell Level returns the sum of the elements we got from the \
previous cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {3, \[Infinity]}, Plus]\)], "Input"],

Cell[BoxData[
    \(35\/6 + 2\ \[Pi] + \@\(2 + x\/3\) + \@x + \(8\ x\)\/3\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Level Specification", "Section"],

Cell[TextData[{
  "The concept of level specification is explained in The Mathematica Book \
(Sections ",
  ButtonBox["2.1.7",
    ButtonData:>{"2.1.7"},
    ButtonStyle->"MainBookLink"],
  ", and ",
  ButtonBox["A.3.6",
    ButtonData:>{"A.3.6"},
    ButtonStyle->"MainBookLink"],
  "), and is explained further here.  The \"level\" of an expression is \
fundamental to an understanding of level specification.  Level 1 of an \
expression is all subexpressions that can be accessed by giving Part a single \
integer position (e.g.   expr[[2]]).  Level 2 of an expression is all \
subexpressions that can be accessed by giving Part two integers to specify \
the position (e.g.    expr[[2,3]]).  The parts of an expression at level (n) \
can be accessed by giving Part a sequence of (n) integers.  Level 0 of an \
expression is the expression itself.  As indicated by the usage message for \
Level (below) the second argument of Level is a level specification.  In the \
cells that follow Level[demo,_] will be used to explore the different \
variations of level specification."
}], "Text",
  CellTags->"Level Specification"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Level\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Level[expr, levelspec] gives a list of all subexpressions of \
expr on levels specified by levelspec. Level[expr, levelspec, f] applies f to \
the list of subexpressions.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Level",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242392684-5465879"]
}, Closed]],

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\(demo = 
        x + Cos[\(\[Pi] \@\( 2 + 1/x\)\)\/3] + 
          Sin[\(\[Pi] \@ x\)\/6];\)\)}], "Input"],

Cell[TextData[{
  "The functions (Apply, Cases, Count, DeleteCases, FreeQ, Level, Map, \
MapIndexed, MemberQ, Position, Replace, Scan) can  use level specification \
with the same conventions described below.  Several examples of using level \
specification are given in the discussion of ",
  ButtonBox["Map",
    ButtonData:>"Map",
    ButtonStyle->"Hyperlink"],
  " in addition to those in this discussion of Level.  Each of these commands \
also have the option Heads.  The Heads option can be True or False and \
controls whether the command should look at the heads of subexpressions."
}], "Text"],

Cell[CellGroupData[{

Cell["A positive integer for a level specification", "Subsection"],

Cell["\<\
When (levelspec) in Level[expr,levelspec] is an integer (n) a list of all \
subexpressions of (expr) at all levels from 1 through (n) is returned.  In \
the cell below Level is used to get a list of all subexpressions of demo at \
level 1.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, 1]\)], "Input"],

Cell[BoxData[
    \({x, Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)], 
      Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next line Level[demo, 2] returns a list of all subexpressions at \
levels 1 through 2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, 2]\)], "Input"],

Cell[BoxData[
    \({x, 1\/3\ \[Pi]\ \@\(2 + 1\/x\), 
      Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)], \(\[Pi]\ \@x\)\/6, 
      Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A list of one positive integer for a level specification", "Subsection"],

Cell["\<\
If the level specification given to Level is a list containing one positive \
integer, then only subexpressions at the level in the list are returned.  In \
the next cell Level gives a list of all subexpressions at level 2.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {2}]\)], "Input"],

Cell[BoxData[
    \({1\/3\ \[Pi]\ \@\(2 + 1\/x\), \(\[Pi]\ \@x\)\/6}\)], "Output"]
}, Closed]],

Cell["\<\
A level specification deeper than the expression can be given.  When Level \
gets such a level specification it returns an empty list as in the following \
line.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {25}]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A list of two positive integers as a level specification", "Subsection"],

Cell["\<\
If Level is given a list of two integers {m,n} as a level specification, then \
we get a list of all subexpressions at level (m) at level (n) and all \
subexpressions at levels between (m) and (n).  The next line returns a list \
of all subexpressions at levels 2, 3, and 4.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {2, 4}]\)], "Input"],

Cell[BoxData[
    \({1\/3, \[Pi], 2 + 1\/x, 1\/2, \@\(2 + 1\/x\), 
      1\/3\ \[Pi]\ \@\(2 + 1\/x\), 1\/6, \[Pi], x, 
      1\/2, \@x, \(\[Pi]\ \@x\)\/6}\)], "Output"]
}, Closed]],

Cell["\<\
The next line gives a list of all subexpressions at levels 0, 1, and 2.  The \
subexpression at level 0 is the expression itself.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {0, 2}]\)], "Input"],

Cell[BoxData[
    \({x, 1\/3\ \[Pi]\ \@\(2 + 1\/x\), 
      Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)], \(\[Pi]\ \@x\)\/6, 
      Sin[\(\[Pi]\ \@x\)\/6], 
      x + Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)] + 
        Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Negative integers in level specifications", "Subsection"],

Cell["\<\
To understand negative levels you have to first understand the Mathematica \
meaning of depth.  The depth of an expression is said to be one greater than \
the maximum number of indices needed to access any part of an expression. \
\>", "Text"],

Cell[CellGroupData[{

Cell["A list of one negative integer for a level specification", \
"Subsubsection"],

Cell["\<\
 A level specification {-n} (where -n is a negative integer) is all \
subexpressions that have depth (n).  Atoms have depth 1, so the level \
specification {-1} in the next line causes Level to return a list of all the \
atoms in (demo2).  \
\>", "Text"],

Cell["\<\
Note:  Rational numbers have a Numerator and Denominator.  However the \
numerator and denominator of rational numbers can't  be accessed using Part \
so they are regarded as atoms and have a depth of 1.  Complex numbers are \
also regarded as atoms although none were included in (demo).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({AtomQ[1/3], Depth[1/3]}\)], "Input"],

Cell[BoxData[
    \({True, 1}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Part[1/3, 1]\)], "Input"],

Cell[BoxData[
    \(\(1\/3\)\[LeftDoubleBracket]1\[RightDoubleBracket]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {\(-1\)}]\)], "Input"],

Cell[BoxData[
    \({x, 1\/3, \[Pi], 2, x, \(-1\), 1\/2, 1\/6, \[Pi], x, 1\/2}\)], "Output"]
}, Closed]],

Cell["\<\
In the next line the level specification is {-4}, and Level returns a list of \
all subexpressions of demo with depth equal to 4.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {\(-4\)}]\)], "Input"],

Cell[BoxData[
    \({\@\(2 + 1\/x\), Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]],

Cell["\<\
As with positive integer level specifications Level may return an empty list \
if the given expression has no subexpressions sufficiently deep.  The next \
line returns an empty list because neither demo or any of it's subexpressions \
have a depth of 25.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {\(-25\)}]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A negative integer as a level specification", "Subsubsection"],

Cell["\<\
If Level is given a negative integer as a level specification it returns all \
subexpressions from level 1 down to (and including) the negative level \
specified.  The next line returns a list of all subexpressions from level 1 \
down to  those at level -4.  Since the level specification goes down to -4 \
all sub expressions returned have a depth  of 4 or greater.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, \(-4\)]\)], "Input"],

Cell[BoxData[
    \({\@\(2 + 1\/x\), 1\/3\ \[Pi]\ \@\(2 + 1\/x\), 
      Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)], Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]],

Cell["\<\
If Level is given (-1) as a level specification (as in the next line) we get \
a list of all subexpressions from level 1 down to the atoms.  This amounts to \
every subexpression, but not the whole expression itself.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, \(-1\)]\)], "Input"],

Cell[BoxData[
    \({x, 1\/3, \[Pi], 2, x, \(-1\), 1\/x, 2 + 1\/x, 1\/2, \@\(2 + 1\/x\), 
      1\/3\ \[Pi]\ \@\(2 + 1\/x\), Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)], 
      1\/6, \[Pi], x, 1\/2, \@x, \(\[Pi]\ \@x\)\/6, 
      Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next line we see level specifications -1 and \[Infinity] are \
equivalent. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, \(-1\)] === Level[demo, \[Infinity]]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
A list of integers including one or two negative integers for a level \
specification\
\>", "Subsubsection"],

Cell["\<\
The next line gives a list of all subexpressions at any level (except level \
0) that have a depth of 3 or greater.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {1, \(-3\)}]\)], "Input"],

Cell[BoxData[
    \({2 + 1\/x, \@\(2 + 1\/x\), 1\/3\ \[Pi]\ \@\(2 + 1\/x\), 
      Cos[1\/3\ \[Pi]\ \@\(2 + 1\/x\)], \(\[Pi]\ \@x\)\/6, 
      Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]],

Cell["\<\
Then the next line gives a list of all subexpressions at levels 2 or above \
with a depth of 4 or less.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(tt = Level[demo, {\(-4\), 2}]\)], "Input"],

Cell[BoxData[
    \({x, \(\[Pi]\ \@x\)\/6, Sin[\(\[Pi]\ \@x\)\/6]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next two cells level specification {0,-1}  is effectively the same as \
level specification {-\[Infinity],\[Infinity]}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {0, \(-1\)}] === 
      Level[demo, {\(-\[Infinity]\), \[Infinity]}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next line Level is asked to return all subexpressions at levels 3 or \
deeper that have a depth of 6 or greater.  Expression demo2 has no \
subexpressions meeting this criteria, so an empty list is returned.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {3, \(-6\)}]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]],

Cell["\<\
The next line gives a list of all subexpression with a depth of 1, 2, or 3.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Level[demo, {\(-3\), \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({x, 1\/3, \[Pi], 2, x, \(-1\), 1\/x, 2 + 1\/x, 1\/2, 1\/6, \[Pi], x, 
      1\/2, \@x, \(\[Pi]\ \@x\)\/6}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ListConvolve", "Section"],

Cell["The next cell demonstrates the basic use of ListConvolve.", "Text",
  CellTags->"ListConvolve"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Off[General::spell1];\)\), "\[IndentingNewLine]", 
    \(\(\(Clear["\<Global`*\>"];\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}]\)}], "Input"],

Cell[BoxData[
    \({a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, 
      a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
Next we see that ListConvolve is equivalent to flattening the result of a \
certain matrix product.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a4", "a3", "a2", "a1", "0", "0"},
              {"0", "a4", "a3", "a2", "a1", "0"},
              {"0", "0", "a4", "a3", "a2", "a1"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows that ListConvolve is closely related to ListCorrelate.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(listA = {a1, a2, a3, a4};\)\), "\[IndentingNewLine]", 
    \(\(listB = {b1, b2, b3, b4, b5, b6};\)\), "\[IndentingNewLine]", 
    \(ListConvolve[listA, listB] === \ 
      ListCorrelate[Reverse[listA], listB]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Specifying the \"overhang\" using  ",
  Cell[BoxData[
      \(TraditionalForm\`{K\_L, K\_R}\)]]
}], "Subsection"],

Cell["\<\
In the next cell we provide ListConvolve {-1,-1} as a third argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
        b6}, {\(-1\), \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, 
      a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6, a1\ b1 + a4\ b4 + a3\ b5 + a2\ b6, 
      a2\ b1 + a1\ b2 + a4\ b5 + a3\ b6, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the last element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the last element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (-1) indicates last element \
of {a1, a2, a3, a4}, and (-2) would indicate the second from the last element \
of {a1, a2, a3, a4}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a4", "a3", "a2", "a1", "0", "0"},
              {"0", "a4", "a3", "a2", "a1", "0"},
              {"0", "0", "a4", "a3", "a2", "a1"},
              {"a1", "0", "0", "a4", "a3", "a2"},
              {"a2", "a1", "0", "0", "a4", "a3"},
              {"a3", "a2", "a1", "0", "0", "a4"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {\(-1\), \(-1\)}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we provide ListConvolve {1,1} as a third argument.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, 
        1}]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a4\ b4 + a3\ b5 + a2\ b6, a2\ b1 + a1\ b2 + a4\ b5 + a3\ b6, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ b6, a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, 
      a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, 
      a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the first element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the first element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (1) indicates first element \
of {a1, a2, a3, a4}, and (2) would indicate the second element of {a1, a2, \
a3, a4}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a1", "0", "0", "a4", "a3", "a2"},
              {"a2", "a1", "0", "0", "a4", "a3"},
              {"a3", "a2", "a1", "0", "0", "a4"},
              {"a4", "a3", "a2", "a1", "0", "0"},
              {"0", "a4", "a3", "a2", "a1", "0"},
              {"0", "0", "a4", "a3", "a2", "a1"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, 
          1}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we provide ListConvolve {1,-1} as a third argument.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
        b6}, {1, \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a4\ b4 + a3\ b5 + a2\ b6, a2\ b1 + a1\ b2 + a4\ b5 + a3\ b6, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ b6, a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, 
      a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6, 
      a1\ b1 + a4\ b4 + a3\ b5 + a2\ b6, a2\ b1 + a1\ b2 + a4\ b5 + a3\ b6, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the first element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the last element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (1) indicates first element \
of {a1, a2, a3, a4}, and (-1) indicates the last element of {a1, a2, a3, a4}.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a1", "0", "0", "a4", "a3", "a2"},
              {"a2", "a1", "0", "0", "a4", "a3"},
              {"a3", "a2", "a1", "0", "0", "a4"},
              {"a4", "a3", "a2", "a1", "0", "0"},
              {"0", "a4", "a3", "a2", "a1", "0"},
              {"0", "0", "a4", "a3", "a2", "a1"},
              {"a1", "0", "0", "a4", "a3", "a2"},
              {"a2", "a1", "0", "0", "a4", "a3"},
              {"a3", "a2", "a1", "0", "0", "a4"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we provide ListConvolve {-1,1} as a third argument. Notice \
this gives the same result as 
ListConvolve[{a1,a2,a3,a4},{b1,b2,b3,b4,b5,b6}]  (ie. {-1,1} is the default \
for the third argument).\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 
        1}]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, 
      a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the last element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the First element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (1) indicates first element \
of {a1, a2, a3, a4}, and (-1) indicates the last element of {a1, a2, a3, a4}.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a4", "a3", "a2", "a1", "0", "0"},
              {"0", "a4", "a3", "a2", "a1", "0"},
              {"0", "0", "a4", "a3", "a2", "a1"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 
          1}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Specifying the padding", "Subsection"],

Cell[TextData[{
  "In the next cell we provide (s) as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, 
      s]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a2\ s + a3\ s + a4\ s, a2\ b1 + a1\ b2 + a3\ s + a4\ s, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ s, a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, 
      a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6, 
      a4\ b4 + a3\ b5 + a2\ b6 + a1\ s, a4\ b5 + a3\ b6 + a1\ s + a2\ s, 
      a4\ b6 + a1\ s + a2\ s + a3\ s}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell performs a series of Dot products that give the same result as \
in the previous cell.  Notice we gave ListConvolve {1,-1} as a third \
argument, and the left part of the first row starts with the first part of \
{a1,a2,a3,a4}.  Also the last row ends with the last element of \
{a1,a2,a3,a4}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\({\[IndentingNewLine]{a1, a2, a3, a4, 0, 0} . {b1, s\ , s\ , s\ , s\ , 
            s\ }, \[IndentingNewLine]{a2, a1, a3, a4, 0, 0} . {b1, b2, s\ , 
            s\ , s\ , s\ }, \[IndentingNewLine]{a3, a2, a1, a4, 0, 0} . {b1, 
            b2, b3, s\ , s\ , s\ }, \[IndentingNewLine]{a4, a3, a2, a1, 0, 
            0} . {b1, b2, b3, b4, s\ , s\ }, \[IndentingNewLine]{0, a4, a3, 
            a2, a1, 0} . {b1, b2, b3, b4, b5, s\ }, \[IndentingNewLine]{0, 0, 
            a4, a3, a2, a1} . {b1, b2, b3, b4, b5, 
            b6}, \[IndentingNewLine]{a1, 0, 0, a4, a3, a2} . {s\ , b2, b3, 
            b4, b5, b6}, \[IndentingNewLine]{a2, a1, 0, 0, a4, a3} . {s\ , 
            s\ , b3, b4, b5, b6}, \[IndentingNewLine]{a3, a2, a1, 0, 0, 
            a4} . {s\ , s\ , s\ , b4, b5, 
            b6}\[IndentingNewLine]};\)\), "\[IndentingNewLine]", 
    \(% === ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}, s]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we provide {u1 ,u2, u3, u4, u5, u6} as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
        b6}, {1, \(-1\)}, {s1, s2, s3, s4, s5, s6}]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a4\ s4 + a3\ s5 + a2\ s6, a2\ b1 + a1\ b2 + a4\ s5 + a3\ s6, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ s6, a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, 
      a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6, 
      a4\ b4 + a3\ b5 + a2\ b6 + a1\ s1, a4\ b5 + a3\ b6 + a2\ s1 + a1\ s2, 
      a4\ b6 + a3\ s1 + a2\ s2 + a1\ s3}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell performs a series of Dot products that give the same result \
as in the previous cell. Notice the difference between giving (s) and giving \
{s,t,u} as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument.  I actually have a hard time seeing when this would be useful."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\({\[IndentingNewLine]{a1, 0, 0, a4, a3, a2} . {b1, b2, b3, s4, s5, 
            s6}, \[IndentingNewLine]{a2, a1, 0, 0, a4, a3} . {b1, b2, b3, b4, 
            s5, s6}, \[IndentingNewLine]{a3, a2, a1, 0, 0, a4} . {b1, b2, b3, 
            b4, b5\ , s6}, \[IndentingNewLine]{a4, a3, a2, a1, 0, 0} . {b1, 
            b2, b3, b4, b5, b6}, \[IndentingNewLine]{0, a4, a3, a2, a1, 
            0} . {b1, b2, b3, b4, b5, u6\ }, \[IndentingNewLine]{0, 0, a4, 
            a3, a2, a1} . {b1, b2, b3, b4, b5, b6}, \[IndentingNewLine]{a1, 
            0, 0, a4, a3, a2} . {s1\ , b2, b3, b4, b5, 
            b6}, \[IndentingNewLine]{a2, a1, 0, 0, a4, a3} . {s1, s2\ , b3, 
            b4, b5, b6}, \[IndentingNewLine]{a3, a2, a1, 0, 0, a4} . {s1, 
            s2\ , s3\ , b4, b5, 
            b6}\[IndentingNewLine]};\)\), "\[IndentingNewLine]", 
    \(% === ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}, {s1, s2, s3, s4, s5, s6}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "To make this more clear I give another example where we give ListConvolve \
a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument in the next cell."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
        b6}, {1, \(-1\)}, {s1, s2}]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a3\ s1 + a2\ s2 + a4\ s2, a2\ b1 + a1\ b2 + a4\ s1 + a3\ s2, 
      a3\ b1 + a2\ b2 + a1\ b3 + a4\ s2, a4\ b1 + a3\ b2 + a2\ b3 + a1\ b4, 
      a4\ b2 + a3\ b3 + a2\ b4 + a1\ b5, a4\ b3 + a3\ b4 + a2\ b5 + a1\ b6, 
      a4\ b4 + a3\ b5 + a2\ b6 + a1\ s1, a4\ b5 + a3\ b6 + a2\ s1 + a1\ s2, 
      a4\ b6 + a1\ s1 + a3\ s1 + a2\ s2}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell performs a series of Dot products that give the same result as \
in the previous cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\({\[IndentingNewLine]{a1, 0, 0, a4, a3, a2} . {b1, b2, b3, s2, s1, 
            s2}, \[IndentingNewLine]{a2, a1, 0, 0, a4, a3} . {b1, b2, b3, b4, 
            s1, s2}, \[IndentingNewLine]{a3, a2, a1, 0, 0, a4} . {b1, b2, b3, 
            b4, b5\ , s2}, \[IndentingNewLine]{a4, a3, a2, a1, 0, 0} . {b1, 
            b2, b3, b4, b5, b6}, \[IndentingNewLine]{0, a4, a3, a2, a1, 
            0} . {b1, b2, b3, b4, b5, u6\ }, \[IndentingNewLine]{0, 0, a4, 
            a3, a2, a1} . {b1, b2, b3, b4, b5, b6}, \[IndentingNewLine]{a1, 
            0, 0, a4, a3, a2} . {s1\ , b2, b3, b4, b5, 
            b6}, \[IndentingNewLine]{a2, a1, 0, 0, a4, a3} . {s1, s2\ , b3, 
            b4, b5, b6}, \[IndentingNewLine]{a3, a2, a1, 0, 0, a4} . {s1, 
            s2\ , s1\ , b4, b5, 
            b6}\[IndentingNewLine]};\)\), "\[IndentingNewLine]", 
    \(% === ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}, {s1, s2}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "It's curious that providing an empty list as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument is equivalent to providing the integer 1 as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}, {}] === 
      ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, 
        1]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell shows that by default ListConvolve uses the second argument \
in place of a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument when none is provided."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}] === \[IndentingNewLine]ListConvolve[{a1, a2, a3, 
          a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, {b1, b2, b3, b4, b5, 
          b6}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Generalizing beyond Times, Plus", "Subsection"],

Cell[TextData[{
  "In the next cell we provide ListConvolve (g) as a ",
  Cell[BoxData[
      \(TraditionalForm\`5\^th\)]],
  " argument and it uses the head (g) in place of Times."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 1}, 
      lst, g]\)], "Input"],

Cell[BoxData[
    \({g[a1, b4] + g[a2, b3] + g[a3, b2] + g[a4, b1], 
      g[a1, b5] + g[a2, b4] + g[a3, b3] + g[a4, b2], 
      g[a1, b6] + g[a2, b5] + g[a3, b4] + g[a4, b3]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we provide ListConvolve (g, h) as a ",
  Cell[BoxData[
      \(TraditionalForm\`5\^th\)]],
  " and ",
  Cell[BoxData[
      \(TraditionalForm\`6\^th\)]],
  " arguments respectively and it uses the heads (g) and (h) in place of \
Times and Plus respectively."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 1}, 
      lst, g, h]\)], "Input"],

Cell[BoxData[
    \({h[g[a4, b1], g[a3, b2], g[a2, b3], g[a1, b4]], 
      h[g[a4, b2], g[a3, b3], g[a2, b4], g[a1, b5]], 
      h[g[a4, b3], g[a3, b4], g[a2, b5], g[a1, b6]]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ListConvolve with matrices", "Subsection"],

Cell["In the next cell we perform a ListConvolution on matrices.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{"m1", "=", 
        RowBox[{"(", GridBox[{
              {"a1", "a2", "a3"},
              {"b1", "b2", "b3"},
              {"c1", "c2", "c3"}
              }], ")"}]}], ";"}], "\n", 
    RowBox[{
      RowBox[{"m2", "=", 
        RowBox[{"(", GridBox[{
              {"x1", "x2", "x3"},
              {"y1", "y2", "y3"},
              {"z1", "z2", "z3"}
              }], ")"}]}], ";"}], "\n", \(ListConvolve[m1, m2]\)}], "Input"],

Cell[BoxData[
    \({{c3\ x1 + c2\ x2 + c1\ x3 + b3\ y1 + b2\ y2 + b1\ y3 + a3\ z1 + 
          a2\ z2 + a1\ z3}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how the same ListConvolution can be done as Dot products \
on parts of the matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[m1, 
        m2] === \[IndentingNewLine]{{Part[m1, 1] . Reverse[Part[m2, 3]] + 
            Part[m1, 2] . Reverse[Part[m2, 2]] + 
            Part[m1, 3] . Reverse[Part[m2, 1]]}}\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "We can give ListConvolve a level specification as a ",
  Cell[BoxData[
      \(TraditionalForm\`7\^th\)]],
  " argument.  The next cell shows that level (2) is the default \
specification when working on matrices. "
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[m1, m2] === \[IndentingNewLine]ListConvolve[m1, 
        m2, {\(-1\), 1}, m2, Times, Plus, 2]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we give ListConvolve the integer (1) as a level \
specification.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[m1, m2, {\(-1\), 1}, m2, Times, Plus, 1]\)], "Input"],

Cell[BoxData[
    \({{c1\ x1 + b1\ y1 + a1\ z1, c2\ x2 + b2\ y2 + a2\ z2, 
        c3\ x3 + b3\ y3 + a3\ z3}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how the same ListConvolution can be done as Dot products \
on parts of the matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mat1 = Transpose[m1];\)\), "\n", 
    \(\(\(mat2 = Transpose[m2];\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(ListConvolve[m1, m2, {\(-1\), 1}, m2, Times, Plus, 
        1] === \n{{Reverse[Part[mat1, 1]] . Part[mat2, 1], 
          Reverse[Part[mat1, 2]] . Part[mat2, 2], 
          Reverse[Part[mat1, 3]] . Part[mat2, 3]}}\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows two ways of expressing the default for the third argument \
of ListConvolve when working with matrices.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListConvolve[m1, m2] === ListConvolve[m1, m2, {\(-1\), 1}] === 
      ListConvolve[m1, m2, {{\(-1\), \(-1\)}, {1, 1}}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
I am having a hard time seeing a pattern to how a ListConvolution on matrices \
is done in different cases.  I would like to have a complete understanding \
for what the third argument of ListConvolve does when working with matrices, \
but it's too hard to decipher.  For example I would like to understand the \
result of the examples below.  \
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[BoxData[
    \(ListConvolve[m1, m2, {1, 1}]\)], "Input"],

Cell[BoxData[
    \(ListConvolve[m1, m2, {{1, 1}, {\(-1\), \(-1\)}}]\)], "Input"],

Cell[BoxData[
    \(ListConvolve[m1, m2, {1, 1}, m2, Times, Plus, 1]\)], "Input"],

Cell["\<\
I also understand we can also perform a ListConvolution on tensors, but that \
is also too confusing for me to think about.\
\>", "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ListCorrelate", "Section"],

Cell["The next cell demonstrates the basic use of ListCorrelate.", "Text",
  CellTags->"ListCorrelate"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Off[General::spell1];\)\), "\[IndentingNewLine]", 
    \(\(Clear["\<Global`*\>"];\)\[IndentingNewLine]\), "\[IndentingNewLine]", \

    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}]\)}], "Input"],

Cell[BoxData[
    \({a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, 
      a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
Next we see that ListCorrelate is equivalent to flattening the result of a \
certain matrix product.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a1", "a2", "a3", "a4", "0", "0"},
              {"0", "a1", "a2", "a3", "a4", "0"},
              {"0", "0", "a1", "a2", "a3", "a4"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows that ListConvolve is closely related to ListCorrelate.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(listA = {a1, a2, a3, a4};\)\), "\[IndentingNewLine]", 
    \(\(listB = {b1, b2, b3, b4, b5, b6};\)\), "\[IndentingNewLine]", 
    \(ListConvolve[listA, listB] === \ 
      ListCorrelate[Reverse[listA], listB]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Specifying the \"overhang\" using  ",
  Cell[BoxData[
      \(TraditionalForm\`{K\_L, K\_R}\)]]
}], "Subsection"],

Cell["\<\
In the next cell we provide ListCorrelate {-1,-1} as a third argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
        b6}, {\(-1\), \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a1\ b4 + a2\ b5 + a3\ b6, a3\ b1 + a4\ b2 + a1\ b5 + a2\ b6, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ b6, a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, 
      a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, 
      a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the last element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the last element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (-1) indicates last element \
of {a1, a2, a3, a4}, and (-2) would indicate the second from the last element \
of {a1, a2, a3, a4}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a4", "0", "0", "a1", "a2", "a3"},
              {"a3", "a4", "0", "0", "a1", "a2"},
              {"a2", "a3", "a4", "0", "0", "a1"},
              {"a1", "a2", "a3", "a4", "0", "0"},
              {"0", "a1", "a2", "a3", "a4", "0"},
              {"0", "0", "a1", "a2", "a3", "a4"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {\(-1\), \(-1\)}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we provide ListCorrelate {1,1} as a third argument.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, 
        1}]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, 
      a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6, a4\ b1 + a1\ b4 + a2\ b5 + a3\ b6, 
      a3\ b1 + a4\ b2 + a1\ b5 + a2\ b6, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the first element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the first element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (1) indicates first element \
of {a1, a2, a3, a4}, and (2) would indicate the second element of {a1, a2, \
a3, a4}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a1", "a2", "a3", "a4", "0", "0"},
              {"0", "a1", "a2", "a3", "a4", "0"},
              {"0", "0", "a1", "a2", "a3", "a4"},
              {"a4", "0", "0", "a1", "a2", "a3"},
              {"a3", "a4", "0", "0", "a1", "a2"},
              {"a2", "a3", "a4", "0", "0", "a1"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, 
          1}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we provide ListCorrelate {1,-1} as a third argument.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
        b6}, {1, \(-1\)}]\)], "Input"],

Cell[BoxData[
    \({a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, 
      a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6}\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the first element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the last element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (1) indicates first element \
of {a1, a2, a3, a4}, and (-1) indicates the last element of {a1, a2, a3, a4}.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a1", "a2", "a3", "a4", "0", "0"},
              {"0", "a1", "a2", "a3", "a4", "0"},
              {"0", "0", "a1", "a2", "a3", "a4"},
              {"a4", "0", "0", "a1", "a2", "a3"},
              {"a3", "a4", "0", "0", "a1", "a2"},
              {"a2", "a3", "a4", "0", "0", "a1"},
              {"a1", "a2", "a3", "a4", "0", "0"},
              {"0", "a1", "a2", "a3", "a4", "0"},
              {"0", "0", "a1", "a2", "a3", "a4"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}]\)}], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we provide ListCorrelate {-1,1} as a third argument. Notice \
this gives the same result as 
ListCorrelate[{a1,a2,a3,a4},{b1,b2,b3,b4,b5,b6}]  (ie. {-1,1} is the default \
for the third argument).\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 
        1}]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a1\ b4 + a2\ b5 + a3\ b6, a3\ b1 + a4\ b2 + a1\ b5 + a2\ b6, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ b6, a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, 
      a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6, 
      a4\ b1 + a1\ b4 + a2\ b5 + a3\ b6, a3\ b1 + a4\ b2 + a1\ b5 + a2\ b6, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ b6}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Length[%]\)], "Input"],

Cell[BoxData[
    \(9\)], "Output"]
}, Closed]],

Cell["\<\
The previous example is equivalent to the matrix product in the next cell.  \
Here we have the last element of {a1, a2, a3, a4} in the upper left position \
of the left matrix..  We also have the First element of {a1, a2, a3, a4} in \
the lower right position of the left matrix.  The (1) indicates first element \
of {a1, a2, a3, a4}, and (-1) indicates the last element of {a1, a2, a3, a4}.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{
        RowBox[{"(", GridBox[{
              {"a4", "0", "0", "a1", "a2", "a3"},
              {"a3", "a4", "0", "0", "a1", "a2"},
              {"a2", "a3", "a4", "0", "0", "a1"},
              {"a1", "a2", "a3", "a4", "0", "0"},
              {"0", "a1", "a2", "a3", "a4", "0"},
              {"0", "0", "a1", "a2", "a3", "a4"},
              {"a4", "0", "0", "a1", "a2", "a3"},
              {"a3", "a4", "0", "0", "a1", "a2"},
              {"a2", "a3", "a4", "0", "0", "a1"}
              }], ")"}], ".", 
        RowBox[{"(", GridBox[{
              {"b1"},
              {"b2"},
              {"b3"},
              {"b4"},
              {"b5"},
              {"b6"}
              }], ")"}]}], ";"}], "\[IndentingNewLine]", \(Flatten[%] === 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 
          1}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Specifying the padding", "Subsection"],

Cell[TextData[{
  "In the next cell we provide (s) as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 1}, 
      s]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a1\ s + a2\ s + a3\ s, a3\ b1 + a4\ b2 + a1\ s + a2\ s, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ s, a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, 
      a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6, 
      a1\ b4 + a2\ b5 + a3\ b6 + a4\ s, a1\ b5 + a2\ b6 + a3\ s + a4\ s, 
      a1\ b6 + a2\ s + a3\ s + a4\ s}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell performs a series of Dot products that give the same result as \
in the previous cell.  Notice we gave ListCorrelate {1,-1} as a third \
argument, and the left part of the first row starts with the first part of \
{a1,a2,a3,a4}.  Also the last row ends with the last element of \
{a1,a2,a3,a4}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\({\[IndentingNewLine]{a4, \ 0, \ 0, a1, a2, a3} . {b1, s\ , s\ , s\ , 
            s\ , s\ }, \[IndentingNewLine]{a3, a4, \ 0, \ 0, a1, a2} . {b1, 
            b2, s\ , s\ , s\ , s\ }, \[IndentingNewLine]{a2, a3, a4, \ 0, \ 
            0, a1} . {b1, b2, b3, s\ , s\ , s\ }, \[IndentingNewLine]{a1, a2, 
            a3, a4, \ 0, \ 0} . {b1, b2, b3, b4, s\ , 
            s\ }, \[IndentingNewLine]{\ 0, a1, a2, a3, a4, \ 0} . {b1, b2, 
            b3, b4, b5, s\ }, \[IndentingNewLine]{\ 0, \ 0, a1, a2, a3, 
            a4} . {b1, b2, b3, b4, b5, b6}, \[IndentingNewLine]{a4, \ 0, \ 0, 
            a1, a2, a3} . {s\ , b2, b3, b4, b5, b6}, \[IndentingNewLine]{a3, 
            a4, \ 0, \ 0, a1, a2} . {s\ , s\ , b3, b4, b5, 
            b6}, \[IndentingNewLine]{a2, a3, a4, \ 0, \ 0, a1} . {s\ , s\ , 
            s\ , b4, b5, 
            b6}\[IndentingNewLine]};\)\), "\[IndentingNewLine]", 
    \(% === ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {\(-1\), 1}, s]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we provide {s1 s2, s3, s4, s5, s6} as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(w1 = 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 
          1}, {s1, s2, s3, s4, s5, s6}]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a1\ s4 + a2\ s5 + a3\ s6, a3\ b1 + a4\ b2 + a1\ s5 + a2\ s6, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ s6, a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, 
      a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6, 
      a1\ b4 + a2\ b5 + a3\ b6 + a4\ s1, a1\ b5 + a2\ b6 + a3\ s1 + a4\ s2, 
      a1\ b6 + a2\ s1 + a3\ s2 + a4\ s3}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell performs a series of Dot products that give the same result \
as in the previous cell. Notice the difference between giving (s) and giving \
{s,t,u} as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument.  I actually have a hard time seeing when this would be useful."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\({\[IndentingNewLine]{a4, \ 0, \ 0, a1, a2, a3} . {b1, s2\ , s3\ , 
            s4\ , s5\ , s6\ }, \[IndentingNewLine]{a3, a4, \ 0, \ 0, a1, 
            a2} . {b1, b2, s3\ , s4\ , s5\ , s6\ }, \[IndentingNewLine]{a2, 
            a3, a4, \ 0, \ 0, a1} . {b1, b2, b3, s4\ , s5\ , 
            s6\ }, \[IndentingNewLine]{a1, a2, a3, a4, \ 0, \ 0} . {b1, b2, 
            b3, b4, s5\ , s6\ }, \[IndentingNewLine]{\ 0, a1, a2, a3, a4, \ 
            0} . {b1, b2, b3, b4, b5, s6\ }, \[IndentingNewLine]{\ 0, \ 0, 
            a1, a2, a3, a4} . {b1, b2, b3, b4, b5, 
            b6}, \[IndentingNewLine]{a4, \ 0, \ 0, a1, a2, a3} . {s1\ , b2, 
            b3, b4, b5, b6}, \[IndentingNewLine]{a3, a4, \ 0, \ 0, a1, 
            a2} . {s1\ , s2\ , b3, b4, b5, b6}, \[IndentingNewLine]{a2, a3, 
            a4, \ 0, \ 0, a1} . {s1\ , s2\ , s3\ , b4, b5, 
            b6}\[IndentingNewLine]};\)\), "\n", 
    \(% === ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {\(-1\), 1}, {s1, s2, s3, s4, s5, s6}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "To make this more clear I give another example where we give ",
  "ListCorrelate",
  " a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument in the next cell."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {\(-1\), 
        1}, {s1, s2}]\)], "Input"],

Cell[BoxData[
    \({a4\ b1 + a2\ s1 + a1\ s2 + a3\ s2, a3\ b1 + a4\ b2 + a1\ s1 + a2\ s2, 
      a2\ b1 + a3\ b2 + a4\ b3 + a1\ s2, a1\ b1 + a2\ b2 + a3\ b3 + a4\ b4, 
      a1\ b2 + a2\ b3 + a3\ b4 + a4\ b5, a1\ b3 + a2\ b4 + a3\ b5 + a4\ b6, 
      a1\ b4 + a2\ b5 + a3\ b6 + a4\ s1, a1\ b5 + a2\ b6 + a3\ s1 + a4\ s2, 
      a1\ b6 + a2\ s1 + a4\ s1 + a3\ s2}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell performs a series of Dot products that give the same result as \
in the previous cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\({\[IndentingNewLine]{a4, \ 0, \ 0, a1, a2, a3} . {b1, s2\ , s1\ , 
            s2\ , s1\ , s2\ }, \[IndentingNewLine]{a3, a4, \ 0, \ 0, a1, 
            a2} . {b1, b2, s1\ , s2\ , s1\ , s2\ }, \[IndentingNewLine]{a2, 
            a3, a4, \ 0, \ 0, a1} . {b1, b2, b3, s2\ , s1\ , 
            s2\ }, \[IndentingNewLine]{a1, a2, a3, a4, \ 0, \ 0} . {b1, b2, 
            b3, b4, s1\ , s2\ }, \[IndentingNewLine]{\ 0, a1, a2, a3, a4, \ 
            0} . {b1, b2, b3, b4, b5, s2\ }, \[IndentingNewLine]{\ 0, \ 0, 
            a1, a2, a3, a4} . {b1, b2, b3, b4, b5, 
            b6}, \[IndentingNewLine]{a4, \ 0, \ 0, a1, a2, a3} . {s1\ , b2, 
            b3, b4, b5, b6}, \[IndentingNewLine]{a3, a4, \ 0, \ 0, a1, 
            a2} . {s1\ , s2\ , b3, b4, b5, b6}, \[IndentingNewLine]{a2, a3, 
            a4, \ 0, \ 0, a1} . {s1\ , s2\ , s1\ , b4, b5, 
            b6}\[IndentingNewLine]};\)\), "\n", 
    \(% === ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {\(-1\), 1}, {s1, s2}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "It's curious that providing an empty list as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument is equivalent to providing the integer 1 as a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}, {}] === 
      ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, 
        1]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell shows that by default ",
  "ListCorrelate",
  " uses the second argument in place of a ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument when none is provided."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, 
          b6}, {1, \(-1\)}] === \[IndentingNewLine]ListCorrelate[{a1, a2, a3, 
          a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, {b1, b2, b3, b4, b5, 
          b6}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Generalizing beyond Times, Plus", "Subsection"],

Cell[TextData[{
  "In the next cell we provide ListConvolve (g) as a ",
  Cell[BoxData[
      \(TraditionalForm\`5\^th\)]],
  " argument and it uses the head (g) in place of Times."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, 
      lst, g]\)], "Input"],

Cell[BoxData[
    \({g[a1, b1] + g[a2, b2] + g[a3, b3] + g[a4, b4], 
      g[a1, b2] + g[a2, b3] + g[a3, b4] + g[a4, b5], 
      g[a1, b3] + g[a2, b4] + g[a3, b5] + g[a4, b6]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we provide ",
  "ListCorrelate",
  " (g, h) as a ",
  Cell[BoxData[
      \(TraditionalForm\`5\^th\)]],
  " and ",
  Cell[BoxData[
      \(TraditionalForm\`6\^th\)]],
  " arguments respectively and it uses the heads (g) and (h) in place of \
Times and Plus respectively."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[{a1, a2, a3, a4}, {b1, b2, b3, b4, b5, b6}, {1, \(-1\)}, 
      lst, g, h]\)], "Input"],

Cell[BoxData[
    \({h[g[a1, b1], g[a2, b2], g[a3, b3], g[a4, b4]], 
      h[g[a1, b2], g[a2, b3], g[a3, b4], g[a4, b5]], 
      h[g[a1, b3], g[a2, b4], g[a3, b5], g[a4, b6]]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ListCorrelate with matrices", "Subsection"],

Cell["In the next cell we perform a ListCorrelate on matrices.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{"m1", "=", 
        RowBox[{"(", GridBox[{
              {"a1", "a2", "a3"},
              {"b1", "b2", "b3"},
              {"c1", "c2", "c3"}
              }], ")"}]}], ";"}], "\n", 
    RowBox[{
      RowBox[{"m2", "=", 
        RowBox[{"(", GridBox[{
              {"x1", "x2", "x3"},
              {"y1", "y2", "y3"},
              {"z1", "z2", "z3"}
              }], ")"}]}], ";"}], "\n", \(ListCorrelate[m1, m2]\)}], "Input"],

Cell[BoxData[
    \({{a1\ x1 + a2\ x2 + a3\ x3 + b1\ y1 + b2\ y2 + b3\ y3 + c1\ z1 + 
          c2\ z2 + c3\ z3}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how the same ListCorrelate can be done as Dot products on \
parts of the matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[m1, 
        m2] === {{Part[m1, 1] . Part[m2, 1] + Part[m1, 2] . Part[m2, 2] + 
            Part[m1, 3] . Part[m2, 3]}}\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "We can give ",
  "ListCorrelate",
  " a level specification as a ",
  Cell[BoxData[
      \(TraditionalForm\`7\^th\)]],
  " argument.  The next cell shows that level (2) is the default \
specification when working on matrices. "
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[m1, m2] === \[IndentingNewLine]ListCorrelate[m1, 
        m2, {1, \(-1\)}, m2, Times, Plus, 2]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we give ListCorrelate the integer (1) as a level \
specification.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[m1, m2, {1, \(-1\)}, m2, Times, Plus, 1]\)], "Input"],

Cell[BoxData[
    \({{a1\ x1 + b1\ y1 + c1\ z1, a2\ x2 + b2\ y2 + c2\ z2, 
        a3\ x3 + b3\ y3 + c3\ z3}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how the same ListCorrelate can be done as Dot products on \
parts of the matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mat1 = Transpose[m1];\)\), "\n", 
    \(mat2 = Transpose[m2]; \n\), "\[IndentingNewLine]", 
    \(ListCorrelate[m1, m2, {1, \(-1\)}, m2, Times, Plus, 
        1] === {{Part[mat1, 1] . Part[mat2, 1], 
          Part[mat1, 2] . Part[mat2, 2], 
          Part[mat1, 3] . Part[mat2, 3]}}\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows two ways of expressing the default for the third argument \
of ListCorrelate when working with matrices.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[
    \(ListCorrelate[m1, m2] === ListCorrelate[m1, m2, {1, \(-1\)}] === 
      ListCorrelate[m1, m2, {{1, 1}, {\(-1\), \(-1\)}}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
I am having a hard time seeing a pattern to how a ListConvolution on matrices \
is done in different cases.  I would like to have a complete understanding \
for what the third argument of ListCorrelate does when working with matrices, \
but it's too hard to decipher.  For example I would like to understand the \
result of the examples below.  \
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[BoxData[
    \(ListCorrelate[m1, m2, {1, 1}]\)], "Input"],

Cell[BoxData[
    \(ListCorrelate[m1, m2, {{\(-1\), \(-1\)}, {1, 1}}]\)], "Input"],

Cell[BoxData[
    \(ListCorrelate[m1, m2, {\(-1\), 1}, m2, Times, Plus, 1]\)], "Input"],

Cell["\<\
I also understand we can also perform a ListCorrelate on tensors, but that is \
also too confusing for me to think about.\
\>", "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Map", "Section"],

Cell[TextData[{
  "Map and (f[#]&) can be used to map any function (f) to each argument under \
any Head.  In the next Cell (Exp[_]) mapped to each term in a sum.  Many \
users understand what Map does with the default level specification.  In the \
first example the default level specification is used, and Exp[_] is mapped \
to each expression at the first level.  The #& notation is explained in the \
discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"Map"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\(demo = 
        x + Cos[\(\(\@x\) \[Pi]\)\/3] + Sin[\(\@x\ \[Pi]\)\/6];\)\), "\n", 
    \(Map[\ Exp[#] &, \ demo]\)}], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^x + \[ExponentialE]\^Cos[\(\[Pi]\ \@x\)\/3] + \
\[ExponentialE]\^Sin[\(\[Pi]\ \@x\)\/6]\)], "Output"]
}, Closed]],

Cell["\<\
Note:  The shorthand notation for Map is   /@ .  This shorthand notation is \
used to do the same as the previous line.  At first this notation seems very \
cryptic.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(\(Exp[#] &\) /@ demo\)\)\)], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^x + \[ExponentialE]\^Cos[\(\[Pi]\ \@x\)\/3] + \
\[ExponentialE]\^Sin[\(\[Pi]\ \@x\)\/6]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "If you need to specify a level specification the short hand notation is \
not at all convenient.  Different variations of ",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " are demonstrated in the lines below.  Many other commands allow a user to \
specify the level specification, and the conventions are always the same.  \
Level specification {3} means to only map the function to Level 3.  In the \
next Cell we Map \n(# + 1)& to all subexpressions in (demo) at Level {3}.\n "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[\((# + z)\) &, demo, {3}]\)], "Input"],

Cell[BoxData[
    \(x + Cos[\((1\/3 + z)\)\ \((\[Pi] + z)\)\ \((\@x + z)\)] + 
      Sin[\((1\/6 + z)\)\ \((\[Pi] + z)\)\ \((\@x + z)\)]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Level specification {-1} refers to the smallest subexpressions (the \
atoms).  In the next cell we add (1) to each atom in (demo).  It should be \
pointed out that the list of atoms includes 1/6, 1/3,  and 1/2, instead of 1, \
2, 3, 6.  This is because since ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " rational numbers as atoms.  Complex numbers are also considered atoms.  \n\
   "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[\ \((# + 1)\) &, demo, \ {\(-1\)}]\)], "Input"],

Cell[BoxData[
    \(1 + x + Cos[4\/3\ \((1 + \[Pi])\)\ \((1 + x)\)\^\(3/2\)] + 
      Sin[7\/6\ \((1 + \[Pi])\)\ \((1 + x)\)\^\(3/2\)]\)], "Output"]
}, Closed]],

Cell["\<\
Level specification (2) refers to all levels from (Level 1) to (Level 2).  \
Now we Map ( #/z&) to all subexpressions of (demo) from (Level 1) to (Level \
2).
 \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[#\/z &, demo, 2]\)], "Input"],

Cell[BoxData[
    \(x\/z + Cos[\(\[Pi]\ \@x\)\/\(3\ z\)]\/z + 
      Sin[\(\[Pi]\ \@x\)\/\(6\ z\)]\/z\)], "Output"]
}, Closed]],

Cell["\<\
The next line Maps (#+z&) to all subexpressions of (demo) at (Level 2) and \
(Level 3).
 \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[# + z &, demo, \ {2, 3}]\)], "Input"],

Cell[BoxData[
    \(x + Cos[z + \((1\/3 + z)\)\ \((\[Pi] + z)\)\ \((\@x + z)\)] + 
      Sin[z + \((1\/6 + z)\)\ \((\[Pi] + z)\)\ \((\@x + z)\)]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
Map has a Heads option like several other functions, but it's hard to think \
of a practical use for this feature.  By default Map uses the setting (Heads\
\[Rule]False).  If your writing a program and you need to make it full proof \
you should use the form  Map[f, expr, Heads\[Rule]False]  instead of the \
shorter (and normally equivalent) form  f/@expr.  The reason is that the user \
may have changed the default setting via SetOptions[Map, Heads\[Rule]True] \
which would change the behavior of  f/@expr.  Now consider the next cell to \
see how Map uses the Heads option.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, h];\)\), "\[IndentingNewLine]", 
    \(\(expr = {h[1], {2, 3}};\)\), "\[IndentingNewLine]", 
    \(Map[f, expr, {2}, \ Heads \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \({h[f[1]], {f[2], f[3]}}\)], "Output"]
}, Closed]],

Cell["\<\
In the cell above (f) was mapped to expressions at positions {1,1}, {2,1}, \
and {2,2} since they are all the expressions at level 2.  In the next cell \
the same example is evaluated with the setting (Heads\[Rule]True) and (f) is \
also mapped to every head at level 2. In this case the heads at level 2 are \
(h) at position {1,0} and List at position {2,0}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Map[f, expr, {2}, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \({\(f[h]\)[f[1]], \(f[List]\)[f[2], f[3]]}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["MapAt", "Section"],

Cell["\<\
MapAt allows us to Map a function to specified positions.  The next cell maps \
foo to position 3.\
\>", "Text",
  CellTags->"MapAt"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(MapAt[foo, {a, b, c, d, e, f}, 3]\)}], "Input"],

Cell[BoxData[
    \({a, b, foo[c], d, e, f}\)], "Output"]
}, Closed]],

Cell["The next cell maps foo to positions {2} and {4}.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapAt[foo, {a, b, c, d, e, f}, {{2}, {4}}]\)], "Input"],

Cell[BoxData[
    \({a, foo[b], c, foo[d], e, f}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["MapIndexed", "Section"],

Cell["\<\
It's a little difficult to learn how to use the MapIndexed function.  In the \
next cell I clear values form all variables and give the simplest use of \
MapIndexed.  Notice the results are in the form f[2,{1}],  f[3,{2}],  etc.\
\>", "Text",
  CellTags->"MapIndexed"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(lst = Prime[Range[6]];\)\), "\n", 
    \(MapIndexed[foo, lst] // TableForm\)}], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(foo[2, {1}]\)},
          {\(foo[3, {2}]\)},
          {\(foo[5, {3}]\)},
          {\(foo[7, {4}]\)},
          {\(foo[11, {5}]\)},
          {\(foo[13, {6}]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      TableForm[ {
        foo[ 2, {1}], 
        foo[ 3, {2}], 
        foo[ 5, {3}], 
        foo[ 7, {4}], 
        foo[ 11, {5}], 
        foo[ 13, {6}]}]]], "Output"]
}, Closed]],

Cell[TextData[{
  "Instead of the form above, one might rather have the result of MapIndexed \
in the form \nf[2,1], f[3,2], etc.  In the line above (f) is applied to two \
arguments, and the second argument has the head List.  A result in the form  \
f[2,1], f[3,2]  is obtained in the next line by removing the head list from \
the second argument.  Technically the head was changed to Sequence, then \
Sequence was removed during evaluation.  The #& notation is explained in the \
discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapIndexed[foo[#1, Sequence @@ #2] &, lst] // TableForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(foo[2, 1]\)},
          {\(foo[3, 2]\)},
          {\(foo[5, 3]\)},
          {\(foo[7, 4]\)},
          {\(foo[11, 5]\)},
          {\(foo[13, 6]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      TableForm[ {
        foo[ 2, 1], 
        foo[ 3, 2], 
        foo[ 5, 3], 
        foo[ 7, 4], 
        foo[ 11, 5], 
        foo[ 13, 6]}]]], "Output"]
}, Closed]],

Cell["\<\
Another use of MapIndexed involves mapping two functions as in the line \
below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapIndexed[{foo[#1], goo[#2]} &, lst] // TableForm\)], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {\(foo[2]\), \(goo[{1}]\)},
          {\(foo[3]\), \(goo[{2}]\)},
          {\(foo[5]\), \(goo[{3}]\)},
          {\(foo[7]\), \(goo[{4}]\)},
          {\(foo[11]\), \(goo[{5}]\)},
          {\(foo[13]\), \(goo[{6}]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the next line (g@@#2) is used to ensure we end up with g[1], g[2], .. \
instead of g[{1}], g[{2}], ....\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapIndexed[{foo[#1], goo @@ #2} &, lst] // TableForm\)], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {\(foo[2]\), \(goo[1]\)},
          {\(foo[3]\), \(goo[2]\)},
          {\(foo[5]\), \(goo[3]\)},
          {\(foo[7]\), \(goo[4]\)},
          {\(foo[11]\), \(goo[5]\)},
          {\(foo[13]\), \(goo[6]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[TextData[{
  "By giving MapIndexed a ",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " for only level 2 you can MapIndex to each element of a matrix. "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapIndexed[foo, {{a, b}, {c, d}}, {2}]\)], "Input"],

Cell[BoxData[
    \({{foo[a, {1, 1}], foo[b, {1, 2}]}, {foo[c, {2, 1}], 
        foo[d, {2, 2}]}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapIndexed[{foo[#1], goo[Sequence @@ #2]} &, {{a, b}, {c, 
          d}}, {2}]\)], "Input"],

Cell[BoxData[
    \({{{foo[a], goo[1, 1]}, {foo[b], goo[1, 2]}}, {{foo[c], 
          goo[2, 1]}, {foo[d], goo[2, 2]}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "MapIndexed can take a level specification using the same conventions as \
the examples where level specification is explained.  A ",
  ButtonBox["practical example",
    ButtonData:>"MapIndexedExample",
    ButtonStyle->"Hyperlink"],
  " that uses MapIndexed with a level specification is given in the section \
on Coefficient and CoefficientList."
}], "Text"],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
MapIndexed has a Heads option with the default setting (Heads\[Rule]False).  \
In the next cell we use (Heads\[Rule]True) and the function with an index is \
mapped to the head of {a,b,c}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapIndexed[foo, {a, b, c}, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(\(foo[List, {0}]\)[foo[a, {1}], foo[b, {2}], foo[c, {3}]]\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["MapThread", "Section"],

Cell["\<\
MapThread can be used to Apply a function to each column of a matrix as I do \
in the next cell. However, before using MapThread I clear the values from all \
variables.\
\>", "Text",
  FontFamily->"Times New Roman",
  CellTags->"MapThread"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(mat = {{a, b, c, d, e, f}, {1, 2, 3, 4, 5, 6}};\)\), "\n", 
    \(MapThread[foo, mat]\)}], "Input"],

Cell[BoxData[
    \({foo[a, 1], foo[b, 2], foo[c, 3], foo[d, 4], foo[e, 5], 
      foo[f, 6]}\)], "Output"]
}, Closed]],

Cell["\<\
 MapThread is equivalent to using Map followed by Apply at level 2 (see \
below).  I have to wonder why it isn't called ApplyThread.\
\>", "Text",
  FontFamily->"Times New Roman"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MapThread[foo, mat] === Apply[foo, Thread[mat], 2]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
In the next few lined we use MapThread to work with the tensor below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Off[General::spell1]\), "\n", 
    \(\(tensor = {\n\t\t{{a111, a112, a113, a114}, {a121, a122, a123, 
              a124}}, \n\t\t{{a211, a212, a213, a214}, \n\t\t\t{a221, a222, 
              a223, a224}}, \n\t\t{{a311, a321, a323, a324}, \n\t\t\t{a321, 
              a322, a323, a324}}\n\t};\)\), "\n", 
    \(On[General::spell1]\), "\n", 
    \(Dimensions[tensor]\)}], "Input"],

Cell[BoxData[
    \({3, 2, 4}\)], "Output"]
}, Closed]],

Cell["In the next line MapThread is used on the above tensor.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t1 = MapThread[foo, tensor];\)\), "\n", 
    \(t1[\([1]\)]\)}], "Input"],

Cell[BoxData[
    \(foo[{a111, a112, a113, a114}, {a211, a212, a213, a214}, {a311, a321, 
        a323, a324}]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(t1[\([2]\)]\)], "Input"],

Cell[BoxData[
    \(foo[{a121, a122, a123, a124}, {a221, a222, a223, a224}, {a321, a322, 
        a323, a324}]\)], "Output"]
}, Closed]],

Cell["\<\
MapThread can work on the tensor above with a third argument as in the next \
example, and gives a very different result than the previous example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t2 = MapThread[foo, tensor, 2];\)\), "\n", 
    \(t2[\([1]\)]\)}], "Input"],

Cell[BoxData[
    \({foo[a111, a211, a311], foo[a112, a212, a321], foo[a113, a213, a323], 
      foo[a114, a214, a324]}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(t2[\([2]\)]\)], "Input"],

Cell[BoxData[
    \({foo[a121, a221, a321], foo[a122, a222, a322], foo[a123, a223, a323], 
      foo[a124, a224, a324]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "An interesting application of MapThread is given below where MapThread is \
used to apply a list of functions to a list of arguments.  The #& notation is \
explained in the discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  ".\n "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(funcs = {f1, \ f2, \ f3};\)\), "\n", 
    \(\(values = {val1, val2, val3};\)\), "\n", 
    \(MapThread[\((#1[#2])\) &, \ {funcs, values}]\)}], "Input"],

Cell[BoxData[
    \({f1[val1], f2[val2], f3[val3]}\)], "Output"]
}, Closed]],

Cell["\<\
Alan Hayes provided the code below to make a list of replacement rules.\
\>", "Text",
  FontFamily->"Times New Roman"],

Cell[CellGroupData[{

Cell[BoxData[
    \(pos = Array[p, {4, 3}]\)], "Input"],

Cell[BoxData[
    \({{p[1, 1], p[1, 2], p[1, 3]}, {p[2, 1], p[2, 2], p[2, 3]}, {p[3, 1], 
        p[3, 2], p[3, 3]}, {p[4, 1], p[4, 2], p[4, 3]}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(posval = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {11, 12, 13}};\)\), "\n", 
    \(Flatten[MapThread[Rule, {pos, posval}, 2]]\)}], "Input"],

Cell[BoxData[
    \({p[1, 1] \[Rule] 1, p[1, 2] \[Rule] 2, p[1, 3] \[Rule] 3, 
      p[2, 1] \[Rule] 4, p[2, 2] \[Rule] 5, p[2, 3] \[Rule] 6, 
      p[3, 1] \[Rule] 7, p[3, 2] \[Rule] 8, p[3, 3] \[Rule] 9, 
      p[4, 1] \[Rule] 11, p[4, 2] \[Rule] 12, p[4, 3] \[Rule] 13}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["MakeBoxes", "Section"],

Cell[TextData[{
  "The code below will ensure any difference of two terms is displayed as a \
difference when you use any form that outputs 2D expressions (StandardForm, \
MatrixForm, TableForm, etc.).   TraditionalForm displays ",
  StyleBox["(b-a)", "InlineInput"],
  " even if you don't make a special definition, it also has many other \
conventions that come with it."
}], "Text",
  CellTags->"MakeBoxes"],

Cell["\<\
The kernel automatically calls MakeBoxes when it needs to format an \
expression using 2D notation.  The rules for MakeBoxes specify that how \
expressions with a certain form are should be displayed one way, and other \
forms should be displayed different ways.  Typically a definition  says a \
certain box structure should be built using parts of the given expression.  \
The various parts that are used in the box structure are often smaller \
expressions that also need to be made into 2D expressions, so MakeBoxes must \
be called on these smaller expressions.  This continues recursively until \
MakeBoxes formats atoms directly into box structures.

When the kernel calls MakeBoxes it passes the form used in the second \
argument. The form can be StandardForm, TraditionalForm, MatrixForm, or any \
other form that formats the output as 2D expressions.  A rule for MakeBoxes \
can have a specific form for the second argument as in MakeBoxes[pattn, \
StandardForm] in which case the definition is only used for StandardForm.  \
You can even define your own for using MakeBoxes[pattn, MyForm], and the \
provided formatting rules will be used when you evaluate expr//MyForm.  In \
the definition below the second argument of MakeBoxes is the pattern (form_). \
 In this case the formatting rule is used for any form that uses 2D \
expressions to format the output.

MakeBoxes has the HoldAllComplete attribute.  As a result you can't use \
MakeBoxes[Evaluate[expr], form] to force the evaluation of (expr).  If (expr) \
must complete evaluation that can be accomplished using 
( MakeBoxes@@{expr,form} ).\
\>", "Text"],

Cell[BoxData[
    \(\(MakeBoxes[\((n_Real | n_Integer | n_Rational)\) a_.  + b_ /; \n
            Head[b] =!= Plus && n < 0, form_] := \n
        RowBox[{MakeBoxes[b, form], "\<-\>", 
            MakeBoxes @@ {\(-n\)\ \ a, form}}];\)\)], "Input"],

Cell["\<\
The above rules for MakeBoxes will produce a more readable display of \
expressions such as the following:\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, y];\)\), "\[IndentingNewLine]", 
    \(Log[y - 2/3]/Sqrt[y - 4\ a] - Exp[y - 2.4]\)}], "Input"],

Cell[BoxData[
    \(Log[y - 2\/3]\/\@\(y - 4\ a\) - \[ExponentialE]\^\(y - 2.4`\)\)], \
"Output"]
}, Closed]],

Cell["The rules for MakeBoxes are stored as FormatValues.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FormatValues[MakeBoxes]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[
          MakeBoxes[\((n_Real | n_Integer | n_Rational)\)\ a_.  + b_ /; 
              Head[b] =!= Plus && n < 0, form_]] \[RuleDelayed] 
        RowBox[{MakeBoxes[b, form], "-", 
            MakeBoxes @@ {\(-n\)\ a, form}}]}\)], "Output"]
}, Closed]],

Cell["\<\
It may be tempting to write a slightly simpler implementation, but this \
simpler implementation has flaws.\
\>", "Text"],

Cell["\<\
The simpler implementation is:
    MakeBoxes[(n_Real|n_Integer|n_Rational)a_.+b_/;
    Head[b]=!=Plus&&n<0,form_]:=
    RowBox[{MakeBoxes[b,form],MakeBoxes@@{n*a,form}}];

In private email Neil Soiffer of Wolfram Research noted that the version \
above has a few problems.
(1) The '-' sign is grouped with the subsequent term as a unary \"minus\", \
instead of binary \"difference\".
This will effect spacing after the minus (not symmetric with respect to '-' \
as is easily seen with 'a-b').
(2) Grouping doesn't work well.  If one evaluates (a-b) and triple clicks on \
the '-' in the output, automatic grouping doesn't work right.
(3)  Perhaps the worst problem is that because '-' is interpreted as a unary \
minus, there is implied multiplication between the 'a' and the '-b' and so it \
will evaluate incorrectly.  Evaluate (a-b) and select the output cell, go to
cell | cell properties | cell evaluatable to make the output cell \
evaluatable, and then evaluate the cell.  The result looks like '-a b'.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Another example", "Subsection"],

Cell["\<\
David park noted that the minus sign gets pulled into the sum in the next \
input.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\((\(-1\)\/2)\) \((a + 2.3*b + c)\)\)], "Input"],

Cell[BoxData[
    \(1\/2\ \((\(-a\) - 2.3`\ b - c)\)\)], "Output"]
}, Closed]],

Cell["\<\
By looking at the box structure of the output cell above you can see what we \
need to use in a MakeBoxes definition.  The input in the next cell does the \
job.  The first definition ensures the negative sign is factored out, and the \
second definition puts the negative sign in the numerator.\
\>", "Text"],

Cell[BoxData[{
    \(MakeBoxes[a_*\(b : Plus[_?Negative*_, \((_?Negative*_)\) .. ]\), 
        form : \((StandardForm | TraditionalForm)\)] := 
      RowBox[{MakeBoxes @@ {\(-a\), form}, 
          RowBox[{"\<(\>", 
              MakeBoxes @@ {\(-b\), 
                  form}, "\<)\>"}]}]\n\), "\[IndentingNewLine]", 
    \(MakeBoxes[p_Rational?Negative, 
        form : \((StandardForm | TraditionalForm)\)] := 
      FractionBox[MakeBoxes @@ {Numerator[p], form}, 
        MakeBoxes @@ {Denominator[p], form}]\)}], "Input"],

Cell["Now the negative sign is always factored out.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({\(-\((1\/2)\)\) \((a + 2.3*b + c)\), \(1\/2\) \((\(-a\) - 2.3*b - 
            c)\)}\)], "Input"],

Cell[BoxData[
    \({\(\(-1\)\/2\) \((a + 2.3`\ b + c)\), \(\(-1\)\/2\) \((a + 2.3`\ b + 
            c)\)}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["MatchQ", "Section"],

Cell["\<\
In order for a pattern to match an expression, the pattern and the expression \
it is compared with must have the same FullForm after evaluation.  For \
example the expression a/b has the FullForm Times[a,Power[b,-1]], so it \
doesn't match the pattern (_Rational).  MatchQ is a very good tool to use \
when testing a pattern to see if it matches the intended expressions.  Some \
interesting examples of MatchQ are given below.\
\>", "Text",
  CellTags->"MatchQ"],

Cell[CellGroupData[{

Cell[BoxData[
    \({MatchQ[3/2, p_/q_], MatchQ[3/2, _Rational]}\)], "Input",
  CellTags->"MatchQ"],

Cell[BoxData[
    \({False, True}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The head ",
  ButtonBox["HoldPattern",
    ButtonData:>"HoldPattern",
    ButtonStyle->"Hyperlink"],
  " used in next cell is explained in another section."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, b];\)\), "\n", 
    \({MatchQ[a/b, _Rational], \nMatchQ[a/b, _/_], \n
      MatchQ[a/b, HoldPattern[_/_]], \nMatchQ[a/b, p_/q_]}\)}], "Input"],

Cell[BoxData[
    \({False, False, True, True}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({MatchQ[a/2, p_/q_], \n\tMatchQ[a/2, _Rational], \n\t
      MatchQ[a/2, _*_Rational]}\)], "Input"],

Cell[BoxData[
    \({False, False, True}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({MatchQ[1/Sqrt[b], _/Sqrt[_]], 
      MatchQ[1/Sqrt[b], HoldPattern[_/Sqrt[_]]], \n\t
      MatchQ[1/Sqrt[b], 1/Sqrt[_]]}\)], "Input"],

Cell[BoxData[
    \({False, False, True}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({MatchQ[a/Sqrt[b], _/Sqrt[_]], \n
      MatchQ[a/Sqrt[b], HoldPattern[_/Sqrt[_]]], \n
      MatchQ[a/Sqrt[b], HoldPattern[x_\ *y_^\((\(-1\)/2)\)]], \n
      MatchQ[a/Sqrt[b], HoldPattern[x_/Sqrt[y_]]], \n
      MatchQ[a/Sqrt[b], x_\ *y_^\((\(-1\)/2)\)], \n
      MatchQ[a/Sqrt[b], x_/Sqrt[y_]]}\)], "Input"],

Cell[BoxData[
    \({False, False, False, False, True, True}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({MatchQ[2 + 3  I, a_ + b_*I], MatchQ[2 + 3  I, _Complex]}\)], "Input"],

Cell[BoxData[
    \({False, True}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({MatchQ[a + b\ I, _Complex], \nMatchQ[a + b\ I, _ + _Complex], \n
      MatchQ[a + b\ I, _ + _*I], \nMatchQ[a + b\ I, \ _ + _*Complex[0, 1]], \n
      MatchQ[a + b\ I, HoldPattern[_ + _*I]], \n
      MatchQ[a + b\ I, HoldPattern[_ + _*Complex[0, 1]]], \n
      MatchQ[a + b\ I, _ + _\ *_Complex\ ], \n
      MatchQ[a + b\ I, \ x_ + y_*I]}\)], "Input"],

Cell[BoxData[
    \({False, False, False, False, False, True, True, True}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(data = {{2, 3}, {1, 4}, {6, 7}, {8, 6}, {2, 1}};\)\), "\n", 
    \(MatchQ[data, {{_, _} .. }]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used with MatchQ.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["MemberQ", "Section"],

Cell["\<\
The first example is simple. MemberQ finds that the sum includes (x) to an \
Integer power.\
\>", "Text",
  CellTags->"MemberQ"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, y];\)\), "\[IndentingNewLine]", 
    \(MemberQ[1 + x + x\^2, Power[x, _Integer]]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
You might wonder why MemberQ doesn't return True in this case.  The reason is \
that the default level specification doesn't have MemberQ check the whole \
expression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MemberQ[x\^2, Power[x, _Integer]]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Next MemberQ is given a ",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " that has it check all levels including the whole expression, and True is \
returned."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MemberQ[x\^2, Power[x, _Integer], {0, \(-1\)}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Next the default level specification stops MemberQ from looking deep \
enough to find the ",
  Cell[BoxData[
      \(TraditionalForm\`x\^2\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MemberQ[{1 + x + x\^2, y}, Power[x, _Integer]]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next example MemberQ is given a level specification deep enough to \
find the ",
  Cell[BoxData[
      \(TraditionalForm\`x\^2\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MemberQ[{1 + x + x\^2, y}, Power[x, _Integer], {0, \(-1\)}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used with MemberQ.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
MemberQ has a Heads option with the default setting (Heads\[Rule]False).  So \
in the next example MemberQ doesn't check the heads of subexpressions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MemberQ[1 + x + x\^2, Plus]\)], "Input"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]],

Cell["\<\
In the next example the setting (Heads\[Rule]True) is used and MemberQ does \
check the heads of subexpressions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(MemberQ[1 + x + x\^2, Plus, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Message", "Section"],

Cell[TextData[{
  "In addition to what I present here you might also want to study \
(PackageDesignTutorial.nb) posted at \n",
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/184",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/184"], None},
    ButtonStyle->"Hyperlink"],
  "\nIn that notebook you will find a section on error handling where good \
use of messages is covered.  A non-trivial application of messages is given \
below, but first I define a function in the next cell that computes the \
magnitude of a vector is defined and the function is used to find the \
magnitude of the vector {2, 3, 4}. "
}], "Text",
  CellTags->"Message"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Mag[v_?VectorQ] := \@Plus @@ \((v . v)\)\), "\n", 
    \(Mag[{2, 3, 4}]\)}], "Input"],

Cell[BoxData[
    \(\@29\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell demonstrates that when ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " is given invalid input it normally posts a message and returns the \
expression that is undefined."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sin[\[Pi]/2, \ 0]\)], "Input"],

Cell[BoxData[
    \(Sin[\[Pi]\/2, 0]\)], "Output"]
}, Closed]],

Cell["\<\
We would like our Mag function to behave like a built in function when given \
an invalid argument.  The next cell defines a message for this purpose.\
\>", "Text"],

Cell[BoxData[
    \(\(Mag::vect = "\<Mag is only defined for vectors.  The expression `1` \
is not a vector.\>";\)\)], "Input"],

Cell["\<\
We could use the definition  Mag[expr_]:=Message[mag::vect,expr].  That would \
cause Mag[expr] with an invalid argument to evaluate to a message and the \
input expression would not be returned.  But we want Mag to work like a \
built-in function so we have it post a message, and return expression passed \
to Mag.  This can be done by putting the message in a condition as in the \
next line.  When this is done the condition will never evaluate to True, so \
the right side of the definition can be almost anything.\
\>", "Text"],

Cell[BoxData[
    \(Mag[expr_] /; 
        Message[Mag::vect, expr] := "\<Never get here.\>"\)], "Input"],

Cell[TextData[{
  "Now when Mag is given an argument that isn't a vector it prints a message \
and returns the input expression since no definition matched.  Here the \
argument given to Mag was  ",
  Cell[BoxData[
      \(TraditionalForm\`{{1, 96\/4 - 5}, {2, 3}}\)]],
  " which evaluated to {{1,19},{2,3}}.  None of the Mag definitions apply, so \
 ",
  Cell[BoxData[
      \(TraditionalForm\`Mag[{{1, 19}, {2, 3}}]\)]],
  "  is returned."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Mag[{{1, 96\/4 - 5}, {2, 3}}]\)], "Input"],

Cell[BoxData[
    \(Mag[{{1, 19}, {2, 3}}]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Mathematica has an undocumented function called ArgumentCountQ which can \
be useful when making definitions for functions that post a message when the \
function is given an incorrect number of arguments. An explanation of this \
feature can be found by looking up ArgumentCountQ at  ",
  ButtonBox["http://support.wolfram.com/Kernel/Symbols/",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[CellGroupData[{

Cell["Checking for non-options", "Subsection"],

Cell["\<\
We can also account for the possibility that one or more of several arguments \
are not options when only options are allowed in these positions.  This is \
what I do with Func defined below.  At the begining of the next cell I clear \
values assigned to all global variables.\
\>", "Text"],

Cell[BoxData[{
    \(\(\(ClearAll["\<Global`*\>"];\)\(\[IndentingNewLine]\)
    \) (*\ 
      Next\ I\ make\ Func\ do\ something\ when\ the\ arguments\ given\ are\ \
\(\(correct\)\(.\)\)\ *) \), "\[IndentingNewLine]", 
    \(\(Func[expr_, 
          opts___?OptionQ] := {expr};\)\[IndentingNewLine]\[IndentingNewLine] \
(*\ The\ next\ definition\ is\ only\ used\ if\ the\ previous\ definition\ \
didn' t\ \(\(match\)\(.\)\)\ *) \), "\[IndentingNewLine]", 
    \(\(\(Func[\ _, opts__] /; 
          With[{nonOptions = 
                Cases[Flatten[{opts}], _?\((\(! OptionQ[#]\) &)\)]}, \
\[IndentingNewLine]nonOptions =!= {} && 
              If[Length[nonOptions] === 1, \[IndentingNewLine]Message[
                  Func::opt, 
                  StringTake[
                    ToString@
                      nonOptions, {2, \(-2\)}]], \[IndentingNewLine]Message[
                  Func::opts, 
                  StringTake[
                    ToString@
                      nonOptions, {2, \(-2\)}]]\[IndentingNewLine]]\
\[IndentingNewLine]] := "\<Never get here.\>";\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(Func::opt = "\<`1` was was used in Func as an argument beyond the \
first argument. Func only allows options beyond the first argument.\>";\)\(\n\
\)
    \)\), "\n", 
    \(\(Func::opts = "\<Expressions, `1`, were given beyond the first \
argument in Func. Only options are allowed beyond the first \
argument.\>";\)\)}], "Input"],

Cell["\<\
Next we see Func[__] evaluates whether there are options or not.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Func[x + y]\), "\[IndentingNewLine]", 
    \(Func[a + b, opt1 \[Rule] val1, opt2 \[RuleDelayed] val2]\)}], "Input"],

Cell[BoxData[
    \({x + y}\)], "Output"],

Cell[BoxData[
    \({a + b}\)], "Output"]
}, Closed]],

Cell["\<\
When one or more argument beyond the first in Func[__] are not options we get \
messages as below, and the original expression is returned.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Func[a + b, opt1 \[Rule] val1, opt, opt2 \[Rule] val2]\)], "Input"],

Cell[BoxData[
    \(Func[a + b, opt1 \[Rule] val1, opt, opt2 \[Rule] val2]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Func[a + b, opt1 \[Rule] val1, opt, opt2 \[Rule] val2, opt3]\)], "Input"],

Cell[BoxData[
    \(Func[a + b, opt1 \[Rule] val1, opt, opt2 \[Rule] val2, 
      opt3]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["General Messages", "Subsection"],

Cell[TextData[{
  "Lets take another look at Mag defined above.  We could also define a \
message for the case where Mag gets more that one argument.  However, we \
would be wise to note define a special message for when too many arguments \
are given, because ",
  StyleBox["Mathematica ",
    FontSlant->"Italic"],
  " already has a set of generic messages that can be associated with many \
functions.  All the built-in messages are defined in the file (messages.m).  \
In the next cell the message used is  ",
  Cell[BoxData[
      \(TraditionalForm\`Message[Mag::argx, _, _]\)]],
  ", but no message named ",
  Cell[BoxData[
      \(TraditionalForm\`Mag::argx\)]],
  " has been defined.  When the kernel sees there is no message named ",
  Cell[BoxData[
      \(TraditionalForm\`\((Mag::argx)\)\)]],
  ", it looks for one named ",
  Cell[BoxData[
      \(TraditionalForm\`\((General::argx)\)\)]],
  " in  (messages.m) and it finds one.  ",
  StyleBox["Mathematica ",
    FontSlant->"Italic"],
  "then usees the text for ",
  Cell[BoxData[
      \(TraditionalForm\`\((General::argx)\)\)]],
  " but when the message is displayed its labled ",
  Cell[BoxData[
      \(TraditionalForm\`\((Mag::argx)\)\)]],
  ".  This allows commonly used messages to be shared by many functions.  The \
messages ",
  Cell[BoxData[
      \(TraditionalForm\`\((General::tag)\)\)]],
  " are briefly explained in section ",
  ButtonBox["2.8.21",
    ButtonData:>{"2.8.21", "21.8"},
    ButtonStyle->"MainBookLink"],
  " of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book"
}], "Text"],

Cell[BoxData[
    \(Mag[arg1_, others__] /; \n\t\ \ \ Message[Mag::argx, Mag, 
          Length[{arg1, others}]] := "\<Never get here.\>"\)], "Input"],

Cell["\<\
Once the rule above is defined, Mag[__] will post a message and return the \
input when it is given more than one argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Mag[3, 4, 5, 6]\)], "Input"],

Cell[BoxData[
    \(Mag::"argx" \(\(:\)\(\ \)\) 
      "\!\(Mag\) called with \!\(4\) arguments; 1 argument is expected."\)], \
"Message"],

Cell[BoxData[
    \(Mag[3, 4, 5, 6]\)], "Output"]
}, Closed]],

Cell["\<\
I tried to pick out the general messages that might have applications in \
packages users write and they are each used in a generic example below.  You \
will find that related messages are arranged in grouped cells.\
\>", "Text"],

Cell[CellGroupData[{

Cell["Number of arguments", "Subsubsection"],

Cell["\<\
Below we have general messages that report an incorrect number of \
arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argctu, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"argctu" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with 1 argument."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argct, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"argct" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argmu, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"argmu" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with 1 argument; \!\(ARG2\) or more arguments are \
expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argr, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"argr" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with 1 argument; \!\(ARG2\) arguments are expected."\
\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argx, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"argx" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments; 1 argument is \
expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argbu, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"argbu" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with 1 argument; between \!\(ARG2\) and \!\(ARG3\) \
arguments are expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argf, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"argf" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments; \!\(ARG3\) or fewer \
arguments are expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argm, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"argm" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments; \!\(ARG3\) or more \
arguments are expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argrx, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"argrx" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments; \!\(ARG3\) arguments are \
expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argtu, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"argtu" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with 1 argument; \!\(ARG2\) or \!\(ARG3\) arguments \
are expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argb, ARG1, ARG2, ARG3, ARG4]\)], "Input"],

Cell[BoxData[
    \(General::"argb" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments; between \!\(ARG3\) and \!\
\(ARG4\) arguments are expected."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::argt, ARG1, ARG2, ARG3, ARG4]\)], "Input"],

Cell[BoxData[
    \(General::"argt" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) called with \!\(ARG2\) arguments; \!\(ARG3\) or \!\(ARG4\) \
arguments are expected."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Invalid arguments", "Subsubsection"],

Cell["\<\
Below we have general messages that report incorrect type of arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::fnsym, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"fnsym" \(\(:\)\(\ \)\) 
      "First argument in \!\(ARG1\) is not a symbol or a string naming a \
symbol."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::notnorm, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"notnorm" \(\(:\)\(\ \)\) 
      "Argument \!\(ARG1\) must be a nonatomic expression."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::bool, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"bool" \(\(:\)\(\ \)\) 
      "True or False expected at position \!\(ARG2\) in \!\(ARG1\)."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ilsm, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"ilsm" \(\(:\)\(\ \)\) 
      "List of machine-size integers expected at position \!\(ARG2\) in \
\!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ilsmi, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"ilsmi" \(\(:\)\(\ \)\) 
      "Single or non-empty list of machine-size integers expected at position \
\!\(ARG2\) in \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ilsmn, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"ilsmn" \(\(:\)\(\ \)\) 
      "Single or non-empty list of non-negative machine-size integers \
expected at position \!\(ARG2\) of \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ilsmp, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"ilsmp" \(\(:\)\(\ \)\) 
      "Single or non-empty list of positive machine-size integers expected at \
position \!\(ARG2\) of \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::innf, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"innf" \(\(:\)\(\ \)\) 
      "Non-negative integer or Infinity expected at position \!\(ARG2\) in \!\
\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::int, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"int" \(\(:\)\(\ \)\) 
      "Integer expected at position \!\(ARG2\) in \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::intm, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"intm" \(\(:\)\(\ \)\) 
      "Machine-size integer expected at position \!\(ARG2\) in \
\!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::intnm, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"intnm" \(\(:\)\(\ \)\) 
      "Non-negative machine-size integer expected at position \!\(ARG2\) in \
\!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::intnz, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"intnz" \(\(:\)\(\ \)\) 
      "Non-zero integer expected at position \!\(ARG2\) in \!\(ARG1\)."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::intpm, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"intpm" \(\(:\)\(\ \)\) 
      "Positive machine-size integer expected at position \!\(ARG2\) in \
\!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ipnf, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"ipnf" \(\(:\)\(\ \)\) 
      "Positive integer or Infinity expected at position \!\(ARG2\) in \
\!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::list, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"list" \(\(:\)\(\ \)\) 
      "List expected at position \!\(ARG2\) in \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::normal, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"normal" \(\(:\)\(\ \)\) 
      "Nonatomic expression expected at position \!\(ARG1\) in \
\!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::seqs, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"seqs" \(\(:\)\(\ \)\) 
      "Sequence specification (+n, -n, {+n}, {-n}, {m, n}, or {m, n, s}) \
expected at position \!\(ARG2\) in \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::seqso, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"seqso" \(\(:\)\(\ \)\) 
      "Sequence specification (+n, -n, {+n}, {-n}, or {m, n}) expected at \
position \!\(ARG2\) in \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::string, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"string" \(\(:\)\(\ \)\) 
      "String expected at position \!\(ARG1\) in \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::strs, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"strs" \(\(:\)\(\ \)\) 
      "String or non-empty list of strings expected at position \!\(ARG1\) in \
\!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::strse, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"strse" \(\(:\)\(\ \)\) 
      "String or list of strings expected at position \!\(ARG1\) in \
\!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::sym, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"sym" \(\(:\)\(\ \)\) 
      "Argument \!\(ARG1\) at position \!\(ARG2\) is expected to be a \
symbol."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::zval, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"zval" \(\(:\)\(\ \)\) 
      "Non-numerical value \!\(ARG1\) found at position \!\(ARG2\) in first \
argument."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Options", "Subsubsection"],

Cell["\<\
Below we have general messages that report problems with options\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::mult, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"mult" \(\(:\)\(\ \)\) 
      "Value of option Multiplicity -> \!\(ARG1\) is not a positive integer."\
\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::estep, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"estep" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) is not a positive \
integer."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::iopf, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"iopf" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be an integer or \
Infinity."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::iopnf, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"iopnf" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be a non-negative \
integer or Infinity."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::iopnm, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"iopnm" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be a non-negative \
machine-size integer."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ioppf, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"ioppf" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be a positive integer \
or Infinity."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::modgp, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"modgp" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be a Gaussian prime \
number."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::modn, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"modn" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be an integer."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::modp, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"modp" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be a prime number or \
zero."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::npt, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"npt" \(\(:\)\(\ \)\) 
      "Value for option \!\(ARG1\) -> \!\(ARG2\) is expected to be a string."\
\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::opset, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"opset" \(\(:\)\(\ \)\) 
      "Option \!\(ARG1\) is not set in \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::opstl, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"opstl" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be a string or a list \
of strings."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::optrs, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"optrs" \(\(:\)\(\ \)\) 
      "Option specification \!\(ARG1\) in \!\(ARG2\) is not a rule for a \
symbol."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::opttf, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"opttf" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be True or False."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::opttfa, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"opttfa" \(\(:\)\(\ \)\) 
      "Value of option \!\(ARG1\) -> \!\(ARG2\) should be True, False, or \
Automatic."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::optx, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"optx" \(\(:\)\(\ \)\) 
      "Unknown option \!\(ARG1\) in \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::par, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"par" \(\(:\)\(\ \)\) 
      "Inappropriate parameter: \!\(ARG1\) -> \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nonopt, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"nonopt" \(\(:\)\(\ \)\) 
      "Options expected (instead of \!\(ARG1\)) beyond position \!\(ARG2\) in \
\!\(ARG3\). An option must be a rule or a list of rules."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Matrices", "Subsubsection"],

Cell["\<\
Below we have general messages that report problems with matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::inf]\)], "Input"],

Cell[BoxData[
    \(General::"inf" \(\(:\)\(\ \)\) 
      "Input matrix contains an infinite entry."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::mindet]\)], "Input"],

Cell[BoxData[
    \(General::"mindet" \(\(:\)\(\ \)\) 
      "Input matrix contains an indeterminate entry."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::sing, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"sing" \(\(:\)\(\ \)\) 
      "Matrix \!\(ARG1\) is singular."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::luc, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"luc" \(\(:\)\(\ \)\) 
      "Result for \!\(ARG1\) of badly conditioned matrix \!\(ARG2\) may \
contain significant numerical errors."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::matrix, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"matrix" \(\(:\)\(\ \)\) 
      "Argument \!\(ARG1\) at position \!\(ARG2\) is not a rectangular \
matrix."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::matsq, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"matsq" \(\(:\)\(\ \)\) 
      "Argument \!\(ARG1\) at position \!\(ARG2\) is not a square \
matrix."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Iterators", "Subsubsection"],

Cell["\<\
Below we have general messages that report problems with iterators.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::iterb]\)], "Input"],

Cell[BoxData[
    \(General::"iterb" \(\(:\)\(\ \)\) 
      "Iterator `1` does not have appropriate bounds."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::itraw, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"itraw" \(\(:\)\(\ \)\) 
      "Raw object \!\(ARG1\) cannot be used as an iterator."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ittag, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"ittag" \(\(:\)\(\ \)\) 
      "Cannot use \!\(ARG1\) as an iterator, since it contains no assignment \
tag."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::itform, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"itform" \(\(:\)\(\ \)\) 
      "Argument \!\(ARG1\) at position \!\(ARG2\) does not have the correct \
form for an iterator."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Directories, Files, I/O", "Subsubsection"],

Cell["\<\
Below we have general messages that report problems with directories, files, \
or I/O.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::isdir]\)], "Input"],

Cell[BoxData[
    \(General::"isdir" \(\(:\)\(\ \)\) 
      "Cannot open directory for reading."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::filro, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"filro" \(\(:\)\(\ \)\) 
      "Attempt to modify a read-only file during \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::fstr, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"fstr" \(\(:\)\(\ \)\) 
      "File specification \!\(ARG1\) is not a string of one or more \
characters."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ioarg, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"ioarg" \(\(:\)\(\ \)\) 
      "Argument in \!\(ARG1\) is not valid for I/O operation."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ioerr, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"ioerr" \(\(:\)\(\ \)\) 
      "I/O error occurred during \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::longp, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"longp" \(\(:\)\(\ \)\) 
      "Pathname in \!\(ARG1\) is too long."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nfdir, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"nfdir" \(\(:\)\(\ \)\) 
      "Directory not found during \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nffil, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"nffil" \(\(:\)\(\ \)\) 
      "File not found during \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::noopen, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"noopen" \(\(:\)\(\ \)\) 
      "Cannot open \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::openr, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"openr" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is open for input."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::openw, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"openw" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is open for output."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::openx, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"openx" \(\(:\)\(\ \)\) "\!\(ARG1\) is not open."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::aofil, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"aofil" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) already open as \!\(ARG2\)."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Polynomials", "Subsubsection"],

Cell["\<\
Below we have general messages that report problems related to polynomials.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::eival]\)], "Input"],

Cell[BoxData[
    \(General::"eival" \(\(:\)\(\ \)\) 
      "Unable to find all roots of the characteristic polynomial."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::bmod, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"bmod" \(\(:\)\(\ \)\) 
      "Modulus \!\(ARG1\) must be an integer or an irreducible univariate \
polynomial."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::modint, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"modint" \(\(:\)\(\ \)\) 
      "Modulus \!\(ARG1\) must be an integer."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::modm, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"modm" \(\(:\)\(\ \)\) 
      "Modulus \!\(ARG1\) is too large for this implementation."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::npoly, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"npoly" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a polynomial with rational number coefficients."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::npolys, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"npolys" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a list of polynomials with rational number \
coefficients."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::poly, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"poly" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a polynomial."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::polyx, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"polyx" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a polynomial with exact coefficients."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nmod, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"nmod" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not valid modulo \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::npv, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"npv" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a polynomial in \!\(ARG2\) with rational number \
coefficients."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nrpi, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"nrpi" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a logical formula consisting of polynomial equations \
and inequalities in \!\(ARG2\) with real number coefficients."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nrtpi, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"nrtpi" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a logical formula consisting of polynomial equations \
and inequalities in \!\(ARG2\) with rational number coefficients."\)], \
"Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Graphics", "Subsubsection"],

Cell["\<\
Below we have general messages that report problems related to graphics.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::pcolor]\)], "Input"],

Cell[BoxData[
    \(General::"pcolor" \(\(:\)\(\ \)\) 
      "The shading function has produced colors of different types."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::color, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"color" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a valid color or gray-level specification."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::lspec, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"lspec" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a valid color, thickness, or dashing specification."\
\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::colfun, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"colfun" \(\(:\)\(\ \)\) 
      "The ColorFunction \!\(ARG1\) does not produce a valid color or \
gray-level directive when applied to element \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::colfun1, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"colfun1" \(\(:\)\(\ \)\) 
      "The ColorFunction \!\(ARG1\) produces a color incompatible with the \
previous color when applied to element \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::gprim, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"gprim" \(\(:\)\(\ \)\) 
      "\!\(ARG2\) was encountered where a \!\(ARG1\) primitive or directive \
was expected."\)], "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Miscellaneous", "Subsubsection"],

Cell["\<\
Below we have general messages that report a variaty of other problems.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(Message[General::bktfn, ARG1, ARG2, ARG3, 
      ARG4]\)\(\ \ \)\)\)], "Input"],

Cell[BoxData[
    \(General::"bktfn" \(\(:\)\(\ \)\) 
      "\"\!\(ARG1\)\" should probably be \"\!\(ARG2\)\".\!\(ARG4\)"\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::cfail]\)], "Input"],

Cell[BoxData[
    \(General::"cfail" \(\(:\)\(\ \)\) 
      "Algorithm failed to converge."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::dbyz]\)], "Input"],

Cell[BoxData[
    \(General::"dbyz" \(\(:\)\(\ \)\) "Division by zero."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::fas]\)], "Input"],

Cell[BoxData[
    \(General::"fas" \(\(:\)\(\ \)\) 
      "Warning: self-contradictory assumptions encountered."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ovfl]\)], "Input"],

Cell[BoxData[
    \(General::"ovfl" \(\(:\)\(\ \)\) 
      "Overflow occurred in computation."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::unpack1]\)], "Input"],

Cell[BoxData[
    \(General::"unpack1" \(\(:\)\(\ \)\) "Unpacking array."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::fmtval, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"fmtval" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a valid format type."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::globn, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"globn" \(\(:\)\(\ \)\) 
      "No matches for \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ifexp, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"ifexp" \(\(:\)\(\ \)\) 
      "The exponent \!\(ARG1\) is not an integer."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ifpa, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"ifpa" \(\(:\)\(\ \)\) 
      "The precision or accuracy \!\(ARG1\) is not representable as a machine \
number."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::indet, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"indet" \(\(:\)\(\ \)\) 
      "Indeterminate expression \!\(ARG1\) encountered."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::ivar, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"ivar" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a valid variable."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::level, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"level" \(\(:\)\(\ \)\) 
      "Level specification \!\(ARG1\) is not of the form n, {n}, or {m, \
n}."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nalg, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"nalg" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not an algebraic number."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::nlist3, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"nlist3" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a list of three numbers."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::notfound, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"notfound" \(\(:\)\(\ \)\) 
      "Symbol \!\(ARG1\) not found."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::notnorm, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"notnorm" \(\(:\)\(\ \)\) 
      "Argument \!\(ARG1\) must be a nonatomic expression."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::notstr, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"notstr" \(\(:\)\(\ \)\) 
      "The format type \!\(ARG1\) is valid only for string input."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::primm, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"primm" \(\(:\)\(\ \)\) 
      "Tried \!\(ARG1\) primes, algorithm failed."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::prims, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"prims" \(\(:\)\(\ \)\) 
      "Prime \!\(ARG1\) is too small, algorithm failed."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::punpack1, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"punpack1" \(\(:\)\(\ \)\) 
      "Unpacking array to level \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::rep, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"rep" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) is not a valid replacement rule."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::stop, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"stop" \(\(:\)\(\ \)\) 
      "Further output of \!\(ARG1\) will be suppressed during this \
calculation."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::unpack, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"unpack" \(\(:\)\(\ \)\) 
      "Unpacking array in call to \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::unuser, ARG1]\)], "Input"],

Cell[BoxData[
    \(General::"unuser" \(\(:\)\(\ \)\) 
      "Unknown user: \!\(ARG1\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::dupv, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"dupv" \(\(:\)\(\ \)\) 
      "Duplicate variable \!\(ARG1\) found in \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::globm, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"globm" \(\(:\)\(\ \)\) 
      "Too many matches for \!\(ARG1\): \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::par, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"par" \(\(:\)\(\ \)\) 
      "Inappropriate parameter: \!\(ARG1\) -> \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::plln, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"plln" \(\(:\)\(\ \)\) 
      "Limiting value \!\(ARG1\) in \!\(ARG2\) is not a machine-size real \
number."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::precw, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"precw" \(\(:\)\(\ \)\) 
      "The precision of the argument function (\!\(ARG1\)) is less than \
WorkingPrecision (\!\(ARG2\))."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::punpack, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"punpack" \(\(:\)\(\ \)\) 
      "Unpacking array to level \!\(ARG2\) in call to \!\(ARG1\)."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::trace, ARG1, ARG2]\)], "Input"],

Cell[BoxData[
    \(General::"trace" \(\(:\)\(\ \)\) 
      "\!\(ARG1\) --> \!\(ARG2\)."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::mbrpos, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"mbrpos" \(\(:\)\(\ \)\) 
      "Position \!\(ARG2\) in \!\(ARG1\) must be one of \!\(ARG3\)."\)], \
"Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::tag, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"tag" \(\(:\)\(\ \)\) 
      "Rule for \!\(ARG1\) of \!\(ARG2\) can only be attached to \!\(ARG3\)."\
\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::bktmch, ARG1, ARG2, ARG3, ARG4]\)], "Input"],

Cell[BoxData[
    \(General::"bktmch" \(\(:\)\(\ \)\) 
      "\"\!\(ARG1\)\" must be followed by \"\!\(ARG2\)\", not \"\!\(ARG3\)\".\
\!\(ARG4\)"\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::heads, ARG1, ARG2, ARG3, ARG4]\)], "Input"],

Cell[BoxData[
    \(General::"heads" \(\(:\)\(\ \)\) 
      "Heads \!\(ARG1\) and \!\(ARG2\) at positions \!\(ARG3\) and \!\(ARG4\) \
are expected to be the same."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Message[General::itflrw, ARG1, ARG2, ARG3]\)], "Input"],

Cell[BoxData[
    \(General::"itflrw" \(\(:\)\(\ \)\) 
      "Warning: In evaluating \!\(ARG1\) to find the number of iterations to \
use for \!\(ARG2\), $MaxExtraPrecision = \!\(ARG3\) was encountered. An upper \
estimate will be used for the number of iterations."\)], "Message"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \( (*\ 
      The\ next\ message\ is\ normally\ turned\ \(\(off\)\(.\)\)\ *) \
\[IndentingNewLine]On[General::newsym]\), "\n", 
    \(Message[General::newsym, ARG1]\), "\n", 
    \(Off[General::newsym]\)}], "Input"],

Cell[BoxData[
    \(General::"newsym" \(\(:\)\(\ \)\) 
      "Symbol \!\(ARG1\) is new."\)], "Message"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["How to tell if a message is On or Off", "Subsection"],

Cell["\<\
The direct answer to this problem is the following:
    If  Head[symbol::tag] === Off
    then  (the message is Off)
    else   (the message is On)\
\>", "Text"],

Cell["\<\
If a message is on and the message is not one of the general messages (which \
are explained in the previous sub-section), then the message has the head \
String.  That is why the next cell returns String.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(On[Show::gtype];\)\), "\[IndentingNewLine]", 
    \(Head[Show::gtype]\)}], "Input"],

Cell[BoxData[
    \(String\)], "Output"]
}, Closed]],

Cell[TextData[{
  "On the other hand if a message is on and the message is one of the general \
messages, then the message has the head MessageName. That is why the next \
cell returns MessageName.  As explained above ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " defines a message (General::argx) that can be used as a message for any \
function, but the message (Show::gtype) is only associated with Show unless \
you make assignments that associate it with other symbols."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(On[Sin::argx];\)\), "\[IndentingNewLine]", 
    \(Head[Sin::argx]\)}], "Input"],

Cell[BoxData[
    \(MessageName\)], "Output"]
}, Closed]],

Cell["\<\
The next cell is typical for what (symbol::tag) evaluates to when the message \
is Off, and the message is not one of the general messages.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Off[Show::gtype];\)\), "\[IndentingNewLine]", 
    \(Show::gtype\)}], "Input"],

Cell[BoxData[
    \($Off["`1` is not a type of graphics."]\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows what (symbol::tag) evaluates to when the message is Off, \
and the message is one of the general messages.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Off[Sin::argx];\)\), "\[IndentingNewLine]", 
    \(Sin::argx\)}], "Input"],

Cell[BoxData[
    \($Off[]\)], "Output"]
}, Closed]],

Cell["The next input turns both messages back on.", "Text"],

Cell[BoxData[
    \(On[Show::gtype, Sin::argx]\)], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["NestList", "Section"],

Cell[TextData[{
  "The documentation for ",
  ButtonBox["NestList",
    ButtonStyle->"RefGuideLink"],
  " is clear, but it isn't immediatly clear when one might want to use \
NestList. I give a usefule example in the next cell which efficiently makes a \
list of the ten smallest prime numbers that are larger than 10^15."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Needs["\<NumberTheory`NumberTheoryFunctions`\>"];\)\), "\n", 
    \(NestList[NextPrime, 10^15, 10] // Rest\)}], "Input"],

Cell[BoxData[
    \({1000000000000037, 1000000000000091, 1000000000000159, 
      1000000000000187, 1000000000000223, 1000000000000241, 1000000000000249, 
      1000000000000259, 1000000000000273, 1000000000000279}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["NHoldAll, NHoldFirst, NHoldRest", "Section"],

Cell["The next cell gives (f) the NHoldRest attribute.", "Text",
  CellTags->"NHoldAll"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(\(Attributes[f] = {NHoldRest};\)\)}], "Input"],

Cell["\<\
Now only the first argument of (f) can be evaluated numerically.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(N[f[\[Pi]\/2, \[Pi]\/3, \[Pi]\/4]]\)], "Input"],

Cell[BoxData[
    \(f[1.5707963267948966`, \[Pi]\/3, \[Pi]\/4]\)], "Output"]
}, Closed]],

Cell["\<\
NHoldAll, NHoldRest and NHoldFirst prevent evaluation even deep inside an \
expression as demonstrated in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(N[{\[Pi] + {f[\[Pi]\/2, \[Pi]\/3, \[Pi]\/4]}}]\)], "Input"],

Cell[BoxData[
    \({{\(\(3.141592653589793`\)\(\[InvisibleSpace]\)\) + 
          f[1.5707963267948966`, \[Pi]\/3, \[Pi]\/4]}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Built-in symbols with attributes NHoldAll, NHoldFirst, NHoldRest\
\>", "Subsection"],

Cell["The next cell makes a list of all built-in symbols.", "Text"],

Cell[BoxData[
    \(\(symbs = 
        Cases[ToExpression /@ Names["\<System`*\>"], _Symbol];\)\)], "Input"],

Cell["\<\
The next cell returns all built-in symbols with the NHoldAll attribute.  If \
you understand what C and Root do it's easy to see why they have the \
attribute NHoldAll.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], NHoldAll] &]\)], "Input"],

Cell[BoxData[
    \({C, Root}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell returns all built-in symbols with the NHoldRest attribute.  If \
these functions didn't have the NHoldRest attribute they wouldn't work \
correctly in certain cases.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], NHoldRest] &]\)], "Input"],

Cell[BoxData[
    \({Drop, Extract, HeldPart, Part, Take}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell returns all built-in symbols with the NHoldFirst attribute.  I \
have no experience with the functions that have the NHoldFirst attribute.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[symbs, MemberQ[Attributes[#], NHoldFirst] &]\)], "Input"],

Cell[BoxData[
    \({EllipticTheta, EllipticThetaPrime, MathieuC, MathieuCharacteristicA, 
      MathieuCharacteristicB, MathieuCPrime, MathieuS, MathieuSPrime, 
      PolyGamma, StieltjesGamma}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["OneIdentity", "Section"],

Cell["\<\
Many users don't understand what the OneIdentiy attribute does.  The cells \
below show how this attribute can effect pattern matching.  OneIdentity can \
have an effect related to the use of optional arguments and another effect on \
functions that also have the Flat attribute.  I was only able to \
understanding many of the subtle ways that OneIdentity works after getting \
Technical Support from Dave Withoff.\
\>", "Text",
  CellTags->"OneIdentity"],

Cell[CellGroupData[{

Cell["OneIdentity and optional arguments", "Subsection"],

Cell["\<\
In the line below we see Default[Power,2] evaluates to (1) and Power has the \
attribute OneIdentity.\
\>", "Text",
  CellTags->"OneIdentity-Default"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? Power\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"x^y gives x to the power y.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Power",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242474880-2863980"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes[Power] = {Listable, NumericFunction, OneIdentity, 
                Protected}\)},
          {" "},
          {GridBox[{
                {\(Power /: Default[Power, 2] := 1\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "Power"],
      Editable->False]], "Print",
  CellTags->"Info3242474880-2863980"]
}, Closed]],

Cell[TextData[{
  "Since Default[Power,2] evaluates to (1), the pattern matcher treats (x) as \
Power[x,1] when matched with the pattern ( Power[x_,n_.] ).  Using  (n_.)  as \
the exponent in power means the exponent is optional, and the Default should \
be used when an exponent is not explicitly present.  This causes the \
definition in the next cell to work on ( integral[x,x] ).  In addition to \
having a value defined for Default[Power,2], the symbol Power has to have the \
OneIdentity attribute or the example in the next cell would not work.  \
Further details of default values are included in the discussion on ",
  ButtonBox["Default",
    ButtonData:>"Default details",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[integral, \ x];\)\), "\n", 
    \(integral[x_^\((n_. )\), 
          x_] /; \((FreeQ[n, x] && 
            n =!= \(-1\))\) := \(\(x^\((n + 1)\)/\((n + 
            1)\)\)\(\ \)\)\), "\n", 
    \({integral[x, x], integral[x^3, x]}\)}], "Input"],

Cell[BoxData[
    \({x\^2\/2, x\^4\/4}\)], "Output"]
}, Closed]],

Cell["\<\
In the next output cell we see the rule for integral[x_^(n_.), x_]  isn't \
used for integral[x,x]  when Power doesn't have the OneIdentity attribute.  \
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Unprotect[Power];\)\), "\n", 
    \(ClearAttributes[Power, OneIdentity]\), "\n", 
    \(ClearAll[integral]\), "\n", 
    \(integral[x_^\((n_. )\), 
          x_] /; \((FreeQ[n, x] && 
            n =!= \(-1\))\) := \(\(x^\((n + 1)\)/\((n + 
            1)\)\)\(\ \ \)\)\), "\n", 
    \({integral[x, x], integral[x^3, x]}\)}], "Input"],

Cell[BoxData[
    \({integral[x, x], x\^4\/4}\)], "Output"]
}, Closed]],

Cell["\<\
To illustrate how Default[expr]  is used, the attribute OneIdentity is \
returned to Power, and  the value of Default[Power,2] is changed.  Then the \
pattern matcher treats integral[x, x] as integral[Power[x, junk], x].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(SetAttributes[Power, \ OneIdentity]\), "\n", 
    \(\(Default[Power, 2] = junk;\)\), "\n", 
    \(\(ClearAll[integral, junk];\)\), "\n", 
    \(integral[x_^\((n_. )\), 
          x_] /; \((FreeQ[n, x] && 
            n =!= \(-1\))\) := \(\(x^\((n + 1)\)/\((n + 
            1)\)\)\(\ \)\)\), "\n", 
    \({integral[x, x], integral[x^3, x]}\)}], "Input"],

Cell[BoxData[
    \({x\^\(1 + junk\)\/\(1 + junk\), x\^4\/4}\)], "Output"]
}, Closed]],

Cell["\<\
Next the value of  Default[Power,2]  is returned to normal, and Power is \
protected again.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Default[Power, 2] = 1;\)\), "\n", 
    \(\(Protect[Power];\)\), "\n", 
    \(?? Power\)}], "Input"],

Cell[BoxData[
    RowBox[{"\<\"x^y gives x to the power y.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Power",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242474882-9613789"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes[Power] = {Listable, NumericFunction, OneIdentity, 
                Protected}\)},
          {" "},
          {GridBox[{
                {\(Power /: Default[Power, 2] = 1\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "Power"],
      Editable->False]], "Print",
  CellTags->"Info3242474882-9613789"]
}, Closed]],

Cell["\<\
There are only three functions in the Mathematica kernel (Version 4.2 or \
earlier) that have built-in values for Default[symb, ___].  The functions are \
Times, Plus, and Power with the default values ( Default[Times]=1,  \
Default[Plus]=0,  Default[Power,2]=1 ).\
\>", "Text"],

Cell[TextData[{
  StyleBox["The cells above demonstrated the way OneIdentity and the value \
assigned to Default[Power,2] affects pattern matching.  A similar \
demonstration is given below on a generic function (f).  In the next cell (f) \
has no attributes.  Here ",
    FontWeight->"Plain"],
  "5 doesn't match the pattern f[a_,b_.] and the rule isn't used."
}], "Text",
  CellTags->"OneIdentity-Default"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f, g]\), "\n", 
    \(\(Default[f] = 0;\)\), "\n", 
    \(5 /. f[a_, b_. ] :> g[a, b]\)}], "Input"],

Cell[BoxData[
    \(5\)], "Output"]
}, Closed]],

Cell["\<\
Next the same thing is done when (f) has the attribute OneIdentity.  The \
OneIdentity attribute permits the pattern matcher to treat 5 as f[5,0].  A \
zero was used as the second argument of (f) because the second argument in \
the pattern is optional and (f) has a default value of zero.  Once 5 is \
treated as f[5,0] the rule can be used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Attributes[f] = {OneIdentity};\)\), "\n", 
    \(\(Default[f] = 0;\)\), "\n", 
    \(5 /. f[a_, b_. ] :> g[a, b]\)}], "Input"],

Cell[BoxData[
    \(g[5, 0]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell Default[f] has no assigned value, but 5 still matches the \
pattern f[a_,b_:t].   Here again the second argument of (f) is optional.  \
Since (f) has the OneIdentity attribute the pattern matcher treats 5 as \
f[5,t] and the rule is applied.  The rule wouldn't be applied if (f) didn't \
have the OneIdentity attribute.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g, t];\)\), "\[IndentingNewLine]", 
    \(\(SetAttributes[f, OneIdentity];\)\), "\[IndentingNewLine]", 
    \(5 /. f[a_, b_:  t] :> g[a, b]\)}], "Input"],

Cell[BoxData[
    \(g[5, t]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["OneIdentity and the Flat attribute", "Subsection"],

Cell[TextData[{
  "OneIdentity also has an effect (independent of optional arguments) for \
symbols that have the attributes ",
  ButtonBox["Flat",
    ButtonData:>"Flat",
    ButtonStyle->"Hyperlink"],
  " and OneIdentity.  Recall the effect the Flat attribute has on pattern \
matching.  In the line below (f) has the Flat attribute and no other \
attributes.  For the given expression (f) has more than two arguments so the \
rule can't be applied as entered.  However the pattern matcher knows (f) is \
Flat, and it treats f[a1,a2,a3,a4] as the equivalent expression \
f[f[a1],f[a2,a3,a4]] in which case the outer (f) has two arguments.  The rule \
can then be applied and we are left with {f[a1],f[a2,a3,a4]}."
}], "Text",
  CellTags->"OneIdentity-Flat"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[a1, a2, a3, a4] /. f[p_, q_] :> {p, q}\)}], "Input"],

Cell[BoxData[
    \({f[a1], f[a2, a3, a4]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example (f) has the attributes Flat and OneIdentity.  The \
OneIdentity attribute prevents the pattern matcher from wrapping (f) around a \
single argument.  As a result the pattern matcher treats f[a1,a2,a3,a4] as \
f[a1,f[a2,a3,a4]] and we are left with {a1,f[a2,a3,a4]} after the rule is \
applied.  Notice how this differs from the previous result.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat, OneIdentity};\)\), "\n", 
    \(f[a1, a2, a3, a4] /. f[p_, q_] :> {p, q}\)}], "Input"],

Cell[BoxData[
    \({a1, f[a2, a3, a4]}\)], "Output"]
}, Closed]],

Cell["\<\
In the last example the rule f[p_,q_]\[RuleDelayed]{p,q} was used with \
ReplaceAll (expr/.rule).  If ReplaceRepeated (expr//.rule) is used the rule \
is applied as many times as possible. You can try it if you like.\
\>", "Text"],

Cell["\<\
In the next output we see Join has the attributes Flat and OneIdentity, and \
the previous demonstration is repeated using Join instead of (f).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? Join\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Join[list1, list2, ... ] concatenates lists together. Join \
can be used on any set of expressions that have the same head.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Join",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242474882-1460760"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(Attributes[Join] = {Flat, OneIdentity, Protected}\)}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "Join"],
      Editable->False]], "Print",
  CellTags->"Info3242474882-1460760"]
}, Closed]],

Cell[TextData[{
  "Since Join has the attributes Flat and OneIdentity the pattern matcher \
treats Join[a1,a2,a3,a4] as Join[a1,Join[a2,a3,a4]], and the rule is used.  \
Here use of ",
  ButtonBox["HoldPattern",
    ButtonData:>"HoldPattern",
    ButtonStyle->"Hyperlink"],
  " is required or Join[a_,b_] would evaluate to Pattern[a,_,b,_] before \
pattern matching is finished."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Join[a1, a2, a3, a4] /. HoldPattern[Join[a_, b_]] :> {a, b}\)], "Input"],

Cell[BoxData[
    \({a1, Join[a2, a3, a4]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell Join doesn't have the OneIdentity attribute, and the pattern \
matcher treats Join[a1,a2,a3,a4] as Join[Join[a1],Join[a2,a3,a4]], and the \
rule is used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAttributes[Join, OneIdentity];\)\), "\[IndentingNewLine]", 
    \(Join[a1, a2, a3, a4] /. HoldPattern[Join[a_, b_]] :> {a, b}\)}], "Input"],

Cell[BoxData[
    \({Join[a1], Join[a2, a3, a4]}\)], "Output"]
}, Closed]],

Cell["\<\
Before continuing we should restore the OneIdentity attribute to Join.\
\>", "Text"],

Cell[BoxData[
    \(SetAttributes[Join, OneIdentity]\)], "Input"],

Cell[TextData[{
  "In the cells below we look at other examples where a function (f) has the \
attributes Flat, OneIdentity. Consider the next cell where (f) still has the \
attributes Flat and OneIdentity.  In this case ",
  Cell[BoxData[
      StyleBox[\(f[a1, a2, a3, a4]\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  " evaluates to ",
  Cell[BoxData[
      StyleBox[\({a1, f[a2, a3, a4]}\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  ", and ",
  Cell[BoxData[
      StyleBox[\(f[a2, a3, a4]\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  " evaluates to ",
  Cell[BoxData[
      StyleBox[\({a2, f[a3, a4]}\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  ".  Then ",
  Cell[BoxData[
      StyleBox[\(f[a3, a4]\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  " evaluates to ",
  Cell[BoxData[
      StyleBox[\({a3, a4}\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  ".  When evaluation is complete we have ",
  Cell[BoxData[
      StyleBox[\({a1, {a2, {a3, a4}}}\),
        FontFamily->"Courier",
        FontWeight->"Bold"]]],
  ".  "
}], "Text",
  GeneratedCell->False],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat, OneIdentity};\)\), "\[IndentingNewLine]", 
    \(f[p_, q_] := {p, q}\), "\n", 
    \(f[a1, a2, a3, a4]\)}], "Input"],

Cell[BoxData[
    \({a1, {a2, {a3, a4}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next input is the same as the last input except (f) does not have the \
OneIdentity attribute.  In this case the pattern matcher treats ",
  Cell[BoxData[
      \(f[a1, a2, a3, a4]\)]],
  " as ",
  Cell[BoxData[
      \(f[f[a1], f[a2, a3, a4]]\)]],
  " which evaluates to ",
  Cell[BoxData[
      \({f[a1], f[a2, a3, a4]}\)]],
  ".  Then the pattern matcher treats ",
  Cell[BoxData[
      \(f[a2, a3, a4]\)]],
  " as ",
  Cell[BoxData[
      \(f[f[a2], f[a3, a4]]\)]],
  " which evaluates to ",
  Cell[BoxData[
      \({f[a1], f[a3, a4]}\)]],
  ".  Then the pattern matcher treats ",
  Cell[BoxData[
      \(f[a3, a4]\)]],
  " as ",
  Cell[BoxData[
      \(f[f[a3], f[a4]]\)]],
  " which evaluates to ",
  Cell[BoxData[
      \({f[a3], f[a4]}\)]],
  ".  When evaluation is complete we have ",
  Cell[BoxData[
      \({f[a1], \ {f[a2], \ {f[a3], f[a4]}}}\)]],
  ". Notice how this differs from the previous result."
}], "Text",
  GeneratedCell->False],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[p_, q_] := {p, q}\), "\n", 
    \(f[a1, a2, a3, a4]\)}], "Input"],

Cell[BoxData[
    \({f[a1], {f[a2], {f[a3], f[a4]}}}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell f[a,b,2,c,d] is treated as f[f[a],f[b,2,c,d]] and other \
variations such as f[f[a,b],f[2,c,d]], but none have two arguments under (f) \
where the first argument has the head Integer.  The pattern matcher is unable \
to find a pattern that matches so the rule is not used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[x_Integer, y_] := {x, y}\), "\n", 
    \(f[a, b, 2, c, d]\)}], "Input"],

Cell[BoxData[
    \(f[a, b, 2, c, d]\)], "Output"]
}, Closed]],

Cell["\<\
Below the very same thing is done except (f) now has the attributes Flat and \
OneIdentity.  In this case the pattern matcher treats f[a,b,2,c,d]  as  \
f[a,b,f[2,f[c,d]]]  in which case f[2,f[c,d]] matches the required pattern.  \
Then f[2,f[c,d]] evaluates to {2,f[c,d]} and f[c,d] doesn't evaluate further \
because the first argument isn't an Integer. We then have f[a,b,{2,f[c,d]}].  \
The outer (f) doesn't evaluate further because the pattern matcher can't make \
it match the required pattern.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat, OneIdentity};\)\), "\n", 
    \(f[x_Integer, y_] := {x, y}\), "\n", 
    \(f[a, b, 2, c, d]\)}], "Input"],

Cell[BoxData[
    \(f[a, b, {2, f[c, d]}]\)], "Output"]
}, Closed]],

Cell["\<\
For the input below the condition was evaluated for different ways of nesting \
layers of (f).  Every possible subexpression matching the pattern was tried \
in the search for a subexpression that matches the pattern f[x_,y_] and makes \
the condition True.  The condition (a print statement) never evaluated to \
True so the rule was not applied.  While searching for a way to make the \
condition True, the expression f[a1, a2, a3, a4] was treated as (in this \
order):
   f[f[a1],f[a2,a3,a4]],
   f[f[a1,a2],f[a3,a4]],
   f[f[a1,a2,a3],f[a4]],
   f[f[f[a1],f[a2,a3]],f[a4]],
   f[f[f[a1,a2],f[a3]],f[a4]],
   f[f[a1],f[f[a2],f[a3,a4]]],
   f[f[f[a1],f[a2]],f[a3,a4]],
   f[f[a1],f[f[a2],f[a3]],f[a4]],
   f[f[a1,a2],f[f[a3],f[a4]]]\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(\(Attributes[f] = {Flat};\)\), "\n", 
    \(f[a1, a2, a3, a4] /. 
      f[x_, y_] :> 
        1 /; Print[HoldForm[x], "\<,  \>", HoldForm[y]]\)}], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a1]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a2, a3, a4]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a1]], ",  ", 
        HoldForm[ 
          f[ a2, a3, a4]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a1, a2]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a3, a4]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a1, a2]], ",  ", 
        HoldForm[ 
          f[ a3, a4]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a1, a2, a3]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a4]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a1, a2, a3]], ",  ", 
        HoldForm[ 
          f[ a4]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a1]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a2, a3]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a1]], ",  ", 
        HoldForm[ 
          f[ a2, a3]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a1, a2]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a3]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a1, a2]], ",  ", 
        HoldForm[ 
          f[ a3]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a2]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a3, a4]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a2]], ",  ", 
        HoldForm[ 
          f[ a3, a4]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a2, a3]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a4]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a2, a3]], ",  ", 
        HoldForm[ 
          f[ a4]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a1]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a2]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a1]], ",  ", 
        HoldForm[ 
          f[ a2]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a2]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a3]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a2]], ",  ", 
        HoldForm[ 
          f[ a3]]],
      Editable->False]], "Print"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{
        TagBox[\(f[a3]\),
          HoldForm], "\[InvisibleSpace]", "\<\",  \"\>", "\[InvisibleSpace]", 
        
        TagBox[\(f[a4]\),
          HoldForm]}],
      SequenceForm[ 
        HoldForm[ 
          f[ a3]], ",  ", 
        HoldForm[ 
          f[ a4]]],
      Editable->False]], "Print"],

Cell[BoxData[
    \(f[a1, a2, a3, a4]\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Optional (x_^n_.), (x_+y_.), (x_*y_.)", "Section"],

Cell["\<\
Optional (_.)  is used to indicate that a default value should be used of a \
value isn't provided.  The feature can only be used with heads that have \
assigned values for either Default[h], Default[h, n], or Default[h, n, i].  \
The only heads that have built-in default values are Plus, Times, Power, and \
they are each demonstrated below.\
\>", "Text",
  CellTags->"Optional"],

Cell[CellGroupData[{

Cell["Example using (x_^n_.)", "Subsection"],

Cell["\<\
In the first example (f) tells us the base and exponent of (s^n).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x_^n_. ] := 
      StringJoin["\<base =\>", ToString[x], "\<,  exponent =\>", 
        ToString[n]]\), "\[IndentingNewLine]", 
    \(f[s^2]\)}], "Input"],

Cell[BoxData[
    \("base =s,  exponent =2"\)], "Output"]
}, Closed]],

Cell["\<\
The next cell (s) matches the pattern (x_^n_.) and the pattern matcher uses \
the default exponent of (1).  The use of (n_.) instead of (n_) indicates that \
the default value should be used if one is not provided explicitly.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[s]\)], "Input"],

Cell[BoxData[
    \("base =s,  exponent =1"\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Example using (x_+y_.)", "Subsection"],

Cell["\<\
In the next example (s) matches the pattern (x_+y_.) and the pattern matcher \
uses the default value of (0) for (y_.) when only a single term is provided.  \
Because Plus has the Flat attribute the pattern matcher recognizez that \
(s1+s2+s3+s4)  is a case of  Plus[s1, Plus[s2,s3,s4] ].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(f[x_ + y_. ] := Add[x, y]\), "\[IndentingNewLine]", 
    \({f[s], f[s1 + s2], f[s1 + s2 + s3 + s4]}\)}], "Input"],

Cell[BoxData[
    \({Add[s, 0], Add[s2, s1], Add[s2 + s3 + s4, s1]}\)], "Output"]
}, Closed]],

Cell["\<\
Next we see that the rule is stored as a definition for  f[ y_. + x_ ]  \
instead of a definition for  f[ x_ + y_. ]  as entered.  I suppose that \
explains why (y) is matched with (s1) in (s1+s2+s3+s4).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3285568764-5243668"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[y_.  + x_] := Add[x, y]\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3285568764-5243668"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Example using (x_*y_.)", "Subsection"],

Cell["\<\
In the next example (s) matches the pattern (x_*y_.) and the pattern matcher \
uses the default value of (1) for (y_.) when only a single factor is \
provided.  Because Times has the Flat attribute the pattern matcher \
recognizez that (s1  s2  s3  s4)  is a case of  Times[s1, Times[s2, s3, s4] \
].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(f[x_*y_. ] := Multiply[x, y]\), "\[IndentingNewLine]", 
    \({f[s], f[s1\ \ s2], f[s1\ \ s2\ \ s3\ \ s4]}\)}], "Input"],

Cell[BoxData[
    \({Multiply[s, 1], Multiply[s2, s1], 
      Multiply[s2\ s3\ s4, s1]}\)], "Output"]
}, Closed]],

Cell["\<\
Next we see that the rule is stored as a definition for  f[ (y_.)  x_ ]  \
instead of a definition for  f[ x_ (y_.) ]  as entered.  I suppose that \
explains why (y) is matched with (s1) in 
(s1  s2  s3  s4).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3285569129-8870368"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[y_. \ x_] := Multiply[x, y]\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3285569129-8870368"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Other applications (rarely used)", "Subsection"],

Cell[TextData[{
  "You can also use arguments like (y_.) as arguments for functions other \
than Power, Plus, Times, but only if you first assign values via Default[f], \
Default[f,i] or Default[f,i,n].  To see examples of this goto the section on \
",
  ButtonBox["Default",
    ButtonData:>"Default details",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(\(Default[f] = z;\)\), "\[IndentingNewLine]", 
    \(f[x_, y_. ] := {x, y}\)}], "Input"],

Cell["\<\
In the next cell the default value (z) is used when (f) is give a single \
argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(f[a, b]\), "\[IndentingNewLine]", 
    \(f[5]\)}], "Input"],

Cell[BoxData[
    \({a, b}\)], "Output"],

Cell[BoxData[
    \({5, z}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Options, OptionQ", "Section"],

Cell[CellGroupData[{

Cell["OptionQ details", "Subsection"],

Cell[TextData[{
  "OptionQ isn't documented in The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book or the Help Browser, but it's helpful when defining a function with \
options.  OptionQ does however have the usage message shown below."
}], "Text",
  CellTags->"Options"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?OptionQ\)\)], "Input"],

Cell[BoxData[
    \("OptionQ[e] returns True if e can be considered an option or list of \
options, and False otherwise."\)], "Print",
  CellTags->"Info3242474884-6448585"]
}, Closed]],

Cell["\<\
In the cells below we see OptionQ is True when it's given a Rule, a \
RuleDelayed or a list of these things. You get an error message if you give \
OptionQ more than one argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \(OptionQ[opt1 \[Rule] True]\), "\n", 
    \(OptionQ[opt2 \[RuleDelayed] var2]\), "\n", 
    \(OptionQ[{opt1 \[Rule] 15, opt2 \[Rule] Automatic, 
        opt3 \[RuleDelayed] False, opt4 \[Rule] All}]\)}], "Input"],

Cell[BoxData[
    \(True\)], "Output"],

Cell[BoxData[
    \(True\)], "Output"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
OptionQ also returns True when it's given nested lists of options.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(OptionQ[{{opt1 \[Rule] 15, {opt2 \[Rule] 10}, 
          opt3 \[RuleDelayed] False, opt4 \[Rule] All}}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
As indicated in the usage message OptionQ returns False when it's given a \
single argument with any other form.  This is seen in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(OptionQ[2]\), "\[IndentingNewLine]", 
    \(OptionQ[h[2]]\), "\[IndentingNewLine]", 
    \(OptionQ[{Opt1 \[Rule] All, 2}]\), "\[IndentingNewLine]", 
    \(OptionQ[{Opt1 \[Rule] All, h[2]}]\), "\[IndentingNewLine]", 
    \(OptionQ[h[Opt1 \[Rule] All]]\)}], "Input"],

Cell[BoxData[
    \(False\)], "Output"],

Cell[BoxData[
    \(False\)], "Output"],

Cell[BoxData[
    \(False\)], "Output"],

Cell[BoxData[
    \(False\)], "Output"],

Cell[BoxData[
    \(False\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Typical use of OptionQ", "Subsection"],

Cell[TextData[{
  "The next cell defines a function that takes options.  This function takes \
one required argument and optional arguments are allowed as long as they all \
pass OptionQ.  The form (opts___?OptionQ) is perhaps the most frequent use of \
",
  ButtonBox["BlankNullSequence",
    ButtonData:>"Blank",
    ButtonStyle->"Hyperlink"],
  " ( ___  ie. \"Tripple Blank\").  Notice this allows for a single option, a \
sequence of options, or no options."
}], "Text"],

Cell[BoxData[
    \(foo[expr_, opts___?OptionQ] := {expr, h @@ Flatten[{opts}]}\)], "Input"],

Cell["\<\
Each usage of foo in the next cell matches the definition of foo above.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(foo[x + y]\), "\[IndentingNewLine]", 
    \(foo[x + y, opt1 \[Rule] 15, opt2 \[Rule] Automatic, 
      opt3 \[Rule] False]\), "\[IndentingNewLine]", 
    \(foo[
      x + y, {opt1 \[Rule] 15, opt2 \[Rule] Automatic, 
        opt3 \[Rule] False}]\), "\[IndentingNewLine]", 
    \(foo[x + y, {opt1 \[Rule] 15, {opt2 \[Rule] Automatic}}, 
      opt3 \[Rule] False]\)}], "Input"],

Cell[BoxData[
    \({x + y, h[]}\)], "Output"],

Cell[BoxData[
    \({x + y, 
      h[opt1 \[Rule] 15, opt2 \[Rule] Automatic, 
        opt3 \[Rule] False]}\)], "Output"],

Cell[BoxData[
    \({x + y, 
      h[opt1 \[Rule] 15, opt2 \[Rule] Automatic, 
        opt3 \[Rule] False]}\)], "Output"],

Cell[BoxData[
    \({x + y, 
      h[opt1 \[Rule] 15, opt2 \[Rule] Automatic, 
        opt3 \[Rule] False]}\)], "Output"]
}, Closed]],

Cell["\<\
The definition of foo doesn't apply to the next example because 6  isn't an \
option.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(foo[x + y, opt1 \[Rule] True, 6, opt2 \[Rule] False]\)], "Input"],

Cell[BoxData[
    \(foo[x + y, opt1 \[Rule] True, 6, opt2 \[Rule] False]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Getting the setting of Options", "Subsection"],

Cell[TextData[{
  "Section  ",
  ButtonBox["2.3.10",
    ButtonData:>{"2.3.10", "10.8"},
    ButtonStyle->"MainBookLink"],
  " of The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book suggests using the form \n   ",
  StyleBox[" name/.{opts}/.Options[f]", "InlineInput"],
  "\nto get the setting of an option.  This technique is used below to get \
the PlotStyle and Axes settings for a function. \n"
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[PlotFunction, x];\)\), "\n", 
    \(\(\(Options[PlotFunction] = {PlotStyle \[Rule] GrayLevel[0], 
          ImageSize \[Rule] Automatic};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(PlotFunction[expr_, opts___?OptionQ] := 
      Module[{style, 
          size}, \[IndentingNewLine]{style, 
            size} = \({PlotStyle, ImageSize} /. {opts}\) /. 
            Options[PlotFunction]; \[IndentingNewLine]MakeGraphic[
          expr, "\<PlotStyle=\>" <> ToString[style], "\<ImageSize=\>" <> 
            ToString[size]]\[IndentingNewLine]]\)}], "Input"],

Cell["\<\
In the next cell PlotFunction performs as expected when given no options, one \
option, or two options.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(PlotFunction[x^2]\), "\n", 
    \(PlotFunction[x^2, PlotStyle \[Rule] Thickness[0.03]]\), "\n", 
    \(PlotFunction[x^2, PlotStyle \[Rule] Thickness[0.03], 
      ImageSize \[RuleDelayed] {xx, yy}]\)}], "Input"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=GrayLevel[0]", 
      "ImageSize=Automatic"]\)], "Output"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=Thickness[0.03]", 
      "ImageSize=Automatic"]\)], "Output"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=Thickness[0.03]", 
      "ImageSize={xx, yy}"]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell Plot alows us to provide a list of options rather than a \
sequence of options.  For consistency we would like our PlotFunction to allow \
us to give a list of options as well.\
\>", "Text"],

Cell[BoxData[
    \(\(Plot[
        Sin[x], {x, 0, 12}, {PlotStyle \[Rule] Thickness[0.03], 
          ImageSize \[Rule] {400, 250}}];\)\)], "Input"],

Cell["\<\
Unfortunately our PlotFunction defined above has a problem when a list of \
option is given in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(PlotFunction[
      x^2, {PlotStyle \[Rule] Thickness[0.03], 
        ImageSize \[Rule] {400, 250}}]\)], "Input"],

Cell[BoxData[
    \(Set::"shape" \(\(:\)\(\ \)\) 
      "Lists \!\({style$38, size$38}\) and \!\({\({\(\(Thickness[0.03`]\)\), \
\(\({400, 250}\)\)}\)}\) are not the same shape."\)], "Message"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=style$38", 
      "ImageSize=size$38"]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The way to avoid the problem in the last exaple is to use a different \
method for getting the option settings.  Instead the following form should \
normally be used to get option settings.\n\t",
  StyleBox["{var1,var2,var3}={opt1,opt2,opt3}/.Flatten[{opts,Options[f]}]", 
    "InlineInput"],
  "\nThis more robust method is used in the next cell."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[PlotFunction];\)\), "\n", 
    \(\(Options[PlotFunction] = {PlotStyle \[Rule] GrayLevel[0], 
          ImageSize \[Rule] Automatic, Ticks -> Automatic, 
          Axes -> True};\)\[IndentingNewLine]\), "\[IndentingNewLine]", 
    \(PlotFunction[expr_, opts___?OptionQ] := 
      Module[{style, 
          size}, \[IndentingNewLine]{style, size} = {PlotStyle, ImageSize} /. 
            Flatten[{opts, 
                Options[PlotFunction]}]; \[IndentingNewLine]MakeGraphic[
          expr, "\<PlotStyle=\>" <> ToString[style], "\<ImageSize=\>" <> 
            ToString[size]]\[IndentingNewLine]]\)}], "Input"],

Cell["\<\
The next cell demonstrates that the new version of PlotFunction can take any \
way of expressing options that passes the OptionQ test.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(PlotFunction[x^2]\), "\n", 
    \(PlotFunction[x^2, PlotStyle \[Rule] Thickness[0.03]]\), "\n", 
    \(PlotFunction[x^2, PlotStyle \[Rule] Thickness[0.03], 
      ImageSize \[RuleDelayed] {xx, yy}]\), "\[IndentingNewLine]", 
    \(PlotFunction[
      x^2, {PlotStyle \[Rule] Thickness[0.03], 
        ImageSize \[Rule] {400, 250}}]\), "\[IndentingNewLine]", 
    \(PlotFunction[
      x^2, \ {PlotStyle \[Rule] GrayLevel[0], {{ImageSize \[Rule] Automatic}, 
          Ticks -> Automatic}, Axes -> True}]\)}], "Input"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=GrayLevel[0]", 
      "ImageSize=Automatic"]\)], "Output"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=Thickness[0.03]", 
      "ImageSize=Automatic"]\)], "Output"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=Thickness[0.03]", 
      "ImageSize={xx, yy}"]\)], "Output"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=Thickness[0.03]", 
      "ImageSize={400, 250}"]\)], "Output"],

Cell[BoxData[
    \(MakeGraphic[x\^2, "PlotStyle=GrayLevel[0]", 
      "ImageSize=Automatic"]\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Ordering", "Section"],

Cell["The Ordering usage message is shown below.", "Text",
  CellTags->"Ordering"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Ordering\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Ordering[list] gives the position at which each element of \
list appears in Sort[list]. Ordering[list, n] gives the positions of the \
first n elements of Sort[list]. Ordering[list, -n] gives the positions of the \
last n elements of Sort[list]. Ordering[list, n, p] uses Sort[list, p].\"\>", 
      " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Ordering",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3276836798-2710999"]
}, Closed]],

Cell["The next cell gives us the ordering of a list.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst = {\(-2\), 4, \(-5\), Sin[2], 4, \[Pi], \(-\[Infinity]\), 
          4, \[Infinity]};\)\), "\[IndentingNewLine]", 
    \(ord = Ordering[lst]\)}], "Input"],

Cell[BoxData[
    \({3, 1, 2, 5, 8, 6, 7, 9, 4}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how we can take the results of Ordering and get a sorted \
list.  When Ordering is given one or two arguments we get the ordering of a \
cononical sort which may not be the ordering of a numerically sorted list.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Part[lst, ord]\), "\[IndentingNewLine]", 
    \(Sort[lst]\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{\(-5\), ",", \(-2\), ",", "4", ",", "4", ",", "4", ",", "\[Pi]",
         ",", 
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]], ",", \(Sin[2]\)}], "}"}]], "Output"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{\(-5\), ",", \(-2\), ",", "4", ",", "4", ",", "4", ",", "\[Pi]",
         ",", 
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]], ",", \(Sin[2]\)}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
Ordering[lst,4]  gives the first four elements of Ordering[lst].  The second \
argument of Ordering can be (All) or an Integer meeting the condition \
(-Length[list] \[LessEqual] n \[LessEqual] Length[list]).  A few cells after \
this example we use All as a a second argument for Ordering.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Ordering[lst, 4]\)], "Input"],

Cell[BoxData[
    \({3, 1, 2, 5}\)], "Output"]
}, Closed]],

Cell["The next cell gives the last four elements of Ordering[lst].", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Ordering[lst, \(-4\)]\)], "Input"],

Cell[BoxData[
    \({6, 7, 9, 4}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell gives the ",
  Cell[BoxData[
      \(TraditionalForm\`2\^nd\)]],
  " through the ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " elements of  Ordering[lst]. "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Ordering[lst, {2, 4}]\)], "Input"],

Cell[BoxData[
    \({1, 2, 5}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The output of the next cell returns with the ",
  Cell[BoxData[
      \(TraditionalForm\`3\^rd\)]],
  " element of Ordering[lst], and ends with the ",
  Cell[BoxData[
      \(TraditionalForm\`2\^nd\)]],
  " from the last element of Ordering[lst]."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Ordering[lst, {3, \(-2\)}]\)], "Input"],

Cell[BoxData[
    \({2, 5, 8, 6, 7, 9}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell returns every other element of Ordering[lst] starting with the \
first element of (lst) and ending with the last element of (lst).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Ordering[lst, {1, \(-1\), 2}]\)], "Input"],

Cell[BoxData[
    \({3, 2, 8, 7, 4}\)], "Output"]
}, Closed]],

Cell["\<\
As mentioned above Ordering normally gives the ordering of a cononical sort.  \
We can give Ordering a third argument to get the Ordering of another type of \
sort.  In the next cell we get the ordering of a numeric sort.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ord2 = Ordering[lst, All, Less]\)], "Input"],

Cell[BoxData[
    \({7, 3, 1, 4, 6, 8, 5, 2, 9}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how we can take the results of the last Ordering and get \
a numerically sorted list.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Part[lst, ord2]\), "\[IndentingNewLine]", 
    \(Sort[lst, Less]\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", \(-5\), ",", \(-2\), ",", \(Sin[2]\), 
        ",", "\[Pi]", ",", "4", ",", "4", ",", "4", ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]]}], "}"}]], "Output"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", \(-5\), ",", \(-2\), ",", \(Sin[2]\), 
        ",", "\[Pi]", ",", "4", ",", "4", ",", "4", ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]]}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
In all the examples above Ordering was given a list, but Ordering can work \
with expressions having any head as shown in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[h];\)\), "\[IndentingNewLine]", 
    \(Ordering[
      h[\(-2\), 4, \(-5\), Sin[2], 4, \[Pi], \(-\[Infinity]\), 
        4, \[Infinity]]]\)}], "Input"],

Cell[BoxData[
    \({3, 1, 2, 5, 8, 6, 7, 9, 4}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Orderless", "Section"],

Cell["\<\
For the input below (f) has the Orderless attribute which causes (f) to sort  \
it's arguments into canonical order.\
\>", "Text",
  CellTags->"Orderless"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \(\(Attributes[f] = {Orderless};\)\), "\n", 
    \(f[z, x, c, v, b]\)}], "Input"],

Cell[BoxData[
    \(f[b, c, v, x, z]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see that numeric arguments aren't necessarily sorted in \
numeric order.  Instead they are sorted into canonical order.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[\[Pi], 4, 3, 2]\)], "Input"],

Cell[BoxData[
    \(f[2, 3, 4, \[Pi]]\)], "Output"]
}, Closed]],

Cell["\<\
Functions with the Orderless attribute sort the arguments before definitions \
are applied.  That explains why the result of the input below is not {x, z} \
or {z, x}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(f[a_, b_, c__] := {a, b}\), "\n", 
    \(f[z, x, c, v, b]\)}], "Input"],

Cell[BoxData[
    \({b, c}\)], "Output"]
}, Closed]],

Cell["\<\
The Orderless attribute can effect pattern matching in ways many users don't \
understand.  The situation demonstrated in the cells below is one such \
example.  The next input clears the definitions and Orderless attribute from \
(f).  The rule applied in the next cell can only be used when the first \
argument of (f) has the head Real.  For this example the first argument is an \
integer so the rule isn't used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f]\), "\n", 
    \(f[5, 4, 3.5, 2, 1.7, \ 1] /. f[x_Real, y__] -> {x, {y}}\)}], "Input"],

Cell[BoxData[
    \(f[5, 4, 3.5`, 2, 1.7`, 1]\)], "Output"]
}, Closed]],

Cell["\<\
For the next input (f) has the Orderless attribute and same rule is applied \
again.  This time the arguments are sorted in canonical order before the rule \
is used.  Then the pattern matcher finds that the rule matches when \
(x\[Rule]1.7) and (y\[Rule] Sequence[1, 2, 3.5, 4, 5]).  The pattern matcher \
could have used (x \[Rule] 3.5) and the appropriate sequence for (y), but the \
other match was found first.  Once the pattern matcher found a match it \
stopped searching.  Notice the arguments used for (y) in the output are \
sorted in canonical order.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Attributes[f] = {Orderless};\)\), "\n", 
    \(f[5, 4, 3.5, 2, 1.7, \ 1] /. f[x_Real, y__] -> {x, {y}}\)}], "Input"],

Cell[BoxData[
    \({1.7`, {1, 2, 3.5`, 4, 5}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Outer", "Section"],

Cell["The first two examples demonstrate the basic use of Outer.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Outer[f, {x1, x2}, {y1, y2, y3}]\)], "Input"],

Cell[BoxData[
    \({{f[x1, y1], f[x1, y2], f[x1, y3]}, {f[x2, y1], f[x2, y2], 
        f[x2, y3]}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Outer[f, {x1, x2}, {y1, y2, y3}, {z1, z2}]\)], "Input"],

Cell[BoxData[
    \({{{f[x1, y1, z1], f[x1, y1, z2]}, {f[x1, y2, z1], 
          f[x1, y2, z2]}, {f[x1, y3, z1], f[x1, y3, z2]}}, {{f[x2, y1, z1], 
          f[x2, y1, z2]}, {f[x2, y2, z1], f[x2, y2, z2]}, {f[x2, y3, z1], 
          f[x2, y3, z2]}}}\)], "Output"]
}, Closed]],

Cell["\<\
A user asked the MathGroup how to define tables like the one below, but \
having larger dimensions without writing the whole table explicitly? \
\>", "Text",
  CellTags->"Outer"],

Cell[BoxData[
    StyleBox[\(\(\ \)\({{f1[x1], f1[x2], f1[x3], f1[x4]}, \n\ \ \ \ {f2[x1], 
          f2[x2], f2[x3], f2[x4]}, \n\ \ \ {f3[x1], f3[x2], f3[x3], 
          f3[x4]}, \n\ \ \ {f4[x1], f4[x2], f4[x3], f4[x4]}}\)\),
      FontFamily->"Courier New",
      FontSize->10]], "Output"],

Cell["Bob Hanlon provided the following solution.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{\(ClearAll["\<Global`*\>"];\), "\[IndentingNewLine]", 
    StyleBox[\(Outer[#1[#2]\  &, \ {f1, \ f2, \ f3, \ f4}\ , \ {x1, \ x2, \ 
          x3}]\),
      FontFamily->"Courier New",
      FontSize->10]}], "Input"],

Cell[BoxData[
    \({{f1[x1], f1[x2], f1[x3]}, {f2[x1], f2[x2], f2[x3]}, {f3[x1], f3[x2], 
        f3[x3]}, {f4[x1], f4[x2], f4[x3]}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell does the same thing, and is based on an example in the Help \
Browser.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    StyleBox[\(Outer[
        MapAll, \ {f1, \ f2, \ f3, \ f4}\ , \ {x1, \ x2, \ x3}]\),
      FontFamily->"Courier New",
      FontSize->10]], "Input"],

Cell[BoxData[
    \({{f1[x1], f1[x2], f1[x3]}, {f2[x1], f2[x2], f2[x3]}, {f3[x1], f3[x2], 
        f3[x3]}, {f4[x1], f4[x2], f4[x3]}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows what we get for the outer product of two matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Outer[f, {{a11, a12}, {a21, a22}}, {{b11, b12}, {b21, b22}}] // 
      MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a11, b11]\), \(f[a11, b12]\)},
                    {\(f[a11, b21]\), \(f[a11, b22]\)}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a12, b11]\), \(f[a12, b12]\)},
                    {\(f[a12, b21]\), \(f[a12, b22]\)}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a21, b11]\), \(f[a21, b12]\)},
                    {\(f[a21, b21]\), \(f[a21, b22]\)}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a22, b11]\), \(f[a22, b12]\)},
                    {\(f[a22, b21]\), \(f[a22, b22]\)}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{
        f[ a11, b11], 
        f[ a11, b12]}, {
        f[ a11, b21], 
        f[ a11, b22]}}, {{
        f[ a12, b11], 
        f[ a12, b12]}, {
        f[ a12, b21], 
        f[ a12, b22]}}}, {{{
        f[ a21, b11], 
        f[ a21, b12]}, {
        f[ a21, b21], 
        f[ a21, b22]}}, {{
        f[ a22, b11], 
        f[ a22, b12]}, {
        f[ a22, b21], 
        f[ a22, b22]}}}}]]], "Output"]
}, Closed]],

Cell["\<\
The next cell flattens what we get from the computing Outer with 4 lists.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Flatten[
      Outer[h, {a1, a2, a3}, {b1, b2, b3}, {c1, c2}, {d1, d2}]]\)], "Input"],

Cell[BoxData[
    \({h[a1, b1, c1, d1], h[a1, b1, c1, d2], h[a1, b1, c2, d1], 
      h[a1, b1, c2, d2], h[a1, b2, c1, d1], h[a1, b2, c1, d2], 
      h[a1, b2, c2, d1], h[a1, b2, c2, d2], h[a1, b3, c1, d1], 
      h[a1, b3, c1, d2], h[a1, b3, c2, d1], h[a1, b3, c2, d2], 
      h[a2, b1, c1, d1], h[a2, b1, c1, d2], h[a2, b1, c2, d1], 
      h[a2, b1, c2, d2], h[a2, b2, c1, d1], h[a2, b2, c1, d2], 
      h[a2, b2, c2, d1], h[a2, b2, c2, d2], h[a2, b3, c1, d1], 
      h[a2, b3, c1, d2], h[a2, b3, c2, d1], h[a2, b3, c2, d2], 
      h[a3, b1, c1, d1], h[a3, b1, c1, d2], h[a3, b1, c2, d1], 
      h[a3, b1, c2, d2], h[a3, b2, c1, d1], h[a3, b2, c1, d2], 
      h[a3, b2, c2, d1], h[a3, b2, c2, d2], h[a3, b3, c1, d1], 
      h[a3, b3, c1, d2], h[a3, b3, c2, d1], h[a3, b3, c2, d2]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next two examples we provide integers as additional arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Outer[f, {{a11, a12}, {a21, a22}}, {{b11, b12}, {b21, b22}}, 2, 1] // 
      MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a11, {b11, b12}]\)},
                    {\(f[a11, {b21, b22}]\)}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a12, {b11, b12}]\)},
                    {\(f[a12, {b21, b22}]\)}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a21, {b11, b12}]\)},
                    {\(f[a21, {b21, b22}]\)}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[a22, {b11, b12}]\)},
                    {\(f[a22, {b21, b22}]\)}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{
        f[ a11, {b11, b12}], 
        f[ a11, {b21, b22}]}, {
        f[ a12, {b11, b12}], 
        f[ a12, {b21, b22}]}}, {{
        f[ a21, {b11, b12}], 
        f[ a21, {b21, b22}]}, {
        f[ a22, {b11, b12}], 
        f[ a22, {b21, b22}]}}}]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Outer[f, {{a11, a12}, {a21, a22}}, {{b11, b12}, {b21, b22}}, 1, 2] // 
      MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[{a11, a12}, b11]\)},
                    {\(f[{a11, a12}, b12]\)}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[{a11, a12}, b21]\)},
                    {\(f[{a11, a12}, b22]\)}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[{a21, a22}, b11]\)},
                    {\(f[{a21, a22}, b12]\)}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {\(f[{a21, a22}, b21]\)},
                    {\(f[{a21, a22}, b22]\)}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{
        f[ {a11, a12}, b11], 
        f[ {a11, a12}, b12]}, {
        f[ {a11, a12}, b21], 
        f[ {a11, a12}, b22]}}, {{
        f[ {a21, a22}, b11], 
        f[ {a21, a22}, b12]}, {
        f[ {a21, a22}, b21], 
        f[ {a21, a22}, b22]}}}]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Part", "Section"],

Cell["\<\
Part[expr,0] is always the same as Head[expr], but Head is a bit faster since \
it doesn't need to determine what part.  For example Part[1+\[Pi], 0] returns \
Plus.\
\>", "Text",
  CellTags->"Part"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Part[1 + \[Pi], 0]\)], "Input"],

Cell[BoxData[
    \(Plus\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see the part at position (2,0) of the list {1,1+\[Pi]} is \
Plus.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Part[{1, 1 + \[Pi]}, 2, 0]\)], "Input"],

Cell[BoxData[
    \(Plus\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell a matrix (m) is made and used in some examples below. Of \
course the method demonstrated in the cells that follow can be used on any \
expression not only matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(\(m = {{x11, x12, x13, x14, x15}, {x21, x22, x23, x24, x25}, {x31, 
            x32, x33, x34, x35}, {x41, x42, x43, x44, x45}, {x51, x52, x53, 
            x54, x55}};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(MatrixForm[m]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"x11", "x12", "x13", "x14", "x15"},
            {"x21", "x22", "x23", "x24", "x25"},
            {"x31", "x32", "x33", "x34", "x35"},
            {"x41", "x42", "x43", "x44", "x45"},
            {"x51", "x52", "x53", "x54", "x55"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
Part has a powerful feature that many users aren't aware of.  The expression \
m[[list1,list2]] returns the sub-matrix of (m) formed by the intersection of \
the rows given by list1 and the columns given by list2. The next cell gives \
an example. This is probably the quickest way to get such a submatrix of (m).\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(m[\([{1, 3, 4}, {2, 5}]\)]\  // MatrixForm\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"x12", "x15"},
            {"x32", "x35"},
            {"x42", "x45"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
m[[n,list2]] returns a list of elements at positions (list2) in row n. The \
next cell gives an example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(m[\([2, {1, 2, 5}]\)]\)], "Input"],

Cell[BoxData[
    \({x21, x22, x25}\)], "Output"]
}, Closed]],

Cell["\<\
Likewise m[[list1,n]] returns a list of elements at positions (list1) of \
column n. The next cell gives an example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(m[\([{1, 2, 5}, 2]\)]\)], "Input"],

Cell[BoxData[
    \({x12, x22, x52}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Use of the forms demonstrated above gives the fastest way to change \
multiple parts of an expression provided the parts can be reached with this \
method. Rob Knapp makes this point in a tutorial on Packed Arrays at   ",
  ButtonBox["http://library.wolfram.com/database/TechNotes/391/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/TechNotes/391/"], None},
    ButtonStyle->"Hyperlink"],
  ".  In that tutorial he shows how this method gives a significant speed \
advantage in an implementation of LUDecomposition. This method of changing \
multiple values is demonstrated on simple examples in the cells below where \
elements of the matrix (m) from above are changed.\n\nNotice the use of All \
inside Part is not available in Version 3 or earlier."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m[\([All, 3]\)] = {a1, a2, a3, a4, a5};\)\), "\[IndentingNewLine]", 
    \(MatrixForm[m]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"x11", "x12", "a1", "x14", "x15"},
            {"x21", "x22", "a2", "x24", "x25"},
            {"x31", "x32", "a3", "x34", "x35"},
            {"x41", "x42", "a4", "x44", "x45"},
            {"x51", "x52", "a5", "x54", "x55"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m[\([2, All]\)] = {b1, b2, b3, b4, b5};\)\), "\[IndentingNewLine]", 
    \(MatrixForm[m]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"x11", "x12", "a1", "x14", "x15"},
            {"b1", "b2", "b3", "b4", "b5"},
            {"x31", "x32", "a3", "x34", "x35"},
            {"x41", "x42", "a4", "x44", "x45"},
            {"x51", "x52", "a5", "x54", "x55"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the next cell All is used to access the first, second and fourth columns \
of matrix (m).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Part[m, All, {1, 2, 4}] // MatrixForm\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"x11", "x12", "x14"},
            {"b1", "b2", "b4"},
            {"x31", "x32", "x34"},
            {"x41", "x42", "x44"},
            {"x51", "x52", "x54"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the next cell we change elements of (m) where rows (1,3) intersect with \
columns (2,3,5).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m[\([{1, 3}, {2, 3, 5}]\)] = {{jjj1, jjj2, jjj3}, {kkk1, kkk2, 
            kkk3}};\)\), "\[IndentingNewLine]", 
    \(MatrixForm[m]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"x11", "jjj1", "jjj2", "x14", "jjj3"},
            {"b1", "b2", "b3", "b4", "b5"},
            {"x31", "kkk1", "kkk2", "x34", "kkk3"},
            {"x41", "x42", "a4", "x44", "x45"},
            {"x51", "x52", "a5", "x54", "x55"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Partition", "Section"],

Cell[TextData[{
  "Lots of users are not familiar with the Partition function.  Partition is \
well documented under Built-in Functions in the ",
  ButtonBox["Help Browser",
    ButtonData:>{"Partition"},
    ButtonStyle->"RefGuideLink"],
  ".  The usage message for this powerful feature is shown below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Partition\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Partition[list, n] partitions list into non-overlapping \
sublists of length n. Partition[list, n, d] generates sublists with offset d. \
Partition[list, {n1, n2, ... }] partitions a nested list into blocks of size \
n1 \[Cross] n2 \[Cross] \[Ellipsis] . Partition[list, {n1, n2, ... }, {d1, \
d2, ... }] uses offset di at level i in list. Partition[list, n, d, {kL, kR}] \
specifies that the first element of list should appear at position kL in the \
first sublist, and the last element of list should appear at or after \
position kR in the last sublist. If additional elements are needed, Partition \
fills them in by treating list as cyclic. Partition[list, n, d, {kL, kR}, x] \
pads if necessary by repeating the element x. Partition[list, n, d, {kL, kR}, \
{x1, x2, ... }] pads if necessary by cyclically repeating the elements xi. \
Partition[list, n, d, {kL, kR}, {}] uses no padding, and so can yield \
sublists of different lengths. Partition[list, nlist, dlist, {klistL, \
klistR}, padlist] specifies alignments and padding in a nested list.\"\>", 
      " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Partition",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242474896-7343620"]
}, Closed]],

Cell["\<\
A simple demonstration of Partition is given in the next cell.  If the third \
argument is not provided the result will be the same as if the a third \
argument equal to the second was provided.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst = Range[50];\)\), "\n", 
    \(Partition[lst, 4]\)}], "Input"],

Cell[BoxData[
    \({{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}, {17, 
        18, 19, 20}, {21, 22, 23, 24}, {25, 26, 27, 28}, {29, 30, 31, 
        32}, {33, 34, 35, 36}, {37, 38, 39, 40}, {41, 42, 43, 44}, {45, 46, 
        47, 48}}\)], "Output"]
}, Closed]],

Cell["\<\
The effect of the third argument is demonstrated in the next two examples..\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Partition[lst, 4, 3]\)], "Input"],

Cell[BoxData[
    \({{1, 2, 3, 4}, {4, 5, 6, 7}, {7, 8, 9, 10}, {10, 11, 12, 13}, {13, 14, 
        15, 16}, {16, 17, 18, 19}, {19, 20, 21, 22}, {22, 23, 24, 25}, {25, 
        26, 27, 28}, {28, 29, 30, 31}, {31, 32, 33, 34}, {34, 35, 36, 
        37}, {37, 38, 39, 40}, {40, 41, 42, 43}, {43, 44, 45, 46}, {46, 47, 
        48, 49}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Partition[lst, 4, 10]\)], "Input"],

Cell[BoxData[
    \({{1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 
        34}, {41, 42, 43, 44}}\)], "Output"]
}, Closed]],

Cell["\<\
Next we give Partition a fourth argument of 3.  Partition then treats the \
list as if it were periodic and ensures the first element of (lst) is the \
third element of the first sublist.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Partition[lst, 5, 5, 3]\)], "Input"],

Cell[BoxData[
    \({{49, 50, 1, 2, 3}, {4, 5, 6, 7, 8}, {9, 10, 11, 12, 13}, {14, 15, 16, 
        17, 18}, {19, 20, 21, 22, 23}, {24, 25, 26, 27, 28}, {29, 30, 31, 32, 
        33}, {34, 35, 36, 37, 38}, {39, 40, 41, 42, 43}, {44, 45, 46, 47, 
        48}}\)], "Output"]
}, Closed]],

Cell["\<\
Next the fourth argument of Partition is 7 and we get a partition where the \
first element of (lst) would be the seventh element of the result if it were \
flattened.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Partition[lst, 5, 5, 7]\)], "Input"],

Cell[BoxData[
    \({{45, 46, 47, 48, 49}, {50, 1, 2, 3, 4}, {5, 6, 7, 8, 9}, {10, 11, 12, 
        13, 14}, {15, 16, 17, 18, 19}, {20, 21, 22, 23, 24}, {25, 26, 27, 28, 
        29}, {30, 31, 32, 33, 34}, {35, 36, 37, 38, 39}, {40, 41, 42, 43, 
        44}}\)], "Output"]
}, Closed]],

Cell["\<\
Partition can work in higher dimensions. In the next example Partition \
seperates a matrix into blocks.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\n", 
    \(\(mtrx = {\[IndentingNewLine]{w1, w2, w3, w4, w5, 
            w6}, \[IndentingNewLine]{x1, x2, x3, x4, x5, 
            x6}, \[IndentingNewLine]{y1, y2, y3, y4, y5, 
            y6}, \[IndentingNewLine]{z1, z2, z3, z4, z5, 
            z6}\[IndentingNewLine]};\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Partition[mtrx, {2, 2}, {2, 2}] // MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"w1", "w2"},
                    {"x1", "x2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"w3", "w4"},
                    {"x3", "x4"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"w5", "w6"},
                    {"x5", "x6"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"y1", "y2"},
                    {"z1", "z2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"y3", "y4"},
                    {"z3", "z4"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"y5", "y6"},
                    {"z5", "z6"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{w1, w2}, {x1, x2}}, {{w3, w4}, {x3, x4}}, {{w5, w6}, {
        x5, x6}}}, {{{y1, y2}, {z1, z2}}, {{y3, y4}, {z3, z4}}, {{y5, y6}, {
        z5, z6}}}}]]], "Output"]
}, Closed]],

Cell["\<\
The next example demonstrates that Partition can work on expressions that \
don't have the head list.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(flst = f @@ Range[1, 20]\)}], "Input"],

Cell[BoxData[
    \(f[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
      20]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Partition[flst, 3]\)], "Input"],

Cell[BoxData[
    \(f[f[1, 2, 3], f[4, 5, 6], f[7, 8, 9], f[10, 11, 12], f[13, 14, 15], 
      f[16, 17, 18]]\)], "Output"]
}, Closed]],

Cell["\<\
I haven't been able to find ways to clearly demonstrate use of the Partition \
features listed below.  Each of these features are in the Partition usage \
message.

\[Bullet]  Partition[list, n, d, {kL, kR}] specifies that the first element \
of list should appear at position kL in the first sublist, and the last \
element of list should appear at or after position kR in the last sublist.

\[Bullet]  Partition[list, n, d, {kL, kR}, x] pads if necessary by repeating \
the element x. 

\[Bullet]  Partition[list, n, d, {kL, kR}, {x1, x2, ... }] pads if necessary \
by cyclically repeating the elements xi.

\[Bullet]  Partition[list, n, d, {kL, kR}, {}] uses no padding, and so can \
yield sublists of different lengths. 

\[Bullet]  Partition[list, nlist, dlist, {klistL, klistR}, padlist] specifies \
alignments and padding in a nested list.\
\>", "Text",
  CellFrame->{{0, 0}, {0, 0.5}}]
}, Closed]],

Cell[CellGroupData[{

Cell["Position", "Section"],

Cell["\<\
Position is used to determine the where a certain pattern can be found in an \
expression.  In the next cell Position returns a list of all the position of \
all parts of demo that match the pattern (_Plus).  The empty list at the end \
of the output list indicates that (demo) itself matches the pattern Position \
is looking for.\
\>", "Text",
  CellTags->"Position"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\(demo = 
        x + 1\/\(x - 1\) + Cos[\(\[Pi] \@\( 2 + x/3\)\)\/3] + 
          Sin[\(\[Pi] \@ f[x + y + 1]\)\/6];\)\), "\[IndentingNewLine]", 
    \(posn = Position[demo, _Plus]\)}], "Input"],

Cell[BoxData[
    \({{1, 1}, {3, 1, 3, 1}, {4, 1, 3, 1, 1}, {}}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we get the subexpression at three of the positions listed in \
the previous result.  Notice each of the sub-expressions is a sum.  The last \
element of the list returned by Position is {}, which indicates that demo \
itself matches the pattern (_Plus).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Part[demo, 1, 1]\), "\[IndentingNewLine]", 
    \(Part[demo, 3, 1, 3, 1]\), "\[IndentingNewLine]", 
    \(Part[demo, 4, 1, 3, 1, 1]\)}], "Input"],

Cell[BoxData[
    \(x - 1\)], "Output"],

Cell[BoxData[
    \(2 + x\/3\)], "Output"],

Cell[BoxData[
    \(1 + x + y\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we pass the list Position returned and get a list of all the \
parts of (demo) that match the pattern.  However, if you have no other need \
for the positions, it would be more direct to get the same result using \
Cases[demo,_Plus,{0,\[Infinity]}].  The results returned by Position can also \
be used as arguments of MapAt, and ReplacePart.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Extract[demo, posn]\)], "Input"],

Cell[BoxData[
    \({x - 1, 2 + x\/3, 1 + x + y, 
      1\/\(x - 1\) + x + Cos[1\/3\ \[Pi]\ \@\(2 + x\/3\)] + 
        Sin[1\/6\ \[Pi]\ \@f[1 + x + y]]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell only the the whole expression matches the pattern and \
Position indicates this by returning {{}}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[h[1, 2, 3], _h]\)], "Input"],

Cell[BoxData[
    \({{}}\)], "Output"]
}, Closed]],

Cell["\<\
When Position finds no parts that match the pattern an empty list is returned \
as in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[x + y, _h]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used with Position.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell["Position[ expr, pattn, levspec ]", "Subsection"],

Cell[TextData[{
  "Position will take a level specification and all the variations I discuss \
under ",
  ButtonBox["Level Specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " are supported.  The next cell repeats an earlier example and returns all \
positions of demo with the head Plus."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, _Plus]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {3, 1, 3, 1}, {4, 1, 3, 1, 1}, {}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell uses level specification 4 and we get all sub-expressions at \
levels 1 through 4 with the head Plus.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, _Plus, 4]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {3, 1, 3, 1}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell uses level specification {4} which means to only look at level \
4.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, _Plus, {4}]\)], "Input"],

Cell[BoxData[
    \({{3, 1, 3, 1}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell uses level specification {0,4} which means to look at levels 0 \
through 4. Level 0 is the entire (demo) expression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, _Plus, {0, 4}]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {3, 1, 3, 1}, {}}\)], "Output"]
}, Closed]],

Cell["\<\
The default level specification for Position is {0,\[Infinity]} as in the \
next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, _Plus, {0, \[Infinity]}]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {3, 1, 3, 1}, {4, 1, 3, 1, 1}, {}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Position[ expr, pattn, levspec, n] ", "Subsection"],

Cell["\<\
In the next cell we get the position of all integers in (data).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(data = {1.3, {1.3, 10}, 1.3, 11, {{1.3, 1.3, 12, 13}}, 14, 15, 1.3, 
          16, 1.3, 17, 18, 19, 1.3};\)\), "\n", 
    \(posn = Position[data, _Integer]\)}], "Input"],

Cell[BoxData[
    \({{2, 2}, {4}, {5, 1, 3}, {5, 1, 
        4}, {6}, {7}, {9}, {11}, {12}, {13}}\)], "Output"]
}, Closed]],

Cell["\<\
Next we can use Extract to get the integers at the above positions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Extract[data, posn]\)], "Input"],

Cell[BoxData[
    \({10, 11, 12, 13, 14, 15, 16, 17, 18, 19}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "We can give position a positive integer as a  ",
  Cell[BoxData[
      \(TraditionalForm\`4\^th\)]],
  " argument to get only the first (n) positions.  In the next cell we get \
the position of the first 4 integers.  Here I am specifying {0,\[Infinity]} \
as the level specification."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(posn = Position[data, _Integer, {0, \[Infinity]}, 4]\)], "Input"],

Cell[BoxData[
    \({{2, 2}, {4}, {5, 1, 3}, {5, 1, 4}}\)], "Output"]
}, Closed]],

Cell["\<\
Next we ask for the position of the first 50 integers.  There are only 10 \
integers to be found, so we are given all 10 positions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(posn = Position[data, _Integer, {0, \[Infinity]}, 50]\)], "Input"],

Cell[BoxData[
    \({{2, 2}, {4}, {5, 1, 3}, {5, 1, 
        4}, {6}, {7}, {9}, {11}, {12}, {13}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Heads option", "Subsection"],

Cell[TextData[{
  "In the next cell Position tells us where the head Plus can be found.  Plus \
is at position 0 (the head of demo).  The head Plus is also at positions ",
  Cell[BoxData[
      \(TraditionalForm\`{1, 1, 0}\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`{3, 1, 3, 1, 0}\)]],
  " and ",
  Cell[BoxData[
      \(TraditionalForm\`{4, 1, 3, 1, 1, 0}\)]],
  " which are the heads of sub-expressions at positions ",
  Cell[BoxData[
      \(TraditionalForm\`{1, 1}\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`{3, 1, 3, 1}\)]],
  ", ",
  Cell[BoxData[
      \(TraditionalForm\`{4, 1, 3, 1, 1}\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, Plus]\)], "Input"],

Cell[BoxData[
    \({{0}, {1, 1, 0}, {3, 1, 3, 1, 0}, {4, 1, 3, 1, 1, 0}}\)], "Output"]
}, Closed]],

Cell["\<\
Position has an option Heads with the default setting (Heads\[Rule]True). If \
Position is used with the option setting (Heads\[Rule]False) it doesn't look \
at the heads of an expression or its sub-expressions.  Hence when the last \
example is repeated with the setting (Heads\[Rule]False) an empty list is \
returned.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[demo, Plus, Heads -> False]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we get the only position of ",
  StyleBox["(2*f[x]+3*f'[x])", "InlineInput"],
  " where the integer 1 can be found.  The only place in this example where \
the integer 1 can be found is in the order of the derivative."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(Position[2*f[x] + 3*\(f'\)[x], 1, Heads -> True]\)}], "Input"],

Cell[BoxData[
    \({{2, 2, 0, 0, 1}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell repeats the previous example with the setting \
(Heads\[Rule]False) and an empty list is returned.  An empty list is returned \
because the pattern matcher would have to look in the head of   ",
  StyleBox["f'[x]", "InlineInput"],
  "  to find the integer 1."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[2*f[x] + 3*\(f'\)[x], 1, Heads -> False]\)], "Input"],

Cell[BoxData[
    \({}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Also read  \"Further Examples\" at the end of the  ",
  ButtonBox["Position",
    ButtonStyle->"RefGuideLink"],
  "  documentation in the Help Browser."
}], "Subsubsection",
  FontSize->12]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pattern  (x:pattn)", "Section"],

Cell[TextData[{
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " lets us use (x_Foo) to say that something with the head Foo will be \
called (x).  It also lets us use (x_?Test)  to say something for which Test \
returns True will be called (x).  Now if we want to say that something \
matching a certain pattern is called (x) we use ",
  Cell[BoxData[
      \(TraditionalForm\`\((x : pattn)\)\)]],
  ".  "
}], "Text",
  CellTags->"Pattern"],

Cell["\<\
The next cell gives an example where use of Pattern is helpful.  Here (ff) is \
only defined when it's argument is an Integer raised to a power.  In addition \
the exponent must have the head Plus.\
\>", "Text"],

Cell[BoxData[
    \(ff[x : \((_Integer^_Plus)\)] := Thread[x, Plus]\)], "Input"],

Cell[TextData[{
  "In the example below we get the result of evaluating  ",
  Cell[BoxData[
      \(TraditionalForm\`Thread[2\^\(3\ x - 5  y\), \ Plus]\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ff[2\^\(3  x - 5  y\)]\)], "Input"],

Cell[BoxData[
    \(2\^\(3\ x\) + 2\^\(\(-5\)\ y\)\)], "Output"]
}, Closed]],

Cell["\<\
Next we see (ff) is undefined when it's argument isn't an Integer raised to a \
power where the exponent has the head Plus.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ff[2\^\(3  x\)]\)], "Input"],

Cell[BoxData[
    \(ff[2\^\(3\ x\)]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ff[x\^\(3  x - 5  y\)]\)], "Input"],

Cell[BoxData[
    \(ff[x\^\(3\ x - 5\ y\)]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pattern Test (x_?Positive), (y_Real?Positive)", "Section"],

Cell[TextData[{
  "PatternTest is closely related to ",
  ButtonBox["Condition",
    ButtonData:>"Condition",
    ButtonStyle->"Hyperlink"],
  ".  PatternTest is used to specify that a certain pattern must meet a \
certain condition.  So for example in the next cell (f) is defined when given \
an argument that is a positive number. "
}], "Text",
  CellTags->"PatternTest"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x_?Positive] := x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[8.3], f[\[Pi]/2], f[\@\(-2\)]}\)}], "Input"],

Cell[BoxData[
    \({3, 9.3`, 1 + \[Pi]\/2, f[\[ImaginaryI]\ \@2]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example (f) is only defined when given an argument that is a \
positive integer.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x_Integer?Positive] := x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[8.3], f[\[Pi]/2], f[\@\(-2\)]}\)}], "Input"],

Cell[BoxData[
    \({3, f[8.3`], f[\[Pi]\/2], f[\[ImaginaryI]\ \@2]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example (f) is defined when given an argument that is a positive \
integer or a positive real number.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x : \((\((_Integer | _Real)\)?Positive)\)] := 
      x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[8.3], f[\[Pi]/2], f[\@\(-2\)]}\)}], "Input"],

Cell[BoxData[
    \({3, 9.3`, f[\[Pi]\/2], f[\[ImaginaryI]\ \@2]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In some cases we want to use a test that isn't a built-in unary operator \
(Positive, NumericQ, AtomQ, ...).  In that case we can use a ",
  ButtonBox["pure function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  " as in the next example.  In the next example (f) is only defined when \
given an argument that is an integer between 0 and 10."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x_Integer?\((0 < # < 10 &)\)] := x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[25], f[8.3], f[\[Pi]/2], f[\@\(-2\)]}\)}], "Input"],

Cell[BoxData[
    \({3, f[25], f[8.3`], f[\[Pi]\/2], f[\[ImaginaryI]\ \@2]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell (f) is only defined when given an argument of any type \
between 0 and 10.  Can you see why we need the part about (Im[#]===0) ?\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x_?\((Im[#] === 0 && 0 < # < 10 &)\)] := 
      x + 1\), "\[IndentingNewLine]", 
    \({f[2], f[25], f[8.3], f[\[Pi]/2], f[\@\(-2\)]}\)}], "Input"],

Cell[BoxData[
    \({3, f[25], 9.3`, 1 + \[Pi]\/2, f[\[ImaginaryI]\ \@2]}\)], "Output"]
}, Closed]],

Cell["\<\
We can't use pattern variables in the test portion of (Pattn/;Test), and that \
is why the definition in the next cell isn't used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[foo];\)\), "\[IndentingNewLine]", 
    \(foo[x_?\((0 < x < 1)\)] := x^2\), "\[IndentingNewLine]", 
    \(foo[0.4]\)}], "Input"],

Cell[BoxData[
    \(foo[0.4`]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Random", "Section"],

Cell[TextData[{
  "On 5 May 2000 Daniel Lichtblau of Wolfram Research reported at    \n",
  ButtonBox["http://forums.wolfram.com/mathgroup/archive/2000/May/msg00088.\
html",
    ButtonData:>{
      URL[ 
      "http://forums.wolfram.com/mathgroup/archive/2000/May/msg00088.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\nthat the numbers produced using to produce rando approximate machine \
numbers are not completely random.  Further more at \n",
  ButtonBox["http://forums.wolfram.com/mathgroup/archive/2004/May/msg00002.\
html",
    ButtonData:>{
      URL[ 
      "http://forums.wolfram.com/mathgroup/archive/2004/May/msg00002.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  " \nAndrzej Kozlowski reported that this is still a problem in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 5.0. \nDaniel Lichtblau suggests that instead of using  Random[]  to \
generate random real machine numbers the following should be used.  I believe \
this will give a random number between 1 and 2.\n"
}], "Text",
  CellTags->"Random"],

Cell[BoxData[
    \(Random[Integer, 2^30 - 1]\/2.0^30 + 
      Random[Integer, 2^30 - 1]\/2.0^30\)], "Input"],

Cell["\<\
However, based on Daniel's explanation of the problem, I expect that the \
following also works around the bug in Random, and runs twice as fast as the \
solution above.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(N[Random[Real, {0, 1}, 17]]\)], "Input"],

Cell[BoxData[
    \(0.48062950070069244`\)], "Output"]
}, Closed]],

Cell["\<\
In the above message Daniel Lichtblau also explained how one can make \
necessary changes to some of the standard packages.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Rationalize", "Section"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Rationalize\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Rationalize[x] takes Real numbers in x that are close to \
rationals, and converts them to exact Rational numbers. Rationalize[x, dx] \
performs the conversion whenever the error made is smaller in magnitude than \
dx.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Rationalize",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242474897-2101131"]
}, Closed]],

Cell["\<\
The line below finds a rational number that is very close to the machine \
number approximation of Pi.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(est1 = Rationalize[N[\[Pi]], \ 0]\)], "Input"],

Cell[BoxData[
    \(245850922\/78256779\)], "Output"]
}, Closed]],

Cell["\<\
Rationalize[N[\[Pi]],0.0]  gives the same number as the line above.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(N[\[Pi] - est1, \ 17]\)], "Input"],

Cell[BoxData[
    \(7.8179366199075435400152113`17*^-17\)], "Output"]
}, Closed]],

Cell["\<\
The next line gives a rational approximation of \[Pi] that is remarkably \
close to the actual value of \[Pi].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(est = Rationalize[\[Pi], \ 0.0]\)], "Input"],

Cell[BoxData[
    \(\[Pi]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Block[{$MaxExtraPrecision = 800}, \nN[\[Pi] - est, \ 17]\n]\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Closed]],

Cell["\<\
If you want to quickly convert a Real to a Rational and you don't care about \
large integers in the numerator and denominator the next line should be used. \
It's about 26 times faster than Rationalize!\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(SetPrecision[14.2, \[Infinity]]\)], "Input"],

Cell[BoxData[
    \(3996944669291315\/281474976710656\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Range", "Section"],

Cell["\<\
In the cells that follow we see Range can be used in a lot of cases where \
Table is often used.  One difference  is that Range will normally make a list \
in about half the time Table would need to make the same list.

Range doesn't  have to count over integers.  In the next line Range starts at \
0 and counts in steps of 1/20  up to the last value less than (\[Pi]/3).  \
Notice (1<\[Pi]/3), but (21/20>\[Pi]/3), sot the list stops at 1.\
\>", "Text",
  CellTags->"Range"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Range[0, \[Pi]/3, 1/20]\)], "Input"],

Cell[BoxData[
    \({0, 1\/20, 1\/10, 3\/20, 1\/5, 1\/4, 3\/10, 7\/20, 2\/5, 9\/20, 1\/2, 
      11\/20, 3\/5, 13\/20, 7\/10, 3\/4, 4\/5, 17\/20, 9\/10, 19\/20, 
      1}\)], "Output"]
}, Closed]],

Cell["The next example is similar to the previous example.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Range[0, 1, \[Pi]/20]\)], "Input"],

Cell[BoxData[
    \({0, \[Pi]\/20, \[Pi]\/10, \(3\ \[Pi]\)\/20, \[Pi]\/5, \[Pi]\/4, \(3\ \
\[Pi]\)\/10}\)], "Output"]
}, Closed]],

Cell["\<\
In the same line where Range makes a list, a listable function such as Times \
or Power can be applied to the list as in the next line. The same list can be \
made using Table, but Range is almost always faster.  If the function being \
applied to each element of the list isn't listable, you can map it over the \
list, and it will work about as fast as if it was listable.  In the two \
following examples Power is applied to the list returned by Range.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, n, a];\)\), "\[IndentingNewLine]", 
    \(x^Range[n, n + 10, 2]\)}], "Input"],

Cell[BoxData[
    \({x\^n, x\^\(2 + n\), x\^\(4 + n\), x\^\(6 + n\), x\^\(8 + n\), 
      x\^\(10 + n\)}\)], "Output"]
}, Closed]],

Cell["The next line give an interesting example.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Range[a, a + 12  n, \ 2  n]\)], "Input"],

Cell[BoxData[
    \({a, a + 2\ n, a + 4\ n, a + 6\ n, a + 8\ n, a + 10\ n, 
      a + 12\ n}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next line Range is used to make a series expansion for Cos[x].  \
Timing experiments show that this is much faster than using Series, but the \
method below is fairly cryptic.  Also creating the series using Range \
requires knowledge of the general form of each term, while Series doesn't \
need this information.  The fact that Series must determine the coefficients \
for each term is probably the reason why it takes much longer.  The #& \
notation is explained in the discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Plus @@ \((\(\(-\((\(-1\))\)^\((#)\)\) 
              x^\((2  # - 2)\)/\(\((2  # - 2)\)!\) &\)[
          Range[7]])\)\)], "Input"],

Cell[BoxData[
    \(1 - x\^2\/2 + x\^4\/24 - x\^6\/720 + x\^8\/40320 - x\^10\/3628800 + 
      x\^12\/479001600\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Repeated (pattn ..), RepeatedNull (pattn ...)", "Section"],

Cell["\<\
Repeated (pattn ..) is used to represent a sequence of arguments that match a \
certain pattern.  For example in the next cell (f) is defined when given a \
sequence of one or more arguments that have the head Real or Integer.  When \
Repeated (..) is used the definition applies when some of the arguments are \
Real and others are Integer.\
\>", "Text",
  CellTags->"Repeated RepeatedNull"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x : \((_Real | _Integer)\) .. ] := 
      Join[{x}, {\[Infinity]}]\), "\[IndentingNewLine]", 
    \({f[2], f[2.4], f[2, 4.3], f[], f[2, s]}\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{"{", 
          RowBox[{"2", ",", 
            InterpretationBox["\[Infinity]",
              DirectedInfinity[ 1]]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{"2.4`", ",", 
            InterpretationBox["\[Infinity]",
              DirectedInfinity[ 1]]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{"2", ",", "4.3`", ",", 
            InterpretationBox["\[Infinity]",
              DirectedInfinity[ 1]]}], "}"}], ",", \(f[]\), 
        ",", \(f[2, s]\)}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
In the previous example (f) was only defined when given one or more arguments \
that are Real or Integer.  NullRepeated (...) represents a sequence multiple, \
one, or an empty set of arguments matching a pattern.  So in the next example \
(f) is defined when given no arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear[f, s]\), "\[IndentingNewLine]", 
    \(f[x : \((_Real | _Integer)\) ... ] := 
      Join[{x}, {\[Infinity]}]\), "\[IndentingNewLine]", 
    \({f[2], f[2.4], f[2, 4.3], f[], f[2, s]}\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{"{", 
          RowBox[{"2", ",", 
            InterpretationBox["\[Infinity]",
              DirectedInfinity[ 1]]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{"2.4`", ",", 
            InterpretationBox["\[Infinity]",
              DirectedInfinity[ 1]]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{"2", ",", "4.3`", ",", 
            InterpretationBox["\[Infinity]",
              DirectedInfinity[ 1]]}], "}"}], ",", 
        RowBox[{"{", 
          InterpretationBox["\[Infinity]",
            DirectedInfinity[ 1]], "}"}], ",", \(f[2, s]\)}], "}"}]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Replace", "Section"],

Cell["\<\
The Replace function is greatly under appriciated because the Wolfram \
Research documentation gives very little discussion of what it can do. After \
reading the documentation on Replace you get the impression that it tries to \
use replacement rules on an entire expression and nothing more. 

The cell below demonstrates this basic use of Replace.  In this case the \
expression (demo) matches the form for the replacement rule. The rule is used \
once and that is the end of it.\
\>", "Text",
  CellTags->"Replace"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a];\)\), "\[IndentingNewLine]", 
    \(\(demo = {0, {1, {2, {3, {4, {5, {6, {7, 7}}}}}}}};\)\), "\n", 
    \(Replace[demo, {x_, y__} \[RuleDelayed] {x, a, y}]\)}], "Input"],

Cell[BoxData[
    \({0, a, {1, {2, {3, {4, {5, {6, {7, 7}}}}}}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The basic use of Replace isn't very useful. The power of Replace lies in \
use of it's third argument where a ",
  ButtonBox["level specification",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " is given. In the next cell the replacement is used at level 1 down to the \
atoms and all levels between."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[demo, {x_, y__} \[RuleDelayed] {x, a, y}, \(-1\)]\)], "Input"],

Cell[BoxData[
    \({0, {1, 
        a, {2, a, {3, a, {4, a, {5, a, {6, a, {7, a, 7}}}}}}}}\)], "Output"]
}, Closed]],

Cell["\<\
In the next case the replacement is only performed at level 3.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[demo, {x_, y__} \[RuleDelayed] {x, a, y}, {3}]\)], "Input"],

Cell[BoxData[
    \({0, {1, {2, {3, a, {4, {5, {6, {7, 7}}}}}}}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell uses the replacement on levels 2, 3, and 4.  As explained below \
the replacements start at the deepest level (level 4 in this case) and works \
up to the higher levels.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[demo, {x_, y__} \[RuleDelayed] {x, a, y}, {2, 4}]\)], "Input"],

Cell[BoxData[
    \({0, {1, {2, a, {3, a, {4, a, {5, {6, {7, 7}}}}}}}}\)], "Output"]
}, Closed]],

Cell["\<\
When the third argument of Replace is  -6  the replacement start with \
expressions with a depth of 6 and works up to level 1.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[demo, {x_, y__} \[RuleDelayed] {x, a, y}, \(-6\)]\)], "Input"],

Cell[BoxData[
    \({0, {1, a, {2, a, {3, a, {4, {5, {6, {7, 7}}}}}}}}\)], "Output"]
}, Closed]],

Cell["\<\
When the third argument of Replace is {-7,4} the replacement start at level 4 \
and work up to expressions with a depth of 7.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[
      demo, {x_, y__} \[RuleDelayed] {x, a, y}, {\(-7\), 4}]\)], "Input"],

Cell[BoxData[
    \({0, {1, {2, a, {3, a, {4, a, {5, {6, {7, 7}}}}}}}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "We can give Replace a list of replacement rules as in the next cell.  We \
could use (lhs\[RuleDelayed]rhs) instead of (lhs\[Rule]rhs) and the \
difference between the two is discussed in the section on ",
  ButtonBox["Rule instead of RuleDelayed",
    ButtonData:>"Rule;RuleDelayed",
    ButtonStyle->"Hyperlink"],
  ". "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[
      w + x + y + z, {x \[Rule] 2  x, 
        y \[Rule] 3  y}, {0, \[Infinity]}]\)], "Input"],

Cell[BoxData[
    \(w + 2\ x + 3\ y + z\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Once Replace changes a part of an expression no further replacements are \
made on that portion of the expression or any of it's subparts.  For example \
the rule in the next cell is only used once on each logrithm.  Normally \
ReplaceRepeated would be used to fully expand the logrithms, but you could \
use FixedPoint and Replace to fully expand these logrithms (I won't do that \
here).\n\n",
  "I don't provide further examples, but any combination of pattern matching \
constructs can be used on the left side of rules given to Replace.  Nuances \
of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[Log[d\ p\ q\ r] Log[a\ b\ c\ d], \ 
      Log[a_\ \ b_] \[RuleDelayed] 
        Log[a] + Log[b], {0, \[Infinity]}]\)], "Input"],

Cell[BoxData[
    \(\((Log[a] + Log[b\ c\ d])\)\ \((Log[d] + Log[p\ q\ r])\)\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["The order of matching patterns and making replacements", "Subsection"],

Cell["\<\
I learned from Allan Hayes that Replace attempts replacements starting at the \
deepest level allowed by the level specification and works its way up to \
higher levels. Allan also explained that Replace doesn't evaluate the \
expression between replacements. Replace doesn't have a holding attribute, so \
it's arguments evaluate before doing replacements. The demonstration and \
explanation below is based on an example Allan Hayes once provided.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(rls = {a1 + b2 \[Rule] baab, b1 + b2 \[Rule] b12, 
          a1 \[Rule] b1};\)\), "\[IndentingNewLine]", 
    \(\(a2 = b2;\)\), "\[IndentingNewLine]", 
    \(\(h[b1 + b2] = bb;\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[h[a1 + a2], rls, {1, 2}]\)], "Input"],

Cell[BoxData[
    \(h[b12]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The important parts of evaluation above are as follows:\nThe first \
argument of Replace evaluates as  h[a1+a2]\[LongRightArrow]h[a1+b2]  since \
(a2=b2).\nNext Replace starts replacements at the deepest level, so the first \
replacement used on  h[a1+b2] is (a1\[Rule]b1) resulting in  h[b1+b2].  No \
evaluation is conducted until Replacements are finished.  Moving up a level \
the replacement (b1+b2\[LongRightArrow]b12) is used and resuts in  h[b12] \
which is the final expression.  Notice we had h[b1+b2] after the first \
replacement, but the definition for h[b1+b2] wasn't used.  Once replacements \
started nothing evaluated until all replacements were finished.\n\n",
  ButtonBox["ReplaceAll and ReplaceRepeated",
    ButtonData:>"ReplaceAll;ReplaceRepeated",
    ButtonStyle->"Hyperlink"],
  " make replacements starting at the top level and work down, but Replace is \
different since it starts replacements at the deeper levels and works it's \
way up.\n\nThe next input shows how you can easily see the order that Replace \
tries replacements on different parts of an expression."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[
      h[f1[a1], \(f2[e]\)[a2]], \((a_ /; Print[a] \[RuleDelayed] 
          0)\), {0, \[Infinity]}]\)], "Input"],

Cell[BoxData[
    \(a1\)], "Print"],

Cell[BoxData[
    \(f1[a1]\)], "Print"],

Cell[BoxData[
    \(b2\)], "Print"],

Cell[BoxData[
    \(\(f2[e]\)[b2]\)], "Print"],

Cell[BoxData[
    \(h[f1[a1], \(f2[e]\)[b2]]\)], "Print"],

Cell[BoxData[
    \(h[f1[a1], \(f2[e]\)[b2]]\)], "Output"]
}, Closed]],

Cell["\<\
Replace makes replacements starting at the deepest level, so in the next cell \
Log[x] is changed to Log[a x].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(Replace[\@x + 2  x\^3 - Log[x]\/y, {x \[Rule] a\ x, 
        Log[x] \[Rule] Log[x + 1]}, {0, \[Infinity]}]\)\)\)], "Input"],

Cell[BoxData[
    \(2\ a\^3\ x\^3 + \@\(a\ x\) - Log[a\ x]\/y\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Since ",
  ButtonBox["ReplaceAll",
    ButtonData:>"ReplaceAll;ReplaceRepeated",
    ButtonStyle->"Hyperlink"],
  " starts making replacements at the highest level, Log[x] in the next cell \
is changed to Log[x+1]."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(\@x + 2  x\^3 - Log[x]\/y /. {x \[Rule] a\ x, 
        Log[x] \[Rule] Log[x + 1]}\)\)\)], "Input"],

Cell[BoxData[
    \(2\ a\^3\ x\^3 + \@\(a\ x\) - Log[1 + x]\/y\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
Replace has a 'Heads' option which controls whether it consideres making \
replacements on the heads of expressions.  The default setting is (Heads\
\[Rule]False).  The next cell shows the order that different parts of the \
expression are considered for replacement when replacing heads is allowed.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Replace[
      h[f1[a1], \(f2[e]\)[a2]], \((a_ /; Print[a] \[RuleDelayed] 
          0)\), {0, \[Infinity]}, Heads \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(h\)], "Print"],

Cell[BoxData[
    \(f1\)], "Print"],

Cell[BoxData[
    \(a1\)], "Print"],

Cell[BoxData[
    \(f1[a1]\)], "Print"],

Cell[BoxData[
    \(f2\)], "Print"],

Cell[BoxData[
    \(e\)], "Print"],

Cell[BoxData[
    \(f2[e]\)], "Print"],

Cell[BoxData[
    \(b2\)], "Print"],

Cell[BoxData[
    \(\(f2[e]\)[b2]\)], "Print"],

Cell[BoxData[
    \(h[f1[a1], \(f2[e]\)[b2]]\)], "Print"],

Cell[BoxData[
    \(h[f1[a1], \(f2[e]\)[b2]]\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ReplaceAll, ReplaceRepeated", "Section"],

Cell["The next cell demonstrates the basic use of ReplaceAll.", "Text",
  CellTags->"ReplaceAll;ReplaceRepeated"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, y];\)\), "\[IndentingNewLine]", 
    \(\(expr = y + Sin[x];\)\), "\[IndentingNewLine]", 
    \(expr /. y \[Rule] 4\)}], "Input"],

Cell[BoxData[
    \(4 + Sin[x]\)], "Output"]
}, Closed]],

Cell["\<\
Evaluation of the previous cell doesn't change the value of (y) or (expr).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({y, expr}\)], "Input"],

Cell[BoxData[
    \({y, y + Sin[x]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "If we provide a list of rules or delayed rules on the right side of \
ReplaceAll several replacements are made.  The difference between \
(lhs\[Rule]rhs) and (lhs\[RuleDelayed]rhs) is covered in the section on ",
  ButtonBox["Rule instead of RuleDelayed",
    ButtonData:>"Rule;RuleDelayed",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. {x \[Rule] \[Pi]\/4, y \[Rule] 5}\)], "Input"],

Cell[BoxData[
    \(5 + 1\/\@2\)], "Output"]
}, Closed]],

Cell["\<\
ReplaceAll considers a list of rules starting from the left.  In the next \
cell the rule (y\[Rule]5) is used and the symbol (y) is no longer in the \
expression.  As a result the rules (y\[Rule]3) and (y\[Rule]4) are not \
used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. {y \[Rule] 5, y \[Rule] 3, y \[Rule] 4}\)], "Input"],

Cell[BoxData[
    \(5 + Sin[x]\)], "Output"]
}, Closed]],

Cell["\<\
If we provide a list of lists of replacement rules on the right side of \
ReplaceAll we get a list of results from making several sets of replacements.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. {{x \[Rule] 1, y \[Rule] 2}, {x \[Rule] 5, 
          y \[Rule] 6}, {x \[Rule] 12, y \[Rule] 13}}\)], "Input"],

Cell[BoxData[
    \({2 + Sin[1], 6 + Sin[5], 13 + Sin[12]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Any combination of pattern matching constructs can be used on the left \
side of rules.  The next cell gives a non-trivial example.  Nuances of ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " are discussed in another section."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(\@x + 4\ z\^2 + z\^3 - Log[x]\/y\^2 /. 
      c_. *s_Symbol^n_Integer \[RuleDelayed] c*n*s^\((n - 1)\)\)\)\)], "Input"],

Cell[BoxData[
    \(\@x + 8\ z + 3\ z\^2 + \(2\ Log[x]\)\/y\^3\)], "Output"]
}, Closed]],

Cell["\<\
Once ReplaceAll changes a part of an expression no further replacements are \
made on that portion of the expression or any of it's subparts.  For example \
the rule in the next cell is used once on each logrithm.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Log[d\ p\ q\ r] Log[a\ b\ c\ d] /. 
      Log[x_\ \ y_] \[RuleDelayed] Log[x] + Log[y]\)], "Input"],

Cell[BoxData[
    \(\((Log[a] + Log[b\ c\ d])\)\ \((Log[d] + Log[p\ q\ r])\)\)], "Output"]
}, Closed]],

Cell["\<\
ReplaceRepeated works just like ReplaceAll except it continues trying the \
rules until the result no longer changes.  In the next cell ReplaceRepeated \
fully expands each logrithm.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Log[d\ p\ q\ r] Log[a\ b\ c\ d] //. 
      Log[x_\ y_] \[RuleDelayed] Log[x] + Log[y]\)], "Input"],

Cell[BoxData[
    \(\((Log[a] + Log[b] + Log[c] + Log[d])\)\ \((Log[d] + Log[p] + Log[q] + 
          Log[r])\)\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["The order of matching patterns and making replacements", "Subsection"],

Cell["\<\
If we put a Print statment at the right place we can see the order that the \
pattern matcher considers different parts of an expression for replacement.  \
Notice the Print statement never returns True, so nothing can match the \
pattern, but each pattern considered is printed.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(h[f1[a1], \(f2[e]\)[a2]] /. \((a_ /; Print[a] \[RuleDelayed] 
          0)\)\)}], "Input"],

Cell[BoxData[
    \(h[f1[a1], \(f2[e]\)[a2]]\)], "Print"],

Cell[BoxData[
    \(h\)], "Print"],

Cell[BoxData[
    \(f1[a1]\)], "Print"],

Cell[BoxData[
    \(f1\)], "Print"],

Cell[BoxData[
    \(a1\)], "Print"],

Cell[BoxData[
    \(\(f2[e]\)[a2]\)], "Print"],

Cell[BoxData[
    \(f2[e]\)], "Print"],

Cell[BoxData[
    \(f2\)], "Print"],

Cell[BoxData[
    \(e\)], "Print"],

Cell[BoxData[
    \(a2\)], "Print"],

Cell[BoxData[
    \(h[f1[a1], \(f2[e]\)[a2]]\)], "Output"]
}, Closed]],

Cell["\<\
Since ReplaceAll starts making replacements at the highest level, Log[x] in \
the next cell is changed to Log[x+1].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(\@x + 2  x\^3 - Log[x]\/y /. {x \[Rule] a\ x, 
        Log[x] \[Rule] Log[x + 1]}\)\)\)], "Input"],

Cell[BoxData[
    \(2\ a\^3\ x\^3 + \@\(a\ x\) - Log[1 + x]\/y\)], "Output"]
}, Closed]],

Cell[TextData[{
  ButtonBox["Replace",
    ButtonData:>"Replace",
    ButtonStyle->"Hyperlink"],
  " makes replacements starting at the deepest level, so in the next cell \
Log[x] is changed to Log[a x]."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(Replace[\@x + 2  x\^3 - Log[x]\/y, {x \[Rule] a\ x, 
        Log[x] \[Rule] Log[x + 1]}, {0, \[Infinity]}]\)\)\)], "Input"],

Cell[BoxData[
    \(2\ a\^3\ x\^3 + \@\(a\ x\) - Log[a\ x]\/y\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we can see (expr/.rules) evaluates (expr), then it \
evaluates (rules), it makes the replacements without evaluating the new \
results.  A new expression is returned ",
  Cell[BoxData[
      \(TraditionalForm\`\((2\^2 + 7)\)\)]],
  " in this case, and this new expression is allowed to evaluate to 11."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(expr = x + y; \ 
    rules = {x \[RuleDelayed] 2\^2, 
        y \[RuleDelayed] 7};\), "\[IndentingNewLine]", 
    \(Trace[expr /. rules]\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{"{", 
          RowBox[{
            TagBox["expr",
              HoldForm], ",", 
            TagBox[\(x + y\),
              HoldForm]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{
            TagBox["rules",
              HoldForm], ",", 
            TagBox[\({x \[RuleDelayed] 2\^2, y \[RuleDelayed] 7}\),
              HoldForm]}], "}"}], ",", 
        TagBox[\(x + y /. \[InvisibleSpace]{x \[RuleDelayed] 2\^2, 
              y \[RuleDelayed] 7}\),
          HoldForm], ",", 
        TagBox[\(2\^2 + 7\),
          HoldForm], ",", 
        RowBox[{"{", 
          RowBox[{
            TagBox[\(2\^2\),
              HoldForm], ",", 
            TagBox["4",
              HoldForm]}], "}"}], ",", 
        TagBox[\(4 + 7\),
          HoldForm], ",", 
        TagBox["11",
          HoldForm]}], "}"}]], "Output"]
}, Closed]],

Cell[TextData[{
  "In the next cell we can see (expr//.rules) evaluates (expr), then it \
evaluates (rules).  The first replacement made is  ",
  Cell[BoxData[
      \(TraditionalForm\`Log[\[ExponentialE]\^5\ a\ b]\ \
\[LongRightArrow]\((Log[\[ExponentialE]\^5] + Log[a\ b]\ )\)\)]],
  "  and ",
  Cell[BoxData[
      \(TraditionalForm\`Log[\[ExponentialE]\^5]\)]],
  " evaluates to 5.  Then the replacement rule is used again to change Log[a \
b] to  (Log[a]+Log[b] )."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(expr = Log[\(\[ExponentialE]\^5\) a\ b] Log[c\ d]; 
    rules = {Log[x_\ \ y_] \[RuleDelayed] 
          Log[x] + Log[y]};\), "\[IndentingNewLine]", 
    \(Trace[expr //. rules]\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{"{", 
          RowBox[{
            TagBox["expr",
              HoldForm], ",", 
            TagBox[\(Log[c\ d]\ Log[a\ b\ \[ExponentialE]\^5]\),
              HoldForm]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{
            TagBox["rules",
              HoldForm], ",", 
            TagBox[\({Log[x_\ y_] \[RuleDelayed] Log[x] + Log[y]}\),
              HoldForm]}], "}"}], ",", 
        TagBox[\(Log[c\ d]\ Log[
                a\ b\ \[ExponentialE]\^5] //. \[InvisibleSpace]{Log[
                  x_\ y_] \[RuleDelayed] Log[x] + Log[y]}\),
          HoldForm], ",", 
        RowBox[{"{", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{
                RowBox[{"{", 
                  RowBox[{
                    RowBox[{"{", 
                      RowBox[{
                        TagBox[\(Log[\[ExponentialE]\^5]\),
                          HoldForm], ",", 
                        TagBox["5",
                          HoldForm]}], "}"}], ",", 
                    TagBox[\(Log[b] + 5\),
                      HoldForm], ",", 
                    TagBox[\(5 + Log[b]\),
                      HoldForm]}], "}"}], ",", 
                TagBox[\(Log[a] + \((5 + Log[b])\)\),
                  HoldForm], ",", 
                TagBox[\(Log[a] + 5 + Log[b]\),
                  HoldForm], ",", 
                TagBox[\(5 + Log[a] + Log[b]\),
                  HoldForm]}], "}"}], ",", 
            TagBox[\(\((Log[c] + Log[d])\)\ \((5 + Log[a] + Log[b])\)\),
              HoldForm], ",", 
            TagBox[\(\((5 + Log[a] + Log[b])\)\ \((Log[c] + Log[d])\)\),
              HoldForm]}], "}"}], ",", 
        TagBox[\(\((5 + Log[a] + Log[b])\)\ \((Log[c] + Log[d])\)\),
          HoldForm]}], "}"}]], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ReplacePart", "Section"],

Cell[TextData[{
  "The ",
  ButtonBox["ReplacePart",
    ButtonStyle->"RefGuideLink"],
  " function is well documented.  Below I give useful function that uses \
ReplacePart."
}], "Text"],

Cell[BoxData[
    \(SwapParts[expr_, pos1_, 
        pos2_] := \[IndentingNewLine]\(ReplacePart[#, #, {pos1, pos2}, {pos2, 
              pos1}] &\)[expr]\)], "Input"],

Cell["\<\
In the next cell I make a matrix and I swap the parts at positions {1,2} and \
{3,2}.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(mtrx = {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}, {41, 
            42, 43, 44}};\)\(\n\)
    \)\ \), "\[IndentingNewLine]", 
    \(SwapParts[mtrx, {1, 2}, {3, 2}]\)}], "Input"],

Cell[BoxData[
    \({{11, 32, 13, 14}, {21, 22, 23, 24}, {31, 12, 33, 34}, {41, 42, 43, 
        44}}\)], "Output"]
}, Closed]],

Cell["In the next cell I swap the first row with the third row.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(SwapParts[mtrx, {1}, {3}]\)], "Input"],

Cell[BoxData[
    \({{31, 32, 33, 34}, {21, 22, 23, 24}, {11, 12, 13, 14}, {41, 42, 43, 
        44}}\)], "Output"]
}, Closed]],

Cell["\<\
Next I demonstrate that SwapParts can work with arbitrary expressions as well \
as matrices.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, y, z];\)\), "\[IndentingNewLine]", 
    \(demo = \((2  x - Sqrt[3 + y^2])\)/\((\(-4\) + z^2)\)\)}], "Input"],

Cell[BoxData[
    \(\(2\ x - \@\(3 + y\^2\)\)\/\(z\^2 - 4\)\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(SwapParts[demo, {1, 2}, {2, 1, 2}]\)], "Input"],

Cell[BoxData[
    \(\(2\ x + z\^2\)\/\(\(-\@\(3 + y\^2\)\) - 4\)\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["RotateRight, RotateLeft", "Section"],

Cell["\<\
RotateRight and RotateLeft can be used on an expression that doesn't have the \
head List.  In the two cells below the arguments of an expression are rotated \
two places to the right and two places to the left.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\n", 
    \(RotateRight[foo[a, b, c, d, e, f, g, h], 2]\)}], "Input"],

Cell[BoxData[
    \(foo[g, h, a, b, c, d, e, f]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(RotateRight[foo[a, b, c, d, e, f, g, h], \(-2\)]\)], "Input"],

Cell[BoxData[
    \(foo[c, d, e, f, g, h, a, b]\)], "Output"]
}, Closed]],

Cell["\<\
Normally RotateRight and RotateLeft are used on a simple list and the second \
argument (if present) is normally an integer.  However, the second argument \
can be a list of integers.  First consider the tensor (m2) below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m2 = {\[IndentingNewLine]{{a1, a2, a3}, {b1, b2, b3}, {c1, c2, 
              c3}}, \[IndentingNewLine]{{d1, d2, d3}, {e1, e2, e3}, {f1, f2, 
              f3}}, \[IndentingNewLine]{{g1, g2, g3}, {h1, h2, h3}, {i1, i2, 
              i3}}\[IndentingNewLine]};\)\), "\n", 
    \(MatrixForm[m2]\)}], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"a1"},
                    {"a2"},
                    {"a3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"b1"},
                    {"b2"},
                    {"b3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"c1"},
                    {"c2"},
                    {"c3"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"d1"},
                    {"d2"},
                    {"d3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"e1"},
                    {"e2"},
                    {"e3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"f1"},
                    {"f2"},
                    {"f3"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"g1"},
                    {"g2"},
                    {"g3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"h1"},
                    {"h2"},
                    {"h3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"i1"},
                    {"i2"},
                    {"i3"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{a1, a2, a3}, {b1, b2, b3}, {c1, c2, c3}}, {{d1, d2, 
        d3}, {e1, e2, e3}, {f1, f2, f3}}, {{g1, g2, g3}, {h1, h2, h3}, {i1, 
        i2, i3}}}]]], "Output"]
}, Closed]],

Cell["\<\
First the default case for RotateRight is demonstrated on the above tensor.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(RotateRight[m2]\)\(//\)\(MatrixForm\)\(\ \)\)\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"g1"},
                    {"g2"},
                    {"g3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"h1"},
                    {"h2"},
                    {"h3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"i1"},
                    {"i2"},
                    {"i3"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"a1"},
                    {"a2"},
                    {"a3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"b1"},
                    {"b2"},
                    {"b3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"c1"},
                    {"c2"},
                    {"c3"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"d1"},
                    {"d2"},
                    {"d3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"e1"},
                    {"e2"},
                    {"e3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"f1"},
                    {"f2"},
                    {"f3"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{g1, g2, g3}, {h1, h2, h3}, {i1, i2, i3}}, {{a1, a2, 
        a3}, {b1, b2, b3}, {c1, c2, c3}}, {{d1, d2, d3}, {e1, e2, e3}, {f1, 
        f2, f3}}}]]], "Output"]
}, Closed]],

Cell["\<\
In the cell below we see the default case is equivalent to a few values for \
the second argument.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(RotateRight[m2] === RotateRight[m2, {1}] === 
      RotateRight[m2, {1, 0}] === \n\tRotateRight[m2, {1, 0, 0}]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
When the second argument is {0,1} or {0,1,0} the second level is rotated one \
place.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(RotateRight[m2, {0, 1}] // MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"c1"},
                    {"c2"},
                    {"c3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"a1"},
                    {"a2"},
                    {"a3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"b1"},
                    {"b2"},
                    {"b3"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"f1"},
                    {"f2"},
                    {"f3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"d1"},
                    {"d2"},
                    {"d3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"e1"},
                    {"e2"},
                    {"e3"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"i1"},
                    {"i2"},
                    {"i3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"g1"},
                    {"g2"},
                    {"g3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"h1"},
                    {"h2"},
                    {"h3"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{c1, c2, c3}, {a1, a2, a3}, {b1, b2, b3}}, {{f1, f2, 
        f3}, {d1, d2, d3}, {e1, e2, e3}}, {{i1, i2, i3}, {g1, g2, g3}, {h1, 
        h2, h3}}}]]], "Output"]
}, Closed]],

Cell["\<\
When the second argument is {0,0,1} the third level is rotated one place.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(RotateRight[m2, {0, 0, 1}] // MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"a3"},
                    {"a1"},
                    {"a2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"b3"},
                    {"b1"},
                    {"b2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"c3"},
                    {"c1"},
                    {"c2"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"d3"},
                    {"d1"},
                    {"d2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"e3"},
                    {"e1"},
                    {"e2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"f3"},
                    {"f1"},
                    {"f2"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"g3"},
                    {"g1"},
                    {"g2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"h3"},
                    {"h1"},
                    {"h2"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"i3"},
                    {"i1"},
                    {"i2"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{a3, a1, a2}, {b3, b1, b2}, {c3, c1, c2}}, {{d3, d1, 
        d2}, {e3, e1, e2}, {f3, f1, f2}}, {{g3, g1, g2}, {h3, h1, h2}, {i3, 
        i1, i2}}}]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Rule (\[Rule])  versus  RuleDelayed (\[RuleDelayed])\
\>", "Section"],

Cell["\<\
A good application of RuleDelayed (\[RuleDelayed]) is in the following line. \
Here RuleDelayed (\[RuleDelayed]) must be used instead of Rule (\[Rule]) \
since Factor must not evaluate until it is given the argument of Log.\
\>", "Text",
  CellTags->"Rule;RuleDelayed"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\((1 + 2\ x + x\^2)\) Log[24 + 26  x + 9  x\^2 + x\^3] /. 
      Log[a_] :> Log[Factor[a]]\)}], "Input"],

Cell[BoxData[
    \(\((1 + 2\ x + 
          x\^2)\)\ Log[\((2 + x)\)\ \((3 + x)\)\ \((4 + x)\)]\)], "Output"]
}, Closed]],

Cell["\<\
The function below will modify any expression so all approximate numbers that \
are equal to an integer are converted to the equivalent integer.  In this \
case RuleDelayed (\[RuleDelayed]) must be used instead of Rule (\[Rule]) \
since the rule must not evaluate until it has an actual value to operate \
on.\
\>", "Text"],

Cell[BoxData[
    \(RealToInteger[expr_] := 
      expr /. \n\t\tx_Real :> If[Round[x] == x, Round[x], x]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(\ \)\(E\^\(5.0\ x\) + 1.34\/\(4.0 + x\) // 
      RealToInteger\)\)\)], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^\(5\ x\) + 1.34`\/\(4 + x\)\)], "Output"]
}, Closed]],

Cell["\<\
Another for using (lhs\[RuleDelayed]rhs) instead of (lhs\[Rule]rhs) is when \
(lhs) includes named patterns. Named patterns can include (x_), (x__), \
(opts___), (m_:4) (j_Integer), (t_?Positive), (n_.) and many other forms. To \
demonstrate how use of (lhs\[Rule]rhs) can cause problems consider the input \
in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x = 34;\)\), "\[IndentingNewLine]", 
    \(Log[\((a1 + a2)\) \((b1 + b2\ )\) \((c1 + c2)\)] /. 
      Log[x_\ \ \ y_] -> Log[x] + Log[y]\)}], "Input"],

Cell[BoxData[
    \(Log[34] + Log[\((b1 + b2)\)\ \((c1 + c2)\)]\)], "Output"]
}, Closed]],

Cell["\<\
In the cell above the global value of (x) was used where we wanted (a1+a2) to \
go.  Most often the problem is much more subtle than in the example above. \
Typically the variable used to name the pattern had a value assigned long \
before you use it in (lhs\[Rule]rhs). One method sure to avoid this problem \
is to clear the values from any variables used to name patterns as in the \
next cell. This of course requires that you don't have values assigned to (x) \
or (y) that you care about.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(Log[\((a1 + a2)\) \((b1 + b2\ )\) \((c1 + c2)\)] /. 
      Log[x_\ \ \ y_] -> Log[x] + Log[y]\)}], "Input"],

Cell[BoxData[
    \(Log[a1 + b2] + Log[\((b1 + b2)\)\ \((c1 + c2)\)]\)], "Output"]
}, Closed]],

Cell["\<\
Another, often more desirable, method of avoiding the error above is to use \
(lhs\[RuleDelayed]rhs) instead of (lhs\[Rule]rhs).  This is done in the next \
cell, and the value assigned to (x) doesn't prevent us from getting the right \
result.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x = 34;\)\), "\[IndentingNewLine]", 
    \(Log[\((a1 + a2)\) \((b1 + b2\ )\) \((c1 + c2)\)] /. 
      Log[x_\ \ \ y_] \[RuleDelayed] Log[x] + Log[y]\)}], "Input"],

Cell[BoxData[
    \(Log[a1 + b2] + Log[\((b1 + b2)\)\ \((c1 + c2)\)]\)], "Output"]
}, Closed]],

Cell["\<\
The only time when using (lhs\[RuleDelayed]rhs) might not work very well is \
when you can save a lot of time by evaluating (rhs) only once.  An example of \
this is given in the next cell where a complicated integral must be evaluated \
each time (g2) is used. It's much more efficient to evaluate the integral \
only once.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g2 = g[x_] \[RuleDelayed] Integrate[Log[\@x + 1], x]\)], "Input"],

Cell[BoxData[
    \(g[x_] \[RuleDelayed] \[Integral]Log[\@x + 
              1] \[DifferentialD]x\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In that case you might want to use the next cell where any values assigned \
to (x) are cleared, and the integral is evaluated immediately using (lhs\
\[Rule]rhs). It's also possible to get the best of both worlds where (rhs) \
evaluates immediately as in the next cell, and gives the right result even if \
(x) has an assigned value!  To do that you need to use a package I make \
available at  ",
  ButtonBox["http://library.wolfram.com/database/MathSource/425",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/MathSource/425"], None},
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(g2 = g[x_] \[Rule] Integrate[Log[\@x + 1], x]\)}], "Input"],

Cell[BoxData[
    \(g[x_] \[Rule] \@x - x\/2 - Log[1 + \@x] + x\ Log[1 + \@x]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Scan", "Section"],

Cell["\<\
Suppose we have a list of expressions which in the example below is a simple \
list of integers.  Now suppose we need to define a function (f) for each \
element of this list. The best way to make the assignments is using Scan.  A \
first attempt at this is given in the next cell.\
\>", "Text",
  CellTags->"Scan"],

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(lst = {12, 24, 35, 46};\)\), "\n", 
    \(Scan[f[#] = Prime[10^7 + #] &, lst]\)}], "Input"],

Cell["\<\
Next we see that our attempt to make assingments for (f) didn't work, and the \
reason is that assignment (f[#]=Prime[10^7+#]&) evaluated before it was give \
integers.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242474919-8383725"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[#1] = Prime[10\^7 + #1] &\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242474919-8383725"]
}, Closed]],

Cell["\<\
The solution is to make the assignment a function with the HoldAll or \
HoldFirst attribute as I do in the next cell.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(Scan[Function[n, f[n] = Prime[10^7 + n], {HoldAll}], lst]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242474919-9355181"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[12] = 179424871\)},
                {" "},
                {\(f[24] = 179425019\)},
                {" "},
                {\(f[35] = 179425261\)},
                {" "},
                {\(f[46] = 179425517\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242474919-9355181"]
}, Closed]],

Cell["\<\
We could have made the above assingments using Map as I do in the next cell.  \
In this case Map makes a list of prime numbers that would be returned if it \
were not for the semi-colon at the end.  Using Scan for this task is more \
efficient than using Map because Scan never builds up an expression to \
return.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(Map[Function[n, f[n] = Prime[10^7 + n], {HoldAll}], 
        lst];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242474920-7316245"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[12] = 179424871\)},
                {" "},
                {\(f[24] = 179425019\)},
                {" "},
                {\(f[35] = 179425261\)},
                {" "},
                {\(f[46] = 179425517\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242474920-7316245"]
}, Closed]],

Cell["\<\
The next example makes assingments for  f[g1[5,3]],  f[g2[8,9]],  and  \
f[g3[12,13]].  \
\>", "Text"],

Cell[BoxData[{
    \(\(expr = h[g1[5, 3], g2[8, 9], g3[12, 13]];\)\), "\n", 
    \(\(ClearAll[f];\)\), "\n", 
    \(Scan[Function[a, f[a] = a\^4, {HoldAll}], expr]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242474920-3777955"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[g1[5, 3]] = g1[5, 3]\^4\)},
                {" "},
                {\(f[g2[8, 9]] = g2[8, 9]\^4\)},
                {" "},
                {\(f[g3[12, 13]] = g3[12, 13]\^4\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242474920-3777955"]
}, Closed]],

Cell[TextData[{
  "However, what we got above might not be the desired result. What if you \
wanted to make assignments for f[5], f[3], f[8], etc. In that case we can get \
the desired result by giving Scan the level specification {2}.  Scan then \
makes assingments for all subexpressions of (expr) at level 2.  Scan can work \
with any of the ",
  ButtonBox["level specifications",
    ButtonData:>"Level Specification",
    ButtonStyle->"Hyperlink"],
  " that I exaplain earlier."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(Scan[Function[a, f[a] = a\^4, {HoldAll}], expr, {2}]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242474920-7649147"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[3] = 81\)},
                {" "},
                {\(f[5] = 625\)},
                {" "},
                {\(f[8] = 4096\)},
                {" "},
                {\(f[9] = 6561\)},
                {" "},
                {\(f[12] = 20736\)},
                {" "},
                {\(f[13] = 28561\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242474920-7649147"]
}, Closed]],

Cell[CellGroupData[{

Cell["Heads Option", "Subsection"],

Cell["\<\
Scan has a Heads option with the default setting (Heads\[Rule]True).  In the \
next example I have Scan work on level {2} of expr with the setting (Heads\
\[Rule]True).  Because of the (Heads\[Rule]True) setting assignments are made \
for f[g1], f[g2], f[g3] where g1, g2, g3 are heads of sub-expressions of \
(expr).\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(Scan[Function[a, f[a] = "\<$\>" <> ToString[a], {HoldAll}], expr, {2}, 
      Heads \[Rule] True]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? f\)], "Input"],

Cell["Global`f", "Print",
  CellTags->"Info3242474920-1486452"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(f[3] = "$3"\)},
                {" "},
                {\(f[5] = "$5"\)},
                {" "},
                {\(f[8] = "$8"\)},
                {" "},
                {\(f[9] = "$9"\)},
                {" "},
                {\(f[12] = "$12"\)},
                {" "},
                {\(f[13] = "$13"\)},
                {" "},
                {\(f[g1] = "$g1"\)},
                {" "},
                {\(f[g2] = "$g2"\)},
                {" "},
                {\(f[g3] = "$g3"\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "f"],
      Editable->False]], "Print",
  CellTags->"Info3242474920-1486452"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Sequence", "Section"],

Cell["\<\
The head Sequence is rarely seen in directly.  Consider the function (f) \
below, where the first two arguments are p1,and p2, and all the remaining \
arguments are part of p3.  All the remaining arguments go with p3 because the \
definition of (f) uses BlankSequence (___) for p3.  The only thing the \
function (f) does is return p3.  One might wonder what head is given to p3.  \
It turns out it is given the head Sequence. After (f) is defined, we use it \
to make the Sequence (seq).\
\>", "Text",
  CellTags->"Sequence"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, foo, h];\)\), "\[IndentingNewLine]", 
    \(\(f[p1_, p2_, p3__] := p3;\)\), "\[IndentingNewLine]", 
    \(seq = f[9, 10, 11, 12, 13, 14, 15]\)}], "Input"],

Cell[BoxData[
    \(Sequence[11, 12, 13, 14, 15]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "If you have a number of sequences inside almost any head the sequences are \
automatically flattened, and the fact that the arguments are a sequence is \
not indicated (see the example in the next line).  The only functions that \
don't splice the sequences together are those with the Attribute ",
  ButtonBox["SequenceHold",
    ButtonData:>"SequenceHold",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({Sequence[2, 3, 4, Sequence[7, 8]]}\)], "Input"],

Cell[BoxData[
    \({2, 3, 4, 7, 8}\)], "Output"]
}, Closed]],

Cell["\<\
Most useful applications of Sequence are variations of the next cell where \
the head (h) is changed to Sequence and the effect is that h[7,11,13] is \
changed to (7,11,13).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(foo[2, 3, 5, h[7, 11, 13], 17] /. h \[Rule] Sequence\)], "Input"],

Cell[BoxData[
    \(foo[2, 3, 5, 7, 11, 13, 17]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["SequenceHold", "Section"],

Cell["Question:  What does the Attribute SequenceHold do for you?", "Text",
  CellTags->"SequenceHold"],

Cell["\<\
Answer:  Rule (\[Rule]) has the SequenceHold Attribute.  As a result a rule \
such as the one in the next line can be used.  If Rule didn't have the \
SequenceHold Attribute  Rule[y,Sequence[y1,y2,y3]]
would evaluate to  Rule[y, y1, y2, y3]  which is an invalid expression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \({x, y, z} /. y -> Sequence[y1, \ y2, \ y3]\)}], "Input"],

Cell[BoxData[
    \({x, y1, y2, y3, z}\)], "Output"]
}, Closed]],

Cell["\<\
Nine built in commands have the SequenceHold Attribute.  They are:
Rule (\[Rule]), RuleDelayed (\[RuleDelayed]), Set (=), SetDelayed (:=), \
TagSet, TagSetDelayed, Timing, UpSet (:=), UpSetDelayed (^:=)\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Series", "Section"],

Cell[TextData[{
  "The typical method of finding a series expansion is to enter the complete \
expression as in  ",
  StyleBox["Series[(x+2)Sin[x],{x,0,5}]", "Input"],
  ". or  ",
  Cell[BoxData[
      \(TraditionalForm\`Series[Log[x\^2 + x], {x, 1, 3}]\)]],
  ".  A seldom documented trick is to get the same series expansions using \
the cells below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\((x + 2)\)\ Sin[\ x] + O[x]\^5\)}], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{\(2\ x\), "+", \(x\^2\), "-", \(x\^3\/3\), "-", \(x\^4\/6\), 
        "+", 
        InterpretationBox[\(O[x]\^5\),
          SeriesData[ x, 0, {}, 1, 5, 1]]}],
      SeriesData[ x, 0, {2, 1, 
        Rational[ -1, 3], 
        Rational[ -1, 6]}, 1, 5, 1]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Log[x\^2 + x] + O[x, 1]\^4\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{\(Log[2]\), "+", \(\(3\ \((x - 1)\)\)\/2\), 
        "-", \(5\/8\ \((x - 1)\)\^2\), "+", \(3\/8\ \((x - 1)\)\^3\), "+", 
        InterpretationBox[\(O[x - 1]\^4\),
          SeriesData[ x, 1, {}, 0, 4, 1]]}],
      SeriesData[ x, 1, {
        Log[ 2], 
        Rational[ 3, 2], 
        Rational[ -5, 8], 
        Rational[ 3, 8]}, 0, 4, 1]]], "Output"]
}, Closed]],

Cell["\<\
You can often use Series to find an asymptotic expansion provided one exists \
for the function in question.  An asymptotic expansion is one where the error \
gets smaller as the argument approaches infinity.  Series will try to find an \
asthmatic expansion if you ask for a series about infinity.  The next cell \
gives an asthmatic expansion of Erfc[x].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Series[Erfc[x], {x, \[Infinity], 6}]\)], "Input"],

Cell[BoxData[
    RowBox[{\(\[ExponentialE]\^\(-x\^2\)\), " ", 
      RowBox[{"(", 
        InterpretationBox[
          
          RowBox[{\(1\/\(\@\[Pi]\ x\)\), 
            "-", \(\((1\/x)\)\^3\/\(2\ \@\[Pi]\)\), 
            "+", \(\(3\ \((1\/x)\)\^5\)\/\(4\ \@\[Pi]\)\), "+", 
            InterpretationBox[\(O[1\/x]\^7\),
              SeriesData[ x, 
                DirectedInfinity[ 1], {}, 1, 7, 1]]}],
          SeriesData[ x, 
            DirectedInfinity[ 1], {
            Power[ Pi, 
              Rational[ -1, 2]], 0, 
            Times[ 
              Rational[ -1, 2], 
              Power[ Pi, 
                Rational[ -1, 2]]], 0, 
            Times[ 
              Rational[ 3, 4], 
              Power[ Pi, 
                Rational[ -1, 2]]]}, 1, 7, 1]], ")"}]}]], "Output"]
}, Closed]],

Cell["The next cell gives an asthmatic expansion of ArcTan[x]. ", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Series[ArcTan[x], {x, \[Infinity], 6}]\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{\(\[Pi]\/2\), "-", \(1\/x\), "+", \(1\/3\ \((1\/x)\)\^3\), 
        "-", \(1\/5\ \((1\/x)\)\^5\), "+", 
        InterpretationBox[\(O[1\/x]\^7\),
          SeriesData[ x, 
            DirectedInfinity[ 1], {}, 0, 7, 1]]}],
      SeriesData[ x, 
        DirectedInfinity[ 1], {
        Times[ 
          Rational[ 1, 2], Pi], -1, 0, 
        Rational[ 1, 3], 0, 
        Rational[ -1, 5]}, 0, 7, 1]]], "Output"]
}, Closed]],

Cell["\<\
It turns out you must first use TrigToExp  to get an asymptotic expansion of \
ArcSinnh[x].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Series[TrigToExp[ArcSinh[x]], {x, \[Infinity], 6}]\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{\((Log[2] - Log[1\/x])\), "+", \(1\/4\ \((1\/x)\)\^2\), 
        "-", \(3\/32\ \((1\/x)\)\^4\), "+", \(5\/96\ \((1\/x)\)\^6\), "+", 
        InterpretationBox[\(O[1\/x]\^7\),
          SeriesData[ x, 
            DirectedInfinity[ 1], {}, 0, 7, 1]]}],
      SeriesData[ x, 
        DirectedInfinity[ 1], {
        Plus[ 
          Log[ 2], 
          Times[ -1, 
            Log[ 
              Power[ x, -1]]]], 0, 
        Rational[ 1, 4], 0, 
        Rational[ -3, 32], 0, 
        Rational[ 5, 96]}, 0, 7, 1]]], "Output"]
}, Closed]],

Cell[TextData[{
  "You may need to make a power series in two or three variables and truncate \
it such that the sum of all exponents in each term is less than or equal to a \
certain integer.  If that is the case download a package I have posted at  ",
  ButtonBox["http://library.wolfram.com/infocenter/MathSource/4950/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/MathSource/4950/"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Set (=)  versus  SetDelayed (:=)", "Section"],

Cell["\<\
Alan Hayes provided an example where (  func[x_]=  ) instead of  
( func[x]:=  ) should be used.  If ( func[x_]:=  ) was used in this example
the least squares fit would be computed  again for every value of (x).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(data = 
        Table[{x, Cos[x] + Random[]/10}, {x, 0, \[Pi]/3, 0.025}];\)\), "\n", 
    \(curve[x_] = Fit[data, {1, x, x\^2}, x]\)}], "Input"],

Cell[BoxData[
    \(\(\(1.0407147343273468`\)\(\[InvisibleSpace]\)\) - 
      0.050835041799088786`\ x - 0.3970583602652394`\ x\^2\)], "Output"]
}, Closed]],

Cell["\<\
In the following line Alan uses \"Epilog->Point/@data\"  to ensure the data \
points
are drawn along with a Plot of the curve.  For this application it makes 
little difference whether Epilog or Prolog is used.\
\>", "Text"],

Cell[BoxData[
    \(\(Plot[curve[t], {t, 0, \[Pi]/3}, 
        Epilog -> Point /@ data];\)\)], "Input"],

Cell["\<\
In the following example (expr) is not a polynomial in (x) until (expr) is \
evaluated.  So we have to use Set (=) to have the function perform as \
intended. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = 1 + x + x\^2;\)\), "\n", 
    \(fun1[x_] := expr\), "\n", 
    \(fun1[E]\)}], "Input"],

Cell[BoxData[
    \(1 + x + x\^2\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\(fun2[x_] = expr;\)\), "\n", 
    \(fun2[E]\)}], "Input"],

Cell[BoxData[
    \(1 + \[ExponentialE] + \[ExponentialE]\^2\)], "Output"]
}, Closed]],

Cell["\<\
In the next example the right hand side can't evaluate until x is given a \
numeric value, so we have to use Set (=).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(area[x_?NumericQ] /; \((x > 0)\) := 
      NIntegrate[Log[t]/\((Exp[t] + 1)\), {t, 1, x}]\), "\n", 
    \({area[1], area[2], area[3], area[4]}\)}], "Input"],

Cell[BoxData[
    \({0.`, 0.06341880240374535`, 0.13226976495416617`, 
      0.16959898132979162`}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example evaluation of (deriv1[expr]) starts with substituting the \
value of (expr) for (x) in the definition of deriv1[x_].  Next the Derivative \
is evaluated, and all is well as (expr) does not have a numeric value.  When \
the argument of ( deriv1 )  is a numeric value the value is substituted for \
(x) in the definition of (deriv1), and a Derivative with respect to a \
constant is not defined.  As a result (deriv1) doesn't work for numeric \
arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(deriv1[x_] := D[x\^3, x]\), "\n", 
    \({deriv1[a], deriv1[\[Pi]]}\)}], "Input"],

Cell[BoxData[
    \({3\ a\^2, \[PartialD]\_\[Pi] \[Pi]\^3}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell the definition of (deriv2) differs from the definition of \
(deriv1) in that Set (=) is used rather than SetDelayed (:=).  Here the \
Derivative is only evaluated  when (deriv2) is defined.  The new function  \
(deriv2) gives the expected result for symbolic or numeric arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\(deriv2[x_] = D[x\^3, x];\)\), "\n", 
    \({deriv2[b], deriv2[\[Pi]]}\)}], "Input"],

Cell[BoxData[
    \({3\ b\^2, 3\ \[Pi]\^2}\)], "Output"]
}, Closed]],

Cell["\<\
Notice the definition of (deriv1) involves the Derivative operation, but the \
definition of (deriv2) does not.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?deriv1\)\)], "Input"],

Cell["Global`deriv1", "Print",
  CellTags->"Info3242474922-7671367"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(deriv1[x_] := \[PartialD]\_x x\^3\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "deriv1"],
      Editable->False]], "Print",
  CellTags->"Info3242474922-7671367"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?deriv2\)\)], "Input"],

Cell["Global`deriv2", "Print",
  CellTags->"Info3242474922-1117472"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(deriv2[x_] = 3\ x\^2\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "deriv2"],
      Editable->False]], "Print",
  CellTags->"Info3242474922-1117472"]
}, Closed]],

Cell["\<\
In the next two lines a Cumulative Distribution Function is defined.  For  \
CDF1 SetDelayed (:=) must be used because NIntegrate can not evaluate until \
we have a numerical value for both limits (upper and lower).  On the other \
hand CDF2 is defined using Set (=).  In this case SetDelayed (:=) could have \
been used but this would be far less efficient.  When CDF2 is defined using \
Set (=) the symbolic integration is only performed when CDF2 is defined.  If \
CDF2 was defined using SetDelayed (:=) the symbolic integration would be \
performed every time CDF2[_] is evaluated.\
\>", "Text"],

Cell[BoxData[
    \(CDF1[a_?NumericQ] := \n
      NIntegrate[\((\(\(-2\)\ E\^\(\(-2\)\ x\)\)\/\(EulerGamma + Log[2]\))\) 
          Log[x], {x, 0, a}]\)], "Input"],

Cell[BoxData[{
    \(\(Clear[a];\)\), "\[IndentingNewLine]", 
    \(\(CDF2[a_] = 
        Integrate[\((\(\(-2\)\ E\^\(\(-2\)\ x\)\)\/\(EulerGamma + Log[2]\))\) 
            Log[x], {x, 0, a}];\)\)}], "Input"],

Cell["\<\
The next example is from the FAQ section of the Wolfram Research web page.  \
When ( f1[n_] ) is defined using Set (=)  Expand has no effect because Expand \
makes no change if the exponent is not a positive integer.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[n];\)\), "\[IndentingNewLine]", 
    \(\(f1[n_Integer] = Expand[\((x + 1)\)\^n];\)\), "\n", 
    \(f1[5]\)}], "Input"],

Cell[BoxData[
    \(\((1 + x)\)\^5\)], "Output"]
}, Closed]],

Cell["\<\
On the other hand ( f2[n_] ) is defined using SetDelayed (:=), and
Expand does not evaluate until the exponent has an integer value.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(f2[n_Integer] := Expand[\((x + 1)\)\^n]\), "\n", 
    \(f2[5]\)}], "Input"],

Cell[BoxData[
    \(1 + 5\ x + 10\ x\^2 + 10\ x\^3 + 5\ x\^4 + x\^5\)], "Output"]
}, Closed]],

Cell[TextData[{
  "A different perspective on explaining Set versus SetDelayed is give in the \
notebook posted at  ",
  ButtonBox["http://library.wolfram.com/infocenter/MathSource/425/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/MathSource/425/"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[CellGroupData[{

Cell["A warning about named patterns in lhs when using (lhs=rhs)", \
"Subsection"],

Cell["\<\
One must be careful about using (lhs=rhs) when (lhs) includes named patterns \
and the pattern name is needed in (rhs).  Named patterns can include (x_), \
(x__), (opts___), (m_:4) (j_Integer), (t_?Positive), (n_.) and many other \
forms. When the variable used to name the pattern is used in (rhs) the global \
value of the variable is used in (rhs).  The next two cells demonstrate the \
problem.\
\>", "Text"],

Cell[BoxData[{
    \(\(x = 47;\)\), "\[IndentingNewLine]", 
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(f[x_] = x + Log[x];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1/6]\)], "Input"],

Cell[BoxData[
    \(47 + Log[47]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Above we see the global value of (x) is used instead of 0.125 to compute \
f[x].  An easy way to avoid the problem is to clear any symbols used to name \
patterns when the patterns are needed on the left side.  Below we can be sure \
that the definition will work as intended because any Global values were \
cleared from x.  This obviously requires that the variables used to name \
patterns have no variables that you care about.  Another solution that \
doesn't have this limitation is available from my ",
  StyleBox["MathSource",
    FontSlant->"Italic"],
  " item at  ",
  ButtonBox["http://library.wolfram.com/database/MathSource/425",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/MathSource/425"], None},
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[f, x];\)\), "\[IndentingNewLine]", 
    \(\(f[x_] = x + Log[x];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[1/6]\)], "Input"],

Cell[BoxData[
    \(1\/6 - Log[6]\)], "Output"]
}, Closed]],

Cell["\<\
However, you can use the symbol used to name a pattern variable on the left \
side of (=) with out problems.  Below the global value of (x) doesn't prevent \
us from getting the intended result.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(\(x = 47;\)\), "\n", 
    \(\(f[x_] /; \((x < 0)\) = \(-1\);\)\), "\n", 
    \(\(f[0] = 0;\)\), "\n", 
    \(\(f[x_] /; \((x > 0)\) = 1;\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \({f[\(-4\)], f[0], f[5], f[50]}\)], "Input"],

Cell[BoxData[
    \({\(-1\), 0, 1, 1}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Evaluation of (lhs=rhs)", "Subsection"],

Cell["\<\
The next cell causes (g) to evaluate to (h) and causes (h) to evaluate to 9. \
As a result both (g) and (h) evaluate to 9.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(g = h;\)\), "\[IndentingNewLine]", 
    \(\(h = 9;\)\), "\[IndentingNewLine]", 
    \({g, h}\)}], "Input"],

Cell[BoxData[
    \({9, 9}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell (g=0) is evaluated and the value of zero is assigned to (g) \
without letting (g) evaluate.  As a result (g) evaluates 0 but (h) still \
evaluates to 9.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(g = 0;\)\), "\[IndentingNewLine]", 
    \({g, h}\)}], "Input"],

Cell[BoxData[
    \({0, 9}\)], "Output"]
}, Closed]],

Cell["\<\
From the examples above it appears (lhs) in (lhs=rhs) doesn't evaluate and \
that is the case if MatchQ[Unevaluated[lhs],_Symbol] would return True. \
However, it isn't that simple if Unevaluated[lhs] isn't a Symbol. To \
demonstrate this consider the next cell where both (h[2]) and (g[2]) return \
9.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[g, h];\)\), "\n", 
    \(\(g = h;\)\), "\n", 
    \(\(h[2] := 9;\)\), "\n", 
    \({g[2], h[2]}\)}], "Input"],

Cell[BoxData[
    \({9, 9}\)], "Output"]
}, Closed]],

Cell["\<\
Now when the next cell is evaluated (g[1+Tan[\[Pi]/2]]) partially evaluates \
prior to assigning the value 0 to something. First (g) evaluates to (h). Then \
(1+Tan[\[Pi]/4]) evaluates to (2). The last thing to happen is that 0 is \
assigned to h[2].  The first argument is held in the sense that h[2] doesn't \
evaluate to 9. If that happened this example would end up with 9=0 which is \
nonsense. A user defined function with the (HoldFirst) attribute will not \
work this way unless complicated definitions are used to ensure that it does.\
\
\>", "Text"],

Cell[BoxData[
    \(\(g[1 + Tan[\[Pi]/4]] = 0;\)\)], "Input"],

Cell["\<\
Now when g[2] is evaluated (g) evaluates to (h) and h[2] evaluates to 0.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(g[2]\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Closed]],

Cell["\<\
Below we see that the new assignment is associated with (h) not with (g).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?g\)\)], "Input"],

Cell["Global`g", "Print",
  CellTags->"Info3284968730-3180209"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(g = h\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "g"],
      Editable->False]], "Print",
  CellTags->"Info3284968730-3180209"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?h\)\)], "Input"],

Cell["Global`h", "Print",
  CellTags->"Info3284968732-8841380"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {GridBox[{
                {\(h[2] = 0\)}
                },
              GridBaseline->{Baseline, {1, 1}},
              ColumnWidths->0.999,
              ColumnAlignments->{Left}]}
          },
        GridBaseline->{Baseline, {1, 1}},
        ColumnAlignments->{Left}],
      Definition[ "h"],
      Editable->False]], "Print",
  CellTags->"Info3284968732-8841380"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Simplify & FullSimplify", "Section"],

Cell[CellGroupData[{

Cell["Consider a special ComplexityFunction", "Subsection"],

Cell["\<\
One might like the following to simplify to 1-Exp[-x], and we would like \
FullSimplify[Log[10^20]] to return (20 Log[10]) which FullSimplify does by \
default.\
\>", "Text",
  CellTags->"Simplify_FullSimplify"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, a];\)\), "\[IndentingNewLine]", 
    \(FullSimplify[1 - Cosh[x] + Sinh[x]]\)}], "Input"],

Cell[BoxData[
    \(1 - Cosh[x] + Sinh[x]\)], "Output"]
}, Closed]],

Cell["\<\
The definitions in the next cell define a new setting for the \
ComplexityFunction that does the trick.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[DigitsLength, Digits1, Digits2, VariableCount];\)\), "\n", 
    \(\(DigitsLength[0 | 1] = 1/10;\)\), "\n", 
    \(\(DigitsLength[\(-1\)] = 1/8;\)\), "\n", 
    \(\(DigitsLength[n_] := Length[IntegerDigits[n]]*2;\)\), "\n", 
    \(\(Digits1[expr_] := 
        Plus @@ \((\(DigitsLength[#] &\) /@ 
              Cases[expr, _Integer, \(-1\)])\);\)\), "\n", 
    \(\(Digits2[expr_] := 
        Plus @@ Flatten[\[IndentingNewLine]Map[
              DigitsLength[#] &, \((\({Numerator[#], Denominator[#]} &\)\  /@ 
                  Cases[expr, _Rational, {\(-1\)}])\), {\(-1\)}\
\[IndentingNewLine]]\[IndentingNewLine]];\)\), "\n", 
    \(\(\(VariableCount[expr_] := 
      Count[expr, _Symbol?\((Not[
                NumericQ[#]] &)\), {\(-1\)}]\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(SetOptions[FullSimplify, 
        ComplexityFunction \[Rule] \((LeafCount[#] + Digits1[#] + 
                Digits2[#] + \((33/10)\)*
                  VariableCount[#] &)\)];\)\)}], "Input"],

Cell["\<\
In the next cell we see that using the new setting for ComplexityFunction \
FullSimplify does what we want.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FullSimplify[1 - Cosh[x] + Sinh[x]]\)], "Input"],

Cell[BoxData[
    \(1 - \[ExponentialE]\^\(-x\)\)], "Output"]
}, Closed]],

Cell["\<\
The next example is taken from the Help Browser. In this case the new setting \
for ComplexityFunction gives the same result we get using ComplexityFunction\
\[Rule]Automatic.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(n = 
        70017833065954769132658110933808716053755043900310001;\)\), "\n", 
    \(FullSimplify[Log[n]]\)}], "Input"],

Cell[BoxData[
    \(5\ Log[20001] + 7\ Log[30001]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see that when using the new setting for \
ComplexityFunction FullSimplify still does a nice job of simplifying a \
complicated algebraic expression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FullSimplify[
      x\^3\ Cot[a\^2] - 
        1\/4\ Csc[
            a\^2]\ \((4\ \[ExponentialE]\^\(\[ImaginaryI]\ a\^2\)\ x\^3 + 
              Sin[a\^2]\ \((2\ \[ImaginaryI]\ \((2\ a\^2 - \[Pi])\)\ x + \(4\ \
\[ImaginaryI]\ \[ExponentialE]\^\(\(-2\)\ \[ImaginaryI]\ x\^2\)\ \[Pi]\ x\)\/\
\(1 + \[ExponentialE]\^\(\(-2\)\ \[ImaginaryI]\ x\^2\)\) + \(8\ \[ImaginaryI]\
\ \[ExponentialE]\^\(2\ \[ImaginaryI]\ \((a\^2 + x\^2)\)\)\ x\ \((a\^2 + \
x\^2)\)\)\/\(1 - \[ExponentialE]\^\(2\ \[ImaginaryI]\ \((a\^2 + x\^2)\)\)\) + 
                    4\ a\^2\ x\ Cot[a\^2 + x\^2] - 
                    2\ \[Pi]\ x\ Tan[
                        x\^2])\))\)\[IndentingNewLine]]\)], "Input"],

Cell[BoxData[
    \(x\^3\ Cot[a\^2 + x\^2]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A simple problem Simplify & FullSimplify can't handle", "Subsection"],

Cell["\<\
J\[UDoubleDot]rgen Tischer sent a problem to the MathGroup that Simplify \
couldn't simplify very well.  Simplify has trouble with the example in the \
next cell for the same reason as the more complicated example \
J\[UDoubleDot]rgen Tischer provided.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[n];\)\), "\[IndentingNewLine]", 
    \(Simplify[5 \((20\^n)\) + 7 \((20\^n)\)]\)}], "Input"],

Cell[BoxData[
    \(4\^n\ 5\^\(1 + n\) + 7\ 20\^n\)], "Output"]
}, Closed]],

Cell["\<\
The code in the next cell forces Simplify to make the appropriate \
simplification.  This is based on a very clever solution Allan Hayes sent to \
the MathGroup.\
\>", "Text"],

Cell[BoxData[{
    \(\(Unprotect[Simplify];\)\), "\n", 
    \(\(\(HiddenSymbols`ModifySimplify = True;\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(Simplify[expr_] /; HiddenSymbols`ModifySimplify := 
      Block[{HiddenSymbols`ModifySimplify}, \[IndentingNewLine]Module[{temp}, \
\[IndentingNewLine]Simplify[\[IndentingNewLine]Factor[
                expr /. \((n_Integer)\)^\((k_)\) \[RuleDelayed] \
\[IndentingNewLine]\((Times @@ \(\((temp[First[#]]^\((k*Last[\ #])\) &)\) /@ 
                          FactorInteger[n]\))\)\[IndentingNewLine]] /. 
              temp[a_] \[RuleDelayed] 
                a\[IndentingNewLine]]\[IndentingNewLine]]\[IndentingNewLine]]\
\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(Protect[Simplify];\)\)}], "Input"],

Cell["\<\
After evaluating the previous cell Simplify does better with the example \
above.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Simplify[5 \((20\^n)\) + 7 \((20\^n)\)]\)], "Input"],

Cell[BoxData[
    \(3\ 4\^\(1 + n\)\ 5\^n\)], "Output"]
}, Closed]],

Cell[TextData[{
  "One might wonder why ",
  Cell[BoxData[
      \(\((12\ \((20\^n)\))\)\)]],
  " isn't returned in the output above.  The reason is that the kernel \
insists on changing ",
  Cell[BoxData[
      \(\((12\ \((20\^n)\))\)\)]],
  " into ",
  Cell[BoxData[
      \(\((3\ \(4\^\(1 + n\)\) 5\^n)\)\)]],
  ".  You can use a function I defined called HoldTemporary which prevents \
further evaluation of an expression, but does not have to have a hold \
released when used in the future. Through use of HoldTemporary one can have \
the output above displayed as ",
  Cell[BoxData[
      \(\((12\ \ 20\^n\ )\)\)]],
  ".  I have a package which defines HoldTemporary posted at  ",
  ButtonBox["http://library.wolfram.com/infocenter/MathSource/705",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/MathSource/705"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Slot, SlotSequence  (#, #n, ##, ##n)", "Section"],

Cell[TextData[{
  "The discussion of (#, #n, ##, ##n) was expanded and moved to the section \
on ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"Pure Functions"]
}, Closed]],

Cell[CellGroupData[{

Cell["Sort", "Section"],

Cell["\<\
By default Sort arranges items in cannonical order rather than numerical \
order. This is reasonable because some or all of the elements may not have a \
numeric value. If all elements of a list have the heads Integer, Rational, or \
Real the cannanocal ordering is a numerical ordering. In the next cell some \
elements of the list don't have the head Integer, Rational or Real and the \
elements aren't sorted numerically even though they could be sorted \
numerically.\
\>", "Text",
  CellTags->"Sort"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sort[{\(-2\), 4, \(-5\), 
        Sin[2], \[Pi], \(-\[Infinity]\), \[Infinity]}]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{\(-5\), ",", \(-2\), ",", "4", ",", "\[Pi]", ",", 
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]], ",", \(Sin[2]\)}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
You can provide Sort a second argument which specifies how elements should be \
compared when they are sorted. In the next cell Less is used as an ordering \
function and the list is sorted numerically. Of course you would get the list \
in opposite order if the ordering function Greater was used. However, Allan \
Hayes has pointed out in the MathGroup that Sort is much slower when an \
ordering function is specified. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sort[{\(-2\), 4, \(-5\), Sin[2], \[Pi], \(-\[Infinity]\), \[Infinity]}, 
      Less]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", \(-5\), ",", \(-2\), ",", \(Sin[2]\), 
        ",", "\[Pi]", ",", "4", ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]]}], "}"}]], "Output"]
}, Closed]],

Cell[TextData[{
  "The ordering function (#1<#2&) has the same effect as the ordering \
function Less, but is more cryptic. In this case there isn't a good reason to \
use the more cryptic ordering function, but in more complicated cases the \
cryptic notation is harder to avoid. If you aren't familiar with the #& \
notation see the section on ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sort[{\(-2\), 4, \(-5\), 
        Sin[2], \[Pi], \(-\[Infinity]\), \[Infinity]}, #1 < #2 &]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        InterpretationBox[\(-\[Infinity]\),
          DirectedInfinity[ -1]], ",", \(-5\), ",", \(-2\), ",", \(Sin[2]\), 
        ",", "\[Pi]", ",", "4", ",", 
        InterpretationBox["\[Infinity]",
          DirectedInfinity[ 1]]}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
Suppose you have the matrix created by the next cell and you want to sort the \
rows according to the value in a certain row of the matrix. The next cell \
makes such a matrix we can use as an example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mtrx = 
        Table[{Random[Integer, {0, 10}], \n\tRandom[Integer, {50, 60}], \n\t
            Random[Integer, {\(-10\), 0}]}, {i, 8}];\)\), "\n", 
    \(TableForm[mtrx]\)}], "Input",
  FontSize->12],

Cell[BoxData[
    TagBox[GridBox[{
          {"6", "52", \(-9\)},
          {"6", "53", \(-2\)},
          {"9", "57", \(-3\)},
          {"4", "50", \(-7\)},
          {"8", "53", \(-7\)},
          {"3", "56", \(-7\)},
          {"7", "55", \(-8\)},
          {"10", "56", \(-5\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the next cell the matrix is sorted according to the value in the first \
column.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m2 = Sort[mtrx];\)\), "\[IndentingNewLine]", 
    \(TableForm[m2]\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"3", "56", \(-7\)},
          {"4", "50", \(-7\)},
          {"6", "52", \(-9\)},
          {"6", "53", \(-2\)},
          {"7", "55", \(-8\)},
          {"8", "53", \(-7\)},
          {"9", "57", \(-3\)},
          {"10", "56", \(-5\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
If we want to sort the matrix according to the value in the second column we \
can use the ordering function  (#1[[2]]<#2[[2]]&) as in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m2 = 
        Sort[mtrx, #1[\([2]\)] < #2[\([2]\)] &];\)\), "\[IndentingNewLine]", 
    \(TableForm[m2]\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"4", "50", \(-7\)},
          {"6", "52", \(-9\)},
          {"8", "53", \(-7\)},
          {"6", "53", \(-2\)},
          {"7", "55", \(-8\)},
          {"10", "56", \(-5\)},
          {"3", "56", \(-7\)},
          {"9", "57", \(-3\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[TextData[{
  "The code in the next cell effectively sorts the matrix on the second \
column. In this case each row is rotated before using Sort. Then Sort can be \
used without an ordering function. After the matrix is sorted the columns are \
put back in the original order. Sort evaluates ",
  StyleBox["much faster",
    FontWeight->"Bold"],
  " this time because an ordering function wasn't specified. When given a \
matrix with thousands of rows this method is about 18 times faster even after \
accounting for the time to rotate each column before and after sorting."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(m2 = 
        Sort[\(RotateLeft[#, 1] &\) /@ mtrx];\)\), "\[IndentingNewLine]", 
    \(\(m2 = \(RotateRight[#, 1] &\) /@ m2;\)\), "\[IndentingNewLine]", 
    \(TableForm[m2]\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"4", "50", \(-7\)},
          {"6", "52", \(-9\)},
          {"8", "53", \(-7\)},
          {"6", "53", \(-2\)},
          {"7", "55", \(-8\)},
          {"3", "56", \(-7\)},
          {"10", "56", \(-5\)},
          {"9", "57", \(-3\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
Sort can work with any expression. In the next cell Sort takes an expression \
with the head (h).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[h];\)\), "\[IndentingNewLine]", 
    \(Sort[h[2, 6, 3, 8, 5, 6, 8, 1, 0, 3]]\)}], "Input"],

Cell[BoxData[
    \(h[0, 1, 2, 3, 3, 5, 6, 6, 8, 8]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Split", "Section"],

Cell["\<\
The usage message for Split and demonstrations of it are shown in the next \
few cells.\
\>", "Text",
  CellTags->"Split"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Split\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Split[list] splits list into sublists consisting of runs of \
identical elements. Split[list, test] treats pairs of adjacent elements as \
identical whenever applying the function test to them yields True.\"\>", " ", 
      
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Split",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242474961-5860318"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(Split[{a, a, b, b, b, b, a, b, a, a, b, b, b, a}]\)}], "Input"],

Cell[BoxData[
    \({{a, a}, {b, b, b, b}, {a}, {b}, {a, a}, {b, b, b}, {a}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Many of the most useful applications of Split require providing Split a \
test function as a second argument. In the next cell Slit Split considers two \
adjacent elements of (lst) \"identical\" if they are both less than 100 or if \
they are both greater or equal to 100. For an explanation of the # & notation \
see the discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(lst = {10, 11, 100, 234, 648, 467, 12, 13, 14, 356, 15, 16, 
          457};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(Split[lst, #1 < 100 === #2 < 100 &]\)}], "Input"],

Cell[BoxData[
    \({{10, 11}, {100, 234, 648, 467}, {12, 13, 14}, {356}, {15, 
        16}, {457}}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell sorts (lst) and returns a list of lists where the first sublist \
is the elements between 0, 10. The second sublist is the elements between 10 \
and 20. The third and fourth sublists are the elements from 20 to 30 and from \
30 to 40.\
\>", "Text"],

Cell[CellGroupData[{

Cell["\<\
lst={8.06833, 32.1809, 20.357, 22.7313, 38.2098, 48.3307, 
 34.9967, 13.2429, 24.3229, 1.89359, 41.7259, 10.4685, 
 26.4448, 41.3348, 46.9688};
 
Split[Sort[lst],Floor[#1/10]===Floor[#2/10]&]\
\>", "Input"],

Cell[BoxData[
    \({{1.89359`, 8.06833`}, {10.4685`, 13.2429`}, {20.357`, 22.7313`, 
        24.3229`, 26.4448`}, {32.1809`, 34.9967`, 38.2098`}, {41.3348`, 
        41.7259`, 46.9688`, 48.3307`}}\)], "Output"]
}, Closed]],

Cell["\<\
Finally Split can be used on expressions that don't have the head List.  This \
is demonstrated in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Split[h[a, a, b, b, b, b, a, b, a, a, b, b, b, a]]\)], "Input"],

Cell[BoxData[
    \(h[h[a, a], h[b, b, b, b], h[a], h[b], h[a, a], h[b, b, b], 
      h[a]]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Subscript (using subscripted symbols)", "Section"],

Cell[TextData[{
  "I wrote a package that makes it very easy to do switch back an forth \
between treating subscripts as symbols and not.  The package is largely based \
on code samples discussed here and the package can be downloaded from  ",
  ButtonBox["http://library.wolfram.com/database/MathSource/4268",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/MathSource/4268"], None},
    ButtonStyle->"Hyperlink"],
  ". \n\nThe next line is a slight variation of a tip David Bailey sent to \
the MathGroup.  Using this code an 'a' with a non-negative integer subscript \
evaluates to a symbol where the character 'a' is concatenated with the \
symbol."
}], "Text",
  Hyphenation->False],

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(a\_\(i_?\((IntegerQ[#] && NonNegative[#] &)\)\) := 
      Symbol[ToString[a] <> ToString[i]]\)}], "Input"],

Cell["\<\
Now in the next line the first three in the list are symbols, and all the \
rest are subscript expressions.  \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ \ {a\_0, \ a\_1, \ a\_2, \ a\_b, \ a\_\(1/2\)}\)], "Input"],

Cell[BoxData[
    \({Symbol, Symbol, Symbol, Subscript, Subscript}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "If this approach is used you must avoid using both ",
  Cell[BoxData[
      \(TraditionalForm\`{a\_1, \ a\_2, \ a\_3}\)]],
  " and {a1, a2, a3} as symbols, since the former will evaluate to the \
latter.  This is demonstrated in the next cell."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({a\_1, \ a\_1 === a1}\)], "Input"],

Cell[BoxData[
    \({a1, True}\)], "Output"]
}, Closed]],

Cell["\<\
The next line shows that the rule above is stored in DownValues[Subscript].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DownValues[Subscript]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[
          a\_\(i_?\((IntegerQ[#1] && NonNegative[#1] &)\)\)] \[RuleDelayed] 
        Symbol[ToString[a] <> ToString[i]]}\)], "Output"]
}, Closed]],

Cell["Before continuing the above DownValue is cleared.", "Text"],

Cell[BoxData[
    \(\(DownValues[Subscript] = {};\)\)], "Input"],

Cell[CellGroupData[{

Cell[TextData[{
  "Colin Rose gave the following examples where Subscripts can be used in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Version 4 without using the notation palette."
}], "Subsection",
  Hyphenation->False],

Cell[CellGroupData[{

Cell[BoxData[
    \(z = Thread[Subscript[y, Range[12]]]\)], "Input"],

Cell[BoxData[
    \({y\_1, y\_2, y\_3, y\_4, y\_5, y\_6, y\_7, y\_8, y\_9, y\_10, y\_11, 
      y\_12}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(z /. Subscript[y, x_] \[RuleDelayed] y^x\)], "Input"],

Cell[BoxData[
    \({y, y\^2, y\^3, y\^4, y\^5, y\^6, y\^7, y\^8, y\^9, y\^10, y\^11, 
      y\^12}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(% /. y^x_. \  \[RuleDelayed] Subscript[y, x]\)], "Input"],

Cell[BoxData[
    \({y\_1, y\_2, y\_3, y\_4, y\_5, y\_6, y\_7, y\_8, y\_9, y\_10, y\_11, 
      y\_12}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(z /. Subscript[y, t_] \[RuleDelayed] Subscript[y, t - 1]\)], "Input"],

Cell[BoxData[
    \({y\_0, y\_1, y\_2, y\_3, y\_4, y\_5, y\_6, y\_7, y\_8, y\_9, y\_10, 
      y\_11}\)], "Output"]
}, Closed]],

Cell["\<\
In v4, you can generally use subscripted \"variables\" as if they were \
symbols.  The examples below work fine.\
\>", "Text",
  Hyphenation->False],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(expr = y\_1 + y\_2;\)\), "\n", 
    \(Solve[expr \[Equal] 2, y\_\(\(1\)\(\ \)\)]\)}], "Input"],

Cell[BoxData[
    \({{y\_1 \[Rule] 2 - y\_2}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Integrate[expr, y\_1]\)], "Input"],

Cell[BoxData[
    \(y\_1\%2\/2 + y\_1\ y\_2\)], "Output"]
}, Closed]],

Cell[BoxData[
    \(\(Plot3D[Sin[y\_1 + y\_2], {y\_1, 0, 3}, {y\_2, 0, 3}];\)\)], "Input"],

Cell[TextData[{
  "The most common problem occurs when people simultaneously try to use \n(x) \
and ",
  Cell[BoxData[
      \(TraditionalForm\`x\_1, \ x\_2, \ \(\(etc\)\(.\)\)\)]],
  "  In that case if one uses (x=7) then  ",
  Cell[BoxData[
      \(TraditionalForm\`x\_1\  \[Rule] \ 7\_1\ , \ 
      x\_2\  \[Rule] \ 7\_2\)]],
  " .  This sort of problem is easily avoided by NOT simultaneously using x \
with ",
  Cell[BoxData[
      \(TraditionalForm\`x\_1, x\_2, \  ... \)]]
}], "Text",
  Hyphenation->False]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Carl Woll indicated we can give Subscript the attribute HoldFirst. As in the \
example below.\
\>", "Subsection",
  Hyphenation->False],

Cell[BoxData[{
    \(\(ClearAll[Subscript];\)\), "\n", 
    \(\(SetAttributes[Subscript, HoldFirst];\)\)}], "Input"],

Cell[TextData[{
  "Now we can have symbols  t,  ",
  Cell[BoxData[
      \(TraditionalForm\`t\_1\)],
    SingleLetterItalics->False],
  " without conflict."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t = 34;\)\), "\[IndentingNewLine]", 
    \(t\_1\)}], "Input"],

Cell[BoxData[
    \(t\_1\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[t\_1, {t\_1, 5}]\)], "Input"],

Cell[BoxData[
    \({1, 2, 3, 4, 5}\)], "Output"]
}, Closed]],

Cell[BoxData[
    \(ClearAll[Subscript]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Collin Rose also indicated use of Symbolize button in the notation palette \
can result in problems as in the following example.\
\>", "Subsection"],

Cell[BoxData[
    \(Needs["\<Utilities`Notation`\>"]\)], "Input"],

Cell[BoxData[{
    RowBox[{
      RowBox[{"Symbolize", "[", 
        TagBox[\(m\_1\),
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], "]"}], ";"}], "\n", 
    RowBox[{
      RowBox[{"Symbolize", "[", 
        TagBox[\(m\_2\),
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], "]"}], ";"}], "\n", 
    RowBox[{
      RowBox[{"Symbolize", "[", 
        TagBox[\(m\_3\),
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], "]"}], ";"}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(z1 = {m\_1, m\_2, m\_3};\)\), "\[IndentingNewLine]", 
    \(Head /@ z1\)}], "Input"],

Cell[BoxData[
    \({Symbol, Symbol, Symbol}\)], "Output"]
}, Closed]],

Cell["So far we don't have a problem.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(z2 = Table[m\_i, {i, 3}]\)], "Input"],

Cell[BoxData[
    \({m\_1, m\_2, m\_3}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ z2\)], "Input"],

Cell[BoxData[
    \({Subscript, Subscript, Subscript}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "We now have two sets of \"identical\" notation in use.  We have ",
  Cell[BoxData[
      \(TraditionalForm\`m\_2\)]],
  " as a Symbol in z1, and  ",
  Cell[BoxData[
      \(TraditionalForm\`m\_2\)]],
  " as subscript expression in z2.  However, the elements in z1 and z2 look \
the same on screen.  One must be careful to make sure this doesn't happen.\n\n\
The steps used above to make ",
  Cell[BoxData[
      \(TraditionalForm\`{m\_1, \ m\_2, \ m\_3}\)]],
  " symbols can be undone by using the RemoveSymbolize button in the \
FullNotation palette.  It's under Symbolizations, StandardForm Symbolize."
}], "Text",
  Hyphenation->False],

Cell[BoxData[{
    RowBox[{
      RowBox[{"RemoveSymbolize", "[", 
        TagBox[\(m\_1\),
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], " ", "]"}], 
      ";"}], "\[IndentingNewLine]", 
    RowBox[{
      RowBox[{"RemoveSymbolize", "[", 
        TagBox[\(m\_2\),
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], " ", "]"}], 
      ";"}], "\[IndentingNewLine]", 
    RowBox[{
      RowBox[{"RemoveSymbolize", "[", 
        TagBox[\(m\_3\),
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], " ", "]"}], ";"}]}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
  "Allan Hayes suggested the following to symbolize ALL subscript objects.  \
Below we see that this will cause even ",
  Cell[BoxData[
      \(TraditionalForm\`\(Log[3]\)\_\(\(\ \)\(a\)\)\)]],
  " to have the head Symbol.  It's hard to imagine why one would use such a \
form, so this may be of little concern."
}], "Subsection",
  Hyphenation->False],

Cell[BoxData[
    \(Needs["\<Utilities`Notation`\>"]\)], "Input"],

Cell[BoxData[
    RowBox[{"Symbolize", "[", 
      TagBox[\(\(\(_\)\(\ \)\)\__\),
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ \ {a\_b, \ t\_2, \ \(Log[3]\)\_a}\)], "Input"],

Cell[BoxData[
    \({Symbol, Symbol, Symbol}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "After using the code above to treat anything with any type of a subscript \
as a Symbol the use of Table below doesn't return the list ",
  Cell[BoxData[
      \(TraditionalForm\`{x\_\(\(1\)\(\ \)\), \ x\_\(\(2\)\(\ \)\), \ 
        x\_\(\(3\)\(\ \)\), \ x\_4}\)]],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[x\_i, {i, 4}]\)], "Input"],

Cell[BoxData[
    \({x\_i, x\_i, x\_i, x\_i}\)], "Output"]
}, Closed]],

Cell["\<\
Before we continue we might want to remove the rule that makes anything with \
a subscript a symbol.  The line after RemoveSymbolize demonstrates that the \
rule was in fact removed.\
\>", "Text"],

Cell[BoxData[
    RowBox[{"RemoveSymbolize", "[", 
      TagBox[\(\(\(_\)\(\ \)\)\__\),
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ Table[a\_i, {i, 4}]\)], "Input"],

Cell[BoxData[
    \({Subscript, Subscript, Subscript, Subscript}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
A modification of code Jason Harris sent to the MathGroup is given below. \
\>", "Subsection"],

Cell[TextData[{
  "One variation of code Jason Harris sent to the MathGroup is shown below.  \
The version below will treat (i) with a non-negative integer subscript as a \
symbol, but (i) with any other subscript is treated as a Subscript \
expression.  This requires the use of some advanced features of the Notation \
palette.  Documentation can be found at ",
  ButtonBox["Notation:Definition:NotationPatternTag",
    ButtonStyle->"AddOnsLink"],
  " under Add-ons in the Help Browser."
}], "Text",
  Hyphenation->False],

Cell[BoxData[
    \(Needs["\<Utilities`Notation`\>"]\)], "Input"],

Cell[BoxData[{
    RowBox[{\(i\_\(n_?\((IntegerQ[#] && NonNegative[#] &)\)\) := 
        ToExpression[MakeBoxes[i\_n]]\), "\[IndentingNewLine]", " "}], "\n", 
    RowBox[{\(IntegerTest[n_] := 
        ToExpression[n, StandardForm, IntegerQ[#] && NonNegative[#] &]\), 
      "\[IndentingNewLine]", " "}], "\n", 
    RowBox[{
      RowBox[{"Symbolize", "[", 
        TagBox[
          SubscriptBox["i", 
            TagBox[\(_?IntegerTest\),
              NotationPatternTag,
              TagStyle->"NotationPatternWrapperStyle"]],
          NotationBoxTag,
          TagStyle->"NotationTemplateStyle"], "]"}], "\[IndentingNewLine]", 
      " "}], "\n", \(i\_\(n_?\((IntegerQ[#] && NonNegative[#] &)\)\) := 
      ToExpression[MakeBoxes[i\_n]]\)}], "Input"],

Cell["\<\
Now (i) with a positive integer subscript is an symbol, while (i) with any \
other subscript is a subscript expression.\
\>", "Text",
  Hyphenation->False],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ {i\_2, i\_\(-3\), i\_a, i\_1.2, i\_\[Pi], 
        i\_\(2/3\)}\)], "Input"],

Cell[BoxData[
    \({Symbol, Subscript, Subscript, Subscript, Subscript, 
      Subscript}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Below ",
  Cell[BoxData[
      \(TraditionalForm\`i\_n\)]],
  " is an expression rather than a Symbol, so the list ",
  Cell[BoxData[
      \(TraditionalForm\`{\ i\_\(\(0\)\(\ \)\), \ i\_\(\(1\)\(\ \)\), \ 
        i\_\(\(2\)\(\ \ \)\), \ i\_\(\(3\)\(\ \)\)}\)]],
  "  is returned."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst = Table[i\_n, {n, 0, 3}]\)], "Input"],

Cell[BoxData[
    \({i\_0, i\_1, i\_2, i\_3}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ lst\)], "Input"],

Cell[BoxData[
    \({Symbol, Symbol, Symbol, Symbol}\)], "Output"]
}, Closed]],

Cell[BoxData[
    RowBox[{"\[FilledSquare]", "  ", 
      StyleBox["How",
        FontFamily->"Times New Roman",
        FontWeight->"Plain",
        FontSlant->"Plain",
        FontTracking->"Plain",
        FontVariations->{"Underline"->False,
        "Outline"->False,
        "Shadow"->False,
        "StrikeThrough"->False,
        "Masked"->False,
        "CompatibilityType"->0,
        "RotationAngle"->0}], 
      StyleBox[" ",
        FontFamily->"Times New Roman",
        FontWeight->"Plain",
        FontSlant->"Plain",
        FontTracking->"Plain",
        FontVariations->{"Underline"->False,
        "Outline"->False,
        "Shadow"->False,
        "StrikeThrough"->False,
        "Masked"->False,
        "CompatibilityType"->0,
        "RotationAngle"->0}], 
      StyleBox[
        RowBox[{"t", 
          StyleBox["o",
            FontFamily->"Times New Roman",
            FontWeight->"Plain",
            FontSlant->"Plain",
            FontTracking->"Plain",
            FontVariations->{"Underline"->False,
            "Outline"->False,
            "Shadow"->False,
            "StrikeThrough"->False,
            "Masked"->False,
            "CompatibilityType"->0,
            "RotationAngle"->0}]}]], 
      StyleBox[" ",
        FontFamily->"Times New Roman",
        FontWeight->"Plain",
        FontSlant->"Plain",
        FontTracking->"Plain",
        FontVariations->{"Underline"->False,
        "Outline"->False,
        "Shadow"->False,
        "StrikeThrough"->False,
        "Masked"->False,
        "CompatibilityType"->0,
        "RotationAngle"->0}], 
      StyleBox["make",
        FontFamily->"Times New Roman",
        FontWeight->"Plain",
        FontSlant->"Plain",
        FontTracking->"Plain",
        FontVariations->{"Underline"->False,
        "Outline"->False,
        "Shadow"->False,
        "StrikeThrough"->False,
        "Masked"->False,
        "CompatibilityType"->0,
        "RotationAngle"->0}], 
      StyleBox[" ",
        FontFamily->"Times New Roman",
        FontWeight->"Plain",
        FontSlant->"Plain",
        FontTracking->"Plain",
        FontVariations->{"Underline"->False,
        "Outline"->False,
        "Shadow"->False,
        "StrikeThrough"->False,
        "Masked"->False,
        "CompatibilityType"->0,
        "RotationAngle"->0}], 
      StyleBox["the",
        FontFamily->"Times New Roman",
        FontWeight->"Plain",
        FontSlant->"Plain",
        FontTracking->"Plain",
        FontVariations->{"Underline"->False,
        "Outline"->False,
        "Shadow"->False,
        "StrikeThrough"->False,
        "Masked"->False,
        "CompatibilityType"->0,
        "RotationAngle"->0}], 
      StyleBox[" ",
        FontFamily->"Times New Roman",
        FontVariations->{"CompatibilityType"->0}], 
      RowBox[{
        StyleBox["expression",
          FontFamily->"Times New Roman",
          FontVariations->{"CompatibilityType"->0}], 
        StyleBox[":",
          FontFamily->"Times New Roman",
          FontVariations->{"CompatibilityType"->0}], "\[IndentingNewLine]", 
        StyleBox[
          RowBox[{"Symbolize", "[", 
            TagBox[
              SubscriptBox["i", 
                TagBox[\(_?IntegerTest\),
                  NotationPatternTag,
                  TagStyle->"NotationPatternWrapperStyle"]],
              NotationBoxTag,
              TagStyle->"NotationTemplateStyle"], "]"}],
          FontWeight->"Bold"]}]}]], "Text"],

Cell["\<\
Short of manually entering the necessary cell expression there are two ways \
to make the Symbolize expression above.  Both are explained below.\
\>", "Text"],

Cell[TextData[StyleBox["\[FilledSmallSquare]  Use keyboard shortcuts:",
  FontVariations->{"CompatibilityType"->0}]], "Text"],

Cell["Type \[EscapeKey]symb\[EscapeKey]\[TabKey]i", "Text"],

Cell[BoxData[
    RowBox[{"Symbolize", "[", 
      TagBox["i",
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input",
  Editable->False,
  Evaluatable->False],

Cell["Depress \[ControlKey]- ", "Text"],

Cell[BoxData[
    RowBox[{"Symbolize", "[", 
      TagBox[\(i\_\[SelectionPlaceholder]\),
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input",
  Editable->False,
  Evaluatable->False],

Cell["\<\
Type  \[EscapeKey]pattwraper\[EscapeKey]\[TabKey]_?IntegerTest\
\>", "Text"],

Cell[BoxData[
    RowBox[{"Symbolize", "[", 
      TagBox[
        SubscriptBox["i", 
          TagBox[\(_?IntegerTest\),
            NotationPatternTag,
            TagStyle->"NotationPatternWrapperStyle"]],
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input",
  Editable->False,
  Evaluatable->False],

Cell[TextData[StyleBox["\[FilledSmallSquare]  Use the Notation palette:",
  FontVariations->{"CompatibilityType"->0}]], "Text"],

Cell["\<\
\[WarningSign] You may need to patch a bug before this will work.\
\>", "Text"],

Cell[TextData[{
  "In some versions of the Notation package one of the needed buttons needs \
to be fixed before the code below will work.To fix the problem use an ASC \
text editor (MS-Word will work on a PC) to edit the file \
(FullNotationPalette.nb).  The file is normally in the directory \n     \
WolframResearch\\Mathematica\\AddOns\\ExtraPackages\\Utilities.\nOnce you \
have the file open with a test editor delete the line shortly after the \
introductory comments containing the word CacheID.  Then use the Find feature \
to locate \"InsertPatternWrapper\" which will bring you to the code segment \
below.  Shortly after \n     ",
  StyleBox["StyleBox[\"InsertPatternWrapper\", ...\n     ",
    FontFamily->"Terminal"],
  "\nChange the code  \n   ",
  StyleBox["ButtonData:>TagBox[\"",
    FontFamily->"Terminal"],
  StyleBox["\\[PlaceHolder]",
    FontFamily->"Terminal",
    FontVariations->{"CompatibilityType"->0}],
  StyleBox["\", NotationPatternTag,  ...\n   ",
    FontFamily->"Terminal"],
  "\nto\n ",
  StyleBox[" ButtonData:>TagBox[\"",
    FontFamily->"Terminal"],
  StyleBox["\\[SelectionPlaceHolder]",
    FontFamily->"Terminal",
    FontVariations->{"CompatibilityType"->0}],
  StyleBox["\", NotationPatternTag, ...\n  \nAfter making these minor edits \
save the file.\n",
    FontFamily->"Terminal"]
}], "Text"],

Cell["Enter the input cell below.", "Text"],

Cell[BoxData[
    \(i\_\(_?IntegerTest\)\)], "Input",
  Editable->False,
  Evaluatable->False],

Cell["\<\
Select the entered expression, and depress the Symbolize[\
\[SelectionPlaceholder]] button in the Notation palette.\
\>", "Text"],

Cell[BoxData[
    RowBox[{"Symbolize", "[", 
      TagBox[\(i\_\(_?IntegerTest\)\),
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input",
  Editable->False,
  Evaluatable->False],

Cell["\<\
Select the subscript 
    _?IntegerTest
Depress the button for \"Full Notation Palette\".
When the Full Notation Palette comes up select \"InsertPatternWrapper\" under \
\"Wrapper Boxes\".\
\>", "Text"],

Cell[BoxData[
    RowBox[{"Symbolize", "[", 
      TagBox[
        SubscriptBox["i", 
          TagBox[\(_?IntegerTest\),
            NotationPatternTag,
            TagStyle->"NotationPatternWrapperStyle"]],
        NotationBoxTag,
        TagStyle->"NotationTemplateStyle"], "]"}]], "Input",
  Editable->False,
  Evaluatable->False],

Cell["\<\
Unfortunately it's rather difficult to use the RemoveSymbolize button to \
remove the definition above.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Another modification of code Jason Harris provided is given below. \
\>", "Subsection"],

Cell["\<\
Once the Notation package is loaded evaluating the next cell will define a \
function (SubscriptSymbols) that takes a symbol as an argument, set up things \
so that if one evaluates SubscriptSymbols[vari], then (vari) with a \
non-negative integer subscript will be treated as a symbol.\
\>", "Text"],

Cell[BoxData[{
    \(\(\(IntegerTest[n_] := 
      ToExpression[n, StandardForm, IntegerQ[#] && NonNegative[#] &]\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(Needs["\<Utilities`Notation`\>"];\)\), "\[IndentingNewLine]", 
    \(SubscriptSymbols[
        x_Symbol] := \((Symbolize[
          NotationBoxTag[
            SubscriptBox[ToString\ @\ x, 
              TagBox[RowBox[{"\<i_\>", "\<?\>", "\<IntegerTest\>"}], 
                NotationPatternTag]]]]; \
\[IndentingNewLine]\[IndentingNewLine]x\_\(i_?IntegerQ\) := 
          ToExpression\ @\ MakeBoxes[\ x\_i])\)\)}], "Input"],

Cell["\<\
The next cell causes (v) with non-negative integer subscript to be treated as \
a Symbol.\
\>", "Text"],

Cell[BoxData[
    \(SubscriptSymbols[v]\)], "Input"],

Cell[TextData[{
  "In the next cell only ",
  Cell[BoxData[
      \(TraditionalForm\`v\_2\)],
    SingleLetterItalics->False],
  " has the Head Symbol."
}], "Text"],

Cell[BoxData[
    \(\(v\_2 = 5;\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ {v\_2, v\_a, v\_1.5, v\_\(2/3\)}\)], "Input"],

Cell[BoxData[
    \({Integer, Subscript, Subscript, Subscript}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Still another modification of code Jason Harris provided is given below.\
\>", "Subsection"],

Cell[BoxData[{
    \(\(Needs["\<Utilities`Notation`\>"];\)\), "\n", 
    \(\(\(IntegerTest[n_] := 
      ToExpression[n, StandardForm, IntegerQ[#] && NonNegative[#] &]\)\(\n\)
    \)\ \), "\n", 
    \(\(\(SymbolTest[n_] := 
      ToExpression[n, 
        StandardForm, \((Head[#] === 
                Symbol && \(! NumericQ[#]\))\) &]\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(VariableQ[_Symbol?\((\(! NumericQ[#]\) &)\)] := True\), "\n", 
    \(\(\(VariableQ[__] := False\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(Symbolize[
        NotationBoxTag[
          SubscriptBox[
            TagBox[RowBox\ @\ {"\<_\>", "\<?\>", "\<SymbolTest\>"}, 
              NotationPatternTag], 
            TagBox[RowBox\ @\ {"\<_\>", "\<?\>", "\<IntegerTest\>"}, 
              NotationPatternTag]]]];\)\(\n\)
    \)\), "\n", 
    \(\((symb_?VariableQ)\)\_\(i_?IntegerQ\) := 
      ToExpression\ @\ MakeBoxes[\ symb\_i]\)}], "Input"],

Cell["\<\
After evaluating the cells above the first three symbols below have the head \
Symbol while the others have the head Subscript.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head /@ {a\_0, b\_1, \[Gamma]\_0, a\_d, b\_1.5, 
        c\_\(2/3\), \[Pi]\_2}\)], "Input"],

Cell[BoxData[
    \({Symbol, Symbol, Symbol, Subscript, Subscript, Subscript, 
      Subscript}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Remove", "Section"],

Cell[TextData[{
  "Remove is discussed in the section on ",
  ButtonBox["Clear, ClearAll, Remove",
    ButtonData:>"Clear",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["TagBox", "Section"],

Cell[TextData[{
  " The feature named TagBox is essential to an improved Units package I \
wrote and have posted at  \n",
  ButtonBox["http://library.wolfram.com/database/MathSource/4283",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/MathSource/4283"], None},
    ButtonStyle->"Hyperlink"],
  "  \nThe usage message for TagBox is given below."
}], "Text",
  CellTags->"TagBox"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?TagBox\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"TagBox[boxes, tag] displays as boxes but maintains tag to \
guide the interpretation of boxes on input.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"TagBox",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3242475074-9991669"]
}, Closed]],

Cell["\<\
The second argument in TagBox is the head the should have rather than the \
head normally used for the boxes displayed.  Only one line of code is needed \
to demonstrateTagBox.\
\>", "Text"],

Cell[BoxData[
    \(MakeBoxes[UnitsWrapper[expr_, u_], 
        form : \((StandardForm | TraditionalForm)\)] := 
      TagBox[RowBox[{MakeBoxes[expr, form], "\< \>", MakeBoxes[u, form]}], 
        UnitsWrapper]\)], "Input"],

Cell["\<\
After evaluating the cell above the output of the next cell looks like \
Times[0,Second] which would evaluate to 0, but the fullform of the expression \
is actually UnitsWrapper[0, Second].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr = UnitsWrapper[0, Second]\)], "Input"],

Cell[BoxData[
    TagBox[\(0\ Second\),
      UnitsWrapper]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(FullForm[expr]\)], "Input"],

Cell[BoxData[
    TagBox[
      StyleBox[\(UnitsWrapper[0, Second]\),
        ShowStringCharacters->True,
        NumberMarks->True],
      FullForm]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Table", "Section"],

Cell["\<\
When we use Table[expr, {i,imin,imax,di}] (imax-imin) doesn't have to be a \
multiple of di.  See the following example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, x];\)\), "\[IndentingNewLine]", 
    \(Table[a + dx, {dx, 0, 3, \[Pi]/8}]\)}], "Input"],

Cell[BoxData[
    \({a, a + \[Pi]\/8, a + \[Pi]\/4, a + \(3\ \[Pi]\)\/8, a + \[Pi]\/2, 
      a + \(5\ \[Pi]\)\/8, a + \(3\ \[Pi]\)\/4, 
      a + \(7\ \[Pi]\)\/8}\)], "Output"]
}, Closed]],

Cell["\<\
You can also give Table (imax, imin,di) that are not numeric as in the next \
line.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[i, {i, \(-x\), x, x/5}]\)], "Input"],

Cell[BoxData[
    \({\(-x\), \(-\(\(4\ x\)\/5\)\), \(-\(\(3\ x\)\/5\)\), \(-\(\(2\ x\)\/5\)\
\), \(-\(x\/5\)\), 0, x\/5, \(2\ x\)\/5, \(3\ x\)\/5, \(4\ x\)\/5, 
      x}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "However, if you want to make a long list ",
  ButtonBox["Range",
    ButtonData:>"Range",
    ButtonStyle->"Hyperlink"],
  ", can usually make in about half the time it takes Table to do the same.  \
In the lines below Range is used to make the lists in two examples above."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(a + Range[0, 3, \[Pi]/8]\)], "Input"],

Cell[BoxData[
    \({a, a + \[Pi]\/8, a + \[Pi]\/4, a + \(3\ \[Pi]\)\/8, a + \[Pi]\/2, 
      a + \(5\ \[Pi]\)\/8, a + \(3\ \[Pi]\)\/4, 
      a + \(7\ \[Pi]\)\/8}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(x\ Range[\(-1\), 1, 1/5]\)], "Input"],

Cell[BoxData[
    \({\(-x\), \(-\(\(4\ x\)\/5\)\), \(-\(\(3\ x\)\/5\)\), \(-\(\(2\ x\)\/5\)\
\), \(-\(x\/5\)\), 0, x\/5, \(2\ x\)\/5, \(3\ x\)\/5, \(4\ x\)\/5, 
      x}\)], "Output"]
}, Closed]],

Cell["\<\
The iterator in Table can be omitted if it isn't used.  The next line makes a \
4x4 matrix of real numbers.  This can save considerable time.  For example \
Table[Random[],{1000},{100}] evaluates in less than half the time it takes to \
evaluate Table[Random[],{i,1000},{j,100}].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[Random[], {4}, {4}]\)], "Input"],

Cell[BoxData[
    \({{0.846124395215748`, 0.20553058959405235`, 0.7259478461146106`, 
        0.31195897331650646`}, {0.651909519968063`, 0.17944590693890725`, 
        0.04179052766249576`, 0.12943515881329415`}, {0.11863007617499129`, 
        0.5355906901208307`, 0.35998880260491156`, 
        0.4470712907949094`}, {0.652190398570263`, 0.5527451600397344`, 
        0.8346696733450342`, 0.18532167799639657`}}\)], "Output"]
}, Closed]],

Cell["\<\
The following construct can be used to make a list of lists that grow in \
length.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[1/\((x + y)\), {x, 6}, {y, x}] // TableForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {\(1\/2\), "\<\"\"\>", "\<\"\"\>", "\<\"\"\>", "\<\"\"\>", \
"\<\"\"\>"},
          {\(1\/3\), \(1\/4\), "\<\"\"\>", "\<\"\"\>", "\<\"\"\>", \
"\<\"\"\>"},
          {\(1\/4\), \(1\/5\), \(1\/6\), "\<\"\"\>", "\<\"\"\>", "\<\"\"\>"},
          {\(1\/5\), \(1\/6\), \(1\/7\), \(1\/8\), "\<\"\"\>", "\<\"\"\>"},
          {\(1\/6\), \(1\/7\), \(1\/8\), \(1\/9\), \(1\/10\), "\<\"\"\>"},
          {\(1\/7\), \(1\/8\), \(1\/9\), \(1\/10\), \(1\/11\), \(1\/12\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      TableForm[ {{
        Rational[ 1, 2]}, {
        Rational[ 1, 3], 
        Rational[ 1, 4]}, {
        Rational[ 1, 4], 
        Rational[ 1, 5], 
        Rational[ 1, 6]}, {
        Rational[ 1, 5], 
        Rational[ 1, 6], 
        Rational[ 1, 7], 
        Rational[ 1, 8]}, {
        Rational[ 1, 6], 
        Rational[ 1, 7], 
        Rational[ 1, 8], 
        Rational[ 1, 9], 
        Rational[ 1, 10]}, {
        Rational[ 1, 7], 
        Rational[ 1, 8], 
        Rational[ 1, 9], 
        Rational[ 1, 10], 
        Rational[ 1, 11], 
        Rational[ 1, 12]}}]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Thread", "Section"],

Cell["\<\
First an example of Thread is given in it's simplest form.  When used in this \
simple form Thread takes an expression with arguments that are all lists of \
equal length. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(Thread[f[{x1, y1}, {x2, y2}, {x3, y3}]]\)}], "Input"],

Cell[BoxData[
    \({f[x1, x2, x3], f[y1, y2, y3]}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see Thread automatically adapts if one or more elements \
aren't lists.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[f[a, {y1, y2, y3}, {z1, z2, z3}, d]]\)], "Input"],

Cell[BoxData[
    \({f[a, y1, z1, d], f[a, y2, z2, d], f[a, y3, z3, d]}\)], "Output"]
}, Closed]],

Cell["\<\
The next three examples have frequent applications.  They have the same form \
an example above but it may not look that way because infix operators \
(\[Rule], \[Equal]) are used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[{opt1, opt2, opt3, opt4} \[Rule] False]\)], "Input"],

Cell[BoxData[
    \({opt1 \[Rule] False, opt2 \[Rule] False, opt3 \[Rule] False, 
      opt4 \[Rule] False}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[{w, x, y, z} \[Rule] {1.2, 3.2, 4.2, 5.2}]\)], "Input"],

Cell[BoxData[
    \({w \[Rule] 1.2`, x \[Rule] 3.2`, y \[Rule] 4.2`, 
      z \[Rule] 5.2`}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[{w, x, y, z} \[Equal] {1.2, 3.2, 4.2, 5.2}]\)], "Input"],

Cell[BoxData[
    \({w == 1.2`, x == 3.2`, y == 4.2`, z == 5.2`}\)], "Output"]
}, Closed]],

Cell["\<\
As indicated above Thread works over lists by default.  In the next example \
some of the expressions at level 1 of (lst1) aren't lists.  In a case such as \
this the expressions that aren't lists are copied.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst1 = 
        f[{x1, y1}, {x2, y2}, {x3, y3}, \n\t\tg[x4, y4], g[x5, y5], 
          g[x6, y6]];\)\), "\n", 
    \(Thread[lst1]\)}], "Input"],

Cell[BoxData[
    \({f[x1, x2, x3, g[x4, y4], g[x5, y5], g[x6, y6]], 
      f[y1, y2, y3, g[x4, y4], g[x5, y5], g[x6, y6]]}\)], "Output"]
}, Closed]],

Cell["\<\
Thread will work over a different head if one is provided as a second \
argument.  The next line threads the same expression as the last one, but \
this time it threads over (g) instead of threading over list.  Similar to the \
last example expressions that didn't have the head (g) were copied.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[lst1, g]\)], "Input"],

Cell[BoxData[
    \(g[f[{x1, y1}, {x2, y2}, {x3, y3}, x4, x5, x6], 
      f[{x1, y1}, {x2, y2}, {x3, y3}, y4, y5, y6]]\)], "Output"]
}, Closed]],

Cell["\<\
In the next line Thread is provided a second and third argument.  The third \
argument tells Thread to only thread across the first three arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst2 = 
        f[g[x1, y1], \ g[x2, y2], \ \n\t\tg[x3, y3], g[x4, y4], 
          g[x5, y5]];\)\), "\n", 
    \(Thread[lst2, g, 3]\)}], "Input"],

Cell[BoxData[
    \(g[f[x1, x2, x3, g[x4, y4], g[x5, y5]], 
      f[y1, y2, y3, g[x4, y4], g[x5, y5]]]\)], "Output"]
}, Closed]],

Cell["\<\
In the next line Thread is given a third argument which says to only thread \
over arguments 2 through 4.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[lst2, g, {2, 4}]\)], "Input"],

Cell[BoxData[
    \(g[f[g[x1, y1], x2, x3, x4, g[x5, y5]], 
      f[g[x1, y1], y2, y3, y4, g[x5, y5]]]\)], "Output"]
}, Closed]],

Cell["\<\
Finally Thread is given (-3) as a third argument.  This means to only thread \
over the last three arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Thread[lst2, g, \(-3\)]\)], "Input"],

Cell[BoxData[
    \(g[f[g[x1, y1], g[x2, y2], x3, x4, x5], 
      f[g[x1, y1], g[x2, y2], y3, y4, y5]]\)], "Output"]
}, Closed]],

Cell["\<\
Roman Meader give the elegant program below which automatically threads \
listable functions across the head Equal.  The program is posted in \
MathSource under Enhancements, Algebraic, 0202-204.  The code for this \
enhancement is shown in the next cell.\
\>", "Text"],

Cell[BoxData[{
    \(\(Unprotect[Equal];\)\ \), "\n", 
    \(\(listableQ[f_]\  := \ MemberQ[Attributes[f], \ Listable];\)\), "\n", 
    \(\(Equal /: \ 
        lhs : \((f_Symbol)\)?
              listableQ[___, \ _Equal, \ ___]\  := \ \n\ \ \ Thread[
          Unevaluated[lhs], \ Equal];\)\), "\n", 
    \(\(Protect[Equal];\)\)}], "Input"],

Cell["\<\
The program above allows one to 'add' two equations in the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\n", 
    \(\(eqn1 = \((4 - 2  x + x\^2 == 0)\);\)\), "\n", 
    \(\(eqn2 = \((5 + 6  x == 0)\);\)\), "\n", 
    \(eqn1 + eqn2\)}], "Input"],

Cell[BoxData[
    \(9 + 4\ x + x\^2 == 0\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Trig option", "Section"],

Cell["\<\
The usage message for the built-in symbol Trig is shown below.\
\>", "Text",
  CellTags->"Trig option"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Trig\)\)], "Input"],

Cell[BoxData[
    \("Trig is an option for algebraic manipulation functions which specifies \
whether trigonometric functions should be treated as rational functions of \
exponentials."\)], "Print",
  CellTags->"Info3242475074-3476455"]
}, Closed]],

Cell["\<\
The built-in functions that have the Trig option are 
Apart, ApartSquareFree, Cancel, Coefficient, CoefficientList, Collect, \
Denominator, Expand, ExpandAll, ExpandDenominator, ExpandNumerator, Exponent, \
Factor, FactorList, FactorSquareFree, FactorSquareFreeList, FactorTerms, \
FactorTermsList, FullSimplify, Numerator, PolynomialGCD, PolynomialLCM, \
PolynomialMod, Resultant, Simplify, Together.

Simplify and FullSimplify have the default setting (Trig\[Rule]True) and all \
other functions above have the default setting (Trig\[Rule]False).  I \
searched through all available documentation and couldn't find a single \
example to demonstrate this option. The examples using the Trig option below \
were provided by Allan Hayes and Andrzej Kozlowski.  In each case the \
original expression would be returned if it were not for the use of (Trig\
\[Rule]True).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(Expand[Sin[2  x], Trig \[Rule] True]\)}], "Input"],

Cell[BoxData[
    \(2\ Cos[x]\ Sin[x]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Apart[Csc[2  x], Trig \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(Cot[x]\/2 + Tan[x]\/2\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cancel[Csc[x] Sin[2  x], Trig \[Rule] True]\)], "Input"],

Cell[BoxData[
    \(2\ Cos[x]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ToString", "Section"],

Cell["\<\
ToString has several options that I won't address here because I never became \
familiar with them. However, there is an interesting problem with converting \
a symbol to a string.  How can we convert a symbol to a string without \
letting the symbol evaluate?  ToString2 below does the job. Notice evaluation \
has to be prevented in two places here.\
\>", "Text",
  CellTags->"ToString"],

Cell[BoxData[{
    \(\(mass = 56;\)\), "\n", 
    \(ClearAll[ToString2]\), "\n", 
    \(\(Attributes[ToString2] = {HoldAll};\)\), "\n", 
    \(ToString2[a_] := ToString[Unevaluated[a]]\)}], "Input"],

Cell["\<\
In the next cell we get the characters used to make the Symbol mass without \
letting the symbol evaluate.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(InputForm[ToString2[mass]]\)], "Input"],

Cell["\"mass\"", "Output"]
}, Closed]],

Cell["\<\
Sometimes you might want a function to convert one of it's arguments to a \
string before the argument evaluates. Then you might want your function to do \
something with the resulting string. In this case a pure function can be used \
to do the string conversion. The next cell defines a function Letters that \
returns the characters used to make the argument before the argument has a \
chance to evaluate.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[Letters];\)\), "\[IndentingNewLine]", 
    \(\(Attributes[Letters] = {HoldAll};\)\), "\[IndentingNewLine]", 
    \(Letters[s_] := 
      Characters[\(Function[
            a, \ \ ToString[Unevaluated[a]], \ \ {HoldAll}]\)\ [
          s]\ \ \ \ ]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Letters[mass]\)], "Input"],

Cell[BoxData[
    \({"m", "a", "s", "s"}\)], "Output"]
}, Closed]],

Cell["Notice mass still has the value that was assigned above.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(mass\)], "Input"],

Cell[BoxData[
    \(56\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Tr", "Section"],

Cell["\<\
Tr computes the trace of a rectangular matrix.  Some examples are given in \
the next two cells.\
\>", "Text",
  CellTags->"Tr"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(Tr[{{a, b, c, d, e}, {v, w, x, y, z}}]\)}], "Input"],

Cell[BoxData[
    \(a + w\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mtrx = {\[IndentingNewLine]{a1, a2, a3}, \[IndentingNewLine]{b1, b2, 
            b3}, \[IndentingNewLine]{c1, c2, 
            c3}\[IndentingNewLine]};\)\), "\[IndentingNewLine]", 
    \(Tr[mtrx, Max]\)}], "Input"],

Cell[BoxData[
    \(Max[a1, b2, c3]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Computing the trace of a matrix is a common operation in linear algebra.  \
",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " generalizes the notion of trace to make it so we can compute Tr[vector].  \
When Tr is given a vector we get the sum of the elements.  The use of (Tr) in \
the next cell does the same thing as ",
  Cell[BoxData[
      \(TraditionalForm\`Plus @@ {a, b, c, d}\)]],
  ".  Rob Knapp showed us that when a vector is a packed array  ",
  Cell[BoxData[
      \(TraditionalForm\`\((Tr[vector]\ )\)\)]],
  " is much faster than ",
  Cell[BoxData[
      \(TraditionalForm\`\((Plus @@ vector)\)\)]],
  ".  My timing tests vary, but I found Tr to be at least 25 times faster \
when given a packed array."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Tr[{a, b, c, d, e}]\)], "Input"],

Cell[BoxData[
    \(a + b + c + d + e\)], "Output"]
}, Closed]],

Cell["\<\
Next I give some examples that go down to different levels of a tensor.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t1 = {{{{a1, b1}, {a2, b2}, {a3, b3}}, {{c1, d1}, {c2, d2}, {c3, 
                d3}}}, \[IndentingNewLine]{{{e1, f1}, {e2, f2}, {e3, 
                f3}}, {{g1, h1}, {g2, h2}, {g3, h3}}}};\)\), "\n", 
    \(Dimensions[t1]\)}], "Input"],

Cell[BoxData[
    \({2, 2, 3, 2}\)], "Output"]
}, Closed]],

Cell["\<\
By default Tr works at the deepest level, which is level 4 in this example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Tr[t1]\)], "Input"],

Cell[BoxData[
    \(a1 + h2\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Tr[t1, Plus, 4]\)], "Input"],

Cell[BoxData[
    \(a1 + h2\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(t1[\([1, 1, 1, 1]\)]\  + t1[\([2, 2, 2, 2]\)]\)], "Input"],

Cell[BoxData[
    \(a1 + h2\)], "Output"]
}, Closed]],

Cell["Next Tr is used at level 3.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Tr[t1, Plus, 3]\)], "Input"],

Cell[BoxData[
    \({a1 + g2, b1 + h2}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(t1[\([1, 1, 1]\)] + t1[\([2, 2, 2]\)]\)], "Input"],

Cell[BoxData[
    \({a1 + g2, b1 + h2}\)], "Output"]
}, Closed]],

Cell["Next Tr is used at level 2.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Tr[t1, Plus, 2]\)], "Input"],

Cell[BoxData[
    \({{a1 + g1, b1 + h1}, {a2 + g2, b2 + h2}, {a3 + g3, 
        b3 + h3}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(t1[\([1, 1]\)] + t1[\([2, 2]\)]\)], "Input"],

Cell[BoxData[
    \({{a1 + g1, b1 + h1}, {a2 + g2, b2 + h2}, {a3 + g3, 
        b3 + h3}}\)], "Output"]
}, Closed]],

Cell["Finally Tr is used at level 1.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Tr[t1, Plus, 1]\)], "Input"],

Cell[BoxData[
    \({{{a1 + e1, b1 + f1}, {a2 + e2, b2 + f2}, {a3 + e3, 
          b3 + f3}}, {{c1 + g1, d1 + h1}, {c2 + g2, d2 + h2}, {c3 + g3, 
          d3 + h3}}}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(t1[\([1]\)] + t1[\([2]\)]\)], "Input"],

Cell[BoxData[
    \({{{a1 + e1, b1 + f1}, {a2 + e2, b2 + f2}, {a3 + e3, 
          b3 + f3}}, {{c1 + g1, d1 + h1}, {c2 + g2, d2 + h2}, {c3 + g3, 
          d3 + h3}}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Transpose", "Section"],

Cell["\<\
Transpose can be used on tensors as well as on matrices and the expressions \
don't have to be nested lists either.
By using the second argument of Transpose you can control the levels that are \
transposed.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, b, c, d, e, f, g, h];\)\), "\[IndentingNewLine]", 
    \(\(\(tt = {{{{1, a}, {2, b}}, {{3, c}, {4, d}}}, {{{5, e}, {6, f}}, {{7, 
                g}, {8, h}}}};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(MatrixForm[tt]\)}], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"1", "a"},
                    {"2", "b"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"3", "c"},
                    {"4", "d"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"5", "e"},
                    {"6", "f"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"7", "g"},
                    {"8", "h"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{1, a}, {2, b}}, {{3, c}, {4, d}}}, {{{5, e}, {6, f}}, {{
        7, g}, {8, h}}}}]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(Transpose[tt]\)\(//\)\(MatrixForm\)\(\ \ \)\)\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"1", "a"},
                    {"2", "b"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"5", "e"},
                    {"6", "f"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"3", "c"},
                    {"4", "d"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"7", "g"},
                    {"8", "h"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{1, a}, {2, b}}, {{5, e}, {6, f}}}, {{{3, c}, {4, d}}, {{
        7, g}, {8, h}}}}]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\(Transpose[
        tt, {1, 2, 4, 3}]\)\(//\)\(MatrixForm\)\(\ \ \)\)\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"1", "2"},
                    {"a", "b"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"3", "4"},
                    {"c", "d"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"5", "6"},
                    {"e", "f"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"7", "8"},
                    {"g", "h"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{1, 2}, {a, b}}, {{3, 4}, {c, d}}}, {{{5, 6}, {e, f}}, {{
        7, 8}, {g, h}}}}]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(Transpose[tt, {2, 1, 4, 3}] // MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"1", "2"},
                    {"a", "b"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"5", "6"},
                    {"e", "f"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"3", "4"},
                    {"c", "d"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"7", "8"},
                    {"g", "h"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{1, 2}, {a, b}}, {{5, 6}, {e, f}}}, {{{3, 4}, {c, d}}, {{
        7, 8}, {g, h}}}}]]], "Output"]
}, Closed]],

Cell["\<\
Tr will do the same as the following, but faster when done with a large \
expression.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Transpose[tt, {1, 1}] // MatrixForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"1"},
                    {"a"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"2"},
                    {"b"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"7"},
                    {"g"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"8"},
                    {"h"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{1, a}, {2, b}}, {{7, g}, {8, h}}}]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Unevaluated", "Section"],

Cell["\<\
When Unevaluated[expr] is an argument of a function (expr) is given to the \
function it is an argument of without evaluating.  Consider the example in \
the next cell.  If it were not for the use of Unevaluated the sum would \
evaluate to 30 which has the head Integer.  Instead the head Plus is \
returned.\
\>", "Text",
  CellTags->"Unevaluated"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Head[Unevaluated[2 + 3 + 5\^2]]\)], "Input"],

Cell[BoxData[
    \(Plus\)], "Output",
  GeneratedCell->False,
  CellAutoOverwrite->False]
}, Closed]],

Cell["\<\
Often times when we make a function with a holding attribute (e.g.  HoldAll, \
HoldRest, HoldFirst) we have to use Unevaluated in the definition of the \
function.  Consider the function in the next cell that converts it's argument \
to a string before the string can evaluate.

Here the HoldAll attribute prevents MakeString from evaluating it's argument. \
 However, we also need to use Unevaluated to ensure ToString doesn't evaluate \
it's argument.\
\>", "Text"],

Cell[BoxData[{
    \(ClearAll[MakeString]\), "\n", 
    \(\(Attributes[MakeString] = {HoldAll};\)\), "\n", 
    \(MakeString[a_] := 
      ToString[Unevaluated[a]] <> "\< is a string\>"\)}], "Input"],

Cell["\<\
The next cell demonstrates the MakeString function.  We see that (mass) is \
converted to a string even though the symbol has a numeric value assigned to \
it.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mass = 56;\)\), "\[IndentingNewLine]", 
    \({mass, MakeString[mass]}\)}], "Input"],

Cell[BoxData[
    \({56, "mass is a string"}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "For more understanding of Unevaluated see examples in my explanation of \
the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " ",
  ButtonBox["evaluation process",
    ButtonData:>"Unevaluated-Advanced",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Update", "Section"],

Cell[TextData[{
  "To see a situation where use of Update is needed see the section on ",
  ButtonBox["Condition",
    ButtonData:>"Condition",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"Update"]
}, Closed]],

Cell[CellGroupData[{

Cell["UpValues", "Section"],

Cell["\<\
Normally Cosh[x]+Sinh[x] doesn't evaluate to Exp[x] but there are different \
ways of making the kernel automatically perform this simplification.  A few \
ways to do this are discussed in the cells below.  Before we begin the next \
cell should be evaluated to unprotect the functions that will be modified.\
\>", "Text",
  CellTags->"Upvalues"],

Cell[BoxData[{
    \(\(Unprotect[Plus, Cosh, Sinh];\)\), "\[IndentingNewLine]", 
    \(Clear[Plus, Cosh, Sinh, t, x]\)}], "Input"],

Cell[TextData[{
  "Once Plus is unprotected evaluating the next cell will cause an expression \
such as ",
  Cell[BoxData[
      \(StandardlForm\`Cosh[x] + Sinh[x]\)]],
  " to evaluate to Exp[z]."
}], "Text"],

Cell[BoxData[
    \(Cosh[z_] + Sinh[z_] := Exp[z]\)], "Input"],

Cell["The rule above has the desired effect in the cell below.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(1\/\(1 + Cosh[t + 1.5] + Sinh[t + 1.5]\)\)], "Input"],

Cell[BoxData[
    \(1\/\(1 + \[ExponentialE]\^\(\(\(1.5`\)\(\[InvisibleSpace]\)\) + \
t\)\)\)], "Output"]
}, Closed]],

Cell[TextData[{
  "However, Plus is a function that's used very often, and the code above \
will slow down evaluation of Plus.  Actually it doesn't slow down Plus as \
much as one might think.  In  ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " versions 3 and 4 the functions Plus and Times apply built in rules before \
user defined rules.  So when the next cell evaluates the kernel uses a \
built-in rule to compute (2+3) before it checks for the above user defined \
identity.  Likewise built-in rules are used for (3+2/3), and (x+2 x), so here \
too the kernel never gets a chance to see if the user defined rule above \
should be used.  As a result the user defined rule had no effect on the speed \
of evaluating the cell below."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(\@\(2 + 3\)\) Exp[3 + 2/3] \((x + 2\ x)\)\)], "Input"],

Cell[BoxData[
    \(3\ \@5\ \[ExponentialE]\^\(11/3\)\ x\)], "Output"]
}, Closed]],

Cell["\<\
On the other hand consider evaluation of the next cell after the above \
identity for Cosh[z_]+Sinh[z_] is in the kernel.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Exp[3 + 2/3 + x] \(\@\(2 + 3 + x\)\) Sin[x + 2\ x + y]\)], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^\(11\/3 + x\)\ \@\(5 + x\)\ Sin[3\ x + y]\)], "Output"]
}, Closed]],

Cell[TextData[{
  "When evaluating the cell above the kernel uses a built-in rule to evaluate \
 ",
  Cell[BoxData[
      \(TraditionalForm\`\((3 + 2/3 + x\[LongRightArrow]11/3 + x\ )\)\)]],
  ", then it checks to see if the user defined rule for ",
  Cell[BoxData[
      \(TraditionalForm\`Sinh[z_] + Cosh[z_]\)]],
  " applies to ",
  Cell[BoxData[
      \(TraditionalForm\`\((11/3 + x)\)\)]],
  ".  Later in the evaluation the kernel uses a built-in rule to evaluate ",
  Cell[BoxData[
      \(TraditionalForm\`\((2 + 3 + x\ \[LongRightArrow]5 + x)\)\)]],
  " and it checks to see if the user defined rule for ",
  Cell[BoxData[
      \(TraditionalForm\`Cosh[z_] + Sinh[z_]\)]],
  " applies to ",
  Cell[BoxData[
      \(TraditionalForm\`\((5 + x)\)\)]],
  ".  Still later in the evaluation the kernel uses a built-in rule to \
evaluate ",
  Cell[BoxData[
      \(TraditionalForm\`\((x + 2\ x + y\ \[LongRightArrow]3\ x + y)\)\)]],
  " and it checks to see if the user defined rule for ",
  Cell[BoxData[
      \(TraditionalForm\`Cosh[z_] + Sinh[z_]\)]],
  " applies to ",
  Cell[BoxData[
      \(TraditionalForm\`\((3\ x + y)\)\)]],
  ".  In this case the user defined rule for ",
  Cell[BoxData[
      \(TraditionalForm\`Cosh[z_] + Sinh[z_]\)]],
  " causes degradation in the time it takes to evaluate the last example even \
though the functions Cosh, Sinh appear nowhere in the expression.\n\nThe user \
defined rule above was a \"DownValue\" for Plus as can be seen from the next \
cell.  When the rule was entered above the kernel determined that Plus is the \
head of ",
  Cell[BoxData[
      \(StandardlForm\`Cosh[z_] + Sinh[z_]\)]],
  " and that is why it was associated with Plus."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DownValues[Plus]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[
          Cosh[z_] + Sinh[z_]] \[RuleDelayed] \[ExponentialE]\^z}\)], "Output"]
}, Closed]],

Cell["\<\
Instead of associating the above identity with Plus (an often used function) \
we can associate the identity with a head one level deeper than Plus.  In \
this case we can associate the identity with Cosh and/or Sinh as an UpValue.  \
Before proceeding we should do away with the above definition.\
\>", "Text"],

Cell[BoxData[
    \(Clear[Plus, Cosh, Sinh]\)], "Input"],

Cell[TextData[{
  "Evaluating the next cell will associate the identity with Sinh as an \
UpValue.  For more on UpValues see The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book section ",
  ButtonBox["2.4.10",
    ButtonStyle->"MainBookLink"],
  "."
}], "Text"],

Cell[BoxData[
    \(Sinh /: Cosh[z_] + Sinh[z_] := Exp[z]\)], "Input"],

Cell["\<\
By starting the line above with Sinh/:  the kernel knows to associate the \
identity with Sinh.  Once the previous cell is evaluated the next cell can be \
used to see that the identity is associated with Sinh.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(UpValues[Sinh]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[
          Cosh[z_] + Sinh[z_]] \[RuleDelayed] \[ExponentialE]\^z}\)], "Output"]
}, Closed]],

Cell["\<\
At first one might guess that the above Identity would cause the next cell to \
change into Exp[3.5] which then evaluates to 33.1155.  However Cosh[3.5] \
evaluates to 16.5728, and Sinh[3.5] evaluates to 16.5426 before the kernel \
checks for the above identity.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cosh[3.5] + Sinh[3.5]\)], "Input"],

Cell[BoxData[
    \(33.11545195869231`\)], "Output"]
}, Closed]],

Cell["\<\
Now when the next line evaluates the above identity is used, but only after \
the kernel finds it can't do anything with Cosh[3] or Sinh[3].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cosh[3] + Sinh[3]\)], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^3\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Now consider evaluation of the expression below.  Here the above identity \
is still stored in UpValues[Sinh] and not  in DownValues[Plus] or anywhere \
else.  Since the identity isn't stored with Plus there is no impact on the \
evaluation of ",
  Cell[BoxData[
      \(StandardlForm\`\((x + 1)\)\)]],
  ", ",
  Cell[BoxData[
      \(StandardlForm\`\(\(Cosh[x + 1]\)\(\ \)\)\)]],
  ", ",
  Cell[BoxData[
      \(StandardlForm\`\((3 + Cosh[x + 1]\ )\)\)]],
  " or ",
  Cell[BoxData[
      \(StandardlForm\`\((3 + Cosh[x + 1]\ )\)\^\(-1\)\)]],
  ".  In fact the above identity has no impact on the evaluation of  Sinh[3]. \
 However, when the kernel evaluates (2 x Sinh[3]) it checks for user defined \
UpValues of Integer (the head of 2), but there are none.  Then the kernel \
checks for user defined UpValues of (x), but there are none.  Then the kernel \
checks the for user defined UpValues of Sinh, and there is an UpValue.  At \
that point the kernel must see if the UpValue for Sinh can be used, but finds \
that it can't.  Then the kernel checks for built in UpValues for Integer, x, \
Sinh and either finds none or none that apply to  ",
  Cell[BoxData[
      \(StandardlForm\`\((2\ x\ Sinh[3]\ )\)\)]],
  ".  Then the kernel checks for user defined DownValues for Times and finds \
none.  Finally the kernel checks for built in DownValues for Times, and \
either finds none or none that apply to ",
  Cell[BoxData[
      \(TraditionalForm\`\((2\ x\ Sinh[3])\)\)]],
  ".  At that point evaluation is complete."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(2\ x\ Sinh[3]\)\/\(3 + Cosh[x + 1]\)\)], "Input"],

Cell[BoxData[
    \(\(2\ x\ Sinh[3]\)\/\(3 + Cosh[1 + x]\)\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Storing the identity for ",
  Cell[BoxData[
      \(TraditionalForm\`Cosh[z_] + Sinh[z_]\)]],
  " with UpValues[Sinh] should have much less impact on the evaluation of \
typical expressions than storing it with DownValues[Plus].  However, this \
identity will have an impact on the evaluation of many expressions that \
include Sinh, and this is likely the reason why Wolfram Research didn't \
include it as part of the default evaluation process.\n\nEvaluating the next \
cell will remove any the above definitions."
}], "Text"],

Cell[BoxData[
    \(Clear[Plus, Cosh, Sinh]\)], "Input"],

Cell[TextData[{
  "Instead of storing the above identity with UpValues[Sinh] one could store \
it with UpValues[Cosh] using the next cell.  The only difference this will \
make is that it will slow down evaluation some ",
  Cell[BoxData[
      \(TraditionalForm\`Cosh[z_]\)]],
  " expressions, but never slow down evaluation of ",
  Cell[BoxData[
      \(TraditionalForm\`Sinh[_]\)]],
  " expressions.  Starting the next line with Cosh/:  tells the kernel to \
store the identity with UpValues[Cosh]."
}], "Text"],

Cell[BoxData[
    \(Cosh /: Cosh[z_] + Sinh[z_] := Exp[z]\)], "Input"],

Cell[TextData[{
  "Still another way to store this identity is to use the next line.  That \
will store the identity with UpValues for each symbol at level 1 of ",
  Cell[BoxData[
      \(StandardlForm\`\((Cosh[z_] + Sinh[z_]\ )\)\)]],
  ".  In this case Plus is at level 0 and Sinh, Cosh are the only symbols at \
level 1.  This approach will slow down evaluation of Sinh[_] and Cosh[_] \
expressions with no advantage over storing the identity only with \
UpValues[Sinh], or only with UpValues[Cosh]."
}], "Text"],

Cell[BoxData[
    \(Cosh[z_] + Sinh[z_] ^:= Exp[z]\)], "Input"],

Cell[TextData[{
  " All example above used UpValues with delayed assignment.  ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " provides ways to make UpValues with immediate assignment, but one should \
",
  StyleBox["be very cautious",
    FontWeight->"Bold"],
  " of them.  This is done in the cells below.  In each case then variable \
(z) is used for the named pattern on the left side, but when (z) has a global \
value this global value will be used on the right side."
}], "Text"],

Cell[BoxData[{
    \(\(z = 7 + 5\ I;\)\), "\[IndentingNewLine]", 
    \(Clear[Plus, \ Sinh, \ Cosh]\), "\[IndentingNewLine]", 
    \(\(Sinh /: Cosh[z_] + Sinh[z_] = Exp[z];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@x + Cosh[3] + Sinh[z]\)], "Input"],

Cell[BoxData[
    \(\@x + Cosh[3] + Sinh[7 + 5\ \[ImaginaryI]]\)], "Output"]
}, Closed]],

Cell["\<\
Instead a definition such as the one above should be stored as an UpValue \
with delayed assignment as I do in the next cell.  When delayed assignment is \
used a global value assigned to (z) will not affect the results.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[Plus, \ Sinh, Cosh];\)\), "\[IndentingNewLine]", 
    \(Sinh /: Cosh[z_] + Sinh[z_] := Exp[z]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@x + Cosh[3] + Sinh[3]\)], "Input"],

Cell[BoxData[
    \(\[ExponentialE]\^3 + \@x\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
We can't assign a definition with a symbol that's too deep inside an \
expression.\
\>", "Subsection"],

Cell[TextData[{
  "We can use UpValues to store the identity ",
  Cell[BoxData[
      \(StandardlForm\`\((Sin[z_]\^\(\(\ \)\(2\)\) + 
            Cos[z_]\^\(\(\ \)\(2\)\) = 1)\)\)]],
  ".  However, this identity can't be stored with the UpValues[Sin] or \
UpValues[Cos] because Sin, Cos are too deep in the expression ",
  Cell[BoxData[
      \(StandardlForm\`\((\ 
        Sin[z_]\^\(\(\ \)\(2\)\) + Cos[z_]\^\(\(\ \)\(2\)\)\ )\)\)]],
  ".  UpValues must be stored with a symbol that appears at level 1.  In this \
case Plus is at level 0, Power is at level 1, Sin, Cos, Integer are at level \
2.  The identity can be stored in  UpValues[Power] as in the next cell."
}], "Text"],

Cell[BoxData[{
    \(\(Unprotect[Plus, Power];\)\), "\[IndentingNewLine]", 
    \(\(Clear[Plus, Power, b];\)\), "\[IndentingNewLine]", 
    \(\(Power /: Sin[z_]\^2 + Cos[z_]\^2 = 1;\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sin[b + \[Pi]/6]\^2 + Cos[b + \[Pi]/6]\^2\)], "Input"],

Cell[BoxData[
    \(1\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(UpValues[Power]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[Cos[z_]\^2 + Sin[z_]\^2] \[RuleDelayed] 1}\)], "Output"]
}, Closed]],

Cell["\<\
We can also store the identity with DownValues[Plus] using the next cell.\
\>", "Text"],

Cell[BoxData[{
    \(\(Unprotect[Power, Plus];\)\), "\n", 
    \(Clear[Plus, Power, a]\), "\n", 
    \(\(Sin[z_]\^2 + Cos[z_]\^2 = 1;\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Sin[a + \[Pi]/3]\^2 + Cos[a + \[Pi]/3]\^2\)], "Input"],

Cell[BoxData[
    \(1\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(DownValues[Plus]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[Cos[z_]\^2 + Sin[z_]\^2] \[RuleDelayed] 1}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Before continuing you might want to evaluate the following to remove all \
definitions made above.\
\>", "Subsection"],

Cell[BoxData[{
    \(\(Unprotect[Plus, Cosh, Sinh, Power];\)\), "\[IndentingNewLine]", 
    \(\(Clear[Plus, Cosh, Sinh, Power];\)\), "\[IndentingNewLine]", 
    \(\(Protect[Plus, Cosh, Sinh, Power];\)\)}], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Verbatim", "Section"],

Cell["The Verbatim usage message is shown below.", "Text",
  CellTags->"Verbatim"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?Verbatim\)\)], "Input"],

Cell[BoxData[
    RowBox[{"\<\"Verbatim[expr] represents expr in pattern matching, \
requiring that expr be matched exactly as it appears, with no substitutions \
for blanks or other transformations.\"\>", " ", 
      ButtonBox[
        StyleBox["More\[Ellipsis]",
          "SR"],
        ButtonData:>"Verbatim",
        Active->True,
        ButtonStyle->"RefGuideLink"]}]], "Print",
  CellTags->"Info3247899362-8348536"]
}, Closed]],

Cell["\<\
Verbatim[expr] is used when you want the pattern matcher to ignore the normal \
meaning of a pattern matching feature.  To demonstrate the next cell shows \
the FullForm of some patterns.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FullForm[{x_, y_List}]\)], "Input"],

Cell[BoxData[
    TagBox[
      StyleBox[\(List[Pattern[x, Blank[]], Pattern[y, Blank[List]]]\),
        ShowSpecialCharacters->False,
        ShowStringCharacters->True,
        NumberMarks->True],
      FullForm]], "Output"]
}, Closed]],

Cell["\<\
The attempt to delete all such patterns in the next cell fails because the \
pattern matcher treats the use of  \"Pattern\" here as a pattern matching \
construct instead of an actual form to search for.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[{x_, y_List, 3, 4, 5}, Pattern[_, _Blank]]\)], "Input"],

Cell[BoxData[
    \({x_, y_List, 3, 4, 5}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell the pattern matcher knows to ignore the meaning of \"Pattern\
\" so (x_) and (y_List) are deleted.  In this case only Pattern was wrapped \
in Verbatim so the pattern matcher did consider the meaning of (_) and \
(_Blank).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteCases[{x_, y_List, 3, 4, 
        5}, \(Verbatim[Pattern]\)[_, _Blank]]\)], "Input"],

Cell[BoxData[
    \({3, 4, 5}\)], "Output"]
}, Closed]],

Cell["\<\
In the next example (Pattern[_,_Blank]) is wrapped in Verbatim so only that \
literal expression is deleted.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(data = {x_, y_List, 3, 4, 5, Pattern[_, _Blank], 6, 
          7};\)\), "\[IndentingNewLine]", 
    \(DeleteCases[data, Verbatim[Pattern[_, _Blank]]]\)}], "Input"],

Cell[BoxData[
    \({x_, y_List, 3, 4, 5, 6, 7}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Suppose you're given a list and want to get the element that matches the \
pattern (opt1\[Rule]_).  The attempt in the next cell doesn't work because \
use of a rule as the second argument in ",
  ButtonBox["Cases",
    ButtonData:>"Cases",
    ButtonStyle->"Hyperlink"],
  " has special meaning."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[{1 + x, opt1 \[Rule] val, opt2 \[Rule] val2, opt1}, 
      opt1 \[Rule] _]\)], "Input"],

Cell[BoxData[
    \({_}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell Verbatim makes Cases treat it's second argument as a form to \
search for instead of replacing (opt1) with (_).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[{1 + x, opt1 \[Rule] val1, opt2 \[Rule] val2, 
        opt1}, \(Verbatim[Rule]\)[opt1, _]\ \ ]\)], "Input"],

Cell[BoxData[
    \({opt1 \[Rule] val1}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["$OutputForms", "Section"],

Cell["The $OutputForms usage message is shown below.", "Text",
  CellTags->"$OutputForms"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(?$OutputForms\)\)], "Input"],

Cell[BoxData[
    \("$OutputForms is a list of the formatting functions that get stripped \
off when wrapped around the output."\)], "Print",
  CellTags->"Info3240648369-5591269"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(m = 
      MatrixForm[Inverse[{{1, 2, 0}, {0, 2, 3}, {1, 2, \(-1\)}}]]\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"4", \(-1\), \(-3\)},
            {\(-\(3\/2\)\), \(1\/2\), \(3\/2\)},
            {"1", "0", \(-1\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["Notice Head[m] returns MatrixForm, but Head[%] retunrs List.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({Head[%], Head[m]}\)], "Input"],

Cell[BoxData[
    \({List, MatrixForm}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell removes MatrixForm from the list assigned to $OutputForms.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Unprotect[$OutputForms];\)\), "\[IndentingNewLine]", 
    \($OutputForms = Complement[$OutputForms, {MatrixForm}]\)}], "Input"],

Cell[BoxData[
    \({AccountingForm, BaseForm, CForm, DisplayForm, EngineeringForm, 
      FortranForm, FullForm, InputForm, MathMLForm, NumberForm, OutputForm, 
      PaddedForm, ScientificForm, Shallow, Short, StandardForm, StyleForm, 
      TableForm, TeXForm, TextForm, TraditionalForm, TreeForm}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(m = 
      MatrixForm[Inverse[{{1, 2, 0}, {0, 2, 3}, {1, 2, \(-1\)}}]]\)], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"4", \(-1\), \(-3\)},
            {\(-\(3\/2\)\), \(1\/2\), \(3\/2\)},
            {"1", "0", \(-1\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
Now that MatrixForm isn't in the list returned by $OutputForms, we get \
MatrixForm for Head[%] and Head[m].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({Head[%], Head[m]}\)], "Input"],

Cell[BoxData[
    \({MatrixForm, MatrixForm}\)], "Output"]
}, Closed]],

Cell["The next cell restores the default setting of $OutputForms.", "Text"],

Cell[BoxData[
    \(\($OutputForms = Union[$OutputForms, {MatrixForm}];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["$PreRead, $Pre, $Post, $PrePrint", "Section"],

Cell[TextData[{
  "The evaluation of expressions can be affected by definitions assigned to \
symbols \n$PreRead, MakeExpression, $Pre, $Post, $PrePrint, Format, \
MakeBoxes. The process of going from input cell to output cell is as follows. \
 Each of these steps requires evaluation of an expression, and that ",
  ButtonBox["evaluation process",
    ButtonData:>"Evaluation-Process",
    ButtonStyle->"Hyperlink"],
  " is explained in a later section.\n\n   (1)  Input Boxes are processed \
using $PreRead.\n   (2)  The boxes $PreRead returns are converted to an \
expression using ",
  ButtonBox["MakeExpression",
    ButtonStyle->"RefGuideLink"],
  ".\n   (3)  The expression MakeExpression returns is processed using $Pre.\n\
   (4)  The expression $Pre returns is evaluated.\n   (5)  The expression \
returned by evaluation is processed by $Post.\n   (6)  The expression $Post \
returns is assigned to (%n) and stored in DownValues[Out].\n   (7)  The \
expression that was assigned to (%n) is processed by $PrePrint.\n   (8)  The \
expression $PrePrint returns is processed by definitions made using ",
  ButtonBox["Format",
    ButtonData:>"Format",
    ButtonStyle->"Hyperlink"],
  ".\n   (9)  The expression Format returns is converted to boxes using ",
  ButtonBox["MakeBoxes",
    ButtonData:>"MakeBoxes",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"$Pre;$Post"],

Cell[CellGroupData[{

Cell["$PreRead", "Subsection"],

Cell[TextData[{
  "Consider the input in the next cell.  The 2-D representation of the cell \
is stored as \nSqrtBox[\n      RowBox[{\n        FractionBox[\"35\", \
\"100\"], \"+\", \"1\"}]]\n        \nBefore ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " can evaluate this input it converts it to the expression\n     \
Power[Plus[Times[35,Power[100,-1]],1],Rational[1,2]]\n     \nHowever, before \
the boxes are converted to this expression ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " checks to see if the boxes should be changed using $PreRead."
}], "Text"],

Cell[BoxData[
    \(\@\(1 + 35\/100\)\)], "Input"],

Cell[TextData[{
  "The next cell cause $Pre to change the box representation of ",
  Cell[BoxData[
      \(TraditionalForm\`num\/den\)]],
  "into the box representation of MyDivide[num,den]."
}], "Text"],

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint, 
        MyDivide];\)\), "\[IndentingNewLine]", 
    \(\($PreRead = \((# /. 
              FractionBox[num_, den_] \[RuleDelayed] 
                RowBox[{"\<MyDivide\>", "\<[\>", 
                    RowBox[{num, "\<,\>", 
                        den}], "\<]\>"}])\) &;\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@\(1 + 35\/100\)\)], "Input"],

Cell[BoxData[
    \(\@\(1 + MyDivide[35, 100]\)\)], "Output"]
}, Closed]],

Cell["The next cell removes the above $PreRead assignment.", "Text"],

Cell[BoxData[
    \($PreRead =. \)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["$Pre", "Subsection"],

Cell["\<\
In the next cell $Pre is given the input before evaluation and changed any \
occurance of 100 into the symbol Hundred.  Use of Unevaluated and HoldAll is \
needed to ensure the expression doesn't evaluate before making the \
replacement.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint, 
        Hundred];\)\), "\[IndentingNewLine]", 
    \(\($Pre = 
        Function[expr, 
          Unevaluated[
              expr] /. \((100 \[Rule] Hundred)\), {HoldAll}];\)\)}], "Input"],

Cell["\<\
Below we see that $Pre makes the replacement before making the calulation  \
(35/100)\[LongRightArrow](7/20).\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\@\(35\/100 + 1\)\)], "Input"],

Cell[BoxData[
    \(\@\(1 + 35\/Hundred\)\)], "Output"]
}, Closed]],

Cell["The next cell removes the above $Pre assignment.", "Text"],

Cell[BoxData[
    \($Pre =. \)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["$Post", "Subsection"],

Cell["\<\
In the next cell we make $Post display matrices in MatrixForm and all other \
results are not affected. The symbols returned by evaluating $OutputForms get \
special treatment in that they affect the printed output, but not the results \
assigned to (%n). By default $OutputForms includes MatrixForm, TableForm, \
ScientificForm and other built-in formatting functions.  Provided MatrixForm \
is in the list returned by $OutputForms we could have assigned the definition \
below to $PrePrint and got the same results.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\), "\n", 
    \(\($Post = \((# /. 
              mtrx_?MatrixQ \[RuleDelayed] 
                MatrixForm[mtrx])\) &;\)\)}], "Input"],

Cell["\<\
After making the assignment above the output of the following is \
automatically displayed in MatrixForm.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(mtrx = {{1, 2, 0}, {0, 2, 3}, {1, 
          2, \(-1\)}}\), "\[IndentingNewLine]", 
    \({Head[%], Head[mtrx]}\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"1", "2", "0"},
            {"0", "2", "3"},
            {"1", "2", \(-1\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"],

Cell[BoxData[
    \({List, List}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell makes it so MatrixForm isn't included in the $OutputForms \
list\
\>", "Text"],

Cell[BoxData[{
    \(\(Unprotect[$OutputForms];\)\), "\[IndentingNewLine]", 
    \(\($OutputForms = Complement[$OutputForms, {MatrixForm}];\)\)}], "Input"],

Cell["\<\
When MatrixForm isn't in the $OutputForms list Head[%] below is MatrixForm.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(mtrx = {{1, 2, 0}, {0, 2, 3}, {1, 
          2, \(-1\)}}\), "\[IndentingNewLine]", 
    \({Head[%], Head[mtrx]}\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"1", "2", "0"},
            {"0", "2", "3"},
            {"1", "2", \(-1\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"],

Cell[BoxData[
    \({MatrixForm, List}\)], "Output"]
}, Closed]],

Cell["\<\
The next cell restores the default setting of $OutputForms and removes the \
above $Post setting.\
\>", "Text"],

Cell[BoxData[{
    \(\($OutputForms = Union[$OutputForms, {MatrixForm}];\)\), "\n", 
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["$PrePrint", "Subsection"],

Cell["\<\
$Post and $PrePrint are very similar and are normally used to affect the way \
output is displayed.  For example in the next cell we make $PrePrint display \
matrices in MatrixForm and all other results are not affected. $PrePrint is \
used after results are assigned to %n, so use of $PrePrint will not affect \
assignments to (%n) regardless of what is assigned to $OutputForms.\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\), "\n", 
    \(\($PrePrint = \((# /. 
              mtrx_?MatrixQ \[RuleDelayed] 
                MatrixForm[mtrx])\) &;\)\)}], "Input"],

Cell["\<\
After making the assignment above the output of the following is \
automatically displayed in MatrixForm. Because of the way $PrePrint works we \
get List for Head[%] below regardless of what is assigned to $OutputForms.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(mtrx = {{1, 2, 0}, {0, 2, 3}, {1, 
          2, \(-1\)}}\), "\[IndentingNewLine]", 
    \({Head[%], Head[mtrx]}\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"1", "2", "0"},
            {"0", "2", "3"},
            {"1", "2", \(-1\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"],

Cell[BoxData[
    \({List, List}\)], "Output"]
}, Closed]],

Cell[BoxData[
    \(Clear[$PreRead, $Pre, $Post, $PrePrint]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["$Post versus  $PrePrint  (a closer look)", "Subsection"],

Cell["Consider the use of $PrePrint in the next cell.", "Text"],

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\), "\n", 
    \(\($PrePrint = \((# /. 
              x_?NumericQ \[RuleDelayed] x + 1)\) &;\)\)}], "Input"],

Cell["\<\
After making the previous assignment to $PrePrint, the next output shows (1+\
\[Pi]) instead of simply \[Pi].  There is clearly no pratical use for this \
sort of thing.  I am only doing this to illustrate the difference between \
$Post and $PrePrint.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(x = \[Pi]\)], "Input"],

Cell[BoxData[
    \(1 + \[Pi]\)], "Output"]
}, Closed]],

Cell["\<\
The result stored with (%n) from the evaluation above is \[Pi] because \
$PrePrint is used after the result is assigned to %n. This is demonstrated in \
the next cell where the previous output is accessed using (%%). \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\), "\n", 
    \(%%\)}], "Input"],

Cell[BoxData[
    \(\[Pi]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we use $Post to do the same thing we did with $PrePrint in \
the previous example.  When we use $Post the replacement is made before the \
result is assigned to (%n).\
\>", "Text"],

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\), "\n", 
    \(\($Post = \((# /. x_?NumericQ \[RuleDelayed] x + 1)\) &;\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(x = \[Pi]\)], "Input"],

Cell[BoxData[
    \(1 + \[Pi]\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we see (1+\[Pi]) is assigned to (%n) when the replacement is \
made using $Post.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[$PreRead, $Pre, $Post, $PrePrint];\)\), "\[IndentingNewLine]", 
    \(%%\)}], "Input"],

Cell[BoxData[
    \(1 + \[Pi]\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Clever Little Programs", "Section",
  CellFrame->{{0, 0}, {0, 4}}],

Cell[CellGroupData[{

Cell["EvaluateAt", "Subsection"],

Cell["\<\
The function in the next cell takes an expression and a list of positions, \
and evaluates in place the parts at the specified positions. This is taken \
verbatim from \"further examples\" for ReplacePart in the Help Browser.\
\>", "ExampleText",
  CellTags->{"ReplacePart", "Evaluate At"}],

Cell[BoxData[
    \(EvaluateAt[expr_, positions_] := 
      Fold[ReplacePart[#1, Part[#1, Sequence @@ #2], #2] &, expr, 
        positions]\)], "Input",
  CellTags->"ReplacePart"],

Cell[TextData[{
  "In this case, ",
  StyleBox["{1,2}", "MR"],
  " specifies the second element of the held list, and ",
  StyleBox["{1,-1,1}", "MR"],
  " the first part of the last element. "
}], "ExampleText",
  CellTags->"ReplacePart"],

Cell[CellGroupData[{

Cell[BoxData[
    \(EvaluateAt[
      HoldForm[{2 + 3, 3 + 4, 2*4 + 5}], {{1, 2}, {1, \(-1\), 1}}]\)], "Input",\

  CellTags->"ReplacePart"],

Cell[BoxData[
    TagBox[\({2 + 3, 7, 8 + 5}\),
      HoldForm]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Evaluate Pattern", "Subsection"],

Cell[TextData[{
  "The function below evaluates all parts of a held expression that match a \
certain pattern. This is based on some code Robby Villegas of Wolfram \
Research discussed at the 1999 Developer Converence.  See \"Working With \
Unevaluated Expressions\" posted at \n",
  ButtonBox["http://library.wolfram.com/conferences/devconf99/#programming",
    ButtonData:>{
      URL[ "http://library.wolfram.com/conferences/devconf99/#programming"], 
      None},
    ButtonStyle->"Hyperlink"],
  ".\nAt that conference Micheal Trott and Adam Strzebonski of Wolfram \
Research are mentioned as the inventors of this trick : see \
\"Trott-Strzebonski method for In-Place Evaluation\". "
}], "Text",
  CellTags->"Evaluate Pattern"],

Cell[BoxData[
    RowBox[{"   ", 
      RowBox[{\(EvaluatePattern[expr_, pattn_]\), ":=", 
        RowBox[{"expr", "/.", 
          RowBox[{\(Pattern[p, pattn]\), 
            StyleBox[" ",
              "Input",
              FontSize->12], 
            StyleBox[":>",
              "Input",
              FontSize->12], 
            StyleBox[" ",
              "Input",
              FontSize->12], 
            StyleBox[\(With[{eval\  = p}, \ eval\  /; \ True]\),
              "Input",
              FontSize->12]}]}]}]}]], "Input"],

Cell[TextData[{
  "The next cell creates a held expression and evaluates all sub expressions \
with the Head Plus but nothing else evaluates. In this example \
Erf[\[Infinity]]+5, 1+3, 5+4, ",
  Cell[BoxData[
      \(TraditionalForm\`\@36 - \@16\)]],
  " evaluate to 6, 4, 9, 2 respectively since they each have the head Plus."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(demo = 
        HoldForm[\((Erf[\[Infinity]] + 
                5)\)\ Sin[\[Pi]\/\(1 + 3\)]\ \@\(5 + 4\)\/\(\@36 - \@16\)];\)\
\), "\n", 
    \(EvaluatePattern[demo, _Plus]\)}], "Input"],

Cell[BoxData[
    TagBox[\(6\/2\ Sin[\[Pi]\/4]\ \@9\),
      HoldForm]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["ReplaceAll at subexpressions matching a pattern", "Subsection"],

Cell[BoxData[{
    \(\(\(PatternReplaceAll::usage = "\<PatternReplaceAll[expr, pattern, \
rule] uses ReplaceAll to make the changes specified by rule, but the \
replacements are only made to subexpressions of expr that match pattern. \
PatternReplaceAll[expr, pattern, {rules}] uses one or more rules.\>";\)\(\
\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(PatternReplaceAll[expr_, 
        pattn_, {rules : \((_Rule | _RuleDelayed)\) .. }] := 
      With[{posn = Reverse@\(Sort@Position[Hold @@ {expr}, pattn]\)}, 
        ReleaseHold[
          Fold[MapAt[Function[a, a /. {rules}], #1, #2] &, Hold @@ {expr}, 
            posn]]]\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(PatternReplaceAll[expr_, pattn_, 
        SingleRule : \((_Rule | _RuleDelayed)\)] := 
      PatternReplaceAll[expr, pattn, {SingleRule}]\)}], "Input"],

Cell["\<\
Comments about the code above:

(1)  (Reverse@Sort...) ensures the later positions in (posn) still apply even \
after folding several times. 

(2)  We can't let the replacements take effect until after Fold is done \
because the 
     position of things may change.  To solve that I use Hold@@{expr}.

(3)  I don't use (rules__?OptionQ) because OptionQ[n_Integer->n+2] returns \
False. 
     Instead I use  rules:(_Rule|_RuleDelayed).

Now some examples:\
\>", "Text"],

Cell[BoxData[
    \(\(ex = 
        b*Gamma[1 + a]^2*Gamma[1 + b]/Gamma[2, 4 + 2  b]*
          PolyGamma[2*b]*\((b + 2)\)^2;\)\)], "Input"],

Cell["\<\
Here we use the rule (b\[Rule]bb) on all subexpressions with the head \
Gamma.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(PatternReplaceAll[ex, _Gamma, b \[Rule] bb]\)], "Input"],

Cell[BoxData[
    \(\(b\ \((2 + b)\)\^2\ Gamma[1 + a]\^2\ Gamma[1 + bb]\ PolyGamma[0, 2\ b]\
\)\/Gamma[2, 4 + 2\ bb]\)], "Output"]
}, Closed]],

Cell["\<\
Here we use the rule (n_Integer\[Rule]n+2) on all subexpressions with the \
head Gamma.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(PatternReplaceAll[ex, _Gamma, n_Integer \[Rule] n + 2]\)], "Input"],

Cell[BoxData[
    \(\(b\ \((2 + b)\)\^2\ Gamma[3 + a]\^2\ Gamma[3 + b]\ PolyGamma[0, 2\ \
b]\)\/Gamma[4, 6 + 4\ b]\)], "Output"]
}, Closed]],

Cell["\<\
Here we use both rules (b\[Rule]bb, n_Integer\[Rule]n+2) on all \
subexpressions with the head Gamma.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(PatternReplaceAll[
      ex, _Gamma, {b \[Rule] bb, n_Integer \[Rule] n + 2}]\)], "Input"],

Cell[BoxData[
    \(\(b\ \((2 + b)\)\^2\ Gamma[3 + a]\^2\ Gamma[3 + bb]\ PolyGamma[0, 2\ b]\
\)\/Gamma[4, 6 + 4\ bb]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Making a periodic function", "Subsection"],

Cell["\<\
In the next cell I define a periodic function that's piecewize linear.  
This example would still work if I changed 
f[x_?(Im[#]===0&)] := f[Mod[x,5]]   to simply 
f[x_] := f[Mod[x,5]]   but by using the more complicated the definition (f) \
is only used for real arguments.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(f[x_?\((0 \[LessEqual] # < 5 &)\)] := 
        If[x < 2, 3, \ x - 4];\)\), "\n", 
    \(\(f[x_?\((Im[#] === 0 &)\)] := f[Mod[x, 5]];\)\), "\n", 
    \(\(Plot[f[x], {x, 0, 13}];\)\)}], "Input",
  FontSize->12],

Cell[GraphicsData["PostScript", "\<\
%!
%%Creator: Mathematica
%%AspectRatio: .61803 
MathPictureStart
/Mabs {
Mgmatrix idtransform
Mtmatrix dtransform
} bind def
/Mabsadd { Mabs
3 -1 roll add
3 1 roll add
exch } bind def
%% Graphics
%%IncludeResource: font Courier
%%IncludeFont: Courier
/Courier findfont 10  scalefont  setfont
% Scaling calculations
0.0238095 0.0732601 0.249872 0.117816 [
[.17033 .23737 -3 -9 ]
[.17033 .23737 3 0 ]
[.31685 .23737 -3 -9 ]
[.31685 .23737 3 0 ]
[.46337 .23737 -3 -9 ]
[.46337 .23737 3 0 ]
[.60989 .23737 -3 -9 ]
[.60989 .23737 3 0 ]
[.75641 .23737 -6 -9 ]
[.75641 .23737 6 0 ]
[.90293 .23737 -6 -9 ]
[.90293 .23737 6 0 ]
[.01131 .01424 -12 -4.5 ]
[.01131 .01424 0 4.5 ]
[.01131 .13206 -12 -4.5 ]
[.01131 .13206 0 4.5 ]
[.01131 .36769 -6 -4.5 ]
[.01131 .36769 0 4.5 ]
[.01131 .4855 -6 -4.5 ]
[.01131 .4855 0 4.5 ]
[.01131 .60332 -6 -4.5 ]
[.01131 .60332 0 4.5 ]
[ 0 0 0 0 ]
[ 1 .61803 0 0 ]
] MathScale
% Start of Graphics
1 setlinecap
1 setlinejoin
newpath
0 g
.25 Mabswid
[ ] 0 setdash
.17033 .24987 m
.17033 .25612 L
s
[(2)] .17033 .23737 0 1 Mshowa
.31685 .24987 m
.31685 .25612 L
s
[(4)] .31685 .23737 0 1 Mshowa
.46337 .24987 m
.46337 .25612 L
s
[(6)] .46337 .23737 0 1 Mshowa
.60989 .24987 m
.60989 .25612 L
s
[(8)] .60989 .23737 0 1 Mshowa
.75641 .24987 m
.75641 .25612 L
s
[(10)] .75641 .23737 0 1 Mshowa
.90293 .24987 m
.90293 .25612 L
s
[(12)] .90293 .23737 0 1 Mshowa
.125 Mabswid
.06044 .24987 m
.06044 .25362 L
s
.09707 .24987 m
.09707 .25362 L
s
.1337 .24987 m
.1337 .25362 L
s
.20696 .24987 m
.20696 .25362 L
s
.24359 .24987 m
.24359 .25362 L
s
.28022 .24987 m
.28022 .25362 L
s
.35348 .24987 m
.35348 .25362 L
s
.39011 .24987 m
.39011 .25362 L
s
.42674 .24987 m
.42674 .25362 L
s
.5 .24987 m
.5 .25362 L
s
.53663 .24987 m
.53663 .25362 L
s
.57326 .24987 m
.57326 .25362 L
s
.64652 .24987 m
.64652 .25362 L
s
.68315 .24987 m
.68315 .25362 L
s
.71978 .24987 m
.71978 .25362 L
s
.79304 .24987 m
.79304 .25362 L
s
.82967 .24987 m
.82967 .25362 L
s
.8663 .24987 m
.8663 .25362 L
s
.93956 .24987 m
.93956 .25362 L
s
.97619 .24987 m
.97619 .25362 L
s
.25 Mabswid
0 .24987 m
1 .24987 L
s
.02381 .01424 m
.03006 .01424 L
s
[(-2)] .01131 .01424 1 0 Mshowa
.02381 .13206 m
.03006 .13206 L
s
[(-1)] .01131 .13206 1 0 Mshowa
.02381 .36769 m
.03006 .36769 L
s
[(1)] .01131 .36769 1 0 Mshowa
.02381 .4855 m
.03006 .4855 L
s
[(2)] .01131 .4855 1 0 Mshowa
.02381 .60332 m
.03006 .60332 L
s
[(3)] .01131 .60332 1 0 Mshowa
.125 Mabswid
.02381 .0378 m
.02756 .0378 L
s
.02381 .06137 m
.02756 .06137 L
s
.02381 .08493 m
.02756 .08493 L
s
.02381 .10849 m
.02756 .10849 L
s
.02381 .15562 m
.02756 .15562 L
s
.02381 .17918 m
.02756 .17918 L
s
.02381 .20275 m
.02756 .20275 L
s
.02381 .22631 m
.02756 .22631 L
s
.02381 .27344 m
.02756 .27344 L
s
.02381 .297 m
.02756 .297 L
s
.02381 .32056 m
.02756 .32056 L
s
.02381 .34412 m
.02756 .34412 L
s
.02381 .39125 m
.02756 .39125 L
s
.02381 .41481 m
.02756 .41481 L
s
.02381 .43838 m
.02756 .43838 L
s
.02381 .46194 m
.02756 .46194 L
s
.02381 .50907 m
.02756 .50907 L
s
.02381 .53263 m
.02756 .53263 L
s
.02381 .55619 m
.02756 .55619 L
s
.02381 .57976 m
.02756 .57976 L
s
.25 Mabswid
.02381 0 m
.02381 .61803 L
s
0 0 m
1 0 L
1 .61803 L
0 .61803 L
closepath
clip
newpath
.5 Mabswid
.02381 .60332 m
.06244 .60332 L
.10458 .60332 L
.12507 .60332 L
.14415 .60332 L
.1536 .60332 L
.16254 .60332 L
.16748 .60332 L
.16883 .60332 L
.16957 .60332 L
.17026 .60332 L
.17149 .01611 L
.17214 .01715 L
.17284 .01827 L
.18221 .03334 L
.22343 .09964 L
.26314 .1635 L
.30133 .22492 L
.34198 .29029 L
.36078 .32051 L
.37066 .33641 L
.38111 .35321 L
.38643 .36176 L
.38788 .3641 L
.38868 .36539 L
.38944 .36662 L
.39015 .60332 L
.39092 .60332 L
.39226 .60332 L
.40252 .60332 L
.42269 .60332 L
.46347 .60332 L
.48373 .60332 L
.50274 .60332 L
.52091 .60332 L
.52588 .60332 L
.53112 .60332 L
.53329 .60332 L
.53447 .60332 L
.5356 .60332 L
.53623 .60332 L
.53692 .01472 L
.53813 .01666 L
.54049 .02045 L
.58141 .08625 L
.62081 .14962 L
.6587 .21055 L
.69904 .27542 L
.71761 .3053 L
.73786 .33786 L
Mistroke
.74318 .34642 L
.74885 .35553 L
.75161 .35996 L
.75296 .36213 L
.7542 .36413 L
.75533 .36595 L
.75652 .60332 L
.75772 .60332 L
.75904 .60332 L
.77914 .60332 L
.81962 .60332 L
.85858 .60332 L
.87843 .60332 L
.88889 .60332 L
.89462 .60332 L
.89742 .60332 L
.89999 .60332 L
.90119 .60332 L
.90231 .60332 L
.90347 .01511 L
.90474 .01715 L
.90985 .02538 L
.92073 .04286 L
.93989 .07368 L
.97619 .13206 L
Mfstroke
% End of Graphics
MathPictureEnd
\
\>"], "Graphics",
  ImageSize->{250, 154.5},
  ImageMargins->{{0, 0}, {0, 0}},
  ImageRegion->{{0, 1}, {0, 1}},
  ImageCache->GraphicsData["Bitmap", "\<\
CF5dJ6E]HGAYHf4PAg9QL6QYHg<PAVmbKF5d0`40007d0001=A000`40O003h00OogoomGoo003oOooe
Ool00?moooEoo`00ogoomGoo003oOooeOol00?moooEoo`007Woo00<007ooOol0ogooe7oo000NOol0
0`00Oomoo`3oOooDOol000ioo`P000Qoo`03001oogoo0?moomAoo`003Woo00<007ooOol017oo00<0
07ooOol01Woo00<007ooOol0ogooe7oo000?Ool00`00Oomoo`0<Ool00`00Oomoo`3oOooDOol0011o
o`03001oogoo00]oo`03001oogoo0?moomAoo`004Goo00<007ooOol02Woo00<007ooOol0ogooe7oo
0002Ool80008Ool00`00Oomoo`09Ool4003bOol00`00Oomoo`2]Ool00`00Oomoo`0]Ool001=oo`03
001oogoo00Qoo`03001oogoo04=oo`800:ioo`800:ioo`8002ioo`0057oo00<007ooOol01goo00<0
07ooOol0@goo0P00[Woo0P00[Woo0P00;Woo000EOol00`00Oomoo`06Ool00`00Oomoo`13Ool00`00
Ool0002]Ool00`00Ool0002]Ool00`00Ool0000]Ool001Eoo`03001oogoo00Ioo`03001oogoo04=o
o`03001oo`000:eoo`04001oogoo002/Ool00`00Ool0000]Ool000ioo`03001oogoo00Aoo`03001o
ogoo00Ioo`03001oogoo04=oo`04001oogoo002/Ool01000Oomoo`00[7oo00@007ooOol002aoo`00
3goo00<007ooOol00Woo00<007ooOol01goo00<007ooOol0@goo00D007ooOomoo`000:]oo`05001o
ogooOol0002[Ool01@00Oomoogoo0000:goo000@Ool4000:Ool00`00Oomoo`13Ool00`00Oomoo`02
Ool00`00Oomoo`2XOol01@00Oomoogoo0000Zgoo00D007ooOomoo`0002]oo`007Woo00<007ooOol0
@goo00<007ooOol00Woo00<007ooOol0Z7oo00<007ooOol00Woo00<007ooOol0Z7oo00<007ooOol0
0Woo00<007ooOol0:7oo000NOol00`00Oomoo`13Ool00`00Oomoo`03Ool00`00Oomoo`2WOol00`00
Oomoo`03Ool00`00Oomoo`2WOol00`00Oomoo`02Ool00`00Oomoo`0XOol001ioo`03001oogoo04=o
o`03001oogoo00Aoo`03001oogoo0:Ioo`03001oogoo00=oo`03001oogoo0:Moo`03001oogoo00=o
o`03001oogoo02Moo`007Woo0P00A7oo00<007ooOol017oo00<007ooOol0YWoo00<007ooOol017oo
00<007ooOol0YWoo00<007ooOol00goo00<007ooOol09goo000NOol00`00Oomoo`13Ool00`00Oomo
o`05Ool00`00Oomoo`2UOol00`00Oomoo`04Ool00`00Oomoo`2VOol00`00Oomoo`04Ool00`00Oomo
o`0VOol001ioo`03001oogoo04=oo`03001oogoo00Eoo`03001oogoo0:Eoo`03001oogoo00Eoo`03
001oogoo0:Eoo`03001oogoo00Aoo`03001oogoo02Ioo`007Woo00<007ooOol0@goo00<007ooOol0
1Woo00<007ooOol0Y7oo00<007ooOol01Woo00<007ooOol0Y7oo00<007ooOol01Goo00<007ooOol0
9Goo000NOol00`00Oomoo`13Ool00`00Oomoo`07Ool00`00Oomoo`2SOol00`00Oomoo`06Ool00`00
Oomoo`2TOol00`00Oomoo`06Ool00`00Oomoo`0TOol001ioo`03001oogoo04=oo`03001oogoo00Mo
o`03001oogoo0:=oo`03001oogoo00Moo`03001oogoo0:=oo`03001oogoo00Ioo`03001oogoo02Ao
o`007Woo00<007ooOol0@goo00<007ooOol027oo00<007ooOol0XWoo00<007ooOol01goo00<007oo
Ool0Xgoo00<007ooOol01goo00<007ooOol08goo000NOol00`00Oomoo`13Ool00`00Oomoo`08Ool0
0`00Oomoo`2ROol00`00Oomoo`08Ool00`00Oomoo`2ROol00`00Oomoo`08Ool00`00Oomoo`0ROol0
01ioo`03001oogoo04=oo`03001oogoo00Uoo`03001oogoo0:5oo`03001oogoo00Qoo`03001oogoo
0:9oo`03001oogoo00Qoo`03001oogoo029oo`007Woo00<007ooOol0@goo00<007ooOol02Woo00<0
07ooOol0X7oo00<007ooOol02Goo00<007ooOol0XGoo00<007ooOol02Goo00<007ooOol08Goo000N
Ool00`00Oomoo`13Ool00`00Oomoo`0:Ool00`00Oomoo`2POol00`00Oomoo`0:Ool00`00Oomoo`2P
Ool00`00Oomoo`0:Ool00`00Oomoo`0POol001ioo`03001oogoo04=oo`03001oogoo00]oo`03001o
ogoo09moo`03001oogoo00Yoo`03001oogoo0:1oo`03001oogoo00Yoo`03001oogoo021oo`007Woo
0P00A7oo00<007ooOol02goo00<007ooOol0Wgoo00<007ooOol02goo00<007ooOol0Wgoo00<007oo
Ool02goo00<007ooOol07goo000NOol00`00Oomoo`13Ool00`00Oomoo`0<Ool00`00Oomoo`2NOol0
0`00Oomoo`0;Ool00`00Oomoo`2OOol00`00Oomoo`0<Ool00`00Oomoo`0NOol001ioo`03001oogoo
04=oo`03001oogoo00aoo`03001oogoo09ioo`03001oogoo00aoo`03001oogoo09ioo`03001oogoo
00aoo`03001oogoo01ioo`007Woo00<007ooOol0@goo00<007ooOol03Goo00<007ooOol0WGoo00<0
07ooOol03Goo00<007ooOol0WGoo00<007ooOol03Goo00<007ooOol07Goo000NOol00`00Oomoo`13
Ool00`00Oomoo`0>Ool00`00Oomoo`2LOol00`00Oomoo`0=Ool00`00Oomoo`2MOol00`00Oomoo`0>
Ool00`00Oomoo`0LOol001ioo`03001oogoo04=oo`03001oogoo00ioo`03001oogoo09aoo`03001o
ogoo00ioo`03001oogoo09aoo`03001oogoo00ioo`03001oogoo01aoo`007Woo00<007ooOol0@goo
00<007ooOol03goo00<007ooOol0Vgoo00<007ooOol03Woo00<007ooOol0W7oo00<007ooOol03goo
00<007ooOol06goo000NOol00`00Oomoo`13Ool00`00Oomoo`0?Ool00`00Oomoo`2KOol00`00Oomo
o`0?Ool00`00Oomoo`2KOol00`00Oomoo`0@Ool00`00Oomoo`0JOol001ioo`03001oogoo04=oo`03
001oogoo011oo`03001oogoo09Yoo`03001oogoo011oo`03001oogoo09Yoo`03001oogoo011oo`03
001oogoo01Yoo`007Woo00<007ooOol0@goo00<007ooOol04Goo00<007ooOol0VGoo00<007ooOol0
47oo00<007ooOol0VWoo00<007ooOol04Goo00<007ooOol06Goo000NOol00`00Oomoo`13Ool00`00
Oomoo`0AOol00`00Oomoo`2IOol00`00Oomoo`0AOol00`00Oomoo`2IOol00`00Oomoo`0AOol00`00
Oomoo`0IOol001ioo`8004Aoo`03001oogoo019oo`03001oogoo09Qoo`03001oogoo015oo`03001o
ogoo09Uoo`03001oogoo019oo`03001oogoo01Qoo`007Woo00<007ooOol0@goo00<007ooOol04Woo
00<007ooOol0V7oo00<007ooOol04Woo00<007ooOol0V7oo00<007ooOol04goo00<007ooOol05goo
000NOol00`00Oomoo`13Ool00`00Oomoo`0COol00`00Oomoo`2GOol00`00Oomoo`0COol00`00Oomo
o`2GOol00`00Oomoo`0COol00`00Oomoo`0GOol001ioo`03001oogoo04=oo`03001oogoo01Aoo`03
001oogoo09Ioo`03001oogoo01=oo`03001oogoo09Moo`03001oogoo01Aoo`03001oogoo01Ioo`00
7Woo00<007ooOol0@goo00<007ooOol057oo00<007ooOol0UWoo00<007ooOol057oo00<007ooOol0
UWoo00<007ooOol057oo00<007ooOol05Woo000NOol00`00Oomoo`13Ool00`00Oomoo`0EOol00`00
Oomoo`2EOol00`00Oomoo`0EOol00`00Oomoo`2EOol00`00Oomoo`0EOol00`00Oomoo`0EOol001io
o`03001oogoo04=oo`03001oogoo01Eoo`03001oogoo09Eoo`03001oogoo01Eoo`03001oogoo09Eo
o`03001oogoo01Ioo`03001oogoo01Aoo`007Woo00<007ooOol0@goo00<007ooOol05Woo00<007oo
Ool0U7oo00<007ooOol05Woo00<007ooOol0U7oo00<007ooOol05Woo00<007ooOol057oo000NOol0
0`00Oomoo`13Ool00`00Oomoo`0GOol00`00Oomoo`2COol00`00Oomoo`0FOol00`00Oomoo`2DOol0
0`00Oomoo`0GOol00`00Oomoo`0COol001ioo`03001oogoo04=oo`03001oogoo01Moo`03001oogoo
09=oo`03001oogoo01Moo`03001oogoo09=oo`03001oogoo01Moo`03001oogoo01=oo`007Woo00<0
07ooOol0@goo00<007ooOol067oo00<007ooOol0TWoo00<007ooOol067oo00<007ooOol0TWoo00<0
07ooOol067oo00<007ooOol04Woo000NOol20014Ool00`00Oomoo`0HOol00`00Oomoo`2BOol00`00
Oomoo`0HOol00`00Oomoo`2BOol00`00Oomoo`0IOol00`00Oomoo`0AOol001ioo`03001oogoo04=o
o`03001oogoo01Uoo`03001oogoo095oo`03001oogoo01Uoo`03001oogoo095oo`03001oogoo01Uo
o`03001oogoo015oo`007Woo00<007ooOol0@goo00<007ooOol06Woo00<007ooOol0T7oo00<007oo
Ool06Woo00<007ooOol0T7oo00<007ooOol06Woo00<007ooOol047oo000NOol00`00Oomoo`13Ool0
0`00Oomoo`0JOol00`00Oomoo`2@Ool00`00Oomoo`0JOol00`00Oomoo`2@Ool00`00Oomoo`0KOol0
0`00Oomoo`0?Ool001ioo`03001oogoo04=oo`03001oogoo01]oo`03001oogoo08moo`03001oogoo
01]oo`03001oogoo08moo`03001oogoo01]oo`03001oogoo00moo`007Woo00<007ooOol0@goo00<0
07ooOol077oo00<007ooOol0SWoo00<007ooOol06goo00<007ooOol0Sgoo00<007ooOol077oo00<0
07ooOol03Woo000NOol00`00Oomoo`13Ool00`00Oomoo`0LOol00`00Oomoo`2>Ool00`00Oomoo`0L
Ool00`00Oomoo`2>Ool00`00Oomoo`0LOol00`00Oomoo`0>Ool000moo`L000Qoo`03001oogoo04=o
o`03001oogoo01eoo`03001oogoo08eoo`03001oogoo01eoo`03001oogoo08eoo`03001oogoo01eo
o`03001oogoo00eoo`004Woo00<007ooOol02Goo00<007ooOol0@goo00<007ooOol07Goo00<007oo
Ool0SGoo00<007ooOol07Goo00<007ooOol0SGoo00<007ooOol07Woo00<007ooOol037oo000BOol0
0`00Oomoo`09Ool00`00Oomoo`13Ool00`00Oomoo`0NOol00`00Oomoo`2<Ool00`00Oomoo`0NOol0
0`00Oomoo`2<Ool00`00Oomoo`0NOol00`00Oomoo`0<Ool0019oo`03001oogoo00Uoo`03001oogoo
04=oo`03001oogoo01moo`03001oogoo08]oo`03001oogoo01moo`03001oogoo08]oo`03001oogoo
01moo`03001oogoo00]oo`004Woo00<007ooOol02Goo00<007ooOol0@goo00<007ooOol07goo00<0
07ooOol0Rgoo00<007ooOol07goo00<007ooOol0Rgoo00<007ooOol07goo00<007ooOol02goo0002
Ool80008Ool00`00Oomoo`09Ool40012Ool00`00Oomoo`0POol00`00Oomoo`2:Ool00`00Oomoo`0P
Ool00`00Oomoo`2:Ool00`00Oomoo`0POol00`00Oomoo`0:Ool0019oo`03001oogoo00Uoo`03001o
ogoo04=oo`03001oogoo021oo`03001oogoo08Yoo`03001oogoo025oo`03001oogoo08Uoo`03001o
ogoo02eoo`004Woo00<007ooOol02Goo00<007ooOol0@goo00<007ooOol08Goo00<007ooOol0RGoo
00<007ooOol08Goo00<007ooOol0RGoo00<007ooOol0;Goo000BOol00`00Oomoo`09Ool00`00Oomo
o`13Ool00`00Oomoo`0ROol00`00Oomoo`28Ool00`00Oomoo`0ROol00`00Oomoo`28Ool00`00Oomo
o`0]Ool0019oo`03001oogoo00Uoo`03001oogoo04=oo`03001oogoo029oo`03001oogoo08Qoo`03
001oogoo029oo`03001oogoo08Qoo`03001oogoo02eoo`004Woo00<007ooOol02Goo00<007ooOol0
@goo00<007ooOol08goo00<007ooOol0Qgoo00<007ooOol08goo00<007ooOol0Qgoo00<007ooOol0
;Goo000>Ool300000goo001oo`0:Ool00`00Oomoo`13Ool00`00Oomoo`0SOol00`00Oomoo`27Ool0
0`00Oomoo`0TOol00`00Oomoo`26Ool00`00Oomoo`0]Ool0015oo`8000]oo`03001oogoo04=oo`03
001oogoo02Aoo`03001oogoo08Ioo`03001oogoo02Aoo`03001oogoo08Ioo`03001oogoo02eoo`00
7Woo00<007ooOol0@goo00<007ooOol09Goo00<007ooOol0QGoo00<007ooOol09Goo00<007ooOol0
QGoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`0UOol00`00Oomoo`25Ool00`00
Oomoo`0VOol00`00Oomoo`24Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo02Io
o`03001oogoo08Aoo`03001oogoo02Ioo`03001oogoo08Aoo`03001oogoo02eoo`007Woo0P00A7oo
00<007ooOol09goo00<007ooOol0Pgoo00<007ooOol09goo00<007ooOol0Pgoo00<007ooOol0;Goo
000NOol00`00Oomoo`13Ool00`00Oomoo`0WOol00`00Oomoo`23Ool00`00Oomoo`0XOol00`00Oomo
o`22Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo02Qoo`03001oogoo089oo`03
001oogoo02Qoo`03001oogoo089oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0
:7oo00<007ooOol0PWoo00<007ooOol0:Goo00<007ooOol0PGoo00<007ooOol0;Goo000NOol00`00
Oomoo`13Ool00`00Oomoo`0YOol00`00Oomoo`21Ool00`00Oomoo`0ZOol00`00Oomoo`20Ool00`00
Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo02Yoo`03001oogoo081oo`03001oogoo02Yo
o`03001oogoo081oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0:Woo00<007oo
Ool0P7oo00<007ooOol0:goo00<007ooOol0Ogoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool0
0`00Oomoo`0[Ool00`00Oomoo`1oOol00`00Oomoo`0/Ool00`00Oomoo`1nOol00`00Oomoo`0]Ool0
01ioo`03001oogoo04=oo`03001oogoo02aoo`03001oogoo07ioo`03001oogoo02aoo`03001oogoo
07ioo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0;7oo00<007ooOol0OWoo00<0
07ooOol0;Goo00<007ooOol0OGoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`0]
Ool00`00Oomoo`1mOol00`00Oomoo`0^Ool00`00Oomoo`1lOol00`00Oomoo`0]Ool001ioo`8004Ao
o`03001oogoo02ioo`03001oogoo07aoo`03001oogoo02ioo`03001oogoo07aoo`03001oogoo02eo
o`007Woo00<007ooOol0@goo00<007ooOol0;Woo00<007ooOol0O7oo00<007ooOol0;goo00<007oo
Ool0Ngoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`0_Ool00`00Oomoo`1kOol0
0`00Oomoo`0_Ool00`00Oomoo`1kOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo
031oo`03001oogoo07Yoo`03001oogoo031oo`03001oogoo07Yoo`03001oogoo02eoo`007Woo00<0
07ooOol0@goo00<007ooOol0<7oo00<007ooOol0NWoo00<007ooOol0<Goo00<007ooOol0NGoo00<0
07ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`0aOol00`00Oomoo`1iOol00`00Oomoo`0a
Ool00`00Oomoo`1iOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo039oo`03001o
ogoo07Qoo`03001oogoo039oo`03001oogoo07Qoo`03001oogoo02eoo`007Woo00<007ooOol0@goo
00<007ooOol0<Woo00<007ooOol0N7oo00<007ooOol0<goo00<007ooOol0Mgoo00<007ooOol0;Goo
000NOol00`00Oomoo`13Ool00`00Oomoo`0cOol00`00Oomoo`1gOol00`00Oomoo`0cOol00`00Oomo
o`1gOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo03=oo`03001oogoo07Moo`03
001oogoo03Aoo`03001oogoo07Ioo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0
=7oo00<007ooOol0MWoo00<007ooOol0=Goo00<007ooOol0MGoo00<007ooOol0;Goo000NOol00`00
Oomoo`13Ool00`00Oomoo`0eOol00`00Oomoo`1eOol00`00Oomoo`0eOol00`00Oomoo`1eOol00`00
Oomoo`0]Ool001ioo`80041oo`P003Aoo`03001oogoo00Yoo`@004=oo`@0021oo`03001oogoo01io
o`<001Eoo`03001oogoo02Aoo`L000Ioo`@003Ioo`L0009oo`03001oo`0000L002Ioo`007Woo00<0
07ooOol0?goo00D007ooOomoo`00009oo`03001oogoo03=oo`03001oogoo00]oo`03001oogoo045o
o`03001oogoo009oo`03001oogoo01eoo`03001oogoo01eoo`05001oogooOol0000EOol00`00Oomo
o`0VOol00`00Oomoo`06Ool00`00Oomoo`02Ool00`00Oomoo`0fOol00`00Oomoo`03Ool00`00Ool0
0006Ool00`00Oomoo`0TOol001ioo`03001oogoo041oo`04001oogoo000iOol00`00Oomoo`0:Ool0
0`00Oomoo`10Ool00`00Oomoo`04Ool00`00Oomoo`0LOol00`00Oomoo`0LOol00`00Oomoo`03Ool0
0`00Oomoo`0BOol00`00Oomoo`0VOol00`00Oomoo`05Ool00`00Oomoo`03Ool00`00Oomoo`0fOol0
0`00Oomoo`03Ool01000Oomoo`00;7oo000NOol00`00Oomoo`11Ool00`00Ool0000iOol00`00Oomo
o`05Ool70010Ool00`00Oomoo`05Ool00`00Oomoo`0LOol00`00Oomoo`0LOol00`00Oomoo`03Ool0
0`00Oomoo`0COol00`00Oomoo`0UOol00`00Oomoo`05Ool00`00Oomoo`04Ool00`00Oomoo`0eOol0
0`00Oomoo`03Ool01@00Oomoogoo0000:goo000NOol00`00Oomoo`12Ool2000jOol00`00Oomoo`04
Ool00`00Oomoo`02Ool00`00Oomoo`0oOol00`00Oomoo`05Ool00`00Oomoo`0LOol00`00Oomoo`0L
Ool00`00Oomoo`03Ool00`00Oomoo`0DOol00`00Oomoo`0TOol00`00Oomoo`05Ool00`00Oomoo`04
Ool00`00Oomoo`0eOol00`00Oomoo`03Ool00`00Oomoo`02Ool00`00Oomoo`0XOol001ioo`03001o
ogoo04=oo`03001oogoo03Uoo`03001oogoo00Aoo`05001oogooOol00011Ool20006Ool00`00Oomo
o`0LOol00`00Oomoo`0MOol01@00Oomoogoo00005goo00<007ooOol097oo00<007ooOol01Goo00<0
07ooOol017oo00<007ooOol0=Goo00<007ooOol00goo00<007ooOol00goo00<007ooOol09goo000N
Ool00`00Oomoo`13Ool2000jOol00`00Oomoo`04Ool01@00Oomoogoo0000@Goo00<007oo000017oo
00<007ooOol07Goo00<007ooOol07Woo100067oo00<007ooOol08goo00<007ooOol01Goo00<007oo
Ool017oo00<007ooOol0=Goo00<007ooOol00goo00<007ooOol017oo00<007ooOol09Woo000NOol0
0`00Oomoo`13Ool00`00Ool0000jOol00`00Oomoo`04Ool01000Oomoo`00@Goo00<007ooOol01000
87oo00<007ooOol07Goo00D007ooOomoo`0001Qoo`03001oogoo02=oo`03001oogoo00Eoo`03001o
ogoo00Aoo`03001oogoo03Eoo`03001oogoo00=oo`03001oogoo00Eoo`03001oogoo02Eoo`007Woo
00<007ooOol0@goo00@007ooOol003Yoo`03001oogoo00=oo`04001oogoo0011Ool00`00Oomoo`0T
Ool00`00Oomoo`0LOol00`00Oomoo`03Ool00`00Oomoo`0FOol00`00Oomoo`0ROol00`00Oomoo`05
Ool00`00Oomoo`04Ool00`00Oomoo`0eOol00`00Oomoo`03Ool00`00Oomoo`06Ool00`00Oomoo`0T
Ool001ioo`03001oogoo04=oo`04001oogoo000jOol00`00Oomoo`04Ool00`00Ool00012Ool00`00
Oomoo`0SOol00`00Oomoo`0LOol00`00Oomoo`03Ool00`00Oomoo`0GOol00`00Oomoo`0QOol00`00
Oomoo`05Ool00`00Oomoo`04Ool00`00Oomoo`0eOol00`00Oomoo`03Ool00`00Oomoo`06Ool00`00
Oomoo`0TOol001ioo`03001oogoo03moo`05001oogooOol00002Ool00`00Oomoo`0iOol00`00Oomo
o`04Ool20013Ool00`00Oomoo`0ROol00`00Oomoo`0LOol00`00Oomoo`03Ool00`00Oomoo`0GOol0
0`00Oomoo`0QOol00`00Oomoo`06Ool00`00Oomoo`02Ool00`00Oomoo`0fOol00`00Oomoo`03Ool0
0`00Ool00006Ool00`00Oomoo`0TOol001ioo`80045oo`06001oogoo001oo`00?Goo00<007ooOol0
0goo0P00A7oo0P008Woo00<007ooOol07Goo00D007ooOomoo`0001]oo`03001oogoo01aoo`<00003
Ool007oo00Moo`03001oogoo009oo`03001oogoo039oo`<00003Ool007oo00Aoo`04001oogoo0004
Ool00`00Oomoo`0UOol001ioo`03001oogoo045oo`@003ioo`03001oogoo00Aoo`03001oogoo04Ao
o`@001ioo`03001oogoo01ioo`<001eoo`03001oogoo01ioo`8000Uoo`@003Qoo`8000Eoo`04001o
ogooOol4000XOol001ioo`03001oogoo04=oo`03001oogoo03ioo`03001oogoo06aoo`03001oogoo
03ioo`03001oogoo06aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0?Woo00<0
07ooOol0K7oo00<007ooOol0?goo00<007ooOol0Jgoo00<007ooOol0;Goo000NOol00`00Oomoo`13
Ool00`00Oomoo`0oOol00`00Oomoo`1[Ool00`00Oomoo`0oOol00`00Oomoo`1[Ool00`00Oomoo`0]
Ool001ioo`03001oogoo04=oo`03001oogoo041oo`03001oogoo06Yoo`03001oogoo041oo`03001o
ogoo06Yoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0@7oo00<007ooOol0JWoo
00<007ooOol0@Goo00<007ooOol0JGoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomo
o`11Ool00`00Oomoo`1YOol00`00Oomoo`11Ool00`00Oomoo`1YOol00`00Oomoo`0]Ool001ioo`03
001oogoo04=oo`03001oogoo045oo`03001oogoo06Uoo`03001oogoo049oo`03001oogoo06Qoo`03
001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0@Woo00<007ooOol0J7oo00<007ooOol0
@Woo00<007ooOol0J7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`13Ool00`00
Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`0]Ool0019oool00>80005oo`00
7Woo00<007ooOol03Woo00<007ooOol03goo00<007ooOol03Woo00<007ooOol03goo00<007ooOol0
3goo00<007ooOol03Woo00<007ooOol03goo00<007ooOol03Woo0P0047oo00<007ooOol03Woo00<0
07ooOol03goo00<007ooOol03goo00<007ooOol03Woo00<007ooOol03goo00<007ooOol03Woo00<0
07ooOol03goo00<007ooOol03goo00<007ooOol03Woo0P0047oo00<007ooOol03Woo00<007ooOol0
3goo00<007ooOol03goo00<007ooOol03Woo00<007ooOol03goo00<007ooOol03Woo00<007ooOol0
3goo00<007ooOol02Woo000NOol00`00Oomoo`0>Ool00`00Oomoo`0?Ool00`00Oomoo`0>Ool00`00
Oomoo`0?Ool00`00Oomoo`0?Ool00`00Oomoo`0>Ool00`00Oomoo`0?Ool00`00Oomoo`0>Ool2000@
Ool00`00Oomoo`0>Ool00`00Oomoo`0?Ool00`00Oomoo`0?Ool00`00Oomoo`0>Ool00`00Oomoo`0?
Ool00`00Oomoo`0>Ool00`00Oomoo`0?Ool00`00Oomoo`0?Ool00`00Oomoo`0>Ool00`00Ool0000?
Ool00`00Oomoo`0>Ool00`00Oomoo`0?Ool00`00Oomoo`0?Ool00`00Oomoo`0>Ool00`00Oomoo`0?
Ool00`00Oomoo`0>Ool00`00Oomoo`0?Ool00`00Oomoo`0:Ool001ioo`03001oogoo04=oo`03001o
ogoo04=oo`03001oo`0004Aoo`03001oogoo021oo`03001oogoo021oo`03001oogoo029oo`03001o
ogoo01ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0AGoo
00<007ooOol0IGoo00<007ooOol0AWoo00<007ooOol0I7oo00<007ooOol0;Goo000NOol00`00Oomo
o`13Ool00`00Oomoo`16Ool00`00Oomoo`1TOol00`00Oomoo`17Ool00`00Oomoo`1SOol00`00Oomo
o`0]Ool001ioo`03001oogoo04=oo`03001oogoo04Moo`03001oogoo06=oo`03001oogoo04Moo`03
001oogoo06=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0Agoo00<007ooOol0
Hgoo00<007ooOol0B7oo00<007ooOol0HWoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00
Oomoo`18Ool00`00Oomoo`1ROol00`00Oomoo`19Ool00`00Oomoo`1QOol00`00Oomoo`0]Ool001io
o`03001oogoo04=oo`03001oogoo04Qoo`03001oogoo069oo`03001oogoo04Uoo`03001oogoo065o
o`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0BGoo00<007ooOol0HGoo00<007oo
Ool0BWoo00<007ooOol0H7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1:Ool0
0`00Oomoo`1POol00`00Oomoo`1:Ool00`00Oomoo`1POol00`00Oomoo`0]Ool001ioo`8004Aoo`03
001oogoo04Yoo`03001oogoo061oo`03001oogoo04]oo`03001oogoo05moo`03001oogoo02eoo`00
7Woo00<007ooOol0@goo00<007ooOol0Bgoo00<007ooOol0Ggoo00<007ooOol0C7oo00<007ooOol0
GWoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1;Ool00`00Oomoo`1OOol00`00
Oomoo`1<Ool00`00Oomoo`1NOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo04ao
o`03001oogoo05ioo`03001oogoo04eoo`03001oogoo05eoo`03001oogoo02eoo`007Woo00<007oo
Ool0@goo00<007ooOol0CGoo00<007ooOol0GGoo00<007ooOol0CGoo00<007ooOol0GGoo00<007oo
Ool0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1=Ool00`00Oomoo`1MOol00`00Oomoo`1>Ool0
0`00Oomoo`1LOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo04ioo`03001oogoo
05aoo`03001oogoo04moo`03001oogoo05]oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<0
07ooOol0CWoo00<007ooOol0G7oo00<007ooOol0Cgoo00<007ooOol0Fgoo00<007ooOol0;Goo000N
Ool00`00Oomoo`13Ool00`00Oomoo`1?Ool00`00Oomoo`1KOol00`00Oomoo`1@Ool00`00Oomoo`1J
Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo051oo`03001oogoo05Yoo`03001o
ogoo051oo`03001oogoo05Yoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0D7oo
00<007ooOol0FWoo00<007ooOol0DGoo00<007ooOol0FGoo00<007ooOol0;Goo000NOol20014Ool0
0`00Oomoo`1AOol00`00Oomoo`1IOol00`00Oomoo`1BOol00`00Oomoo`1HOol00`00Oomoo`0]Ool0
01ioo`03001oogoo04=oo`03001oogoo059oo`03001oogoo05Qoo`03001oogoo059oo`03001oogoo
05Qoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0DWoo00<007ooOol0F7oo00<0
07ooOol0Dgoo00<007ooOol0Egoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1C
Ool00`00Oomoo`1GOol00`00Oomoo`1COol00`00Oomoo`1GOol00`00Oomoo`0]Ool001ioo`03001o
ogoo04=oo`03001oogoo05=oo`03001oogoo05Moo`03001oogoo05Aoo`03001oogoo05Ioo`03001o
ogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0E7oo00<007ooOol0EWoo00<007ooOol0EGoo
00<007ooOol0EGoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1EOol00`00Oomo
o`1EOol00`00Oomoo`1EOol00`00Oomoo`1EOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03
001oogoo05Eoo`03001oogoo05Eoo`03001oogoo05Ioo`03001oogoo05Aoo`03001oogoo02eoo`00
7Woo00<007ooOol0@goo00<007ooOol0EWoo00<007ooOol0E7oo00<007ooOol0Egoo00<007ooOol0
Dgoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1GOol00`00Oomoo`1COol00`00
Oomoo`1GOol00`00Oomoo`1COol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo05Mo
o`03001oogoo05=oo`03001oogoo05Qoo`03001oogoo059oo`03001oogoo02eoo`007Woo0P00A7oo
00<007ooOol0F7oo00<007ooOol0DWoo00<007ooOol0FGoo00<007ooOol0DGoo00<007ooOol0;Goo
000NOol00`00Oomoo`13Ool00`00Oomoo`1IOol00`00Oomoo`1AOol00`00Oomoo`1IOol00`00Oomo
o`1AOol00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo05Uoo`03001oogoo055oo`03
001oogoo05Yoo`03001oogoo051oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0
FWoo00<007ooOol0D7oo00<007ooOol0Fgoo00<007ooOol0Cgoo00<007ooOol0;Goo000NOol00`00
Oomoo`13Ool00`00Oomoo`1JOol00`00Oomoo`1@Ool00`00Oomoo`1KOol00`00Oomoo`1?Ool00`00
Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo05]oo`03001oogoo04moo`03001oogoo05ao
o`03001oogoo04ioo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0G7oo00<007oo
Ool0CWoo00<007ooOol0GGoo00<007ooOol0CGoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool0
0`00Oomoo`1LOol00`00Oomoo`1>Ool00`00Oomoo`1MOol00`00Oomoo`1=Ool00`00Oomoo`0]Ool0
01ioo`03001oogoo04=oo`03001oogoo05eoo`03001oogoo04eoo`03001oogoo05ioo`03001oogoo
04aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0GWoo00<007ooOol0C7oo00<0
07ooOol0GWoo00<007ooOol0C7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1N
Ool00`00Oomoo`1<Ool00`00Oomoo`1OOol00`00Oomoo`1;Ool00`00Oomoo`0]Ool001ioo`8004Ao
o`03001oogoo05moo`03001oogoo04]oo`03001oogoo05moo`03001oogoo04]oo`03001oogoo02eo
o`007Woo00<007ooOol0@goo00<007ooOol0Ggoo00<007ooOol0Bgoo00<007ooOol0H7oo00<007oo
Ool0BWoo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1POol00`00Oomoo`1:Ool0
0`00Oomoo`1POol00`00Oomoo`1:Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo
065oo`03001oogoo04Uoo`03001oogoo065oo`03001oogoo04Uoo`03001oogoo02eoo`007Woo00<0
07ooOol0@goo00<007ooOol0HGoo00<007ooOol0BGoo00<007ooOol0HGoo00<007ooOol0BGoo00<0
07ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1ROol00`00Oomoo`18Ool00`00Oomoo`1R
Ool00`00Oomoo`18Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06=oo`03001o
ogoo04Moo`03001oogoo06=oo`03001oogoo04Moo`03001oogoo02eoo`003goo1`0027oo00<007oo
Ool0@goo00<007ooOol0Hgoo00<007ooOol0Agoo00<007ooOol0Hgoo00<007ooOol0Agoo00<007oo
Ool0;Goo000BOol00`00Oomoo`09Ool00`00Oomoo`13Ool00`00Oomoo`1TOol00`00Oomoo`16Ool0
0`00Oomoo`1TOol00`00Oomoo`16Ool00`00Oomoo`0]Ool0019oo`03001oogoo00Uoo`03001oogoo
04=oo`03001oogoo06Eoo`03001oogoo04Eoo`03001oogoo06Eoo`03001oogoo04Eoo`03001oogoo
02eoo`004Woo00<007ooOol02Goo00<007ooOol0@goo00<007ooOol0IGoo00<007ooOol0AGoo00<0
07ooOol0IGoo00<007ooOol0AGoo00<007ooOol0;Goo000BOol00`00Oomoo`09Ool00`00Oomoo`13
Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]
Ool0019oo`03001oogoo00Uoo`@0049oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Io
o`03001oogoo04Aoo`03001oogoo02eoo`004Woo00<007ooOol02Goo00<007ooOol0@goo00<007oo
Ool0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000BOol0
0`00Oomoo`09Ool00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol0
0`00Oomoo`14Ool00`00Oomoo`0]Ool0019oo`03001oogoo00Uoo`03001oogoo04=oo`03001oogoo
06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`004Woo00<0
07ooOol02Goo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<0
07ooOol0A7oo00<007ooOol0;Goo000BOol00`00Oomoo`09Ool00`00Oomoo`13Ool00`00Oomoo`1V
Ool00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool000ioo`<00003
Ool007oo00Yoo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03
001oogoo04Aoo`03001oogoo02eoo`004Goo0P002goo00<007ooOol0@goo00<007ooOol0IWoo00<0
07ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13
Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]
Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001o
ogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo
00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol20014Ool00`00Oomoo`1VOol0
0`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo
04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo
02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<0
07ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14
Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001o
ogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo
00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo
00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomo
o`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03
001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0
@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0
;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00
Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Ao
o`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo0P00A7oo00<007ooOol0IWoo
00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomo
o`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomo
o`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03
001oogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0
A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00
Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001io
o`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Ao
o`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007oo
Ool0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol0
0`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo
04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo
02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<0
07ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14
Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001o
ogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo
0P00A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007oo
Ool0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol0
0`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo
04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<0
07ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000N
Ool00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14
Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001o
ogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo
00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomo
o`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomo
o`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03
001oogoo04Aoo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0
A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00
Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001io
o`8004Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001o
ogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo
00<007ooOol0A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomo
o`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03
001oogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`00
7Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0
A7oo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00
Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`0]Ool000ioo`P000Qoo`03001oogoo04=oo`03001o
ogoo06Ioo`03001oogoo04Aoo`03001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`003Woo
00<007ooOol017oo00<007ooOol01Woo00<007ooOol0@goo00<007ooOol0IWoo00<007ooOol0A7oo
00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0;Goo000?Ool00`00Oomoo`0<Ool00`00Oomo
o`13Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomo
o`0]Ool0011oo`03001oogoo00]oo`03001oogoo04=oo`03001oogoo06Ioo`03001oogoo04Aoo`03
001oogoo06Ioo`03001oogoo04Aoo`03001oogoo02eoo`004Goo00<007ooOol02Woo00<007ooOol0
@goo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0IWoo00<007ooOol0A7oo00<007ooOol0
;Goo000BOol00`00Oomoo`09Ool40012Ool00`00Oomoo`1VOol00`00Oomoo`14Ool00`00Oomoo`1V
Ool00`00Oomoo`14Ool00`00Oomoo`0]Ool001=oo`03001oogoo00Qoo`03001oogoo04=oo`03001o
ogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`0057oo
00<007ooOol01goo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo
00<007ooOol0@goo00<007ooOol0;Goo000EOol00`00Oomoo`06Ool00`00Oomoo`13Ool00`00Oomo
o`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001Eoo`03
001oogoo00Ioo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03
001oogoo04=oo`03001oogoo02eoo`003Woo00<007ooOol017oo00<007ooOol01Woo00<007ooOol0
@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0
;Goo000?Ool00`00Oomoo`02Ool00`00Oomoo`07Ool00`00Oomoo`13Ool00`00Oomoo`1WOol00`00
Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool0011oo`@000Yoo`03001o
ogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001o
ogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo
00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomo
o`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03
001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`00
7Woo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0
@goo00<007ooOol0;Goo000NOol20014Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1W
Ool00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Moo`03001o
ogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo
00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo
000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomo
o`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03
001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0
Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00
Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00
Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Mo
o`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<007oo
Ool0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool0
0`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool0
01ioo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo
04=oo`03001oogoo02eoo`007Woo0P00A7oo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0
Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00
Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=o
o`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eo
o`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007oo
Ool0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool0
0`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo
06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<0
07ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<0
07ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1W
Ool00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Moo`03001o
ogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo
00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo
000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomo
o`13Ool00`00Oomoo`0]Ool001ioo`8004Aoo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo
06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<0
07ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13
Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]
Ool001ioo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001o
ogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo
00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomo
o`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03
001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03
001oogoo02eoo`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0
Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00
Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=o
o`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eo
o`007Woo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007oo
Ool0@goo00<007ooOol0;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool0
0`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001ioo`8004Aoo`03001oogoo06Moo`03
001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0
@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0
;Goo000NOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00
Oomoo`13Ool00`00Oomoo`0]Ool001ioo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=o
o`03001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`007Woo00<007ooOol0@goo00<007oo
Ool0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo000NOol0
0`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool0
0`00Oomoo`0]Ool000moo`D000Yoo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03
001oogoo06Moo`03001oogoo04=oo`03001oogoo02eoo`003Woo00<007ooOol00goo00<007ooOol0
1goo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0Igoo00<007ooOol0
@goo00<007ooOol0;Goo000EOol00`00Oomoo`06Ool00`00Oomoo`13Ool00`00Oomoo`1WOol00`00
Oomoo`13Ool00`00Oomoo`1WOol00`00Oomoo`13Ool00`00Oomoo`0]Ool001Eoo`03001oogoo00Io
o`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=oo`03001oogoo06Moo`03001oogoo04=o
o`03001oogoo02eoo`005Goo00<007ooOol01Woo00<007ooOol0@goo00<007ooOol0Igoo00<007oo
Ool0@goo00<007ooOol0Igoo00<007ooOol0@goo00<007ooOol0;Goo000EOol00`00Oomoo`06Oom7
001YOom7001YOom7000_Ool001Aoo`03001oogoo00Moo`03001oogoo0?moomAoo`004Goo0`002Woo
00<007ooOol0ogooe7oo000DOol00`00Oomoo`07Ool00`00Oomoo`3oOooDOol001Eoo`03001oogoo
00Ioo`03001oogoo0?moomAoo`005Goo00<007ooOol01Woo00<007ooOol0ogooe7oo000>Ool20004
Ool00`00Oomoo`07Ool00`00Oomoo`3oOooDOol0011oo`@000Yoo`03001oogoo0?moomAoo`00ogoo
mGoo003oOooeOol00?moooEoo`00ogoomGoo003oOooeOol00001\
\>"],
  ImageRangeCache->{{{0, 499}, {308, 0}} -> {-0.852576, -2.22074, 0.0568242, \
0.0353343}}]
}, Closed]],

Cell[TextData[{
  "However, ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " can't do things like Integrals or Fourier series on the function defined \
above.  If you wanted to find several terms of the Fourier series of the \
above function I recommend defining the function over the period (-2.5 \
\[LessEqual] x \[LessEqual] 2.5) using UnitStep functions as in the next \
cell.  Of course the function isn't actually periodic this way, but the \
function FourierTrigSeries doesn't care about that."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(f[
          x_] := \((1 + x)\) UnitStep[x + 5/2] + \((2 - x)\) 
            UnitStep[x] + \((\(-7\) + x)\) UnitStep[x - 2];\)\)}], "Input"],

Cell[CellGroupData[{

Cell["\<\
Needs[\"Calculus`FourierTransform`\"];
FourierTrigSeries[f[t], t, 4, FourierParameters\[Rule]{0,5/2}]\
\>", "Input",
  CellTags->"S5.12.1"],

Cell[BoxData[
    \(\@\(5\/2\)\ \((39\/\(10\ \@10\) + \@10\ \((\(2 - 15\ \[Pi]\)\/\(50\ \
\[Pi]\^2\) - \(\(-15\)\ \[Pi] - 2\)\/\(50\ \[Pi]\^2\))\)\ Cos[
              5\ \[Pi]\ t] + \@10\ \((\(2 + 45\ \[Pi]\)\/\(450\ \[Pi]\^2\) - \
\(45\ \[Pi] - 2\)\/\(450\ \[Pi]\^2\))\)\ Cos[
              15\ \[Pi]\ t] + \@10\ \((\(1 + 25\ \[Pi]\)\/\(25\ \[Pi]\^2\) - \
\(1 + 4\ \[Pi]\)\/\(25\ \[Pi]\^2\))\)\ Sin[5\ \[Pi]\ t] - 
          Sin[10\ \[Pi]\ t]\/\(5\ \@10\ \[Pi]\) + \@10\ \((\(75\ \[Pi] - \
1\)\/\(225\ \[Pi]\^2\) - \(12\ \[Pi] - 1\)\/\(225\ \[Pi]\^2\))\)\ Sin[
              15\ \[Pi]\ t] - 
          Sin[20\ \[Pi]\ t]\/\(10\ \@10\ \[Pi]\))\)\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In general you should find that ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "'s full symbolic capabilities including Integrate, LaplaceTransform, etc. \
can be used on piecewise continuous functions defined in terms of UnitsStep \
functions. This isn't true for the programming style used earlier."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Take generalized", "Subsection"],

Cell[TextData[{
  "The #& notation is explained in the discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"FoldList_Example1"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(\(TakeRepeated[ls_List, t_List] := 
      First /@ Rest[\n
          FoldList[Through[{Take, Drop}[#1[\([2]\)], #2]] &, {{}, ls}, 
            t]]\)\(\n\)
    \)\), "\n", 
    \(\(a1 = {a, b, c, d, e, f, g, h, i, j, k, l, m};\)\), "\n", 
    \(TakeRepeated[a1, {2, 3, 4, 1}]\)}], "Input"],

Cell[BoxData[
    \({{a, b}, {c, d, e}, {f, g, h, i}, {j}}\)], "Output"]
}, Closed]],

Cell["\<\
Portions of the function above are implemented below to illustrate how it \
works.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(tst = 
        FoldList[
          Through[{Take, Drop}[#1[\([2]\)], #2]] &, {{}, a1}, {2, 3, 4, 
            1}];\)\), "\n", 
    \(Do[Print[tst[\([n]\)]\ \ \ ], {n, 5}]\)}], "Input"],

Cell[BoxData[
    \({{}, {a, b, c, d, e, f, g, h, i, j, k, l, m}}\)], "Print"],

Cell[BoxData[
    \({{a, b}, {c, d, e, f, g, h, i, j, k, l, m}}\)], "Print"],

Cell[BoxData[
    \({{c, d, e}, {f, g, h, i, j, k, l, m}}\)], "Print"],

Cell[BoxData[
    \({{f, g, h, i}, {j, k, l, m}}\)], "Print"],

Cell[BoxData[
    \({{j}, {k, l, m}}\)], "Print"]
}, Closed]],

Cell["\<\
The effects of FoldList and Through are hard to grasp.  The lines below \
demonstrates what they do.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FoldList[f, x, {2, 3, 4, 1}]\ \  // TableForm\)], "Input"],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {"x"},
          {\(f[x, 2]\)},
          {\(f[f[x, 2], 3]\)},
          {\(f[f[f[x, 2], 3], 4]\)},
          {\(f[f[f[f[x, 2], 3], 4], 1]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      TableForm[ {x, 
        f[ x, 2], 
        f[ 
          f[ x, 2], 3], 
        f[ 
          f[ 
            f[ x, 2], 3], 4], 
        f[ 
          f[ 
            f[ 
              f[ x, 2], 3], 4], 1]}]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g];\)\), "\n", 
    \(Through[\((f + g)\)[x]]\)}], "Input"],

Cell[BoxData[
    \(f[x] + g[x]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Thread generalized", "Subsection"],

Cell["This was written by Carl Woll.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(\(WollThread[h_, args_List] := \n\t
      Table[h @@ Part[args, Flatten[Position[Length /@ args, a_ /; a >= i]], 
            i], {i, Length[args]}]\)\(\n\)
    \)\ \), "\n", 
    \(WollThread[Plus, {{a, b}, {c, d, e}, {f}}]\)}], "Input"],

Cell[BoxData[
    \({a + c + f, b + d, e}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Flatten without evaluating subexpressions", "Subsection"],

Cell["This was written by Dave Wagner.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(Attributes[MyFlatten] = {HoldFirst};\)\), "\n", 
    \(\(\(MyFlatten[
        stuff_] := \n\ \ Flatten[Hold[stuff] /. List -> Hold, Infinity, 
          Hold] /. \n\t\tHold[x__] :> Hold[{x}]\)\(\n\)
    \)\ \ \), "\n", 
    \(MyFlatten[{{Sqrt[4] + 3, x1}, {{x3}, x4}}]\)}], "Input"],

Cell[BoxData[
    \(Hold[{\@4 + 3, x1, x3, x4}]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Preventing TrigExpand from expanding as far as it can", "Subsection"],

Cell["\<\
You may not want TrigExpand to go as far as possible in expanding the \
trigonometric expression below.  Tom Burton prevents TrigExpand from \
expanding the products by changing the Head Times, and then changing it back \
to Times after using TrigExpand.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(expr = 
        Sin[2  \[Pi]\ \ \[Omega]\ \ t + 2\ \[Pi]\ \ \[Delta]];\)\), "\n", 
    \(TrigExpand[expr]\)}], "Input"],

Cell[BoxData[
    \(2\ Cos[\[Pi]\ \[Delta]]\ Cos[\[Pi]\ t\ \[Omega]]\^2\ Sin[\[Pi]\ \
\[Delta]] + 
      2\ Cos[\[Pi]\ \[Delta]]\^2\ Cos[\[Pi]\ t\ \[Omega]]\ Sin[\[Pi]\ t\ \
\[Omega]] - 
      2\ Cos[\[Pi]\ t\ \[Omega]]\ Sin[\[Pi]\ \[Delta]]\^2\ Sin[\[Pi]\ t\ \
\[Omega]] - 
      2\ Cos[\[Pi]\ \[Delta]]\ Sin[\[Pi]\ \[Delta]]\ Sin[\[Pi]\ t\ \
\[Omega]]\^2\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(TrigExpand[expr /. HoldPattern[Times[p__]] :> TimesHold[p]] /. \n\t
      TimesHold[p__] :> Times[p]\)], "Input"],

Cell[BoxData[
    \(Cos[2\ \[Pi]\ t\ \[Omega]]\ Sin[2\ \[Pi]\ \[Delta]] + 
      Cos[2\ \[Pi]\ \[Delta]]\ Sin[2\ \[Pi]\ t\ \[Omega]]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Finding the Domain of a defined function", "Subsection"],

Cell["\<\
Suppose we have a function (f[_]) that is defined for certain arguments.
The Cells below include a  program designed to indicate the values where (f) \
is defined.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f, Domain];\)\), "\[IndentingNewLine]", 
    \(\(f[1] = Sin[1];\)\), "\n", 
    \(\(f[2] = Sin[2];\)\), "\n", 
    \(f[q_Rational] := Sin[Numerator[q]]\), "\n", 
    \(f[n_?Negative] := Sin[\(-n\)]\)}], "Input"],

Cell["Definitions for (f) are stored in DownValues[f].", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DownValues[f]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[f[1]] \[RuleDelayed] Sin[1], 
      HoldPattern[f[2]] \[RuleDelayed] Sin[2], 
      HoldPattern[f[q_Rational]] \[RuleDelayed] Sin[Numerator[q]], 
      HoldPattern[f[n_?Negative]] \[RuleDelayed] Sin[\(-n\)]}\)], "Output"]
}, Closed]],

Cell["\<\
A certain part of each DownValue indicates the type of argument for which (f)
is defined.  This operation is an important part of the function below which \
gives the same
result without the Pattern matching notation.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(Part[#, 1, 1, 1] &\) /@ DownValues[f]\)], "Input"],

Cell[BoxData[
    \({1, 2, q_Rational, n_?Negative}\)], "Output"]
}, Closed]],

Cell[BoxData[{
    \(\(ClearAll[Domain];\)\), "\[IndentingNewLine]", 
    \(Domain[func_] := 
      Module[{temp, t0, t1, 
          t2}, \n\((temp = \(Part[#, 1, 1, 1] &\) /@ 
              DownValues[f]; \n\t\t\tt0 = 
            Select[temp, NumericQ]; \n\t\t\tt1 = 
            Map[Part[#, 2, 1] &, Cases[temp, _Pattern]]; \n\t\t\tt2 = 
            Map[Part[#, 2] &, Cases[temp, _PatternTest]]; \n\t\t\tJoin[t0, 
            t1, t2])\)\n\t]\)}], "Input"],

Cell["\<\
  
Now Domain[f] can be use to determine the values where (f) is defined.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Domain[f]\)], "Input"],

Cell[BoxData[
    \({1, 2, Rational, Negative}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Finding the constant term(s) in a sum", "Subsection"],

Cell[TextData[{
  "The short program below will find the constant term in a sum.  The #& \
notation used here is explained in the discussion of ",
  ButtonBox["Function",
    ButtonData:>"Function",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[ConstantTerm, x, a, b];\)\), "\[IndentingNewLine]", 
    \(\(ConstantTerm[expr_?NumericQ] := expr;\)\), "\[IndentingNewLine]", 
    \(\(\(ConstantTerm[expr_Plus] := 
        Select[expr, NumericQ[#] &];\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(ConstantTerm[expr_] /; 
          MemberQ[Attributes[Evaluate[Head[expr]]], NumericFunction] = 
        0;\)\)}], "Input"],

Cell["\<\
Below we see several examples where the constant term is found.  When the \
expression has no constant term 0 is returned.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ConstantTerm[
      1/3\  + \ x\  + \ Sqrt[2]\  + \ x\ y^2\  + \ 
        Pi\  + \ \(\(3\)\(\ \)\)\/\(1 + \@\(y + 1\)\)]\)], "Input"],

Cell[BoxData[
    \(1\/3 + \@2 + \[Pi]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ConstantTerm[x\  + \ x\ y^2\  - \ x^2]\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ConstantTerm[\[Pi]\/\(4 + \[Pi]/2\)\ x]\)], "Input"],

Cell[BoxData[
    \(0\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(ConstantTerm[Sqrt[x] + 1/x + 5 + Sqrt[2]]\)], "Input"],

Cell[BoxData[
    \(5 + \@2\)], "Output"]
}, Closed]],

Cell["\<\
ConstantTerm isn't defined if it's given an argument that isn't a numeric \
function. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(ConstantTerm[a && b]\)], "Input"],

Cell[BoxData[
    \(ConstantTerm[a && b]\)], "Output"]
}, Closed]],

Cell["\<\
An alternate definition for ConstantTerm with the same effect is given in the \
next cell.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[ConstantTerm];\)\), "\[IndentingNewLine]", 
    \(ConstantTerm[poly_?PolynomialQ] := \n\t
      With[{posn = \n\ \ \ \ \ \ Position[
              poly, _Symbol?\((Not[
                      NumericQ[#]] &)\), \n\t\ \ \ \ \ \ \ Heads -> 
                False\n\t\ \ \ ]\n\ \ }, \n\t
        ReplacePart[poly, 0, posn]\n]\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["KroneckerProduct of matrices", "Subsection"],

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(KroneckerProduct[A_?MatrixQ, 
        B_?MatrixQ] := \[IndentingNewLine]With[{tensor = 
            Outer[Times, Transpose[A], B]}, \[IndentingNewLine]\ \ Flatten[
          MapThread[Join, tensor, 2], 1]]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(A = {{a11, a12}, {a21, a22}};\)\), "\n", 
    \(\(B = {{b11, b12}, {b21, b22}};\)\), "\n", 
    \(KroneckerProduct[A, B] // MatrixForm\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {\(a11\ b11\), \(a11\ b12\), \(a12\ b11\), \(a12\ b12\)},
            {\(a11\ b21\), \(a11\ b22\), \(a12\ b21\), \(a12\ b22\)},
            {\(a21\ b11\), \(a21\ b12\), \(a22\ b11\), \(a22\ b12\)},
            {\(a21\ b21\), \(a21\ b22\), \(a22\ b21\), \(a22\ b22\)}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
InterpolatingFunction form for the solution to a system of equations.\
\>", "Subsection"],

Cell[TextData[{
  "Carl Woll gave the solution below on how to find Interpolating functions \
that solve a set of equations.  \nSuppose you are trying to find \
Interpolating functions for y[t], x[t] that solve the equations \n",
  Cell[BoxData[
      \(TraditionalForm\`\(\({\ 
        x[t]\^2 + y[t]\^2 == t\^2\ \ , \ \ y[t] == x[t]\^2\ }\)\(\ \)\)\)]],
  "  for (t) between 0 and 1."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[x, y, f, g, t];\)\), "\[IndentingNewLine]", 
    \(\(f[t_] := x[t]\^2 + y[t]\^2 - t\^2;\)\), "\[IndentingNewLine]", 
    \(\(g[t_] := y[t] - x[t]\^2;\)\), "\[IndentingNewLine]", 
    \(eqs = {\(f'\)[t] == 0, \(g'\)[t] == 0, f[1] == 0, 
        g[1] == 0}\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{
          RowBox[{\(\(-2\)\ t\), "+", 
            RowBox[{"2", " ", \(x[t]\), " ", 
              RowBox[{
                SuperscriptBox["x", "\[Prime]",
                  MultilineFunction->None], "[", "t", "]"}]}], "+", 
            RowBox[{"2", " ", \(y[t]\), " ", 
              RowBox[{
                SuperscriptBox["y", "\[Prime]",
                  MultilineFunction->None], "[", "t", "]"}]}]}], "==", "0"}], 
        ",", 
        RowBox[{
          RowBox[{
            RowBox[{
              SuperscriptBox["y", "\[Prime]",
                MultilineFunction->None], "[", "t", "]"}], "-", 
            RowBox[{"2", " ", \(x[t]\), " ", 
              RowBox[{
                SuperscriptBox["x", "\[Prime]",
                  MultilineFunction->None], "[", "t", "]"}]}]}], "==", "0"}], 
        ",", \(\(-1\) + x[1]\^2 + y[1]\^2 == 0\), 
        ",", \(y[1] - x[1]\^2 == 0\)}], "}"}]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell["soln=NDSolve[eqs,{x,y},{t,0,1}]", "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}], ",", 
            RowBox[{"y", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}], ",", 
            RowBox[{"y", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}], ",", 
            RowBox[{"y", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}]}], "}"}], ",", 
        RowBox[{"{", 
          RowBox[{
            RowBox[{"x", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}], ",", 
            RowBox[{"y", "\[Rule]", 
              TagBox[\(InterpolatingFunction[{{0.`, 1.`}}, "<>"]\),
                False,
                Editable->False]}]}], "}"}]}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
x1=x/.soln[[1]];
y1=y/.soln[[1]];

Block[{$DisplayFunction=Identity},
    p1=Plot[Re[x1[t]],{t,0,1},PlotLabel->\"Real Part of x\"];
    p2=Plot[Im[x1[t]],{t,0,1},PlotLabel->\"Imaginary Part of x\"];
    p3=Plot[Re[y1[t]],{t,0,1},PlotLabel->\"Real Part of y\"];
    p4=Plot[Im[y1[t]],{t,0,1},PlotLabel->\"Imaginary Part of y\"];
    ];
Show[GraphicsArray[{{p1,p2},{p3,p4}},GraphicsSpacing -> \
0.2,ImageSize->{550,380}]];\
\>", "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Making a list of integers relatively prime to n", "Subsection"],

Cell["\<\
Suppose we want to find a list of integers relatively prime to a Positive \
Integer (n). An immediate candidate is the function in the next cell, but it \
isn't very fast for large n because it has to examine each integer between 2 \
and (n-1).\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[RelativePrimes, pdLst, g];\)\), "\[IndentingNewLine]", 
    \(RelativePrimes[n_Integer] /; n > 2 := \[IndentingNewLine]Select[
        Range[n - 1], GCD[#, n] === 1 &]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(RelativePrimes[400000];\) // Timing\)], "Input"],

Cell[BoxData[
    \({9.340000000000003`\ Second, Null}\)], "Output"]
}, Closed]],

Cell["\<\
Ranko Bojanic found a faster solution that uses the fact  that  k< n is \
relatively prime to n if it is not divisible by any prime divisor of n. The \
list of  prime divisors of n is obtained by the following function.\
\>", "Text"],

Cell[BoxData[
    StyleBox[\(pdLst[n_] := First[Transpose[FactorInteger[n]]]\),
      FormatType->StandardForm,
      FontFamily->"Courier New",
      FontSize->10]], "Input"],

Cell[TextData[{
  "The definition for (pdList) in the next cell is faster, but it doesn't \
work in Version 3 or earlier. I am sort of splitting hairs here because an \
expression has to be quite large for Part[expr, All, 1] to be significantly \
faster, and FactorInteger will seldom return a list with more than ",
  Cell[BoxData[
      \(TraditionalForm\`10\^6\)]],
  " factors."
}], "Text"],

Cell[BoxData[
    \(pdLst[n_] := Part[FactorInteger[n], All, 1]\)], "Input"],

Cell["\<\
If (d) is a prime divisor of (n), then a list of integers between 2 and (n-1) \
which are not divisible by n is given by the following line.\
\>", "Text"],

Cell[BoxData[
    RowBox[{\(g[n_Integer, d_Integer]\), ":=", 
      StyleBox[\(Complement[Range[2, n - 1], \ d\ Range[n\ /\ d]]\),
        FormatType->StandardForm,
        FontFamily->"Courier New",
        FontSize->10]}]], "Input"],

Cell["\<\
We have to take all these lists, for all prime divisors of n, and their \
intersection will be the list of all integers between 2 and (n-1) which are \
relatively prime to n.  It is now easy to see that the list of relative prime \
integers of n can be found from the following function.\
\>", "Text"],

Cell[BoxData[{
    StyleBox[\(ClearAll[RelativePrimes];\),
      FormatType->StandardForm,
      FontFamily->"Courier New",
      FontSize->10], "\[IndentingNewLine]", 
    RowBox[{
      StyleBox[\(RelativePrimes[n_Integer] /; n > 2\),
        FormatType->StandardForm,
        FontFamily->"Courier New",
        FontSize->10], 
      StyleBox[":=",
        FormatType->StandardForm,
        FontFamily->"Courier New",
        FontSize->10], 
      StyleBox["\[IndentingNewLine]",
        FormatType->StandardForm,
        FontFamily->"Courier New",
        FontSize->10], 
      RowBox[{
        StyleBox["Module",
          FormatType->StandardForm,
          FontFamily->"Courier New",
          FontSize->10], 
        StyleBox["[",
          FormatType->StandardForm,
          FontFamily->"Courier New",
          FontSize->10], 
        StyleBox[\({g = 
              Complement[
                  Range[2, 
                    n - 1], #\ \ Range[
                      n\ /\ #]] &, \[IndentingNewLine]pdLst = 
              First[Transpose[FactorInteger[n]]]}, \[IndentingNewLine]Apply[
            Intersection, Map[g, pdLst]]\),
          FormatType->StandardForm,
          FontFamily->"Courier New",
          FontSize->10], "\[IndentingNewLine]", "]"}]}]}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(RelativePrimes[42]\)], "Input"],

Cell[BoxData[
    \({5, 11, 13, 17, 19, 23, 25, 29, 31, 37, 41}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The solution in the next cell is a slight variation of a program Alan \
Hayes wrote and it's a little faster than the last program. Keep in mind this \
variation doesn't work in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Version 3 or earlier because of the use of Part[expt, All, 1]."
}], "Text",
  CellTags->"RelativePrimes_Fold"],

Cell[BoxData[{
    \(\(ClearAll[RelativePrimes];\)\), "\[IndentingNewLine]", 
    \(RelativePrimes[n_Integer] /; n > 2 := \[IndentingNewLine]Fold[
        Complement[#, #2] &, 
        Range[2, n - 1], \(Range[#, n - 1, #] &\) /@ 
          Part[FactorInteger[n], All, 1]]\)}], "Input"],

Cell[CellGroupData[{

Cell["How the above implementation of RelativePrimes works", "Subsubsection"],

Cell[TextData[{
  "Lets consider what it does to compute RelativePrimes[42].\n\n\
Part[FactorInteger[42],All,1] returns a list of prime factors of (42) which \
is {2.3.7}.\nThen the pure function (Range[#,41,#]&) is mapped over the list \
{2, 3, 7}. This is computed as (lst1) in the next cell.. The #& notation is \
explained in the discussion of ",
  ButtonBox["Slot and SlotSequence",
    ButtonData:>"Pure Functions",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst1 = \(Range[#, 41, #] &\) /@ {2, 3, 7}\)], "Input"],

Cell[BoxData[
    \({{2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 
        38, 40}, {3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39}, {7, 14, 
        21, 28, 35}}\)], "Output"]
}, Closed]],

Cell["\<\
Then (lst2) is simply a list of integers from 2 to 41 which is the output of \
the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst2 = Range[2, 41]\)], "Input"],

Cell[BoxData[
    \({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 
      21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 
      39, 40, 41}\)], "Output"]
}, Closed]],

Cell["\<\
Then the list of relative divisors is returned by effectively evaluating the \
next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Fold[Complement[#, #2] &, lst2, lst1]\)], "Input"],

Cell[BoxData[
    \({5, 11, 13, 17, 19, 23, 25, 29, 31, 37, 41}\)], "Output"]
}, Closed]],

Cell["\<\
What Fold does in the previous cell is explicitly spelled out in the next \
cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Complement[
      Complement[Complement[lst2, Part[lst1, 1]], Part[lst1, 2], 
        Part[lst1, 3]]]\)], "Input"],

Cell[BoxData[
    \({5, 11, 13, 17, 19, 23, 25, 29, 31, 37, 41}\)], "Output"]
}, Closed]],

Cell["\<\
This implementation is elegant and runs efficiently in Mathematica, but I \
think the code is much more difficult to understand, so it's harder to \
maintain.\
\>", "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["An Algebraic Transformation", "Subsection"],

Cell["\<\
A user in the MathGroup wanted Mathematica to change 
((-1+a) x-a y)\\^2  into  ((a-1)x+a y)\\^2
Allan Hayes gave the solution in the next cell.  This solution has to be \
entered on a case by case basis.\
\>", "Text",
  CellTags->"Algebra_Transformation"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[a, x, y];\)\), "\[IndentingNewLine]", 
    \(\((\((\(-1\) + a)\) x - a\ y)\)^2 /. \((p_^n_?EvenQ)\) \[RuleDelayed] 
        Collect[\(-p\), x]^n\)}], "Input"],

Cell[BoxData[
    \(\((\((1 - a)\)\ x + a\ y)\)\^2\)], "Output"]
}, Closed]],

Cell[TextData[{
  "FactorRule in the next cell works and the rule doesn't need to know what \
variables are involved.  The only disadvantage of FactorRule is that it's \
more complicated than the first solution.  The use of (expr :) is discussed \
in my section on ",
  ButtonBox["Pattern",
    ButtonData:>"Pattern",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[BoxData[
    \(\(FactorRule = 
        expr : \((__Plus)\)^\((n_?
                  EvenQ)\) \[RuleDelayed] \[IndentingNewLine]\((Map[\(-#\) &, 
                  Part[expr, 1], 1]^n /. 
              Times[\(-1\), a_, b___] \[RuleDelayed] \(-a\)*
                  b)\);\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\((\((\(-1\) + a)\) x - a\ y)\)^2 /. FactorRule\)], "Input"],

Cell[BoxData[
    \(\((\((1 - a)\)\ x + a\ y)\)\^2\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["A New Together", "Subsection"],

Cell[TextData[{
  "A user wrote to the MathGroup indicating that Together takes a very long \
time with expressions that have on the order of ",
  Cell[BoxData[
      \(10\^7\)]],
  " leaves. They noticed together expands the numerator of the result as in \
the next example, and suspected time could be saved if the numerator wasn't \
expanded."
}], "Text",
  CellTags->"Together"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(Together[\(a + b\)\/\(c + d\) + \(e + f\)\/\(g + f\)]\)}], "Input"],

Cell[BoxData[
    \(\(c\ e + d\ e + a\ f + b\ f + c\ f + d\ f + a\ g + b\ g\)\/\(\((c + \
d)\)\ \((f + g)\)\)\)], "Output"]
}, Closed]],

Cell[BoxData[
    \(\(expr = \(a + b\)\/\(c + d\) + \(e + f\)\/\(g + f\);\)\)], "Input"],

Cell["\<\
Allan Hayes wrote SimpleTogether below which doesn't expand the numerator. \
Allan's code is given in the next cell and it's very fast and very slick.\
\>", "Text"],

Cell[BoxData[{
    \(SimpleTogether[
        expr_Plus] := \(\((\((Plus @@ \((#\ List @@ expr)\))\)/#)\) &\)[
        Times @@ Union[Denominator /@ \(List @@ expr\)]]\), "\n", 
    \(SimpleTogether[expr_] := expr\)}], "Input"],

Cell["\<\
In the next cell we see that SimpleTogether doesn't expand the numerator of \
the result.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(SimpleTogether[\(a + b\)\/\(c + d\) + \(e + f\)\/\(g + f\)]\)], "Input"],

Cell[BoxData[
    \(\(\((c + d)\)\ \((e + f)\) + \((a + b)\)\ \((f + g)\)\)\/\(\((c + d)\)\ \
\((f + g)\)\)\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Notice Allan's program uses Union which has a SameTest option.  Some \
nuances of Union and it's option are discussed at:\n",
  ButtonBox["http://support.wolfram.com/Kernel/Symbols/System/Union.html",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Union.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "  where it says the default SameTest setting used by Union is stronger \
than using Equal or SameQ! This is demonstrated in the next line."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst = N[Pi, 18] {1, 1 + 10\^\(-20\)};\)\), "\[IndentingNewLine]", 
    \(Union[lst]\)}], "Input"],

Cell[BoxData[
    \({3.1415926535897932384626433833`18, 
      3.14159265358979323849405926890462`18}\)], "Output"]
}, Closed]],

Cell["\<\
Next Union returns only one of the numbers when SameQ is used for SameTest.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Union[lst, SameTest \[Rule] \((SameQ[#1, #2] &)\)]\)], "Input"],

Cell[BoxData[
    \({3.1415926535897932384626433833`18}\)], "Output"]
}, Closed]],

Cell["\<\
Considering the lines above I think Alan's SimpleTogether function should use \
Union with the option SameTest\[Rule](SameQ[{#1,#2}]&).  In some applications \
something else might be needed.  With that in mind I wrote a version of \
Allan's program that has a SameTest option. I also give SimpleTogether the \
options Modulus and Trig which the built-in version has and I give it a usage \
message. The only thing missing is the extension option which the built-in \
version of Together does have.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[SimpleTogether];\)\), "\[IndentingNewLine]", 
    \(\(\(SimpleTogether::usage = \[IndentingNewLine]"\<SimpleTogether[expr] \
puts terms in a sum over a common denominator without 
factoring the numerator of the result.\>";\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(Options[SimpleTogether] = {SameTest \[Rule] \((SameQ[#1, #2] &)\), 
          Modulus \[Rule] 0, Trig \[Rule] False};\)\), "\n", 
    \(\(\(Attributes[SimpleTogether] = {Listable};\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(SimpleTogether[expr_Plus, 
        opts___?OptionQ] := \[IndentingNewLine]Module[{tst, mods, 
          trg}, \[IndentingNewLine]{tst, mods, 
            trg} = {SameTest, Modulus, Trig} /. 
            Flatten[{opts, 
                Options[
                  SimpleTogether]}]; \[IndentingNewLine]\(\((\((Plus @@ \((#\ \
List @@ expr)\))\)/#)\) &\)[
          Times @@ Union[\((\((Denominator[#, Modulus \[Rule] mods, 
                        Trig \[Rule] trg] &)\) /@ \(List @@ expr\))\), 
              SameTest \[Rule] tst]]\[IndentingNewLine]]\)\(\n\)
    \)\), "\n", 
    \(SimpleTogether[expr_, opts___?OptionQ] := expr\)}], "Input"],

Cell["Next we see that SimpleTogether still works.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(SimpleTogether[\(a + b\)\/\(c + d\) + \(e + f\)\/\(g + f\)]\)], "Input"],

Cell[BoxData[
    \(\(\((c + d)\)\ \((e + f)\) + \((a + b)\)\ \((f + g)\)\)\/\(\((c + d)\)\ \
\((f + g)\)\)\)], "Output"]
}, Closed]],

Cell["\<\
I don't demonstrate the options but the default settings are shown below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Options[SimpleTogether]\)], "Input"],

Cell[BoxData[
    \({SameTest \[Rule] \((#1 === #2 &)\), Modulus \[Rule] 0, 
      Trig \[Rule] False}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Making a Tensor into a Matrix", "Subsection"],

Cell["Consider the tensor (t1) in the next cell.", "Text",
  CellTags->"Tensor_to_Matrix"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[t1];\)\), "\[IndentingNewLine]", 
    \(\(t1 = {{{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, {{2, 2, 2}, {2, 2, 2}, {2, 
                2, 2}}}, {{{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}, {{4, 4, 4}, {4, 
                4, 4}, {4, 4, 4}}}};\)\), "\[IndentingNewLine]", 
    \(MatrixForm[t1]\)}], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"1", "1", "1"},
                    {"1", "1", "1"},
                    {"1", "1", "1"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"2", "2", "2"},
                    {"2", "2", "2"},
                    {"2", "2", "2"}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"3", "3", "3"},
                    {"3", "3", "3"},
                    {"3", "3", "3"}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {"4", "4", "4"},
                    {"4", "4", "4"},
                    {"4", "4", "4"}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, {{2, 2, 2}, {2, 2, 
        2}, {2, 2, 2}}}, {{{3, 3, 3}, {3, 3, 3}, {3, 3, 3}}, {{4, 4, 4}, {4, 
        4, 4}, {4, 4, 4}}}}]]], "Output"]
}, Closed]],

Cell["\<\
A user in the MathGroup wanted to express this tensor as a matrix with \
MatrixForm in the next cell. Visually  this is simple. However, the \
complicated structure of a tensor makes it a challenge to write an elegant \
program that makes the conversion.\
\>", "Text"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"1", "1", "1", "2", "2", "2"},
            {"1", "1", "1", "2", "2", "2"},
            {"1", "1", "1", "2", "2", "2"},
            {"3", "3", "3", "4", "4", "4"},
            {"3", "3", "3", "4", "4", "4"},
            {"3", "3", "3", "4", "4", "4"}
            }], "\[NoBreak]", ")"}],
      (MatrixForm[ #]&)]], "Output",
  Editable->False],

Cell["\<\
Allan Hayes provided the following two solutions in the MathGroup.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{"t2", "=", 
        RowBox[{"Apply", "[", 
          StyleBox[\(Join, Join\  @@ \ Transpose[t1, \ {1, \ 3, \ 2}], 1\),
            FormatType->StandardForm], 
          StyleBox["]",
            FormatType->StandardForm]}]}], 
      StyleBox[";",
        FormatType->StandardForm]}], "\[IndentingNewLine]", \(MatrixForm[
      t2]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"1", "1", "1", "2", "2", "2"},
            {"1", "1", "1", "2", "2", "2"},
            {"1", "1", "1", "2", "2", "2"},
            {"3", "3", "3", "4", "4", "4"},
            {"3", "3", "3", "4", "4", "4"},
            {"3", "3", "3", "4", "4", "4"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\ \(t2 = 
        Flatten[Map[Flatten, Transpose[t1, \ {1, \ 3, \ 2}], {2}], 
          1];\)\), "\[IndentingNewLine]", 
    \(MatrixForm[t2]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"1", "1", "1", "2", "2", "2"},
            {"1", "1", "1", "2", "2", "2"},
            {"1", "1", "1", "2", "2", "2"},
            {"3", "3", "3", "4", "4", "4"},
            {"3", "3", "3", "4", "4", "4"},
            {"3", "3", "3", "4", "4", "4"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
Now suppose you want to do the same thing on the higher rank tensor (t1) \
below\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(m1 = {\ \ \ {\ {{11, 11}, {11, 11}}, {{12, 12}, {12, 
                12}}}, \ {\ {{13, 13}, {13, 13}}, {{14, 14}, {14, 
                14}}\ }};\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(m2 = {\ \ \ {\ {{15, 15}, {15, 15}}, {{16, 16}, {16, 
                16}}}, \ {\ {{17, 17}, {17, 17}}, {{18, 18}, {18, 
                18}}\ }};\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(m3 = {\ \ \ {\ {{19, 19}, {19, 19}}, {{20, 20}, {20, 
                20}}}, \ {\ {{21, 21}, {21, 21}}, {{22, 22}, {22, 
                22}}\ }};\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(m4 = {\ \ \ {\ {{23, 23}, {23, 23}}, {{24, 24}, {24, 
                24}}}, \ {\ {{25, 25}, {25, 25}}, {{26, 26}, {26, 
                26}}\ }};\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(t1 = {{m1, m2}, {m3, m4}};\)\), "\[IndentingNewLine]", 
    \(MatrixForm[t1]\)}], "Input"],

Cell[BoxData[
    InterpretationBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"11", "11"},
                            {"11", "11"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"12", "12"},
                            {"12", "12"}
                            }], "\[NoBreak]", ")"}]},
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"13", "13"},
                            {"13", "13"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"14", "14"},
                            {"14", "14"}
                            }], "\[NoBreak]", ")"}]}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"15", "15"},
                            {"15", "15"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"16", "16"},
                            {"16", "16"}
                            }], "\[NoBreak]", ")"}]},
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"17", "17"},
                            {"17", "17"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"18", "18"},
                            {"18", "18"}
                            }], "\[NoBreak]", ")"}]}
                    }], "\[NoBreak]", ")"}]},
            {
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"19", "19"},
                            {"19", "19"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"20", "20"},
                            {"20", "20"}
                            }], "\[NoBreak]", ")"}]},
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"21", "21"},
                            {"21", "21"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"22", "22"},
                            {"22", "22"}
                            }], "\[NoBreak]", ")"}]}
                    }], "\[NoBreak]", ")"}], 
              RowBox[{"(", "\[NoBreak]", GridBox[{
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"23", "23"},
                            {"23", "23"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"24", "24"},
                            {"24", "24"}
                            }], "\[NoBreak]", ")"}]},
                    {
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"25", "25"},
                            {"25", "25"}
                            }], "\[NoBreak]", ")"}], 
                      RowBox[{"(", "\[NoBreak]", GridBox[{
                            {"26", "26"},
                            {"26", "26"}
                            }], "\[NoBreak]", ")"}]}
                    }], "\[NoBreak]", ")"}]}
            }], "\[NoBreak]", ")"}],
      MatrixForm[ {{{{{{11, 11}, {11, 11}}, {{12, 12}, {12, 12}}}, {{{13, 
        13}, {13, 13}}, {{14, 14}, {14, 14}}}}, {{{{15, 15}, {15, 15}}, {{16, 
        16}, {16, 16}}}, {{{17, 17}, {17, 17}}, {{18, 18}, {18, 18}}}}}, {{{{{
        19, 19}, {19, 19}}, {{20, 20}, {20, 20}}}, {{{21, 21}, {21, 21}}, {{
        22, 22}, {22, 22}}}}, {{{{23, 23}, {23, 23}}, {{24, 24}, {24, 
        24}}}, {{{25, 25}, {25, 25}}, {{26, 26}, {26, 26}}}}}}]]], "Output"]
}, Closed]],

Cell["\<\
Mathematica Version 4 has a NestWhile function that comes in handy here. The \
code in the next cell will merge together tensors of any rank.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    RowBox[{
      RowBox[{"t2", "=", 
        RowBox[{"NestWhile", "[", 
          RowBox[{
            RowBox[{
              RowBox[{"Apply", "[", 
                
                StyleBox[\(Join, Join\  @@ \ Transpose[#, \ {1, \ 3, \ 2}], 
                  1\),
                  FormatType->StandardForm], 
                StyleBox["]",
                  FormatType->StandardForm]}], 
              StyleBox["&",
                FormatType->StandardForm]}], 
            StyleBox[",",
              FormatType->StandardForm], 
            StyleBox["t1",
              FormatType->StandardForm], 
            StyleBox[",",
              FormatType->StandardForm], 
            StyleBox[\(TensorRank[#] > 2 &\),
              FormatType->StandardForm]}], 
          StyleBox["]",
            FormatType->StandardForm]}]}], 
      StyleBox[";",
        FormatType->StandardForm]}], "\[IndentingNewLine]", \(MatrixForm[
      t2]\)}], "Input"],

Cell[BoxData[
    TagBox[
      RowBox[{"(", "\[NoBreak]", GridBox[{
            {"11", "11", "12", "12", "15", "15", "16", "16"},
            {"11", "11", "12", "12", "15", "15", "16", "16"},
            {"13", "13", "14", "14", "17", "17", "18", "18"},
            {"13", "13", "14", "14", "17", "17", "18", "18"},
            {"19", "19", "20", "20", "23", "23", "24", "24"},
            {"19", "19", "20", "20", "23", "23", "24", "24"},
            {"21", "21", "22", "22", "25", "25", "26", "26"},
            {"21", "21", "22", "22", "25", "25", "26", "26"}
            }], "\[NoBreak]", ")"}],
      Function[ BoxForm`e$, 
        MatrixForm[ BoxForm`e$]]]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Distribute - A slick application", "Subsection"],

Cell[TextData[{
  "Dr. John Erb sent a problem to the MathGroup.\nHe had several pieces of \
plastic of different thickness and wanted elegant ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " code that would determine what thicknesses can be made by stacking \
together one or more of the pieces of plastic. \n\nRobby Villegas replied to \
the MathGroup in   [mg3203] Re: array ordered, of 18 Feb 1996:\nThis problem \
amounts to finding all subsets of the list of thicknesses T, and for each \
subset adding up its elements. Any subset of T can be described by giving a \
status to each of T's elements: absent or present (as noted in Jorma \
Virtamo's solution). In terms of a contribution to the total thickness, the \
ith element adds 0 if it is absent, or adds (ti) if it is present. Thus, if \
you take the Cartesian product of these ordered pairs: {0, t1} x {0, t2} x . \
. . x {0, tn} you get all possible combinations of plates, e.g. {t1, 0, 0, \
t4, t5, ...}, and you can add the elements of each combination. 'Distribute' \
is perfect for forming Cartesian products. .....\nWhat follows is a slight \
variation of Robby's solution.\nFirst we get a list of thicknesses paired \
with zero in s2."
}], "Text",
  CellTags->"Distribute - Application"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(s1 = {0.12, 0.34, 0.53, 0.53};\)\), "\[IndentingNewLine]", 
    \(s2 = Thread[{0, s1}]\)}], "Input"],

Cell[BoxData[
    \({{0, 0.12`}, {0, 0.34`}, {0, 0.53`}, {0, 0.53`}}\)], "Output"]
}, Closed]],

Cell["\<\
Next Distribute returns the cartesian product of all the ordered pairs.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst = Distribute[s2, List, List]\)], "Input"],

Cell[BoxData[
    \({{0, 0, 0, 0}, {0, 0, 0, 0.53`}, {0, 0, 0.53`, 0}, {0, 0, 0.53`, 
        0.53`}, {0, 0.34`, 0, 0}, {0, 0.34`, 0, 0.53`}, {0, 0.34`, 0.53`, 
        0}, {0, 0.34`, 0.53`, 0.53`}, {0.12`, 0, 0, 0}, {0.12`, 0, 0, 
        0.53`}, {0.12`, 0, 0.53`, 0}, {0.12`, 0, 0.53`, 0.53`}, {0.12`, 
        0.34`, 0, 0}, {0.12`, 0.34`, 0, 0.53`}, {0.12`, 0.34`, 0.53`, 
        0}, {0.12`, 0.34`, 0.53`, 0.53`}}\)], "Output"]
}, Closed]],

Cell["\<\
As Robby Villegas pointed out Distribute can take third and fourth arguments \
which specify heads that should be used to replace the outer and inner heads \
that were distributed. In this case we want the outer head to remain as List \
and we want to add the sublists. Hence Distribute in the next line does the \
job.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Distribute[s2, List, List, List, Plus] // Union\)], "Input"],

Cell[BoxData[
    \({0, 0.12`, 0.34`, 0.46`, 0.53`, 0.65`, 0.8700000000000001`, 0.99`, 
      1.06`, 1.1800000000000002`, 1.4000000000000001`, 1.52`}\)], "Output"]
}, Closed]],

Cell["\<\
Alternatively we can use the next cell to get lists of the form {{sum, \
list},...} where 'sum' is the total of the elements in 'list', and Union has \
removed elements with same sum, and sorted the list so the values of sum are \
increasing.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(q1 = 
      Union[\({Plus @@ #, #} &\) /@ lst, 
        SameTest -> \((First[#1] === First[#2] &)\)]\)], "Input"],

Cell[BoxData[
    \({{0, {0, 0, 0, 0}}, {0.12`, {0.12`, 0, 0, 0}}, {0.34`, {0, 0.34`, 0, 
          0}}, {0.46`, {0.12`, 0.34`, 0, 0}}, {0.53`, {0, 0, 0, 
          0.53`}}, {0.65`, {0.12`, 0, 0, 0.53`}}, {0.8700000000000001`, {0, 
          0.34`, 0, 0.53`}}, {0.99`, {0.12`, 0.34`, 0, 0.53`}}, {1.06`, {0, 
          0, 0.53`, 0.53`}}, {1.1800000000000002`, {0.12`, 0, 0.53`, 
          0.53`}}, {1.4000000000000001`, {0, 0.34`, 0.53`, 
          0.53`}}, {1.52`, {0.12`, 0.34`, 0.53`, 0.53`}}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Union without sorting", "Subsection"],

Cell[TextData[{
  "In June 2000 there was a long thread in the MathGroup and you can read \
about the discussion at \n",
  ButtonBox["http://library.wolfram.com/mathgroup/archive/2000/Jun/msg00115.\
html",
    ButtonData:>{
      URL[ 
      "http://library.wolfram.com/mathgroup/archive/2000/Jun/msg00115.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "  on how to write an efficient function that does the same thing as Union \
without sorting the elements. Many agree that the best way to do this is with \
the following ingeniuos function written by Carl Woll."
}], "Text",
  CellTags->"DeleteRepititions"],

Cell[BoxData[{
    \(\(ClearAll[DeleteRepititions];\)\), "\[IndentingNewLine]", 
    \(DeleteRepititions[x_] := 
      Module[{t}, \[IndentingNewLine]t[n_] := \((t[n] = Sequence[]; n)\); 
        t /@ x\[IndentingNewLine]]\)}], "Input"],

Cell["DeleteRepititions is demonstrated below.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteRepititions[\ {3, 1, 1, 6, 3, 2, 1, 1, 8, 2, 6, 8}\ ]\)], "Input"],

Cell[BoxData[
    \({3, 1, 6, 2, 8}\)], "Output"]
}, Closed]],

Cell["\<\
Actually the version Carl Woll posted used Block where I use Module above.  \
The function runs a bit faster when defined using Block, but then it gives \
the wrong result in the following example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DeleteRepititions[\ {3, 1, 1, t[3], 3, 2, t[3], 1, 1, 8, 2, 6, 
        8}\ ]\)], "Input"],

Cell[BoxData[
    \({3, 1, t[3], 2, 8, 6}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["The Evaluation Process", "Section"],

Cell[TextData[{
  "When evaluating an expression the mathematica kernel applies a collection \
of rules to an expression until the expression no longer changes.  In the \
discussion below I explain the evaluation process in greater depth.  This \
discussion of the evaluation process is based on a tutorial by David Withoff \
which is posted at   ",
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/4683/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/4683/"], None},
    ButtonStyle->"Hyperlink"],
  ".   That tutorial applied to ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 2.0, and further details to reflect changes in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 3.0 come from  Power Programming With ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " the kernel (by David Wagner).  The book by David Wagner is apparently out \
of print.  As far as I know there were no changes to the evaluation process \
in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 4 or ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " 5.\n\nThis discussion doesn't cover the use of MakeExpression, $PreRead, \
$Pre, $Post, $PrePrint, FormatValues, and MakeBoxes.  That is all discussed \
in an ",
  ButtonBox["earlier section",
    ButtonData:>"$Pre;$Post",
    ButtonStyle->"Hyperlink"],
  ".  Each step discussed there requires completing the evaluation process \
discussed in this section.\n\nFurthermore, this discussion doesn't address \
the ",
  ButtonBox["pattern matching",
    ButtonData:>"Pattern-Matching",
    ButtonStyle->"Hyperlink"],
  " process.\n"
}], "Text",
  CellTags->"Evaluation-Process"],

Cell[CellGroupData[{

Cell["Steps of Evaluating of  h[a1, a2, a3]", "Subsection"],

Cell[TextData[{
  "Below I talk about \"external DownValues\", \"internal DownValues\" and \
likewise for UpValues, SubValues, and NValues.  External values are those \
that are not part of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " kernel while internal values are those that are part of the kernel.  \n\n\
The 17 steps below are repeated until an expression no longer changes, and \
the decision to end the process happens in step 3 below.  When the expression \
being evaluated does change the whole process starts again at the begininig \
on the new expression.  In pathalogical cases such as in the next cell \
evaluation completes due to exceeding $IterationLimit.  In other cases \
evaluation completes due to exceeding $RecursionLimit.  I don't discuss how \
counting iterarions and recursions fit into the evaluation process because I \
have never seen an explanation of when that happens."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(\(f[x_] := f[x + 1];\)\), "\[IndentingNewLine]", 
    \(f[2]\)}], "Input"],

Cell[BoxData[
    \($IterationLimit::"itlim" \(\(:\)\(\ \)\) 
      "Iteration limit of \!\(4096\) exceeded."\)], "Message"],

Cell[BoxData[
    \(Hold[f[4097 + 1]]\)], "Output"]
}, Closed]],

Cell["\<\
This discussion overlooks the fact that NHoldAll, NHoldRest and NHoldFirst \
prevent N from approximating one or more argument of affected expressions.

Also the functions Plus and Times use internal UpValues and internal \
DownValues before external definitions, but that detail is overlooked \
below.\
\>", "Text"],

Cell[TextData[{
  StyleBox["Step 1",
    FontSize->16],
  "\nIf the expression being evaluated is a symbol with an OwnValue replace \
it with the OwnValue.  ",
  ButtonBox["OwnValues",
    ButtonData:>"OwnValues",
    ButtonStyle->"Hyperlink"],
  " are used when some value is assigned to a symbol (e.g.   x=5)."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 2",
    FontSize->16],
  "\nEvaluate the head of the expression."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 3",
    FontSize->16],
  "\nIf no part of the expression has changed during the last time around \
this procedure, return the expression.  This is an optimazation that prevents \
unecessary reevaluation of large expressions."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 4\n",
    FontSize->16],
  "If  (h) has the ",
  ButtonBox["HoldAllComplete",
    ButtonData:>"HoldAllComplete",
    ButtonStyle->"Hyperlink"],
  " attribute skip to step 11 below. HoldAllComplete prevents any changes to \
the arguments of a function.  \n\nIf (h) doens't have attributes that prevent \
evaluation of some or all arguments, the argumenrts evaluate from left to \
right.  When (h) has either attribute (",
  ButtonBox["HoldFirst, HoldRest, HoldAll",
    ButtonData:>"HoldAll",
    ButtonStyle->"Hyperlink"],
  ") evaluation continues without evaluating the affected arguments.  If any \
of the arguments have the head ",
  ButtonBox["Unevaluated",
    ButtonData:>"Unevaluated",
    ButtonStyle->"Hyperlink"],
  ", then the head Unevaluated is removed and further evaluation of the \
argument is prevented.  In step 17 the head Unevaluated may be restored to \
the argument.\n\nIf (h) has either attribute (HoldFirst, HoldRest, HoldAll), \
and an argument of (h) has the head Evaluate, then the argument evaluates \
even if the attribute would have prevented evaluation."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 5",
    FontSize->16],
  "\nIf (h) has the ",
  ButtonBox["Flat",
    ButtonData:>"Flat",
    ButtonStyle->"Hyperlink"],
  " attribute flatten layers of (h) as in the next cell."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(Attributes[h] = {Flat};\)\), "\[IndentingNewLine]", 
    \(h[a1, h[h[a2], a3], h[a4]]\)}], "Input"],

Cell[BoxData[
    \(h[a1, a2, a3, a4]\)], "Output"]
}, Closed]],

Cell[TextData[{
  StyleBox["Step 6",
    FontSize->16],
  "\nIf (h) does not have the ",
  ButtonBox["SequenceHold",
    ButtonData:>"SequenceHold",
    ButtonStyle->"Hyperlink"],
  " attribute splice together sequences.  \nIn the next cell Sequences are \
spliced together."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(h[Sequence[a1, a2], Sequence[a3, a4], a5]\)}], "Input"],

Cell[BoxData[
    \(h[a1, a2, a3, a4, a5]\)], "Output"]
}, Closed]],

Cell["\<\
Next (h) has the SequenceHold attribute and sequences aren't spliced.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(Attributes[h] = {SequenceHold};\)\), "\[IndentingNewLine]", 
    \(h[Sequence[a1, a2], Sequence[a3, a4], a5]\)}], "Input"],

Cell[BoxData[
    \(h[Sequence[a1, a2], Sequence[a3, a4], a5]\)], "Output"]
}, Closed]],

Cell[TextData[{
  StyleBox["Step 7",
    FontSize->16],
  "\nIf (h) has the Listable attribute thread (h) over Lists.  \nThis has the \
same effect as evaluating  Thread[ h[a1,a2,a3] ]  when (h) isn't Listable."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(Attributes[h] = {Listable};\)\), "\[IndentingNewLine]", 
    \(h[{a1, a2, a3, a4}]\)}], "Input"],

Cell[BoxData[
    \({h[a1], h[a2], h[a3], h[a4]}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(h[{a1, a2}, c, {b1, b2}]\)], "Input"],

Cell[BoxData[
    \({h[a1, c, b1], h[a2, c, b2]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  StyleBox["Step 8",
    FontSize->16],
  "\nIf (h) has the Orderless attribute sort the arguments of (h).  \nNote \
the arguments are sorted in canonical order which may not be the same as \
numeric order when the arguments are numeric.  This is seen in the next \
cell."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(Attributes[h] = {Orderless};\)\), "\[IndentingNewLine]", 
    \(h[\[Pi], 4, 2, 3]\)}], "Input"],

Cell[BoxData[
    \(h[2, 3, 4, \[Pi]]\)], "Output"]
}, Closed]],

Cell[TextData[{
  StyleBox["Step 9",
    FontSize->16],
  "\nUse external ",
  ButtonBox["Upvalues",
    ButtonData:>"Upvalues",
    ButtonStyle->"Hyperlink"],
  " for the symbolic head of of each argument of the expression.  For example \
in the next cell we would use the external UpValues of (g1), then the \
external UpValues of (g2),  then the external UpValues of Derivative are \
used.\n\nThe \"symbolic head\" of an expression is the result of nesting Head \
until a symbol is returned.    Notice Derivative is the symbolic head of  ",
  Cell[BoxData[
      \(TraditionalForm\`\((\ \(f\ '\)\ [a]\ )\)\)]],
  ".  Here we have to nest head three times to get a symbol.  The head of of  \
",
  Cell[BoxData[
      \(TraditionalForm\`\((\ \(f\ '\)\ [a]\ )\)\)]],
  " is (f ' ), and the head of that is Derivative[1], which finally has the \
head Derivative."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(h[g1[a], g2[a], \(f'\)[a]];\)\)}], "Input"],

Cell[TextData[{
  StyleBox["Step 10",
    FontSize->16],
  "\nUse internal UpValues for the symbolic head of of each argument of the \
expression.  For example in the previous cell we would use the internal \
UpValues of (g1), then the internal UpValues of (g2),  then the internal \
UpValues of Derivative are used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 11",
    FontSize->16],
  "\nIf (h) in  ",
  Cell[BoxData[
      \(TraditionalForm\`h[g1[a], \ g2[a], \ g3[a]\ ]\)]],
  "  is a symbol, the external ",
  ButtonBox["DownValues",
    ButtonData:>"DownValues",
    ButtonStyle->"Hyperlink"],
  " for (h) are used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 12",
    FontSize->16],
  "\nIf (h)  in h[g1[a], g2[a], g3[a]]  is not a symbol the external ",
  ButtonBox["SubValues",
    ButtonData:>"SubValues",
    ButtonStyle->"Hyperlink"],
  " of (h) are used.  The head of the expression in the next cell is h[1].  \
Since (h[1]) isn't a symbol the Subvalues of (h) would be used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[BoxData[
    \(\(\(h[1]\)[a, b, c];\)\)], "Input"],

Cell[TextData[{
  StyleBox["Step 13",
    FontSize->16],
  "\nIf (h) in  ",
  Cell[BoxData[
      \(TraditionalForm\`h[g1[a], \ g2[a], \ g3[a]\ ]\)]],
  "  is a symbol, the internal DownValues for (h) are used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 14",
    FontSize->16],
  "\nIf (h)  in h[g1[a], g2[a], g3[a]]  is not a symbol the internal \
SubValues of (h) are used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 15",
    FontSize->16],
  "\nUse external NValues if the expression being evaluated has the head N.  \
More precisely the ",
  ButtonBox["NValues",
    ButtonData:>"NValues",
    ButtonStyle->"Hyperlink"],
  " of the symbolic head of the first argument of N are used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 16",
    FontSize->16],
  "\nUse internal NValues if the expression being evaluated has the head N.  \
As in the previous step the NValues of the symbolic head of the first \
argument of N are used."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}}],

Cell[TextData[{
  StyleBox["Step 17",
    FontSize->16],
  "\nIf no UpValues, DownValues, SubValues, or NValues were used, and any \
arguments of (h) did have the head Unevaluated. Then the head Unevaluated is \
restored to that argument.  This is demonstrated in the next cell."
}], "Text",
  CellFrame->{{0, 0}, {0, 0.5}},
  CellTags->"Unevaluated-Advanced"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(a = 26;\)\), "\[IndentingNewLine]", 
    \(h[a + 4, Unevaluated[a]]\)}], "Input"],

Cell[BoxData[
    \(h[30, Unevaluated[a]]\)], "Output"]
}, Closed]],

Cell["\<\
Unevaluated prevents sequences from splicing, and prevents attributes such as \
Flat and Orderless from taking effect.  This is demonstrated in the next \
cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(h[x + x, 
      Unevaluated[Sequence[x, 2  x], 
        Plus[z, Plus[a, d], Plus[d, a]]]]\)}], "Input"],

Cell[BoxData[
    \(h[2\ x, 
      Unevaluated[Sequence[x, 2\ x], 
        z + \((a + d)\) + \((d + a)\)]]\)], "Output"]
}, Closed]],

Cell["\<\
However, in the next cell (h) has a downvalue that applies and we don't see \
Unevaluated in the result.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(h[x_, y_, z_] := h[x, y]\), "\[IndentingNewLine]", 
    \(h[4 + a, Unevaluated[a], 0]\)}], "Input"],

Cell[BoxData[
    \(h[4 + a, a]\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Some Examples", "Subsection"],

Cell["\<\
From the discussion above it may be hard to understand the order that parts \
of a complicated expression evaluate.  I provide two examples below to \
demonstrate.  First evaluate the next cell which makes some definitions we \
will use.\
\>", "Text"],

Cell[BoxData[{
    \(Clear["\<Global`*\>"]\), "\n", 
    \(\(a1 = b1;\)\), "\n", 
    \(\(a2 := {h[b2], b3};\)\), "\n", 
    \(\(b2 = c2;\)\), "\n", 
    \(\(b3 = b4;\)\), "\[IndentingNewLine]", 
    \(\(h = g;\)\), "\n", 
    \(\(g[x_] := x + z;\)\)}], "Input"],

Cell["Consider evaluation of the example in the next cell.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({{h[a1], a2}, a1}\)], "Input"],

Cell[BoxData[
    \({{b1 + z, {c2 + z, b4}}, b1}\)], "Output"]
}, Closed]],

Cell["\<\
You could see the order of evaluation using Trace or a similar function, but \
I find the output of these functions difficult to read. Instead I like to use \
Print statements as I do below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Clear["\<Global`*\>"]\), "\n", 
    \(\(a1 := \((Print["\<a1 \[Rule] b1\>"]; b1)\);\)\), "\n", 
    \(\(a2 := \((Print["\<a2 \[Rule] {h[b2],b3}\>"]; {h[b2], 
            b3})\);\)\), "\n", 
    \(\(b2 := \((Print["\<b2 \[Rule] c2\>"]; c2)\);\)\), "\n", 
    \(\(b3 := \((Print["\<b3 \[Rule] b4\>"]; 
          b4)\);\)\), "\[IndentingNewLine]", 
    \(\(h := \((Print["\<h \[Rule] g\>"]; g)\);\)\), "\n", 
    \(\(\(g[x_] := \((Print["\<g[_] \[Rule] \>" <> ToString[x] <> "\<+z\>"]; 
          x + z)\);\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \({{h[a1], a2}, a1}\)}], "Input"],

Cell[BoxData[
    \("h \[Rule] g"\)], "Print"],

Cell[BoxData[
    \("a1 \[Rule] b1"\)], "Print"],

Cell[BoxData[
    \("g[_] \[Rule] b1+z"\)], "Print"],

Cell[BoxData[
    \("a2 \[Rule] {h[b2],b3}"\)], "Print"],

Cell[BoxData[
    \("h \[Rule] g"\)], "Print"],

Cell[BoxData[
    \("b2 \[Rule] c2"\)], "Print"],

Cell[BoxData[
    \("g[_] \[Rule] c2+z"\)], "Print"],

Cell[BoxData[
    \("b3 \[Rule] b4"\)], "Print"],

Cell[BoxData[
    \("a1 \[Rule] b1"\)], "Print"],

Cell[BoxData[
    \({{b1 + z, {c2 + z, b4}}, b1}\)], "Output"]
}, Closed]],

Cell["\<\
Next consider how expressions evaluate when the head (h) in h[x] is a \
non-trivial expression.  The next cell gives one such example.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(h = g;\)\), "\[IndentingNewLine]", 
    \(\(g[n_] := f[2\ n];\)\), "\[IndentingNewLine]", 
    \(\(f[n_]\)[y_] := y^n\), "\[IndentingNewLine]", 
    \(\(m = 3;\)\), "\[IndentingNewLine]", 
    \(\(\(s = t;\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(h[m]\)[s]\)}], "Input"],

Cell[BoxData[
    \(t\^6\)], "Output"]
}, Closed]],

Cell["\<\
The next cell shows how evaluation in this example progresses.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear["\<Global`*\>"];\)\), "\[IndentingNewLine]", 
    \(\(h = \((Print["\<h \[Rule] g\>"]; g)\);\)\), "\[IndentingNewLine]", 
    \(\(\(g[
          n_] := \((Print["\<g[\>" <> ToString[n] <> "\<] \[Rule] f[\>" <> \ 
              ToString[2  n] <> "\<]\>"]; 
          f[2  n])\);\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(\(f[n_]\)[
        y_] := \((Print["\<f[\>" <> ToString[n] <> "\<][\>" <> 
            ToString[y] <> "\<] \[Rule] \>" <> ToString[y] <> "\<^\>" <> 
            ToString[n]]; y^n)\)\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(m = \((Print["\<m \[Rule] 3\>"]; 3)\);\)\), "\[IndentingNewLine]", 
    \(\(\(s = \((Print["\<s \[Rule] t\>"]; t)\);\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(h[m]\)[s]\)}], "Input"],

Cell[BoxData[
    \("h \[Rule] g"\)], "Print"],

Cell[BoxData[
    \("m \[Rule] 3"\)], "Print"],

Cell[BoxData[
    \("s \[Rule] t"\)], "Print"],

Cell[BoxData[
    \("g[3] \[Rule] f[6]"\)], "Print"],

Cell[BoxData[
    \("f[6][t] \[Rule] t^6"\)], "Print"],

Cell[BoxData[
    \(t\^6\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Where definitions are stored", "Section"],

Cell[TextData[{
  "The order that definitions are stored and changing the order of the \
definitions is discussed in sections ",
  ButtonBox["2.4.7",
    ButtonStyle->"MainBookLink"],
  " and ",
  ButtonBox["2.4.13",
    ButtonStyle->"MainBookLink"],
  " of The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book.\n\nIn some cases you might also need to write a function that will \
automatically examine the definitions of a certain symbol.  Your function \
might then return part of those definitions or automatically make changes to \
some of the definitions. In order to do this you need to know where the \
definitions are stored.  Mathematica stores definitions as DownValues, ",
  ButtonBox["UpValues",
    ButtonData:>"Upvalues",
    ButtonStyle->"Hyperlink"],
  ", OwnValues, NValues, SubValues, FormatValues, DefaultValues, and \
Messages.  Except for ",
  Cell[BoxData[
      \(TraditionalForm\`Attributes[symb]\)]],
  " and Options[symb] anything that affects evaluation of expressions \
involving symb are stored in one of these places and they are each discussed \
below.\n\nIf you evaluate (??symb) all information asssociated with symb is \
displayed, except the only message displayed is (symb::usage) and only if \
symb has a usage message."
}], "Text",
  CellTags->"Definition-Storage"],

Cell[CellGroupData[{

Cell["DownValues", "Subsection"],

Cell["\<\
Definitions made using (f[args] := rhs) are stored in DownValues[f] as \
demonstrated with the next cell.\
\>", "Text",
  CellTags->"DownValues"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, x, y];\)\), "\n", 
    \(\(x = 4;\)\), "\[IndentingNewLine]", 
    \(f[x_, y_] := x^2 - y^2\), "\n", 
    \(DownValues[f]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[f[x_, y_]] \[RuleDelayed] x\^2 - y\^2}\)], "Output"]
}, Closed]],

Cell["\<\
Definitions made using (f[args] = rhs) are also in DownValues[f] as \
demonstrated with the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(f[x_, y_] = x^2 - y^2\), "\n", 
    \(DownValues[f]\)}], "Input"],

Cell[BoxData[
    \(16 - y\^2\)], "Output"],

Cell[BoxData[
    \({HoldPattern[f[x_, y_]] \[RuleDelayed] 16 - y\^2}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["UpValues", "Subsection"],

Cell["\<\
Definitions made using (f/: lhs ^:= rhs) are stored in UpValues[f] as \
demonstrated with the next cell.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(\(x = 4;\)\), "\[IndentingNewLine]", 
    \(f[x_] + f[\(-x_\)] ^:= 2\ f[x]\), "\n", 
    \(UpValues[f]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[f[\(-x_\)] + f[x_]] \[RuleDelayed] 2\ f[x]}\)], "Output"]
}, Closed]],

Cell["\<\
Definitions made using (f/: lhs := rhs) are also stored in UpValues[f].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g];\)\), "\[IndentingNewLine]", 
    \(\(f /: f[x_] + g[y_] := {x, y};\)\), "\[IndentingNewLine]", 
    \(UpValues[f]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[f[x_] + g[y_]] \[RuleDelayed] {x, y}}\)], "Output"]
}, Closed]],

Cell["\<\
On rare occasions it's wise to store definitions using (f[args] ^= rhs) and \
these definitions are also stored in UpValues[f].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g];\)\), "\[IndentingNewLine]", 
    \(\(f[x_] + g[y_] ^= {x, y};\)\), "\n", 
    \(UpValues[f]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[f[x_] + g[y_]] \[RuleDelayed] {4, y}}\)], "Output"]
}, Closed]],

Cell["\<\
Use of (f/: lhs = rhs) isn't even documented, but it seems to give the \
expected result and it also makes a definition stored in  UpValues[f].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f, g];\)\), "\[IndentingNewLine]", 
    \(\(f /: f[x_] + g[y_] = {x, y};\)\), "\[IndentingNewLine]", 
    \(UpValues[f]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[f[x_] + g[y_]] \[RuleDelayed] {4, y}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["OwnValues", "Subsection"],

Cell["\<\
Definitions for (symb=expr) and (symb:=expr) are stored in OwnValues[symb].  \
The next cell assigns a value to expr.\
\>", "Text",
  CellTags->"OwnValues"],

Cell[BoxData[{\(ClearAll[expr, x];\), "\[IndentingNewLine]", 
    RowBox[{
      FormBox[\(expr = 2 + x\),
        "TraditionalForm"], ";"}]}], "Input"],

Cell["\<\
Next we see the above definition is stored in OwnValues[expr].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(OwnValues[expr]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[expr] \[RuleDelayed] 2 + x}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["NValues", "Subsection"],

Cell["\<\
Definitions for N[f[args]] are stored in NValues[f].  The next cell makes a \
definition for  N[f[x_,y_]].\
\>", "Text",
  CellTags->"NValues"],

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(N[f[x_, y_]] := N[{x, y, 0, 0, 0}]\)}], "Input"],

Cell["\<\
The above definition isn't used to evaluate the next cell because N wasn't \
used.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[\[Pi], \@3]\)], "Input"],

Cell[BoxData[
    \(f[\[Pi], \@3]\)], "Output"]
}, Closed]],

Cell["In the next cell our definition for N[f[x_,y_]] is used.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(N[f[\[Pi], \@3]]\)], "Input"],

Cell[BoxData[
    \({3.141592653589793`, 1.7320508075688772`, 0.`, 0.`, 0.`}\)], "Output"]
}, Closed]],

Cell["Our definition for N[f[x_,y_]] is stored in NValues[f].", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(NValues[f]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[N[f[x_, y_]]] \[RuleDelayed] 
        N[{x, y, 0, 0, 0}]}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["SubValues", "Subsection"],

Cell["\<\
Definitions for  f[arg1][args]  are stored in  SubValues[f].  This is \
demonstrated with the next cell.\
\>", "Text",
  CellTags->"SubValues"],

Cell[BoxData[{
    \(\(ClearAll[f, a, x, y];\)\), "\[IndentingNewLine]", 
    \(\(f[a_]\)[x_, y_] := {a, x^2 - y^2}\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(SubValues[f]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[\(f[a_]\)[x_, y_]] \[RuleDelayed] {a, 
          x\^2 - y\^2}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The next cell has the effect of defining a function ",
  Cell[BoxData[
      \(TraditionalForm\`f\_1\)]],
  " and the definition is stored in SubValues[Subscript]. \nThe definition is \
stored in SubValues[Subscript] because the head of  ",
  Cell[BoxData[
      \(TraditionalForm\`f\_1[x_, y_]\)]],
  "  is  Subscript[f,1]. "
}], "Commentary",
  SingleLetterItalics->False],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[f, Subscript]\), "\[IndentingNewLine]", 
    \(\(f\_1[x_, y_] := x^2 - y^2;\)\), "\[IndentingNewLine]", 
    \(f\_1[4, 1]\)}], "Input"],

Cell[BoxData[
    \(15\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(SubValues[Subscript]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[f\_1[x_, y_]] \[RuleDelayed] x\^2 - y\^2}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["FormatValues", "Subsection"],

Cell[TextData[{
  "A user once wrote to the MathGroup asking how one could ensure rational \
numbers greater than one are displayed as improper fractions.  ",
  Cell[BoxData[
      \(TraditionalForm\`P . J . \ Hinton\)]],
  " of Wolfram Research gave the solution below to change the way rational \
numbers are formated."
}], "Text",
  CellTags->"FormatValues"],

Cell[BoxData[{
    \(\(Unprotect[Rational];\)\), "\n", 
    \(Format[
        Rational[num_Integer, den_Integer] /; 
          Abs[num/den] > 
            1] := \[IndentingNewLine]DisplayForm[\[IndentingNewLine]RowBox[{\
ToString[Quotient[num, den]], \[IndentingNewLine]FractionBox[
              ToString[Mod[num, den]], 
              ToString[
                den]]\[IndentingNewLine]}\[IndentingNewLine]]\
\[IndentingNewLine]]\)}], "Input"],

Cell["\<\
After evaluating the cell above the output of the next cell is formatted as \
an improper fraction.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(14/3 - 1\)], "Input"],

Cell[BoxData[
    TagBox[\(3  2\/3\),
      DisplayForm]], "Output"]
}, Closed]],

Cell["\<\
Below we see that the above definition is stored in  FormatValues[Rational]. \
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FormatValues[Rational]\)], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{
        RowBox[{\(HoldPattern[
            MakeBoxes[
              Rational[num_Integer, den_Integer] /; Abs[num\/den] > 1, 
              FormatType_]]\), "\[RuleDelayed]", 
          RowBox[{"Format", "[", 
            RowBox[{
              
              TagBox[\(ToString[Quotient[num, den]] 
                  ToString[Mod[num, den]]\/ToString[den]\),
                DisplayForm], ",", "FormatType"}], "]"}]}], ",", 
        RowBox[{
          RowBox[{"HoldPattern", "[", 
            TagBox[
              
              FormBox[\(Rational[num_Integer, den_Integer] /; 
                  Abs[num\/den] > 1\),
                "StandardForm"],
              Format], "]"}], "\[RuleDelayed]", 
          
          TagBox[\(ToString[Quotient[num, den]] 
              ToString[Mod[num, den]]\/ToString[den]\),
            DisplayForm]}]}], "}"}]], "Output"]
}, Closed]],

Cell["\<\
Before you continue you might want to evaluate the next cell to restore the \
default formatting of rational numbers.\
\>", "Text"],

Cell[BoxData[{
    \(\(FormatValues[Rational] = {};\)\), "\[IndentingNewLine]", 
    \(\(Protect[Rational];\)\)}], "Input"],

Cell[TextData[{
  "MakeBoxes is similar to Format and FormatValues, and definitions using \
MakeBoxes are stored in ",
  Cell[BoxData[
      \(TraditionalForm\`DownValues[MakeBoxes]\)]],
  " or possibly in UpValues for the type of expression being formatted."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["DefaultValues", "Subsection"],

Cell[TextData[{
  "Anything stored using Default[f], Default[f,i], or Default[f,i,n] is \
stored in DefaultValues[f].  The built-in functions Plus, Times and Power \
have defaults stored as DefaultValues as the next cell shows. Use of ",
  ButtonBox["Default",
    ButtonData:>"Default details",
    ButtonStyle->"Hyperlink"],
  " was explained in an earlier section. "
}], "Text",
  CellTags->"DefaultValues"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(DefaultValues[Plus]\), "\n", 
    \(DefaultValues[Times]\), "\n", 
    \(DefaultValues[Power]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[Default[Plus]] \[RuleDelayed] 0}\)], "Output"],

Cell[BoxData[
    \({HoldPattern[Default[Times]] \[RuleDelayed] 1}\)], "Output"],

Cell[BoxData[
    \({HoldPattern[Default[Power, 2]] \[RuleDelayed] 1}\)], "Output"]
}, Closed]],

Cell["\<\
 Options are also stored in DefaultValues as demonstrated with the next cell.\
\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DefaultValues[Cancel]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[Options[Cancel]] \[RuleDelayed] {Extension \[Rule] None, 
          Modulus \[Rule] 0, Trig \[Rule] False}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "You could use DefaultValues to see what options a function has or change \
the options, but I can't see why anyone would want to do this.  Since options \
are stored as DefaultValues you should be cautious about using ",
  Cell[BoxData[
      \(TraditionalForm\`DefaultValues[symb] = {}\)]],
  " to delete all defaults.\n",
  "\nIn the next cell I assign a value to Default[f1,2] and I give f1 \
options."
}], "Text"],

Cell[BoxData[{
    \(\(ClearAll[f1];\)\), "\[IndentingNewLine]", 
    \(\(Default[f1, 2] = {1};\)\), "\[IndentingNewLine]", 
    \(\(Options[f1] = {opt1 \[Rule] val1, 
          opt3 \[RuleDelayed] val3};\)\)}], "Input"],

Cell["\<\
The next cell shows that the previous definitions are stored in \
DefaultValues[f1].\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(DefaultValues[f1]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[Default[f1, 2]] \[RuleDelayed] {1}, 
      HoldPattern[Options[f1]] \[RuleDelayed] {opt1 \[Rule] val1, 
          opt3 \[RuleDelayed] val3}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Messages", "Subsection"],

Cell["The next cell makes Messages related to the symbol foo.", "Text",
  CellTags->"Messages"],

Cell[BoxData[{
    \(\(foo::usage = "\<foo is a Symbol.\>";\)\), "\[IndentingNewLine]", 
    \(\(foo::err1 = "\<foo had invalid input.\>";\)\), "\[IndentingNewLine]", \

    \(\(foo::err2 = "\<foo got stuck.\>";\)\)}], "Input"],

Cell["\<\
At times you might want to check on or manipulate the messages above.  The \
next cell gives us the list of messages as they are stored.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Messages[foo]\)], "Input"],

Cell[BoxData[
    \({HoldPattern[foo::"err1"] \[RuleDelayed] "foo had invalid input.", 
      HoldPattern[foo::"err2"] \[RuleDelayed] "foo got stuck.", 
      HoldPattern[foo::"usage"] \[RuleDelayed] 
        "foo is a Symbol."}\)], "Output"]
}, Closed]],

Cell["\<\
Below we see that evaluating (??foo) displays the usage message for foo, but \
not the error messages for foo.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(?? foo\)], "Input"],

Cell[BoxData[
    \("foo is a Symbol."\)], "Print",
  CellTags->"Info3248519924-1535622"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Subtle points about arithmetic", "Section"],

Cell["\<\
I agree with the result below.  If we multiply a number with 50 digits of \
precision by a machine precision number, all the extra digits are garbage.  I \
get back a number with 16 digits of precision and this is good.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(pie = SetPrecision[Pi, 50];\)\), "\[IndentingNewLine]", 
    \(\(area = pie \((1.25)\)\^2;\)\), "\[IndentingNewLine]", 
    \({Precision[pie], Precision[area]}\)}], "Input"],

Cell[BoxData[
    \({50, 16}\)], "Output"]
}, Closed]],

Cell["\<\
Next I multiply a number with only 4 digits of precision by a machine \
precision number and Mathematica doesn't know that the result should have 4 \
digits of precision.  I don't like this.\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mass = SetPrecision[4.2, 4];\)\), "\[IndentingNewLine]", 
    \(\(density = mass/1.25;\)\), "\[IndentingNewLine]", 
    \({Precision[mass], Precision[density]}\)}], "Input"],

Cell[BoxData[
    \({4, 16}\)], "Output"]
}, Closed]],

Cell["\<\
To do the calculation above correctly we can do something like the line \
below.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(mass = SetPrecision[4.2, 4];\)\), "\[IndentingNewLine]", 
    \(\(density = mass/SetPrecision[1.25, \ 10];\)\), "\[IndentingNewLine]", 
    \({Precision[mass], Precision[density]}\)}], "Input"],

Cell[BoxData[
    \({4, 4}\)], "Output"]
}, Closed]],

Cell["\<\
At first you might guess that if a numeric function gets a machine precision \
number it returns a machine precision number whenever possible.  This isn't \
always true, and it can be hard to predict what you will get.  Consider the \
line below, and look at the ByteCount of the results.  If memory is concern \
and precision isn't important you should use N[Erf[x2]] to make sure the \
result is a machine number.\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x1 = Erf[26.0];\)\), "\[IndentingNewLine]", 
    \(\(x2 = Erf[27.0];\)\), "\[IndentingNewLine]", 
    \({Precision[x1], Precision[x2]}\)}], "Input"],

Cell[BoxData[
    \({16, 331}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \({ByteCount[x1], ByteCount[x2]}\)], "Input"],

Cell[BoxData[
    \({16, 192}\)], "Output"]
}, Closed]],

Cell["\<\
In the line below (b1 = a1 + Pi - 1) and the kernel thinks (b1) has better \
precision than (a1).  This is wrong!\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(a1 = Exp[1000.0]/Exp[1000];\)\), "\[IndentingNewLine]", 
    \(\(b1 = a1 + \[Pi] - 1;\)\), "\[IndentingNewLine]", 
    \({Precision[a1], Precision[b1]}\)}], "Input"],

Cell[BoxData[
    \({13, 24}\)], "Output"]
}, Closed]],

Cell["\<\
WRI tech support  indicated the calculation above can be 
done correctly by using ($MinPrecision = -Infinity).  I can't recall how, but \
I think I once saw that you can cause problems if you use the default setting \
($MinPrecision=-\[Infinity]).\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(Block[{$MinPrecision = \(-\[Infinity]\)}, \[IndentingNewLine]\(b1 = 
          a1 + \[Pi] - 1;\)]\), "\[IndentingNewLine]", 
    \({Precision[a1], Precision[b1]}\)}], "Input"],

Cell[BoxData[
    \({13, 13}\)], "Output"]
}, Closed]],

Cell["\<\
Sometimes the kernel leaves machine precision arithmetic unfinished.  See the \
example below.\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[
    \(x = 15.4/0.125 + Log[1 - Erf[8]]\)], "Input"],

Cell[BoxData[
    \(\(\(123.2`\)\(\[InvisibleSpace]\)\) + Log[1 - Erf[8]]\)], "Output"]
}, Closed]],

Cell["\<\
Below we see simply using N on the result above returns Indeterminate.  \
That's why it was returned unfinished.  We have to use arbitrary precision to \
get an ordinary number.  In this case I am impressed with how careful the \
kernel is.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({N[x], N[x, 17]}\)], "Input"],

Cell[BoxData[
    \({Indeterminate, 56.540528029194846`}\)], "Output"]
}, Closed]],

Cell["\<\
Next we say x2=N[x,25], but we only get a machine number back because of the \
123.2 term in (x).\
\>", "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x2 = N[x, 25];\)\), "\[IndentingNewLine]", 
    \({Precision[x2], MachineNumberQ[x2]}\)}], "Input"],

Cell[BoxData[
    \({16, True}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Below I define x1 and x2 to be two machine numbers very close to 9.1. \
Notice ",
  Cell[BoxData[
      \(TraditionalForm\`\((x1 === 9.1)\)\)]],
  " returns True and (x2===9.1) returns False.  It's interesting that \
(x1===9.1) returns True because we don't get zero for (x1-9.1).  Hence, if \
you really want to know if two machine numbers are exactly the same you \
should use (x-y===0.0) or (x-y\[Equal]0.0) or (x-y\[Equal]0).  I haven't \
looked into the trade offs between the three forms.  It may be that neither \
of these forms is sufficient if you are comparing arbitrary precision \
numbers."
}], "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(x1 = 9.1 + 8*$MachineEpsilon;\)\), "\[IndentingNewLine]", 
    \(\(x2 = 9.1 + 16*$MachineEpsilon;\)\), "\n", 
    \({x1 === 9.1, x2 === 9.1, x1 - 9.1, x2 - 9.1}\)}], "Input"],

Cell[BoxData[
    \({True, False, 1.7763568394002505`*^-15, 
      3.552713678800501`*^-15}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "In the cell above we saw that both x1 and x2 are a bit larger than 9.1.  \
In the next cell I define a value for f[9.1] and this definition is used for \
f[x1] but not for f[x2].  It seems that when the kernel computes f[x] the \
definition assigned to f[9.1] is used if and only if ",
  Cell[BoxData[
      \(TraditionalForm\`\((x === 9.1)\)\)]],
  " evaluates to True."
}], "Commentary"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(f[9.1] = 25;\)\), "\[IndentingNewLine]", 
    \({f[9.1], f[x1], f[x2]}\), "\[IndentingNewLine]", 
    \(\)}], "Input"],

Cell[BoxData[
    \({25, 25, f[9.100000000000003`]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "For more read the  ",
  ButtonBox["Numerics Report",
    ButtonStyle->"GettingStartedLink"],
  "  in the Help Browser."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Lists and Tables of Data", "Section"],

Cell[CellGroupData[{

Cell["Importing an columns of data from an ASCII file", "Subsection"],

Cell["\<\
Suppose you have matrix of data in an ASCII file, and the file is in a \
directory included in $Path.\
\>", "Text"],

Cell[BoxData[
    \(\(!! data.txt\)\)], "Input"],

Cell["\<\
In version 4.0 and later data can be brought in with the Import command using \
the line in the next cell.  When the second argument is \"Table\" entries are \
brought in as numbers when possible and as strings when they can't be \
numbers.\
\>", "Text"],

Cell["\<\
MyData=Import[\"data.txt\",\"Table\"];
TableForm[MyData]\
\>", "Input"],

Cell["\<\
This can be done in any version of Mathematica using ReadList as below. You \
might also prefer this method because it may be faster than Import. In this \
example the second argument {Word, Number, Number} indicates each line is an \
ASC string, followed two numbers.\
\>", "Text"],

Cell["\<\
MyData=ReadList[\"data.txt\", {Word,Number,Number}];
TableForm[MyData]\
\>", "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Working with a List or Table of data", "Subsection"],

Cell["\<\
For some efficient ways of making lists see examples of Range, Array, and \
Table.  Some good ways to work with a matrix of numbers are shown in the \
Cells below.  First we make a matrix of random integers called (data).\t\t  \
\
\>", "Text",
  CellTags->"Lists_Tables"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(data = 
        Table[{Random[Integer, {0, 10}], \n\tRandom[Integer, {50, 60}], \n\t
            Random[Integer, {\(-10\), 0}]}, {i, 8}];\)\), "\n", 
    \(TableForm[data]\)}], "Input",
  FontSize->12],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(-1\)},
          {"7", "50", \(-5\)},
          {"10", "57", \(-5\)},
          {"7", "60", \(-10\)},
          {"6", "54", \(-4\)},
          {"2", "50", "0"},
          {"10", "58", "0"},
          {"10", "54", \(-10\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[TextData[{
  "Functions that have the Listable attribute are performed on each element \
of nested lists.  Hence the following line adds 100 to each element of data. \
Besides being very concise this is the most efficient way to do something \
like this in ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(d2 = data + 500;\)\), "\n", 
    \(TableForm[d2]\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"502", "551", "499"},
          {"507", "550", "495"},
          {"510", "557", "495"},
          {"507", "560", "490"},
          {"506", "554", "496"},
          {"502", "550", "500"},
          {"510", "558", "500"},
          {"510", "554", "490"}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
In the next line MapAt is used to add 500 to the fourth row of data.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(d2 = MapAt[# + 500 &, data, 4];\)\), "\n", 
    \(TableForm[d2]\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(-1\)},
          {"7", "50", \(-5\)},
          {"10", "57", \(-5\)},
          {"507", "560", "490"},
          {"6", "54", \(-4\)},
          {"2", "50", "0"},
          {"10", "58", "0"},
          {"10", "54", \(-10\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["We can perform an operation f[] on the third column of data.", "Text",
  FontSize->12],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[f];\)\), "\[IndentingNewLine]", 
    \(data /. {x_, y_, z_} :> {x, y, f[z]} // TableForm\)}], "Input",
  FontSize->12],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(f[\(-1\)]\)},
          {"7", "50", \(f[\(-5\)]\)},
          {"10", "57", \(f[\(-5\)]\)},
          {"7", "60", \(f[\(-10\)]\)},
          {"6", "54", \(f[\(-4\)]\)},
          {"2", "50", \(f[0]\)},
          {"10", "58", \(f[0]\)},
          {"10", "54", \(f[\(-10\)]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
Sometimes the simple method above doesn't do what you want. For example in \
the next cell the pattern matcher assigns (x,y,z) to the 1st, 2nd, 3rd rows, \
but we wanted (x,y,z) to be the 1st, 2nd and 3rd elements of each row.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(d2 = Take[data, 3];\)\), "\[IndentingNewLine]", 
    \(d2 /. {x_, y_, z_} :> {x, y, f[z]} // TableForm\)}], "Input",
  FontSize->12],

Cell[BoxData[
    InterpretationBox[GridBox[{
          {"2", "51", \(-1\)},
          {"7", "50", \(-5\)},
          {\(f[{10, 57, \(-5\)}]\), "\<\"\"\>", "\<\"\"\>"}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      TableForm[ {{2, 51, -1}, {7, 50, -5}, 
        f[ {10, 57, -5}]}]]], "Output"]
}, Closed]],

Cell["\<\
The problem in the last example can be avoided if we ensue either x, y or z \
is numeric as in the next cell.  We could just as well ensure x, y, or z is \
not a vector.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(d2 = Take[data, 3];\)\), "\[IndentingNewLine]", 
    \(d2 /. {x_?NumericQ, y_, z_} :> {x, y, f[z]} // TableForm\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(f[\(-1\)]\)},
          {"7", "50", \(f[\(-5\)]\)},
          {"10", "57", \(f[\(-5\)]\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
We can swap the second and third columns. To keep this example simple I don't \
ensure that neither x, y or z are numeric, but in some cases that would be \
necessary.\
\>", "Text",
  FontSize->12],

Cell[CellGroupData[{

Cell[BoxData[
    \(data /. {x_, y_, z_} :> {x, z, y} // TableForm\)], "Input",
  FontSize->12],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", \(-1\), "51"},
          {"7", \(-5\), "50"},
          {"10", \(-5\), "57"},
          {"7", \(-10\), "60"},
          {"6", \(-4\), "54"},
          {"2", "0", "50"},
          {"10", "0", "58"},
          {"10", \(-10\), "54"}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
We can select the elements of data that have a second element less than 56.  \
\
\>", "Text",
  FontSize->12],

Cell[CellGroupData[{

Cell[BoxData[
    \(Select[data, \((#[\([2]\)] < 56)\) &\ ]\  // TableForm\)], "Input",
  FontSize->12],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(-1\)},
          {"7", "50", \(-5\)},
          {"6", "54", \(-4\)},
          {"2", "50", "0"},
          {"10", "54", \(-10\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell["\<\
The method below is less cryptic, but it requires the use of a global \
variable to name the testing function. It also turns out that the less \
cryptic method takes about twice as much time to evaluate.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(small[sample_] := sample[\([2]\)] < 56;\)\), "\n", 
    \(Select[data, small] // TableForm\)}], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(-1\)},
          {"7", "50", \(-5\)},
          {"6", "54", \(-4\)},
          {"2", "50", "0"},
          {"10", "54", \(-10\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[TextData[{
  "One method that's very attractive is to use Cases as below.\nAlso see the \
separate discussion of ",
  ButtonBox["Cases",
    ButtonData:>"Cases",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Cases[data, \ {_, y_, _} /; y < 56]\  // TableForm\)], "Input",
  FontSize->12],

Cell[BoxData[
    TagBox[GridBox[{
          {"2", "51", \(-1\)},
          {"7", "50", \(-5\)},
          {"6", "54", \(-4\)},
          {"2", "50", "0"},
          {"10", "54", \(-10\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      Function[ BoxForm`e$, 
        TableForm[ BoxForm`e$]]]], "Output"]
}, Closed]],

Cell[TextData[{
  "To see how to sort a matrix according to the values in a certain column of \
the matrix see the discussion of ",
  ButtonBox["Sort",
    ButtonData:>"Sort",
    ButtonStyle->"Hyperlink"],
  ".  For more on this topic see \n",
  ButtonBox["http://documents.wolfram.com/v5/Built-inFunctions/\
AdvancedDocumentation/LinearAlgebra/",
    ButtonData:>{
      URL[ 
      "http://documents.wolfram.com/v5/Built-inFunctions/\
AdvancedDocumentation/LinearAlgebra/"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Pattern Matching", "Section"],

Cell[TextData[{
  "The symbols ",
  ButtonBox["Blank, BlankSequence, BlankNullSequence",
    ButtonData:>"Blank",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Alternatives",
    ButtonData:>"Alternatives",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Pattern",
    ButtonData:>"Pattern",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Optional",
    ButtonData:>"Optional",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Repeated, RepeatedNull",
    ButtonData:>"Repeated RepeatedNull",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Condition",
    ButtonData:>"Condition",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["PatternTest",
    ButtonData:>"PatternTest",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Verbatim",
    ButtonData:>"Verbatim",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["HoldPattern",
    ButtonData:>"HoldPattern",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Default",
    ButtonData:>"Default details",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Orderless",
    ButtonData:>"Orderless",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Flat",
    ButtonData:>"Flat",
    ButtonStyle->"Hyperlink"],
  ", and ",
  ButtonBox["OneIdentity",
    ButtonData:>"OneIdentity",
    ButtonStyle->"Hyperlink"],
  " are all related to pattern matching in ",
  StyleBox["Mathematica.  ",
    FontSlant->"Italic"],
  "Each of these symbols are discussed in this notebook."
}], "Text",
  CellTags->"Pattern-Matching"],

Cell[CellGroupData[{

Cell["Some examples", "Subsection"],

Cell[BoxData[
    \(\(\( (*\ 
      An\ Integer\ *) \)\(\[IndentingNewLine]\)\(x_Integer\)\(\ \)\)\)], \
"Input"],

Cell[BoxData[
    \(\(\( (*\ 
      A\ sequence\ of\ one\ or\ more\ Integers\ in\ a\ list\ *) \)\(\
\[IndentingNewLine]\)\({x__Integer}\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ A\ sequence\ of\ one\ or\ more\ Integers\ in\ a\ list, \ 
      or\ an\ empty\ list\ *) \)\(\[IndentingNewLine]\)\({x___Integer}\)\(\ \
\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ A\ Positive\ number\ *) \)\(\[IndentingNewLine]\)\(x_?
      Positive\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      A\ sequence\ of\ one\ or\ more\ Positive\ numbers\ in\ a\ list\ *) \)\(\
\[IndentingNewLine]\)\({x__?Positive}\)\(\ \)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      A\ sequence\ of\ one\ or\ more\ Positive\ numbers\ in\ a\ list, \ 
      or\ an\ empty\ list\ *) \)\(\[IndentingNewLine]\)\({x___?
        Positive}\)\(\ \)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ A\ Positive\ Integer\ *) \)\(\[IndentingNewLine]\)\(x_Integer?
      Positive\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      A\ number\ between\  - 
        1\ and\ 1\ *) \)\(\[IndentingNewLine]\)\(x_?\((\(-1\) < # < 
            1 &)\)\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      A\ list\ of\ {x, 
          y}\ coordinates\ *) \)\(\[IndentingNewLine]\)\(data : {{_, _} \
.. }\)\)\)], "Input"],

Cell[BoxData[
    \(\(\( (*\ 
      A\ pair\ of\ numbers\ where\ x\ is\ less\ than\ y\ *) \)\(\
\[IndentingNewLine]\)\({x_, y_} /; x < y\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["A pattern must match the FullForm", "Subsection"],

Cell[TextData[{
  "Finding the right pattern needed to make a transformation on an algebraic \
expression can be non-trivial. Consider the next cell where we would like to \
make the transformation\n",
  Cell[BoxData[
      FormBox[
        StyleBox[\(\(a\/\(s - z1\)\)\[LongRightArrow]\(a\/\(1 - 
                  Exp[z1]\ /z\)\)\),
          FontSize->16], TraditionalForm]]],
  " on each term.\nThis is a simplified example of a real world problem I \
encountered when I needed to change the transfer function of a continuous \
filter to the transfer function (in the z-domain) of the corresponding \
discrete filter. The most intuitive attempt to make this transformation is \
shown in the next cell, and you can see it doesn't work."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(\(Clear[expr, x, s]\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(expr = \(\(8\)\(\ \)\)\/\(2 + 4  \[ImaginaryI] + s\) + \(\(3\)\(\ \
\)\)\/\(2 - 4  \[ImaginaryI] + s\);\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(expr /. 
      a_/\((s - z1_)\) \[RuleDelayed] a/\((1 - Exp[z1]/z)\)\)}], "Input"],

Cell[BoxData[
    \(3\/\(\((2 - 4\ \[ImaginaryI])\) + s\) + 
      8\/\(\((2 + 4\ \[ImaginaryI])\) + s\)\)], "Output"]
}, Closed]],

Cell["\<\
The attempt above doesn't work because the pattern doesn't match the FullForm \
of the expression we want to change.  The next cell indicates what the \
FullForm is.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(FullForm[8\/\(2 + 4  \[ImaginaryI] + s\)]\)], "Input"],

Cell[BoxData[
    TagBox[
      StyleBox[\(Times[8, Power[Plus[Complex[2, 4], s], \(-1\)]]\),
        ShowSpecialCharacters->False,
        ShowStringCharacters->True,
        NumberMarks->True],
      FullForm]], "Output"]
}, Closed]],

Cell["\<\
The transformation in the next cell mathces the FullForm and does what we \
want.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(expr /. \((a_*\((s + z1_)\)^\(-1\))\) \[RuleDelayed] 
        a/\((1 - Exp[\(-z1\)]/z)\)\)], "Input"],

Cell[BoxData[
    \(8\/\(1 - \[ExponentialE]\^\(\(-4\)\ \[ImaginaryI] - 2\)\/z\) + 
      3\/\(1 - \[ExponentialE]\^\(4\ \[ImaginaryI] - 2\)\/z\)\)], "Output"]
}, Closed]],

Cell[TextData[{
  "For more examples in pattern matching see the sections on  ",
  ButtonBox["MatchQ",
    ButtonData:>"MatchQ",
    ButtonStyle->"Hyperlink"],
  " and ",
  ButtonBox["HoldPattern",
    ButtonData:>"HoldPattern",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"],

Cell[TextData[{
  "Note:  The attributes ",
  ButtonBox["Orderless",
    ButtonData:>"Orderless",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["Flat",
    ButtonData:>"Flat",
    ButtonStyle->"Hyperlink"],
  ", and ",
  ButtonBox["OneIdentity",
    ButtonData:>"OneIdentity",
    ButtonStyle->"Hyperlink"],
  " have an effect on pattern matching."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["The pattern matcher doesn't look inside \"atoms\"", "Subsection"],

Cell["\<\
Integers, rational numbers, and complex numbers are \"atoms\", and the \
pattern matcher doesn't look at the individual parts of these things.  That \
is why we get only only one Position from the next input.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Position[{2, 222, 3\/2, 2 + 3  \[ImaginaryI]}, 2]\)], "Input"],

Cell[BoxData[
    \({{1}}\)], "Output"]
}, Closed]],

Cell["\<\
Keep in mind that the functions in the table below can be used to take apart \
atoms.  
Also be aware that the real and imaginary parts of a complex number can each \
be Real, Rational, or Integer values.
\
\>", "Text"],

Cell[TextData[Cell[BoxData[GridBox[{
        {
          StyleBox["Head",
            FontWeight->"Bold"], 
          StyleBox[\(Function\ to\ take\ apart\ the\ atom\),
            FontWeight->"Bold"]},
        {"Complex", \(Re, \ Im\)},
        {"Rational", \(Numerator, \ Denominator\)},
        {"Real", "RealDigits"},
        {"Integer", "IntegerDigits"},
        {"String", "Characters"}
        },
      ColumnWidths->{7, 17},
      ColumnAlignments->{Left}]]]], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["The pattern (x_Symbol) may not be specific enough", "Subsection"],

Cell["\<\
In the next input a function f[x, n] is defined where x must be a symbol and \
n must be an integer.\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[f, z, t, x, n];\)\), "\[IndentingNewLine]", 
    \(f[x_Symbol, n_Integer] := Expand[\((x + 1)\)\^n]\)}], "Input"],

Cell[TextData[{
  "Below we see that the above definition is used for ",
  StyleBox["f[\[Pi],3]", "InlineInput"],
  " and",
  StyleBox["[s,3]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  " when (s) evaluates to the symbol (t)."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(s = t;\)\), "\[IndentingNewLine]", 
    \({f[s, 3], f[Pi, 3]}\)}], "Input"],

Cell[BoxData[
    \({1 + 3\ t + 3\ t\^2 + t\^3, 
      1 + 3\ \[Pi] + 3\ \[Pi]\^2 + \[Pi]\^3}\)], "Output"]
}, Closed]],

Cell["\<\
However you might want to require that the first argument of (f) is a \
variable and \[Pi] is clearly not a variable.  The next definition does the \
job.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\[IndentingNewLine]", 
    \(\(\(f[x_Symbol?\((\(! NumericQ[#]\) &)\), n_Integer] := 
      Expand[\((x + 1)\)\^n]\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \({f[s, 3], f[Pi, 3]}\)}], "Input"],

Cell[BoxData[
    \({1 + 3\ t + 3\ t\^2 + t\^3, f[\[Pi], 3]}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "However, it gets a more complicated if you want to account for symbols \
that were removed.  This was explained by Robby Villegas of Wolfram Research \
at the 1999 Developer Converence.  See \"Working With Unevaluated Expressions\
\" posted at \n",
  ButtonBox["http://library.wolfram.com/conferences/devconf99/#programming",
    ButtonData:>{
      URL[ "http://library.wolfram.com/conferences/devconf99/#programming"], 
      None},
    ButtonStyle->"Hyperlink"],
  ".\n\nBelow the symbol (t) is removed, so (s) evaluates to ",
  StyleBox["Removed[\"t\"]",
    FontFamily->"Courier",
    FontWeight->"Bold"],
  ". When f[s, 3] is evaluated the first argument Removed[\"t\"] matches the \
pattern ",
  StyleBox["(x_Symbol?(!NumericQ[#]&))", "InlineInput"],
  ". One would think Removed[\"t\"] would be an expression with Head Removed \
and argument \"t\", but it doesn't work that way.  "
}], "Text",
  CellTags->"s_Symbol"],

Cell[BoxData[
    \(Remove[t]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(f[s, 3]\)], "Input"],

Cell[BoxData[
    RowBox[{"1", "+", 
      RowBox[{"3", " ", 
        TagBox[\(Removed["t"]\),
          False,
          Editable->False]}], "+", 
      RowBox[{"3", " ", 
        SuperscriptBox[
          TagBox[\(Removed["t"]\),
            False,
            Editable->False], "2"]}], "+", 
      SuperscriptBox[
        TagBox[\(Removed["t"]\),
          False,
          Editable->False], "3"]}]], "Output"]
}, Closed]],

Cell["\<\
In the next cell I give a new definition for (f) that requires that the first \
argument is a non-numeric symbol that hasn't been Removed. \
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(ClearAll[f];\)\), "\n", 
    \(f[x_Symbol?\((\(! NumericQ[#]\) && NameQ[ToString[#]] &)\), n_Integer] := 
      Expand[\((x + 1)\)\^n]\), "\n", 
    \({f[z, 3], f[s, 3], f[\[Pi], 3]}\)}], "Input"],

Cell[BoxData[
    RowBox[{"{", 
      RowBox[{\(1 + 3\ z + 3\ z\^2 + z\^3\), ",", 
        RowBox[{"f", "[", 
          RowBox[{
            TagBox[\(Removed["t"]\),
              False,
              Editable->False], ",", "3"}], "]"}], ",", \(f[\[Pi], 3]\)}], 
      "}"}]], "Output"]
}, Closed]],

Cell["\<\
You might find the function (UserSymbolQ) below useful.  It returns True when \
it's argument is a Non-numeric symbol that hasn't been removed and is not in \
the System Context.\
\>", "Text"],

Cell[BoxData[
    RowBox[{
      RowBox[{"UserSymbolQ", "=", 
        RowBox[{"Function", "[", 
          RowBox[{\({a}\), ",", 
            RowBox[{\(Head[a] === Symbol\), "&&", 
              RowBox[{"(", 
                RowBox[{\(Context[a]\), "=!=", 
                  StyleBox["\"\<System`\>\"",
                    ShowSpecialCharacters->False,
                    ShowStringCharacters->True,
                    NumberMarks->True]}], ")"}], 
              "&&", \(NameQ[ToString[a]]\)}]}], "]"}]}], ";"}]], "Input"],

Cell["In the cell below the only \"UserSymbol\" is t4.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(t2 = t1;\)\), "\n", 
    \(\(t3 = 3;\)\), "\n", 
    \(Remove[t1]\), "\n", 
    \(UserSymbolQ /@ {Sin, \[Pi], 3, t2, t3, t4}\)}], "Input"],

Cell[BoxData[
    \({False, False, False, False, False, True}\)], "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Controlling Memory Usage", "Section"],

Cell[CellGroupData[{

Cell["Use a sensible  $HistoryLength", "Subsection",
  CellTags->"Controlling Memory Usage"],

Cell[TextData[{
  "By default ($HistoryLength=\[Infinity]), and this causes Mathematica to \
remember every 'In' cell and 'Out' cell during your entire session. This is \
ridiculous because you would never make reference to an output from a very \
long time ago as I do with  ",
  StyleBox["In[943]",
    FontColor->RGBColor[0, 0, 1]],
  "  in the next cell."
}], "Text"],

Cell[BoxData[
    \(Expand[%27]\)], "Input",
  CellLabel->"In[943]:=",
  Editable->False,
  Evaluatable->False,
  CellLabelAutoDelete->False],

Cell["\<\
To avoid eating up more and more memory you should put something like the \
next line at the end of your (init.m) file.  That way $HistoryLenght will \
always be set to 15 when you start Mathemmatica.\
\>", "Text"],

Cell[BoxData[
    \(\($HistoryLength = 15;\)\)], "Input"],

Cell[TextData[{
  StyleBox["How to find your (Init.m) file.",
    FontSize->14,
    FontColor->RGBColor[1, 0, 0]],
  "\nEvaluating the next cell will return the directory where your (init.m) \
file is located."
}], "Text"],

Cell[BoxData[
    \(ToFileName[{$TopDirectory, "\<Configuration\>", "\<Kernel\>"}]\)], \
"Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Save your notebook once in a while", "Subsection"],

Cell["\<\
Saving your notebook allows the Front End to return excess memory to the \
Operating System.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Clear the Clipboard", "Subsection"],

Cell["\<\
If you Copy or Cut something that requires a lot of memory clear the \
ClipBoard when you are done with it. An easy way to essentially clear the \
clipboard is to select a small expression, a few words in a text cell, or \
something else that is small, and select Copy under the Edit menu.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["End with ; (a semi-colon) to avoid lengthy output", "Subsection"],

Cell["\<\
Ending with a semi-colon suppresses output. When an output is very long this \
saves time and memory.\
\>", "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Tech Support Secrets", "Section"],

Cell[TextData[{
  "From  ",
  ButtonBox["http://support.wolfram.com/mathematica/kernel/Symbols/",
    ButtonData:>{
      URL[ "http://support.wolfram.com/mathematica/kernel/Symbols/"], None},
    ButtonStyle->"Hyperlink"],
  "  you can access web pages Wolfram Research technical support provides for \
every built-in Mathematica symbol. In most cases you are linked to a web page \
that shows the usage message of the symbol and the full explanation from \
Appendix A.10 of the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Book for the selected symbol.  The real value of this resource is the \
extra information provided for 30 or so kernel symbols. The extra information \
they provide about these symbols isn't available anywhere else!  \
Unfortunately Wolfram Research does nothing to show which of the  1700+  \
symbols in the System context have this extra information.\n\nI came across a \
lot of these pages with juicy bits of information and hyperlinks for the \
respective symbols are provided below."
}], "Text",
  CellTags->"Tech Support"],

Cell[TextData[{
  ButtonBox["AdjustmentBox",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
AdjustmentBox.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Apart",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Apart.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ArgumentCountQ",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/ArgumentCountQ.html"],
       None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Assumptions",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
Assumptions.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Coefficient",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/Coefficient.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Compile",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Compile.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["D",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/D.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Derivative",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/Derivative.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Det",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Det.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Dot",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Dot.html"]\
, None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["DSolve",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/DSolve.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Factor",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Factor.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["FactorInteger",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/FactorInteger.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Flat",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Flat.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["FullOptions",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
FullOptions.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["FullSimplify",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/FullSimplify.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["HoldAllComplete",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/HoldAllComplete.html"]\
, None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["HoldComplete",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/HoldComplete.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Integrate",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Integrate.html"],
       None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Interpolation",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/Interpolation.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Interval",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Interval.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["LinearProgramming",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
LinearProgramming.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["ListContourPlot",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
ListContourPlot.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["LUDecomposition",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
LUDecomposition.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["MakeRules",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/MakeRules.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["MatrixExp",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/MatrixExp.html"],
       None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["MatrixQ",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/MatrixQ.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["NDSolve",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/NDSolve.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Notebook",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Notebook.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["OneIdentity",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/OneIdentity.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Permutations",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/\
Permutations.html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Precision",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Precision.html"],
       None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Prime",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Prime.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["PrimePi",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/PrimePi.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Random",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Random.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Residue",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Residue.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Return",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Return.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Root",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Root.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Roots",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Roots.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Series",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Series.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Simplify",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Simplify.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Solve",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Solve.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["StoppingTest",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/Kernel/Symbols/System/StoppingTest.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Sum",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Sum.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Timing",
    ButtonData:>{
      URL[ 
      "http://support.wolfram.com/mathematica/kernel/Symbols/System/Timing.\
html"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Together",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Together.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["Union",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Union.html"], 
      None},
    ButtonStyle->"Hyperlink"]
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Programming for Speed", "Section"],

Cell["\<\
In the cells below I give some rules of thumb that enhance the speed of \
Mathematica programs.\
\>", "Text",
  CellTags->"Speedy_Programming"],

Cell[CellGroupData[{

Cell["Use look up tables", "Subsection"],

Cell["\<\
When you have values for (f) defined for specific values such as 
f[1]=y1;
f[2]=y2;
f[3]=y3;
  ...
Mathematica can evaluate something like f[2] with great speed. The speed of \
evaluation is very fast for definitions that are free of patterns such as x_ \
or {x_,y_}. I refer to storage of function values for specific arguments as a \
look up table.

For example you could define a new version of Prime that evaluates over a \
certain range of large integers much faster than the built-in Prime function. \
The next cell defines MyPrime which uses Prime for n<5000000000, and has \
explicit values stored for 5000000000<n<5000000010.  I felt it would be \
appropriate to first try the rules for 5000000000<n<5000000010 so I rearrange \
the list of DownValues. The output below shows the resulting list of \
definitions.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(ClearAll[MyPrime]\), "\n", 
    \(\(\(MyPrime[n_Integer?\((# < 5000000000 &)\)] := 
      Prime[n]\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(Evaluate[MyPrime /@ Range[5000000000, 5000000010]] = \n
        Table[Prime[n], {n, 5000000000, 5000000010}];\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(DownValues[MyPrime] = RotateRight[DownValues[MyPrime], 1]\)}], "Input"],

Cell[BoxData[
    \({HoldPattern[MyPrime[n_Integer?\((#1 < 5000000000 &)\)]] \[RuleDelayed] 
        Prime[n], 
      HoldPattern[MyPrime[5000000000]] \[RuleDelayed] 122430513841, 
      HoldPattern[MyPrime[5000000001]] \[RuleDelayed] 122430513847, 
      HoldPattern[MyPrime[5000000002]] \[RuleDelayed] 122430513857, 
      HoldPattern[MyPrime[5000000003]] \[RuleDelayed] 122430513913, 
      HoldPattern[MyPrime[5000000004]] \[RuleDelayed] 122430513923, 
      HoldPattern[MyPrime[5000000005]] \[RuleDelayed] 122430513971, 
      HoldPattern[MyPrime[5000000006]] \[RuleDelayed] 122430514049, 
      HoldPattern[MyPrime[5000000007]] \[RuleDelayed] 122430514069, 
      HoldPattern[MyPrime[5000000008]] \[RuleDelayed] 122430514091, 
      HoldPattern[MyPrime[5000000009]] \[RuleDelayed] 122430514123, 
      HoldPattern[MyPrime[5000000010]] \[RuleDelayed] 
        122430514181}\)], "Output"]
}, Closed]],

Cell["\<\
Now in the next cell I do the same thing with explicit values stored for \
5000000000<n<5000010000, but display of the list of rules is suppressed \
because it's very long. You should be patient when the next cell is evaluated \
because it takes several minutes.\
\>", "Text"],

Cell[BoxData[{
    \(ClearAll[MyPrime]\), "\n", 
    \(\(\(MyPrime[n_Integer?\((# < 5000000000 &)\)] := 
      Prime[n]\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(\(Evaluate[MyPrime /@ Range[5000000000, 5000010000]] = \n
        Table[Prime[n], {n, 5000000000, 
            5000010000}];\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(DownValues[MyPrime] = 
        RotateRight[DownValues[MyPrime], 1];\)\)}], "Input"],

Cell["\<\
Once the definitions for MyPrime are stored a list of primes can be made with \
the next cell almost instantly.\
\>", "Text"],

Cell[BoxData[
    \(Table[MyPrime[n], {n, 5000000000, 5000000400}]\)], "Input"],

Cell["\<\
An  implementation with more sensible use of memory would only store explicit \
definitions of MyPrime for say 5000000500, 50000001000, 5000001500, \
5000002000, ... and would evaluate Nest[NextPrime,MyPrime[50000001000],43] to \
determine MyPrime[50000001043]. I didn't do that here because my purpose here \
is to demonstrate how fast the lookup table is.

Often times look-up tables are created on the fly using definitions of the \
form:
f[x_]:=f[x]=expr
This can result in efficient programs if (f) needs to be evaluated many times \
for the same argument.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Use functional programming", "Subsection"],

Cell["\<\
The tools of functional programming include:
   Map  MapAt  Thread  Apply  MapThread  MapAll  MapIndexed  Fold  FixedPoint \
 Nest  NestWhile
   FoldList  FixedPointList  NestList  NestWhileList  Scan  Inner  Outer  \
Distribute.
Each of these are often an important part of very efficient programs.

Other functional programming tools available are:
    ComposeList, Composition  Operate  Through.
 These other functional programming features are also efficient, but seldom \
needed in practice.
 
No examples of the functions listed above are provided here, but many of them \
have a devoted section in this notebook\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Use pure functions", "Subsection"],

Cell["\<\
In the next cell three similar functions are defined . The function f1 is \
defined with a named pattern while pure functions are used to define f2 and \
f3. We see the implementation defined with pure functions run much faster \
than the definition defined with a named pattern.  Also the short hand form \
(6 #+13)&  runs a bit faster than Function[x, 6 x+13].\
\>", "Text"],

Cell[BoxData[{
    \(\(ClearAll[lst, f1, f2, f3];\)\), "\[IndentingNewLine]", 
    \(\(SetAttributes[{f1, f2, f3}, Listable];\)\ \), "\[IndentingNewLine]", 
    \(\(f1[x_] = 3  x + 5;\)\), "\n", 
    \(\(f2 = Function[x, 4\ x + 6];\)\), "\[IndentingNewLine]", 
    \(\(\(f3 = 6  # + 13 &;\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(lst1 = Range[10^6];\)\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(f1[lst1];\) // Timing\)], "Input"],

Cell[BoxData[
    \({4.781000000000006`\ Second, Null}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(f2[lst1];\) // Timing\)], "Input"],

Cell[BoxData[
    \({0.07800000000000296`\ Second, Null}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(f3[lst1];\) // Timing\)], "Input"],

Cell[BoxData[
    \({0.06199999999999761`\ Second, Null}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Use \"linked lists\" instead of adding to a list", "Subsection"],

Cell["\<\
The most straight forward way of adding to a list uses PrependTo or AppendTo \
as in the next cell. There are a number of other ways you could effectively \
do the same thing but they are all very slow for making long lists. As an \
example consider the program in the next cell which makes a list by \
prepending values.\
\>", "Text",
  CellTags->"Linked-List"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst1 = {};\)\), "\[IndentingNewLine]", 
    \(Do[\((y = Sin[20.0\ t]; 
          If[Positive[y], PrependTo[lst1, y]];)\), \[IndentingNewLine]{t, 0, 
          10^4}] // Timing\)}], "Input"],

Cell[BoxData[
    \({4.22999999999999`\ Second, Null}\)], "Output"]
}, Closed]],

Cell["\<\
The faster way to build the list in the previous cell is to make a linked \
list which looks like  
{... ,y4,{y3,{y2,{y1}}}} instead of {...  ,y4,y3,y2,y1} as returned by the \
program in the previous cell. Flatten can then be used to convert the linked \
list into a flattened list.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst2 = {};\)\), "\[IndentingNewLine]", 
    \(Do[\((y = Sin[20.0\ t]; 
          If[Positive[y], lst2 = {y, lst2}];)\), \[IndentingNewLine]{t, 0, 
          10^4}] // Timing\)}], "Input"],

Cell[BoxData[
    \({0.3900000000000148`\ Second, Null}\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst1 == Flatten[lst2]\)], "Input"],

Cell[BoxData[
    \(True\)], "Output"]
}, Closed]],

Cell["\<\
However a temporary head is needed if you want to quickly build up a list \
such as 
{... ,{x4,y4},{x3,y3},{x2,y2},{x1,y1}}. In that case an expression with the \
form 
h[{x4,y4},h[{x3,y3},h[{x2,y2},h[x1,y2]]]] can be built-up. Then you can get \
the desired result by flattening the nested list and changing the head (h) to \
List. This is done in the next two cells.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(lst2 = h[];\)\), "\[IndentingNewLine]", 
    \(\(\(Do[\((y = Sin[20.0\ t]; 
        If[Positive[y], lst2 = h[{t, y}, lst2]];)\), \[IndentingNewLine]{t, 
        0, 12}]\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(lst2\)}], "Input"],

Cell[BoxData[
    \(h[{12, 0.9454451549211168`}, 
      h[{11, 0.08839871248753149`}, 
        h[{8, 0.21942525837900473`}, 
          h[{7, 0.9802396594403116`}, 
            h[{6, 0.5806111842123143`}, 
              h[{2, 0.7451131604793488`}, 
                h[{1, 0.9129452507276277`}, h[]]]]]]]]\)], "Output"]
}, Closed]],

Cell[CellGroupData[{

Cell[BoxData[
    \(lst2 = Flatten[lst2] /. h -> List\)], "Input"],

Cell[BoxData[
    \({{12, 0.9454451549211168`}, {11, 0.08839871248753149`}, {8, 
        0.21942525837900473`}, {7, 0.9802396594403116`}, {6, 
        0.5806111842123143`}, {2, 0.7451131604793488`}, {1, 
        0.9129452507276277`}}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Avoid use of AppendTo and PrependTo", "Subsection"],

Cell["\<\
Use of PrependTo and AppendTo is not a problem if they only evaluate a few \
times.  But your program will be very slow if they evaluate many times.  This \
point was made in the previous rule of thumb.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Don't compute the same thing over and over", "Subsection"],

Cell[TextData[{
  "Often times one needs to have an understanding of the ",
  ButtonBox["evaluation process",
    ButtonData:>"Evaluation-Process",
    ButtonStyle->"Hyperlink"],
  " to know when things are computed over and over.  An example of this point \
is given in the section on Set versus SetDelayed which is copied below.\n\n\
Alan Hayes provided the code in the next cell as an example where (  \
func[x_]=  ) should be used instead of ( func[x]:=  ).\nIf we did use ( \
func[x_]:=  ) in this example the least squares fit would be computed  again \
for every value of (x) when we evaluate something like \nPlot[curve[t],{t,0,\
\[Pi]/3}]."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x];\)\), "\[IndentingNewLine]", 
    \(\(data = 
        Table[{x, Cos[x] + Random[]/10}, {x, 0, \[Pi]/3, 0.025}];\)\), "\n", 
    \(curve[x_] = Fit[data, {1, x, x\^2}, x]\)}], "Input"],

Cell[BoxData[
    \(\(\(1.0444861456299661`\)\(\[InvisibleSpace]\)\) + 
      0.02492241415586885`\ x - 0.4937189510715279`\ x\^2\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Use the simplest form possible", "Subsection"],

Cell["\<\
Some Mathematica functions are special cases of other functions. An example \
of this is Range which is a special case of Table. Hence Range will make a \
list in the next cell faster than Table would.\
\>", "Text"],

Cell[BoxData[{
    \(\(slow = Table[i, {i, 5000}];\)\), "\[IndentingNewLine]", 
    \(\(fast = Range[5000];\)\)}], "Input"],

Cell["\<\
Lots of Mathematica functions have multiple forms available. In many cases \
simpler forms are available which are special cases of more general forms. \
Hence Table runs faster in the next cell when an iterator isn't used.\
\>", "Text"],

Cell[BoxData[{
    \(\(slow = Table[Random[], {i, 10^5}];\)\), "\[IndentingNewLine]", 
    \(\(fast = Table[Random[], {10^5}];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Minimize the number of expressions the kernel must evaluate", \
"Subsection"],

Cell["\<\
Ensuring that a program needs to evaluate the fewest number of expressions is \
an important part of minimizing the time a program needs to evaluate. For \
example the Dot product of two vectors evaluates much faster when the built \
in Dot function is used in the next cell.  Here the slow version evaluates \
Part 100 times, Times 50 times and one call to Sum.  The fast version makes \
only one call to Dot.  Clearly Dot must multiply respective parts of each \
list, but it does so much more effeciently than we can with the slow version.\
\
\>", "Text"],

Cell[BoxData[{\(Clear[x, y];\), "\[IndentingNewLine]", \(x = 
        Range[50];\), "\[IndentingNewLine]", \(y = 
        Table[\((\(-0.9\))\)\^n, {n, 50}];\), "\[IndentingNewLine]", 
    RowBox[{
      RowBox[{"slow", "=", 
        RowBox[{
          StyleBox[\(\[Sum]\+\(i = 1\)\%50\),
            ScriptLevel->0], 
          StyleBox[" ",
            ScriptLevel->0], \(Part[x, i] Part[y, i]\)}]}], 
      ";"}], "\[IndentingNewLine]", \(fast = x . y;\)}], "Input"],

Cell["\<\
Another example (which only works in Version 4 or later) is given in the next \
cell where the slow method of making a list needs to evaluate Part 12 times, \
but the fast method does the same thing in one application of Take.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[x, lst];\)\), "\n", 
    \(\(data = x\ Range[70];\)\), "\n", 
    \(\(slow = Table[Part[data, 3\ n], {n, 1, 12}];\)\), "\n", 
    \(fast = Take[data, {3, 50, 3}]\)}], "Input"],

Cell[BoxData[
    \({3\ x, 6\ x, 9\ x, 12\ x, 15\ x, 18\ x, 21\ x, 24\ x, 27\ x, 30\ x, 
      33\ x, 36\ x, 39\ x, 42\ x, 45\ x, 48\ x}\)], "Output"]
}, Closed]],

Cell["\<\
Still another example (which only works in Version 4) is given in the next \
cell where the slow method maps First onto each element of data, but the fast \
method does the same thing with one application of Part. When the slow method \
is used First must be evaluated over and over.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(Clear[data];\)\), "\[IndentingNewLine]", 
    \(\(data = 
        Table[{i, 2.5\ i\^3}, {i, 1, 120, 3}];\)\), "\[IndentingNewLine]", 
    \(\(slow = First /@ data;\)\), "\[IndentingNewLine]", 
    \(fast = Part[data, All, 1]\)}], "Input"],

Cell[BoxData[
    \({1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 
      55, 58, 61, 64, 67, 70, 73, 76, 79, 82, 85, 88, 91, 94, 97, 100, 103, 
      106, 109, 112, 115, 118}\)], "Output"]
}, Closed]],

Cell["\<\
In the next cell we can use Table and Take to split up a list into sublists.  \
The built-in function Partition is designed just for this purpose and does \
the job much faster.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \(\(data = Range[100];\)\), "\n", 
    \(\(slow = 
        Table[Take[data, {10*n, 10*\((n + 1)\)}], {n, 1, 9}];\)\), "\n", 
    \(fast = Partition[data, 10]\)}], "Input"],

Cell[BoxData[
    \({{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19, 
        20}, {21, 22, 23, 24, 25, 26, 27, 28, 29, 30}, {31, 32, 33, 34, 35, 
        36, 37, 38, 39, 40}, {41, 42, 43, 44, 45, 46, 47, 48, 49, 50}, {51, 
        52, 53, 54, 55, 56, 57, 58, 59, 60}, {61, 62, 63, 64, 65, 66, 67, 68, 
        69, 70}, {71, 72, 73, 74, 75, 76, 77, 78, 79, 80}, {81, 82, 83, 84, 
        85, 86, 87, 88, 89, 90}, {91, 92, 93, 94, 95, 96, 97, 98, 99, 
        100}}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "Other special purpose functions are ListConvolve, ListCorrelate, Split, \
Ordering, and Tr to name a few.  Any direct use of these functions is \
probably faster than doing the same thing with some ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " code you might write. \n",
  "\n",
  "Another example of this principle is changing the value at multiple parts \
of an expression by using the Part feature only once. This is demonstrated in \
the section on ",
  ButtonBox["Part",
    ButtonData:>"Part",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Use approximate machine numbers whenever appropriate", "Subsection"],

Cell["\<\
If your application can tolerate the round off error inherent in machine \
precision arithmetic you can greatly improve the speed of your program by \
ensuring all numeric calculation is done on approximate machine numbers. Of \
course certain calculations over integers (e.g. multiplication and addition) \
are quickly computed over machine integers and computing with approximate \
numbers would not be any faster in that case.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Use Packed Arrays", "Subsection"],

Cell[TextData[{
  "Rob Knapp provides a tutorial on Packed Arrays at  ",
  ButtonBox["http://library.wolfram.com/database/TechNotes/391/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/database/TechNotes/391/"], None},
    ButtonStyle->"Hyperlink"],
  ". and I give simplified examples of the trick he uses to speed up an \
implementation of LUDecomposition above in my discussion of ",
  ButtonBox["Part",
    ButtonData:>"Part",
    ButtonStyle->"Hyperlink"],
  ".\n\nAs Rob explains you often need to use certain programming methods to \
get the improved speed possible with the with Packed Arrays. \nTo start with \
you only get the benefit of packed arrays when your data structure can fit in \
a packed array.  For more on this subject see chapter 6 (Performance) at: \n\
",
  ButtonBox["http://documents.wolfram.com/v5/Built-inFunctions/\
AdvancedDocumentation/LinearAlgebra/",
    ButtonData:>{
      URL[ 
      "http://documents.wolfram.com/v5/Built-inFunctions/\
AdvancedDocumentation/LinearAlgebra/"], None},
    ButtonStyle->"Hyperlink"],
  ".\n "
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Use Compile effectively", "Subsection"],

Cell[TextData[{
  " The speed of programs can often be enhanced if they are written using \
Compile, but you need to take certain steps to ensure the program evaluates \
with compiled evaluation. This is discussed in the section on ",
  ButtonBox["Compile",
    ButtonData:>"Compiled_Evaluation",
    ButtonStyle->"Hyperlink"],
  ".  As I mention in that discussion only certain types of work can be done \
with compiled evaluation."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Don't use ReplacePart, MapAt or Insert when the last argument is a 
long List (>40).\
\>", "Subsection"],

Cell[TextData[{
  "ReplacePart, MapAt and Insert are very slow in this case. For mor \
explanation see the discussion of ",
  ButtonBox["Slow Kernel Functions",
    ButtonData:>"Slow_Functions",
    ButtonStyle->"Hyperlink"],
  "."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Be careful about modifying large data structures in place over and over\
\>", "Subsection"],

Cell[TextData[{
  "This discussion on modifying large data structures comes from  \"Power \
Programming with Mathematica The Kernel\"  by David B. Wagner.\n\nThis isn't \
so much a rule of thumb, but a trick that is useful in special cases. \
Consider computing a moving average of a list of numbers.  With the first \
approach below we use (s) as our input and output.  As explained where I \
discuss the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " ",
  ButtonBox["evaluation process",
    ButtonData:>"Evaluation-Process",
    ButtonStyle->"Hyperlink"],
  " each element of (s) is evaluated again each time s[[i]] is accessed \
because (s) was modified since it was last used.  All the exccess evaluation \
is very inefficient and the time needed with this approach is proportional to \
the square of the length of the list."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \( (*\ Slow; \ 
      O[n\^2]\ *) \[IndentingNewLine]\(s = 
        Range[2*10^4];\)\), "\[IndentingNewLine]", 
    \(\(Do[
          s[\([i]\)] = \((s[\([i]\)] + s[\([i + 1]\)])\)/2, {i, 
            Length[s] - 1}];\) // Timing\)}], "Input"],

Cell[BoxData[
    \({13.765000000000008`\ Second, Null}\)], "Output"]
}, Closed]],

Cell["\<\
By simply hanging the head of the list to HoldComplete the exccess evaluation \
is prevented, and the time needed is directly proportional to the length of \
the list.  At the end we change the head back to List.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \( (*\ Fast; \ 
      O[n]\ *) \[IndentingNewLine]\(s = 
        Range[2*10^4];\)\), "\[IndentingNewLine]", 
    \(Timing[\[IndentingNewLine]s = HoldComplete @@ s; \[IndentingNewLine]Do[
        s[\([i]\)] = \((s[\([i]\)] + s[\([i + 1]\)])\)/2, {i, 
          Length[s] - 1}]; \[IndentingNewLine]s = 
        List @@ s;\[IndentingNewLine]]\)}], "Input"],

Cell[BoxData[
    \({0.23499999999999943`\ Second, Null}\)], "Output"]
}, Closed]],

Cell["\<\
It's even better to avoid a procedual approach all together as I do in the \
next cell.  The performance gain here is largely due to reducing the number \
of expressions that need to evaluate (one of my other rules of thumb).

However, in some cases the HoldComplete trick above provides the best \
solution.\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
    \( (*\ Very\ Fast\ *) \[IndentingNewLine]\(s = 
        Range[2*10^4];\)\), "\[IndentingNewLine]", 
    \(Timing[\(\((Rest[s] + Drop[s, \(-1\)])\)/2;\)]\)}], "Input"],

Cell[BoxData[
    \({0.046999999999997044`\ Second, Null}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Beware of inefficient patterns", "Subsection"],

Cell[TextData[{
  "Most of this discussion on inefficient patterns is from \"Power \
Programming with Mathematica The Kernel\" by David B.Wagner.\n\nAn \
implementation of run length encoding is given below.  This implementation \
written by Frank Zizza is clearly elegant and it even won an award in a \
programming contest at a 1990 ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " conference."
}], "Text"],

Cell[BoxData[
    \(runEncode[s_List] := 
      Map[{#, 1} &, 
          s] //. \[IndentingNewLine]{h___, {x_, n_}, {x_, m_}, 
            t___} :> {h, {x, n + m}, t}\)], "Input"],

Cell["In the next cell we see an example using runEncode.", "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \(runEncode[{1, 0, 0, 1, 1, 0, 1, 1, 1, 1}]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {0, 2}, {1, 2}, {0, 1}, {1, 4}}\)], "Output"]
}, Closed]],

Cell["\<\
Next we see that runEncode takes a long time to encode a list of 2000 \
integers.  In fact the time it takes this implementation to finish is \
proportional to the square of the length of the list, and this is not good at \
all.\
\>", "Text"],

Cell[BoxData[
    \(\(tst = Table[Random[Integer, {0, 1}], {2*10^3}];\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(runEncode1[tst];\) // Timing\)], "Input"],

Cell[BoxData[
    \({14.296`\ Second, Null}\)], "Output"]
}, Closed]],

Cell[TextData[{
  "The reason this implementation performs poorly is because of the way the \
kernel performs pattern matching. In the next cell we see pattern matching in \
action by causing the replacement to print each attempt at matching the \
pattern.\n\nThere are two important points about this result.  First, the \
kernel attempts to match sequence patterns (e.g.  __, ___, ",
  ButtonBox["Repeated",
    ButtonData:>"Repeated RepeatedNull",
    ButtonStyle->"Hyperlink"],
  ", ",
  ButtonBox["RepeatedNull",
    ButtonData:>"Repeated RepeatedNull",
    ButtonStyle->"Hyperlink"],
  ") from left to right.  Second, once the kernel finds a succeful match for \
the pattern, it starts the comparing patterns for the next iteration at the \
left end of the input, which for this particular algorithm is a guarenteed \
waste of time."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    \({{1, 1}, {0, 1}, {0, 1}, {1, 1}, {1, 1}, {1, 1}, {1, 
          1}} //. \n{h___, {x_, n_}, {y_, m_}, 
            t___} /; \((Print[{h, {{x, n}, {y, m}}, t}]; 
            x \[Equal] y)\) \[RuleDelayed] {h, {x, n + m}, t}\)], "Input"],

Cell[BoxData[
    \({{{1, 1}, {0, 1}}, {0, 1}, {1, 1}, {1, 1}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {{0, 1}, {0, 1}}, {1, 1}, {1, 1}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{{1, 1}, {0, 2}}, {1, 1}, {1, 1}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {{0, 2}, {1, 1}}, {1, 1}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {0, 2}, {{1, 1}, {1, 1}}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{{1, 1}, {0, 2}}, {1, 2}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {{0, 2}, {1, 2}}, {1, 1}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {0, 2}, {{1, 2}, {1, 1}}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{{1, 1}, {0, 2}}, {1, 3}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {{0, 2}, {1, 3}}, {1, 1}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {0, 2}, {{1, 3}, {1, 1}}}\)], "Print"],

Cell[BoxData[
    \({{{1, 1}, {0, 2}}, {1, 4}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {{0, 2}, {1, 4}}}\)], "Print"],

Cell[BoxData[
    \({{1, 1}, {0, 2}, {1, 4}}\)], "Output"]
}, Closed]],

Cell["\<\
Below I give a run length encoding implementation that performs much better.  \
Unfortunately the implementation below is more difficult to understand.  You \
will find the time this implementation takes is directly proportional to the \
length of the input list.\
\>", "Text"],

Cell[BoxData[{
    \(\(foo = 
        Module[{t1 = #1}, \[IndentingNewLine]If[
              Part[#1, \(-1\), 1] === 
                First[#2], \[IndentingNewLine]\(Part[
                  t1, \(-1\), \(-1\)]++\), \[IndentingNewLine]t1 = 
                Join[t1, {#2}]\[IndentingNewLine]]; \[IndentingNewLine]t1] &;\
\)\[IndentingNewLine]\), "\n", 
    \(runEncode2[s_List] := 
      With[{s1 = Map[{#, 1} &, s]}, \[IndentingNewLine]Fold[foo, {First[s1]}, 
          Rest[s1]]\[IndentingNewLine]]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(runEncode2[{1, 0, 0, 1, 1, 0, 1, 1, 1, 1}]\)], "Input"],

Cell[BoxData[
    \({{1, 1}, {0, 2}, {1, 2}, {0, 1}, {1, 4}}\)], "Output"]
}, Closed]],

Cell["\<\
Below we see that the second implementation performs much better.\
\>", "Text"],

Cell[BoxData[
    \(\(tst = Table[Random[Integer, {0, 1}], {2*10^3}];\)\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(\(runEncode2[tst];\) // Timing\)], "Input"],

Cell[BoxData[
    \({0.14`\ Second, Null}\)], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Check These Sources Too", "Subsection"],

Cell[TextData[{
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/388/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/388/"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/320/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/320/"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/422/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/422/"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/321/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/321/"], None},
    ButtonStyle->"Hyperlink"],
  "\n",
  ButtonBox["http://library.wolfram.com/infocenter/Conferences/367/",
    ButtonData:>{
      URL[ "http://library.wolfram.com/infocenter/Conferences/367/"], None},
    ButtonStyle->"Hyperlink"]
}], "Text"],

Cell[TextData[{
  "Also see Alan Hayes in-depth articles on efficient ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " programming in The ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " Journal which are posted at \n",
  ButtonBox["http://www.mathematica-journal.com/issue/v2i2/",
    ButtonData:>{
      URL[ "http://www.mathematica-journal.com/issue/v2i2/"], None},
    ButtonStyle->"Hyperlink"],
  "  and  ",
  ButtonBox["http://www.mathematica-journal.com/issue/v5i1/",
    ButtonData:>{
      URL[ "http://www.mathematica-journal.com/issue/v5i1/"], None},
    ButtonStyle->"Hyperlink"],
  "."
}], "Text",
  CellTags->"Fast Programming"],

Cell["\<\
Chapter 10 of 
Power Programming with Mathematica The Kernel  
by David B. Wagner  (ISBN 0-07-912237-X)  
gives more advice on improving the speed of Mathematica programs.  
Unfortunately this great book is out of print, but you may be able to get a \
copy from an online auction such as e-bay or from the amazon.com out of print \
book service.\
\>", "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Slow Kernel Functions", "Section"],

Cell[TextData[{
  "Functions ReplacePart, MapAt, Insert, AppendTo, and PrependTo are very \
slow ",
  Cell[BoxData[
      \(TraditionalForm\`\((ie . \ \ O[n\^2]\ )\)\)]],
  " when they are used to make a large number of changes to an expression.  \
The other functions I list here are not extremly slow, but they are all much \
slower than the simpler form of the same function (eg. Sort[list,p] is much \
slower than Sort[list])."
}], "Text"],

Cell[CellGroupData[{

Cell["\<\
ReplacePart, MapAt, Insert (when the last argument is a long list).\
\>", "Subsection"],

Cell["\<\
ReplacePart, MapAt, and Inset can be very slow.

Consider the expressions:
   ReplacePart[expr, 1, lst]
   MapAt[f,expr, lst]
   Inset[expr, 1, lst]
Where (lst) has the form {{__Integer},{__Integer}, ...] and Length[lst]=n. 
In that case each of these functions are O[n^2].  For those who aren't \
familiar with this notation, O[n^2] means the evaluation time is proportional \
to n^2.  Hence if (lst) is a long list of lists these functions are very \
slow.\
\>", "Text",
  CellTags->"Slow_Functions"],

Cell[CellGroupData[{

Cell["Here is the evidence", "Subsubsection"],

Cell[BoxData[{
    \(\(ClearAll[TestReplacePart, TestMapAt, 
        TestInsert];\)\), "\[IndentingNewLine]", 
    \(TestReplacePart[n_] := 
      Module[{size, p1, lst2, 
          t1}, \[IndentingNewLine]\((size = 
            250*2^\((n + 1)\); \[IndentingNewLine]p1 = 
            Union[Table[{Random[Integer, {1, size}]}, {size/
                    2}]]; \[IndentingNewLine]lst2 = 
            Table[Random[], {size}]; \[IndentingNewLine]t1 = \
\((\(\(ReplacePart[lst2, 1, p1];\) // Timing\) // 
                First)\); \[IndentingNewLine]{Length[p1], 
            t1})\)\[IndentingNewLine]]\)}], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[TestReplacePart[n], {n, 5}] // TableForm\)], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"395", \(0.04999999999999982`\ Second\)},
          {"780", \(0.21999999999999975`\ Second\)},
          {"1580", \(0.9299999999999997`\ Second\)},
          {"3108", \(4.009999999999999`\ Second\)},
          {"6276", \(18.12`\ Second\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      (TableForm[ #]&)]], "Output"]
}, Closed]],

Cell[BoxData[
    \(TestMapAt[n_] := 
      Module[{size, p1, p2, 
          t1}, \[IndentingNewLine]\((size = 
            2\ Floor[250*2^n]; \[IndentingNewLine]p1 = 
            Union[Table[{Random[Integer, {1, size}]}, {size/
                    2}]]; \[IndentingNewLine]p2 = 
            Table[i, {i, size}]; \[IndentingNewLine]t1 = 
            First[Timing[\(MapAt[# + 8 &, p2, 
                    p1];\)]]; \[IndentingNewLine]{Length[p1], 
            t1}\[IndentingNewLine])\)]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[TestMapAt[n], {n, 5}] // TableForm\)], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"396", \(0.060000000000002274`\ Second\)},
          {"782", \(0.269999999999996`\ Second\)},
          {"1593", \(1.259999999999998`\ Second\)},
          {"3191", \(5.490000000000002`\ Second\)},
          {"6272", \(24.28`\ Second\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      (TableForm[ #]&)]], "Output"]
}, Closed]],

Cell[BoxData[
    \(TestInsert[n_] := 
      Module[{size, p1, p2, 
          t1}, \[IndentingNewLine]\((size = 
            2\ Floor[150*2^n]; \[IndentingNewLine]p1 = 
            Union[Table[{Random[Integer, {1, size}]}, {size/
                    2}]]; \[IndentingNewLine]p2 = 
            Table[Random[], {i, size}]; \[IndentingNewLine]t1 = 
            First[Timing[\(Insert[p2, 1, p1];\)]]; \[IndentingNewLine]{Length[
              p1], t1}\[IndentingNewLine])\)]\)], "Input"],

Cell[CellGroupData[{

Cell[BoxData[
    \(Table[TestInsert[n], {n, 5}] // TableForm\)], "Input"],

Cell[BoxData[
    TagBox[GridBox[{
          {"237", \(0.060000000000002274`\ Second\)},
          {"472", \(0.10999999999999943`\ Second\)},
          {"951", \(0.4899999999999949`\ Second\)},
          {"1879", \(1.980000000000004`\ Second\)},
          {"3786", \(8.399999999999991`\ Second\)}
          },
        RowSpacings->1,
        ColumnSpacings->3,
        RowAlignments->Baseline,
        ColumnAlignments->{Left}],
      (TableForm[ #]&)]], "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Would a faster algorithm give \"wrong\" results?", "Subsubsection"],

Cell["\<\
It seems like there must be algorithms for (ReplacePart, MapAt, Insert) that \
would evaluate much faster with a long list of parts.  It may be that the \
developers used slower methods which are needed to ensure that the result is \
correct.  A similar issue had to be addressed with Union.  However, in the \
case of Union the developers decided to use a method that is O[n Log[n]] and \
they accepted the risk that the result might include some duplicates.\
\>", "Text"],

Cell[TextData[{
  "At  ",
  ButtonBox["http://support.wolfram.com/Kernel/Symbols/System/Union.html",
    ButtonData:>{
      URL[ "http://support.wolfram.com/Kernel/Symbols/System/Union.html"], 
      None},
    ButtonStyle->"Hyperlink"],
  "  we see Union treats elements as duplicates only if they appear in \
adjacent positions after sorting.  Apparently this method is O[n Log[n]], and \
Union would be O[n^2] if it compared all pairs of elements."
}], "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["AppendTo, PrependTo", "Subsection"],

Cell[TextData[{
  "AppendTo and PrependTo are very slow when used on large expressions.  \
Instead use a \"",
  ButtonBox["linked list",
    ButtonData:>"Linked-List",
    ButtonStyle->"Hyperlink"],
  "\" as I discuss under programming for speed."
}], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Sort[list,p]", "Subsection"],

Cell["\<\
Sort[list]  is faster than  Sort[list, p] but sometimes we can't avoid the \
slower form.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Ordering[list,n,p]", "Subsection"],

Cell["\<\
Ordering[list, n, p] is slower than  Ordering[list]  or Ordering[list, n] but \
sometimes we can't avoid the slower form.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Split[list,test]", "Subsection"],

Cell["\<\
Split[list, test]  is slower than  Split[list] but sometimes we can't avoid \
the slower form.\
\>", "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["MatrixQ[expr,test], VectorQ[expr,test]", "Subsection"],

Cell["MatrixQ[expr, test]  is slower than  MatrixQ[expr].", "Text"],

Cell["\<\
Likewise  VectorQ[expr, test]  is slower than  VectorQ[expr].\
\>", "Text"],

Cell["\<\
However, sometimes we can't avoid the slower form of VectorQ and MatrixQ. \
\>", "Text",
  FontWeight->"Plain"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
(SameTest\[Rule]func)  instead of (SameTest\[Rule]Automatic)\
\>", "Subsection"],

Cell["\<\
The functions (Complement, FixedPoint, FixedPointList, Intersection, Union) \
all have a SameTest option. When they are given a non-default setting for the \
SameTest option they run much slower that with the default setting (SameTest\
\[Rule]Automatic).  Sometimes we have no choice but to use these functions \
with a non default SameTest setting.  You should just be aware that this \
slows down performance.\
\>", "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Functions with attributes OneIdentity, Flat, or Orderless", "Section"],

Cell[TextData[{
  "All symbols built into the ",
  StyleBox["Mathematica",
    FontSlant->"Italic"],
  " kernel (Version 3.0, 4.0) with one or more of the attributes OneIdentity, \
Flat, or Orderless are listed in the table below.  This table shows a circle \
to indicate that a certain function has one of the attributes. "
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[
    TagBox[GridBox[{
          {" ", \(\(OneIdentity\)\(\ \ \ \)\), \(\(Flat\)\(\ \ \ \)\), 
            "Orderless"},
          {"Max", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {"Min", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {"Plus", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {"Times", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {"Xor", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {"And", "\[FilledSmallCircle]", "\[FilledSmallCircle]", " "},
          {"Composition", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            " "},
          {"Dot", "\[FilledSmallCircle]", "\[FilledSmallCircle]", " "},
          {"Intersection", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            " "},
          {"Join", "\[FilledSmallCircle]", "\[FilledSmallCircle]", " "},
          {"NonCommutativeMultiply", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]", " "},
          {"Or", "\[FilledSmallCircle]", "\[FilledSmallCircle]", " "},
          {"StringJoin", "\[FilledSmallCircle]", "\[FilledSmallCircle]", 
            " "},
          {"Union", "\[FilledSmallCircle]", "\[FilledSmallCircle]", " "},
          {"Power", "\[FilledSmallCircle]", " ", " "},
          {"ArithmeticGeometricMean", " ", " ", "\[FilledSmallCircle]"},
          {"Multinomial", " ", " ", "\[FilledSmallCircle]"},
          {\(GCD\ \ \[Dagger]\), " ", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {\(LCM\ \ \[Dagger]\), " ", "\[FilledSmallCircle]", 
            "\[FilledSmallCircle]"},
          {\(DiracDelta\ \ \[DoubleDagger]\), " ", " ", 
            "\[FilledSmallCircle]"},
          {\(KroneckerDelta\ \ \[DoubleDagger]\), " ", " ", 
            "\[FilledSmallCircle]"},
          {\(DiscreteDelta\ \ \[DoubleDagger]\), " ", " ", 
            "\[FilledSmallCircle]"},
          {\(UnitStep\ \ \[DoubleDagger]\), " ", " ", "\[FilledSmallCircle]"}
          },
        ColumnAlignments->{Right, Center}],
      DisplayForm]], "Subsubsection",
  Editable->False,
  CellFrame->False],

Cell["\<\
\[Dagger]   GCD, LCM  have the attributes Flat, Orderless in Version 4.0, but \
not in Version 3.0.
\[DoubleDagger]  Functions new to the kernel as of version 4.0.\
\>", "Text",
  Editable->False]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Mathematica Web Pages", "Section"],

Cell[TextData[ButtonBox["http://support.wolfram.com/",
  ButtonData:>{
    URL[ "http://support.wolfram.com/"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://forums.wolfram.com/",
  ButtonData:>{
    URL[ "http://forums.wolfram.com/"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://library.wolfram.com/infocenter",
  ButtonData:>{
    URL[ "http://library.wolfram.com/infocenter"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://www.ifm.ethz.ch/~kaufmann/news.html",
  ButtonData:>{
    URL[ "http://www.ifm.ethz.ch/~kaufmann/news.html"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://www.webring.org/cgi-bin/webring?ring=\
mathematica;list",
  ButtonData:>{
    URL[ "http://www.webring.org/cgi-bin/webring?ring=mathematica;list"], 
    None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox[" http://www.salford.co.uk/mathematica/",
  ButtonData:>{
    URL[ "http://www.salford.co.uk/mathematica/"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://www.unca.edu/~mcmcclur/mathematicaGraphics/\
index.html",
  ButtonData:>{
    URL[ "http://www.unca.edu/~mcmcclur/mathematicaGraphics/index.html"], 
    None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://www.math.washington.edu/~lee/Ricci/",
  ButtonData:>{
    URL[ "http://www.math.washington.edu/~lee/Ricci/"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://home.earthlink.net/~djmp/Mathematica.html",
  ButtonData:>{
    URL[ "http://home.earthlink.net/~djmp/Mathematica.html"], None},
  ButtonStyle->"Hyperlink"]], "Text"],

Cell[TextData[ButtonBox["http://www.dimi.uniud.it/~gorni/",
  ButtonData:>{
    URL[ "http://www.dimi.uniud.it/~gorni/"], None},
  ButtonStyle->"Hyperlink"]], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Hidden Treasures in the Help Browser", "Section"],

Cell[TextData[{
  StyleBox["Experimental and Developer contexts",
    FontWeight->"Bold"],
  "\n- From the Help Browser select \"Built-in functions\" and scroll the \
left column to the bottom.\n- Select Additional Functions from the left \
column.\n- Select Developer Context or Experimental context from the second \
column.\n- Categories and functions are listed in the third, fourth columns."
}], "Text"],

Cell[TextData[{
  StyleBox["Other Information",
    FontWeight->"Bold"],
  "   You will find lots of good stuff under 'Other Information'"
}], "Text"],

Cell[BoxData[
    ButtonBox[\(Notation\ package\ documentation\),
      ButtonData:>"Notation:Documentation:Entering Notation",
      ButtonStyle->"AddOnsLink"]], "Text"],

Cell[BoxData[
    ButtonBox[\(More\ Notation\ documentation\),
      ButtonData:>"New Notations",
      ButtonStyle->"AddOnsLink"]], "Text"],

Cell[TextData[ButtonBox["Numerics Report",
  ButtonStyle->"GettingStartedLink"]], "Text"]
}, Closed]],

Cell[CellGroupData[{

Cell["Important Keyboard Shortcuts", "Section"],

Cell[TextData[{
  "Ctrl .    ",
  StyleBox["(that's  the keys Ctrl, and the . key at the same time)",
    FontSlant->"Italic"],
  "\n    Extend selection to a larger sub expression, the whole cell, group \
of cells, ... ,all cells.  This is about the only way to select a cell when \
the CellBracket isn't shown!"
}], "Commentary"],

Cell["\<\
Ctrl a
Select ALL cells in the selected notebook.\
\>", "Commentary"],

Cell[TextData[{
  "Ctrl Shift [    ",
  StyleBox["(that's the keys Ctrl, Shift, [  at the same time)",
    FontSlant->"Italic"],
  "\nOpen ALL selected cells."
}], "Commentary"],

Cell[TextData[{
  "Ctrl Shif E  ",
  StyleBox["(that's the keys Ctrl, Shift, E  at the same time)",
    FontSlant->"Italic"],
  "\nSwitch the current cell between normal and the underlying box \
structure."
}], "Commentary"],

Cell["\<\
Ctrl Shift ]
Close ALL selected cells\
\>", "Commentary"],

Cell[TextData[{
  "Ctrl K  ",
  StyleBox["(with something selected)",
    FontSlant->"Italic"],
  "\nComplete the selection\nExamples:  \"Work Ctrl k\" \[Rule] \
WorkingPrecision\n                 \"\\[Contour Ctrl k\" \[Rule] \
\[ContourIntegral]  )"
}], "Commentary"]
}, Closed]]
}, Open  ]]
},
FrontEndVersion->"5.2 for X",
ScreenRectangle->{{0, 1280}, {0, 1024}},
WindowToolbars->"EditBar",
WindowSize->{1183, 815},
WindowMargins->{{Automatic, 31}, {Automatic, 28}},
PrintingCopies->1,
PrintingPageRange->{Automatic, Automatic},
ShowSelection->True,
Magnification->1.25,
StyleDefinitions -> "PastelColor.nb"
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{
  "Alternatives"->{
    Cell[11882, 442, 261, 5, 60, "Text",
      CellTags->"Alternatives"]},
  "Apply"->{
    Cell[14955, 534, 106, 3, 33, "Text",
      CellTags->"Apply"]},
  "Blank"->{
    Cell[25141, 905, 171, 4, 33, "Text",
      CellTags->"Blank"]},
  "Partial evaluation1"->{
    Cell[33474, 1201, 198, 4, 33, "Text",
      CellTags->"Partial evaluation1"]},
  "$DisplayFunction"->{
    Cell[35649, 1274, 147, 4, 33, "Text",
      CellTags->"$DisplayFunction"]},
  "ButtonProgramming"->{
    Cell[41300, 1476, 600, 15, 75, "Text",
      CellTags->"ButtonProgramming"]},
  "Pure_Function_Example"->{
    Cell[44376, 1550, 726, 13, 96, "Text",
      CellTags->"Pure_Function_Example"]},
  "ButtonStyles"->{
    Cell[47937, 1661, 1543, 26, 273, "Text",
      CellTags->"ButtonStyles"]},
  "Cases"->{
    Cell[60934, 2013, 147, 4, 33, "Text",
      CellTags->"Cases"],
    Cell[64194, 2132, 210, 5, 80, "Input",
      CellTags->"Cases"],
    Cell[65006, 2159, 167, 4, 56, "Input",
      CellTags->"Cases"]},
  "Clear"->{
    Cell[66444, 2208, 361, 10, 33, "Text",
      CellTags->"Clear"]},
  "MapIndexedExample"->{
    Cell[74360, 2473, 593, 14, 54, "Text",
      CellTags->{"MapIndexedExample", "CoefficientsToPolynomial"}]},
  "CoefficientsToPolynomial"->{
    Cell[74360, 2473, 593, 14, 54, "Text",
      CellTags->{"MapIndexedExample", "CoefficientsToPolynomial"}]},
  "Complement"->{
    Cell[77924, 2588, 237, 6, 33, "Text",
      CellTags->"Complement"]},
  "Compiled_Evaluation"->{
    Cell[83755, 2785, 1147, 18, 145, "Text",
      CellTags->"Compiled_Evaluation"]},
  "Condition"->{
    Cell[98283, 3245, 185, 7, 33, "Text",
      CellTags->"Condition"]},
  "Count"->{
    Cell[104958, 3510, 106, 3, 33, "Text",
      CellTags->"Count"]},
  "DeleteCases"->{
    Cell[109867, 3723, 118, 3, 33, "Text",
      CellTags->"DeleteCases"]},
  "Default details"->{
    Cell[113817, 3896, 143, 4, 33, "Text",
      CellTags->"Default details"]},
  "Dot"->{
    Cell[120751, 4146, 241, 6, 33, "Text",
      CellTags->"Dot"]},
  "Evaluate"->{
    Cell[127217, 4380, 296, 6, 54, "Text",
      CellTags->"Evaluate"]},
  "ExactNumberQ"->{
    Cell[131563, 4526, 614, 12, 75, "Text",
      CellTags->"ExactNumberQ"]},
  "Info3292238823-5325569"->{
    Cell[133774, 4591, 322, 9, 29, "Print",
      CellTags->"Info3292238823-5325569"]},
  "Info3242392617-9633741"->{
    Cell[135200, 4640, 334, 9, 50, "Print",
      CellTags->"Info3242392617-9633741"]},
  "Flat"->{
    Cell[136143, 4674, 366, 10, 54, "Text",
      CellTags->"Flat"]},
  "Attributes warning"->{
    Cell[138159, 4735, 103, 1, 56, "Subsection",
      CellTags->"Attributes warning"]},
  "Info3242392618-3366990"->{
    Cell[141212, 4850, 63, 1, 27, "Print",
      CellTags->"Info3242392618-3366990"],
    Cell[141278, 4853, 503, 15, 65, "Print",
      CellTags->"Info3242392618-3366990"]},
  "Info3242392618-7584819"->{
    Cell[141909, 4879, 63, 1, 27, "Print",
      CellTags->"Info3242392618-7584819"],
    Cell[141975, 4882, 437, 13, 30, "Print",
      CellTags->"Info3242392618-7584819"]},
  "Info3242392618-6169565"->{
    Cell[142584, 4908, 63, 1, 27, "Print",
      CellTags->"Info3242392618-6169565"]},
  "Flatten"->{
    Cell[145796, 5020, 196, 4, 33, "Text",
      CellTags->"Flatten"]},
  "Fold"->{
    Cell[149558, 5152, 132, 4, 33, "Text",
      CellTags->"Fold"]},
  "Partial evaluation 2"->{
    Cell[152414, 5255, 277, 5, 50, "Text",
      CellTags->"Partial evaluation 2"]},
  "FoldList"->{
    Cell[154840, 5335, 226, 5, 54, "Text",
      CellTags->"FoldList"]},
  "Info3242392636-8498059"->{
    Cell[155140, 5347, 326, 9, 29, "Print",
      CellTags->"Info3242392636-8498059"]},
  "Format"->{
    Cell[156671, 5398, 139, 4, 33, "Text",
      CellTags->"Format"]},
  "FreeQ"->{
    Cell[158825, 5472, 378, 11, 33, "Text",
      CellTags->"FreeQ"]},
  "Function"->{
    Cell[160996, 5571, 101, 3, 36, "Text",
      CellTags->"Function"]},
  "No_Argument_Functions"->{
    Cell[172593, 6000, 1184, 22, 180, "Text",
      CellTags->"No_Argument_Functions"]},
  "Hold"->{
    Cell[175705, 6098, 272, 6, 55, "Text",
      CellTags->{"Hold", "HoldAll"}]},
  "HoldAll"->{
    Cell[175705, 6098, 272, 6, 55, "Text",
      CellTags->{"Hold", "HoldAll"}]},
  "HoldAllComplete"->{
    Cell[180674, 6257, 332, 6, 54, "Text",
      CellTags->"HoldAllComplete"]},
  "HoldPattern"->{
    Cell[183477, 6370, 116, 3, 33, "Text",
      CellTags->"HoldPattern"]},
  "Hyperlinks"->{
    Cell[188431, 6585, 101, 1, 56, "Subsection",
      CellTags->"Hyperlinks"]},
  "Email"->{
    Cell[196690, 6814, 880, 28, 450, "Text",
      CellTags->"Email"]},
  "Inner"->{
    Cell[198244, 6874, 384, 8, 54, "Text",
      CellTags->"Inner"]},
  "Insert"->{
    Cell[202749, 7056, 85, 1, 33, "Text",
      CellTags->"Insert"]},
  "Level"->{
    Cell[204271, 7109, 442, 9, 77, "Text",
      CellTags->"Level"]},
  "Level Specification"->{
    Cell[207263, 7215, 1124, 22, 117, "Text",
      CellTags->"Level Specification"]},
  "Info3242392684-5465879"->{
    Cell[208458, 7244, 422, 10, 49, "Print",
      CellTags->"Info3242392684-5465879"]},
  "ListConvolve"->{
    Cell[218510, 7620, 101, 1, 33, "Text",
      CellTags->"ListConvolve"]},
  "ListCorrelate"->{
    Cell[240333, 8307, 103, 1, 33, "Text",
      CellTags->"ListCorrelate"]},
  "Map"->{
    Cell[262710, 9017, 542, 12, 75, "Text",
      CellTags->"Map"]},
  "MapAt"->{
    Cell[267950, 9185, 143, 4, 33, "Text",
      CellTags->"MapAt"]},
  "MapIndexed"->{
    Cell[268634, 9217, 278, 5, 54, "Text",
      CellTags->"MapIndexed"]},
  "MapThread"->{
    Cell[273981, 9412, 251, 6, 33, "Text",
      CellTags->"MapThread"]},
  "MakeBoxes"->{
    Cell[278228, 9569, 410, 8, 54, "Text",
      CellTags->"MakeBoxes"]},
  "MatchQ"->{
    Cell[284148, 9726, 474, 8, 75, "Text",
      CellTags->"MatchQ"],
    Cell[284647, 9738, 99, 2, 39, "Input",
      CellTags->"MatchQ"]},
  "MemberQ"->{
    Cell[287420, 9847, 138, 4, 33, "Text",
      CellTags->"MemberQ"]},
  "Message"->{
    Cell[290250, 9977, 693, 13, 98, "Text",
      CellTags->"Message"]},
  "NHoldAll"->{
    Cell[336394, 11836, 88, 1, 33, "Text",
      CellTags->"NHoldAll"]},
  "OneIdentity"->{
    Cell[338919, 11935, 466, 8, 75, "Text",
      CellTags->"OneIdentity"]},
  "OneIdentity-Default"->{
    Cell[339469, 11949, 160, 4, 33, "Text",
      CellTags->"OneIdentity-Default"],
    Cell[344473, 12110, 408, 8, 47, "Text",
      CellTags->"OneIdentity-Default"]},
  "Info3242474880-2863980"->{
    Cell[339698, 11960, 279, 8, 29, "Print",
      CellTags->"Info3242474880-2863980"],
    Cell[339980, 11970, 576, 16, 69, "Print",
      CellTags->"Info3242474880-2863980"]},
  "Info3242474882-9613789"->{
    Cell[343310, 12074, 279, 8, 27, "Print",
      CellTags->"Info3242474882-9613789"],
    Cell[343592, 12084, 575, 16, 62, "Print",
      CellTags->"Info3242474882-9613789"]},
  "OneIdentity-Flat"->{
    Cell[346412, 12174, 759, 14, 85, "Text",
      CellTags->"OneIdentity-Flat"]},
  "Info3242474882-1460760"->{
    Cell[348557, 12236, 374, 9, 50, "Print",
      CellTags->"Info3242474882-1460760"],
    Cell[348934, 12247, 300, 8, 27, "Print",
      CellTags->"Info3242474882-1460760"]},
  "Optional"->{
    Cell[359369, 12632, 391, 7, 54, "Text",
      CellTags->"Optional"]},
  "Info3285568764-5243668"->{
    Cell[361631, 12711, 63, 1, 28, "Print",
      CellTags->"Info3285568764-5243668"],
    Cell[361697, 12714, 443, 13, 29, "Print",
      CellTags->"Info3285568764-5243668"]},
  "Info3285569129-8870368"->{
    Cell[363202, 12767, 63, 1, 27, "Print",
      CellTags->"Info3285569129-8870368"],
    Cell[363268, 12770, 447, 13, 30, "Print",
      CellTags->"Info3285569129-8870368"]},
  "Options"->{
    Cell[364802, 12835, 287, 7, 54, "Text",
      CellTags->"Options"]},
  "Info3242474884-6448585"->{
    Cell[365162, 12849, 172, 3, 29, "Print",
      CellTags->"Info3242474884-6448585"]},
  "Ordering"->{
    Cell[374168, 13152, 82, 1, 33, "Text",
      CellTags->"Ordering"]},
  "Info3276836798-2710999"->{
    Cell[374324, 13160, 549, 12, 69, "Print",
      CellTags->"Info3276836798-2710999"]},
  "Orderless"->{
    Cell[379883, 13365, 165, 4, 33, "Text",
      CellTags->"Orderless"]},
  "Outer"->{
    Cell[383181, 13481, 188, 4, 33, "Text",
      CellTags->"Outer"]},
  "Part"->{
    Cell[390138, 13690, 209, 5, 33, "Text",
      CellTags->"Part"]},
  "Info3242474896-7343620"->{
    Cell[396785, 13921, 1316, 22, 209, "Print",
      CellTags->"Info3242474896-7343620"]},
  "Position"->{
    Cell[404107, 14135, 379, 7, 54, "Text",
      CellTags->"Position"]},
  "Pattern"->{
    Cell[413075, 14485, 448, 11, 54, "Text",
      CellTags->"Pattern"]},
  "PatternTest"->{
    Cell[414708, 14551, 374, 9, 54, "Text",
      CellTags->"PatternTest"]},
  "Random"->{
    Cell[417973, 14665, 1054, 25, 186, "Text",
      CellTags->"Random"]},
  "Info3242474897-2101131"->{
    Cell[419783, 14726, 476, 11, 49, "Print",
      CellTags->"Info3242474897-2101131"]},
  "Range"->{
    Cell[421728, 14810, 486, 9, 119, "Text",
      CellTags->"Range"]},
  "Repeated RepeatedNull"->{
    Cell[424831, 14907, 402, 7, 54, "Text",
      CellTags->"Repeated RepeatedNull"]},
  "Replace"->{
    Cell[427340, 14982, 529, 10, 119, "Text",
      CellTags->"Replace"]},
  "ReplaceAll;ReplaceRepeated"->{
    Cell[436500, 15297, 113, 1, 33, "Text",
      CellTags->"ReplaceAll;ReplaceRepeated"]},
  "Rule;RuleDelayed"->{
    Cell[458070, 16027, 279, 5, 54, "Text",
      CellTags->"Rule;RuleDelayed"]},
  "Scan"->{
    Cell[462936, 16173, 325, 6, 54, "Text",
      CellTags->"Scan"]},
  "Info3242474919-8383725"->{
    Cell[463701, 16197, 63, 1, 28, "Print",
      CellTags->"Info3242474919-8383725"],
    Cell[463767, 16200, 445, 13, 30, "Print",
      CellTags->"Info3242474919-8383725"]},
  "Info3242474919-9355181"->{
    Cell[464578, 16230, 63, 1, 28, "Print",
      CellTags->"Info3242474919-9355181"],
    Cell[464644, 16233, 627, 19, 149, "Print",
      CellTags->"Info3242474919-9355181"]},
  "Info3242474920-7316245"->{
    Cell[465847, 16273, 63, 1, 28, "Print",
      CellTags->"Info3242474920-7316245"],
    Cell[465913, 16276, 627, 19, 149, "Print",
      CellTags->"Info3242474920-7316245"]},
  "Info3242474920-3777955"->{
    Cell[466912, 16313, 63, 1, 27, "Print",
      CellTags->"Info3242474920-3777955"],
    Cell[466978, 16316, 591, 17, 105, "Print",
      CellTags->"Info3242474920-3777955"]},
  "Info3242474920-7649147"->{
    Cell[468267, 16357, 63, 1, 27, "Print",
      CellTags->"Info3242474920-7649147"],
    Cell[468333, 16360, 720, 23, 207, "Print",
      CellTags->"Info3242474920-7649147"]},
  "Info3242474920-1486452"->{
    Cell[469701, 16408, 63, 1, 27, "Print",
      CellTags->"Info3242474920-1486452"],
    Cell[469767, 16411, 903, 29, 325, "Print",
      CellTags->"Info3242474920-1486452"]},
  "Sequence"->{
    Cell[470761, 16449, 536, 9, 75, "Text",
      CellTags->"Sequence"]},
  "SequenceHold"->{
    Cell[472631, 16511, 103, 1, 33, "Text",
      CellTags->"SequenceHold"]},
  "Info3242474922-7671367"->{
    Cell[481798, 16815, 68, 1, 27, "Print",
      CellTags->"Info3242474922-7671367"],
    Cell[481869, 16818, 456, 13, 30, "Print",
      CellTags->"Info3242474922-7671367"]},
  "Info3242474922-1117472"->{
    Cell[482409, 16839, 68, 1, 27, "Print",
      CellTags->"Info3242474922-1117472"],
    Cell[482480, 16842, 443, 13, 30, "Print",
      CellTags->"Info3242474922-1117472"]},
  "Info3284968730-3180209"->{
    Cell[489910, 17095, 63, 1, 27, "Print",
      CellTags->"Info3284968730-3180209"],
    Cell[489976, 17098, 423, 13, 30, "Print",
      CellTags->"Info3284968730-3180209"]},
  "Info3284968732-8841380"->{
    Cell[490478, 17119, 63, 1, 27, "Print",
      CellTags->"Info3284968732-8841380"],
    Cell[490544, 17122, 426, 13, 30, "Print",
      CellTags->"Info3284968732-8841380"]},
  "Simplify_FullSimplify"->{
    Cell[491160, 17148, 221, 5, 33, "Text",
      CellTags->"Simplify_FullSimplify"]},
  "Pure Functions"->{
    Cell[497332, 17337, 230, 8, 33, "Text",
      CellTags->"Pure Functions"]},
  "Sort"->{
    Cell[497625, 17352, 515, 9, 75, "Text",
      CellTags->"Sort"]},
  "Split"->{
    Cell[504716, 17585, 132, 4, 33, "Text",
      CellTags->"Split"]},
  "Info3242474961-5860318"->{
    Cell[504919, 17596, 464, 11, 49, "Print",
      CellTags->"Info3242474961-5860318"]},
  "TagBox"->{
    Cell[530842, 18504, 398, 9, 77, "Text",
      CellTags->"TagBox"]},
  "Info3242475074-9991669"->{
    Cell[531312, 18520, 356, 9, 29, "Print",
      CellTags->"Info3242475074-9991669"]},
  "Trig option"->{
    Cell[541922, 18903, 113, 3, 33, "Text",
      CellTags->"Trig option"]},
  "Info3242475074-3476455"->{
    Cell[542105, 18913, 236, 4, 49, "Print",
      CellTags->"Info3242475074-3476455"]},
  "ToString"->{
    Cell[543845, 18970, 399, 7, 75, "Text",
      CellTags->"ToString"]},
  "Tr"->{
    Cell[545823, 19040, 138, 4, 33, "Text",
      CellTags->"Tr"]},
  "Unevaluated"->{
    Cell[555458, 19391, 359, 7, 54, "Text",
      CellTags->"Unevaluated"]},
  "Update"->{
    Cell[557433, 19461, 214, 7, 33, "Text",
      CellTags->"Update"]},
  "Upvalues"->{
    Cell[557714, 19475, 356, 6, 54, "Text",
      CellTags->"Upvalues"]},
  "Verbatim"->{
    Cell[571221, 19896, 82, 1, 33, "Text",
      CellTags->"Verbatim"]},
  "Info3247899362-8348536"->{
    Cell[571377, 19904, 423, 10, 49, "Print",
      CellTags->"Info3247899362-8348536"]},
  "$OutputForms"->{
    Cell[574613, 20025, 90, 1, 33, "Text",
      CellTags->"$OutputForms"]},
  "Info3240648369-5591269"->{
    Cell[574781, 20033, 179, 3, 29, "Print",
      CellTags->"Info3240648369-5591269"]},
  "$Pre;$Post"->{
    Cell[577215, 20125, 1392, 28, 296, "Text",
      CellTags->"$Pre;$Post"]},
  "ReplacePart"->{
    Cell[587370, 20473, 300, 5, 48, "ExampleText",
      CellTags->{"ReplacePart", "Evaluate At"}],
    Cell[587673, 20480, 179, 4, 39, "Input",
      CellTags->"ReplacePart"],
    Cell[587855, 20486, 238, 7, 29, "ExampleText",
      CellTags->"ReplacePart"],
    Cell[588118, 20497, 140, 4, 39, "Input",
      CellTags->"ReplacePart"]},
  "Evaluate At"->{
    Cell[587370, 20473, 300, 5, 48, "ExampleText",
      CellTags->{"ReplacePart", "Evaluate At"}]},
  "Evaluate Pattern"->{
    Cell[588426, 20513, 733, 14, 119, "Text",
      CellTags->"Evaluate Pattern"]},
  "S5.12.1"->{
    Cell[633155, 21445, 149, 4, 56, "Input",
      CellTags->"S5.12.1"]},
  "FoldList_Example1"->{
    Cell[634400, 21478, 205, 7, 30, "Text",
      CellTags->"FoldList_Example1"]},
  "RelativePrimes_Fold"->{
    Cell[652583, 22095, 366, 8, 47, "Text",
      CellTags->"RelativePrimes_Fold"]},
  "Algebra_Transformation"->{
    Cell[655489, 22197, 266, 6, 68, "Text",
      CellTags->"Algebra_Transformation"]},
  "Together"->{
    Cell[656969, 22249, 382, 9, 66, "Text",
      CellTags->"Together"]},
  "Tensor_to_Matrix"->{
    Cell[662042, 22401, 90, 1, 30, "Text",
      CellTags->"Tensor_to_Matrix"]},
  "Distribute - Application"->{
    Cell[673294, 22696, 1267, 20, 235, "Text",
      CellTags->"Distribute - Application"]},
  "DeleteRepititions"->{
    Cell[677104, 22793, 618, 14, 85, "Text",
      CellTags->"DeleteRepititions"]},
  "Evaluation-Process"->{
    Cell[678723, 22848, 1697, 41, 248, "Text",
      CellTags->"Evaluation-Process"]},
  "Unevaluated-Advanced"->{
    Cell[690232, 23204, 360, 8, 101, "Text",
      CellTags->"Unevaluated-Advanced"]},
  "Definition-Storage"->{
    Cell[695980, 23416, 1318, 29, 184, "Text",
      CellTags->"Definition-Storage"]},
  "DownValues"->{
    Cell[697358, 23451, 155, 4, 33, "Text",
      CellTags->"DownValues"]},
  "OwnValues"->{
    Cell[700080, 23562, 166, 4, 48, "Text",
      CellTags->"OwnValues"]},
  "NValues"->{
    Cell[700721, 23591, 153, 4, 30, "Text",
      CellTags->"NValues"]},
  "SubValues"->{
    Cell[701807, 23643, 153, 4, 30, "Text",
      CellTags->"SubValues"]},
  "FormatValues"->{
    Cell[703178, 23700, 361, 8, 66, "Text",
      CellTags->"FormatValues"]},
  "DefaultValues"->{
    Cell[705991, 23796, 410, 9, 66, "Text",
      CellTags->"DefaultValues"]},
  "Messages"->{
    Cell[708291, 23877, 95, 1, 30, "Text",
      CellTags->"Messages"]},
  "Info3248519924-1535622"->{
    Cell[709311, 23913, 89, 2, 29, "Print",
      CellTags->"Info3248519924-1535622"]},
  "Lists_Tables"->{
    Cell[716879, 24183, 281, 6, 54, "Text",
      CellTags->"Lists_Tables"]},
  "Pattern-Matching"->{
    Cell[725632, 24506, 1496, 58, 54, "Text",
      CellTags->"Pattern-Matching"]},
  "s_Symbol"->{
    Cell[734332, 24819, 944, 20, 178, "Text",
      CellTags->"s_Symbol"]},
  "Controlling Memory Usage"->{
    Cell[737716, 24932, 92, 1, 56, "Subsection",
      CellTags->"Controlling Memory Usage"]},
  "Tech Support"->{
    Cell[739871, 25011, 1067, 20, 140, "Text",
      CellTags->"Tech Support"]},
  "Speedy_Programming"->{
    Cell[749498, 25347, 153, 4, 33, "Text",
      CellTags->"Speedy_Programming"]},
  "Linked-List"->{
    Cell[755603, 25523, 372, 7, 66, "Text",
      CellTags->"Linked-List"]},
  "Fast Programming"->{
    Cell[776409, 26151, 662, 19, 67, "Text",
      CellTags->"Fast Programming"]},
  "Slow_Functions"->{
    Cell[778103, 26205, 512, 13, 208, "Text",
      CellTags->"Slow_Functions"]}
  }
*)

(*CellTagsIndex
CellTagsIndex->{
  {"Alternatives", 793025, 26659},
  {"Apply", 793113, 26662},
  {"Blank", 793194, 26665},
  {"Partial evaluation1", 793289, 26668},
  {"$DisplayFunction", 793396, 26671},
  {"ButtonProgramming", 793501, 26674},
  {"Pure_Function_Example", 793612, 26677},
  {"ButtonStyles", 793718, 26680},
  {"Cases", 793810, 26683},
  {"Clear", 794030, 26690},
  {"MapIndexedExample", 794125, 26693},
  {"CoefficientsToPolynomial", 794269, 26696},
  {"Complement", 794399, 26699},
  {"Compiled_Evaluation", 794500, 26702},
  {"Condition", 794603, 26705},
  {"Count", 794689, 26708},
  {"DeleteCases", 794778, 26711},
  {"Default details", 794877, 26714},
  {"Dot", 794968, 26717},
  {"Evaluate", 795052, 26720},
  {"ExactNumberQ", 795145, 26723},
  {"Info3292238823-5325569", 795253, 26726},
  {"Info3242392617-9633741", 795371, 26729},
  {"Flat", 795471, 26732},
  {"Attributes warning", 795567, 26735},
  {"Info3242392618-3366990", 795686, 26738},
  {"Info3242392618-7584819", 795891, 26743},
  {"Info3242392618-6169565", 796096, 26748},
  {"Flatten", 796198, 26751},
  {"Fold", 796282, 26754},
  {"Partial evaluation 2", 796379, 26757},
  {"FoldList", 796480, 26760},
  {"Info3242392636-8498059", 796583, 26763},
  {"Format", 796685, 26766},
  {"FreeQ", 796769, 26769},
  {"Function", 796856, 26772},
  {"No_Argument_Functions", 796958, 26775},
  {"Hold", 797059, 26778},
  {"HoldAll", 797156, 26781},
  {"HoldAllComplete", 797261, 26784},
  {"HoldPattern", 797360, 26787},
  {"Hyperlinks", 797454, 26790},
  {"Email", 797548, 26793},
  {"Inner", 797633, 26796},
  {"Insert", 797717, 26799},
  {"Level", 797800, 26802},
  {"Level Specification", 797897, 26805},
  {"Info3242392684-5465879", 798014, 26808},
  {"ListConvolve", 798123, 26811},
  {"ListCorrelate", 798221, 26814},
  {"Map", 798310, 26817},
  {"MapAt", 798392, 26820},
  {"MapIndexed", 798480, 26823},
  {"MapThread", 798572, 26826},
  {"MakeBoxes", 798663, 26829},
  {"MatchQ", 798751, 26832},
  {"MemberQ", 798907, 26837},
  {"Message", 798994, 26840},
  {"NHoldAll", 799083, 26843},
  {"OneIdentity", 799175, 26846},
  {"OneIdentity-Default", 799279, 26849},
  {"Info3242474880-2863980", 799478, 26854},
  {"Info3242474882-9613789", 799686, 26859},
  {"OneIdentity-Flat", 799888, 26864},
  {"Info3242474882-1460760", 800001, 26867},
  {"Optional", 800194, 26872},
  {"Info3285568764-5243668", 800298, 26875},
  {"Info3285569129-8870368", 800505, 26880},
  {"Options", 800697, 26885},
  {"Info3242474884-6448585", 800800, 26888},
  {"Ordering", 800905, 26891},
  {"Info3276836798-2710999", 801008, 26894},
  {"Orderless", 801115, 26897},
  {"Outer", 801203, 26900},
  {"Part", 801286, 26903},
  {"Info3242474896-7343620", 801386, 26906},
  {"Position", 801494, 26909},
  {"Pattern", 801583, 26912},
  {"PatternTest", 801676, 26915},
  {"Random", 801767, 26918},
  {"Info3242474897-2101131", 801872, 26921},
  {"Range", 801975, 26924},
  {"Repeated RepeatedNull", 802076, 26927},
  {"Replace", 802178, 26930},
  {"ReplaceAll;ReplaceRepeated", 802287, 26933},
  {"Rule;RuleDelayed", 802403, 26936},
  {"Scan", 802497, 26939},
  {"Info3242474919-8383725", 802597, 26942},
  {"Info3242474919-9355181", 802804, 26947},
  {"Info3242474920-7316245", 803012, 26952},
  {"Info3242474920-3777955", 803220, 26957},
  {"Info3242474920-7649147", 803428, 26962},
  {"Info3242474920-1486452", 803636, 26967},
  {"Sequence", 803830, 26972},
  {"SequenceHold", 803924, 26975},
  {"Info3242474922-7671367", 804032, 26978},
  {"Info3242474922-1117472", 804239, 26983},
  {"Info3284968730-3180209", 804446, 26988},
  {"Info3284968732-8841380", 804653, 26993},
  {"Simplify_FullSimplify", 804859, 26998},
  {"Pure Functions", 804968, 27001},
  {"Sort", 805060, 27004},
  {"Split", 805143, 27007},
  {"Info3242474961-5860318", 805244, 27010},
  {"TagBox", 805348, 27013},
  {"Info3242475074-9991669", 805450, 27016},
  {"Trig option", 805558, 27019},
  {"Info3242475074-3476455", 805665, 27022},
  {"ToString", 805770, 27025},
  {"Tr", 805854, 27028},
  {"Unevaluated", 805941, 27031},
  {"Update", 806032, 27034},
  {"Upvalues", 806120, 27037},
  {"Verbatim", 806210, 27040},
  {"Info3247899362-8348536", 806313, 27043},
  {"$OutputForms", 806423, 27046},
  {"Info3240648369-5591269", 806530, 27049},
  {"$Pre;$Post", 806637, 27052},
  {"ReplacePart", 806735, 27055},
  {"Evaluate At", 807092, 27064},
  {"Evaluate Pattern", 807217, 27067},
  {"S5.12.1", 807316, 27070},
  {"FoldList_Example1", 807415, 27073},
  {"RelativePrimes_Fold", 807525, 27076},
  {"Algebra_Transformation", 807640, 27079},
  {"Together", 807744, 27082},
  {"Tensor_to_Matrix", 807842, 27085},
  {"Distribute - Application", 807955, 27088},
  {"DeleteRepititions", 808073, 27091},
  {"Evaluation-Process", 808183, 27094},
  {"Unevaluated-Advanced", 808298, 27097},
  {"Definition-Storage", 808411, 27100},
  {"DownValues", 808516, 27103},
  {"OwnValues", 808609, 27106},
  {"NValues", 808699, 27109},
  {"SubValues", 808789, 27112},
  {"FormatValues", 808884, 27115},
  {"DefaultValues", 808983, 27118},
  {"Messages", 809078, 27121},
  {"Info3248519924-1535622", 809181, 27124},
  {"Lists_Tables", 809289, 27127},
  {"Pattern-Matching", 809391, 27130},
  {"s_Symbol", 809491, 27133},
  {"Controlling Memory Usage", 809599, 27136},
  {"Tech Support", 809714, 27139},
  {"Speedy_Programming", 809821, 27142},
  {"Linked-List", 809924, 27145},
  {"Fast Programming", 810025, 27148},
  {"Slow_Functions", 810130, 27151}
  }
*)

(*NotebookFileOutline
Notebook[{

Cell[CellGroupData[{
Cell[1776, 53, 316, 10, 135, "Title"],

Cell[CellGroupData[{
Cell[2117, 67, 82, 1, 58, "Section"],
Cell[2202, 70, 350, 6, 54, "Text"],
Cell[2555, 78, 1291, 31, 205, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[3883, 114, 59, 1, 37, "Section"],

Cell[CellGroupData[{
Cell[3967, 119, 80, 1, 56, "Subsection"],
Cell[4050, 122, 1587, 60, 341, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[5674, 187, 81, 1, 45, "Subsection"],
Cell[5758, 190, 3342, 136, 759, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[9137, 331, 48, 0, 45, "Subsection"],
Cell[9188, 333, 2580, 100, 561, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[11817, 439, 62, 1, 45, "Section"],
Cell[11882, 442, 261, 5, 60, "Text",
  CellTags->"Alternatives"],

Cell[CellGroupData[{
Cell[12168, 451, 167, 3, 45, "Input"],
Cell[12338, 456, 142, 3, 55, "Output"]
}, Closed]],
Cell[12495, 462, 112, 3, 34, "Text"],

Cell[CellGroupData[{
Cell[12632, 469, 173, 3, 84, "Input"],
Cell[12808, 474, 58, 1, 37, "Output"]
}, Closed]],
Cell[12881, 478, 465, 10, 59, "Text"],

Cell[CellGroupData[{
Cell[13371, 492, 199, 3, 84, "Input"],
Cell[13573, 497, 70, 1, 37, "Output"]
}, Closed]],
Cell[13658, 501, 1071, 22, 209, "Text"],
Cell[14732, 525, 159, 2, 44, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[14928, 532, 24, 0, 40, "Section"],
Cell[14955, 534, 106, 3, 33, "Text",
  CellTags->"Apply"],

Cell[CellGroupData[{
Cell[15086, 541, 102, 2, 39, "Input"],
Cell[15191, 545, 161, 2, 37, "Output"]
}, Closed]],
Cell[15367, 550, 63, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[15455, 554, 109, 2, 59, "Input"],
Cell[15567, 558, 162, 2, 37, "Output"]
}, Closed]],
Cell[15744, 563, 195, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[15964, 573, 42, 1, 39, "Input"],
Cell[16009, 576, 165, 3, 37, "Output"]
}, Closed]],
Cell[16189, 582, 169, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[16383, 589, 106, 2, 39, "Input"],
Cell[16492, 593, 46, 1, 37, "Output"]
}, Closed]],
Cell[16553, 597, 474, 9, 120, "Text"],

Cell[CellGroupData[{
Cell[17052, 610, 49, 1, 39, "Input"],
Cell[17104, 613, 171, 3, 57, "Output"]
}, Closed]],
Cell[17290, 619, 96, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[17411, 625, 54, 1, 39, "Input"],
Cell[17468, 628, 172, 3, 57, "Output"]
}, Closed]],
Cell[17655, 634, 162, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[17842, 641, 50, 1, 40, "Input"],
Cell[17895, 644, 40, 1, 35, "Output"]
}, Closed]],
Cell[17950, 648, 170, 3, 30, "Text"],
Cell[18123, 653, 143, 3, 40, "Input"],
Cell[18269, 658, 48, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[18342, 662, 42, 1, 40, "Input"],
Cell[18387, 665, 123, 2, 35, "Output"]
}, Closed]],
Cell[18525, 670, 49, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[18599, 674, 43, 1, 40, "Input"],
Cell[18645, 677, 127, 2, 35, "Output"]
}, Closed]],
Cell[18787, 682, 65, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[18877, 686, 52, 1, 40, "Input"],
Cell[18932, 689, 117, 2, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[19086, 696, 34, 0, 55, "Subsection"],
Cell[19123, 698, 447, 7, 67, "Text"],

Cell[CellGroupData[{
Cell[19595, 709, 184, 3, 80, "Input"],
Cell[19782, 714, 54, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[19873, 720, 46, 1, 40, "Input"],
Cell[19922, 723, 38, 1, 35, "Output"]
}, Closed]],
Cell[19975, 727, 287, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[20287, 736, 70, 1, 40, "Input"],
Cell[20360, 739, 54, 1, 35, "Output"]
}, Closed]]
}, Closed]],
Cell[20441, 744, 202, 6, 45, "Subsection"]
}, Closed]],

Cell[CellGroupData[{
Cell[20680, 755, 24, 0, 40, "Section"],
Cell[20707, 757, 441, 10, 76, "Text"],

Cell[CellGroupData[{
Cell[21173, 771, 58, 1, 39, "Input"],
Cell[21234, 774, 172, 3, 55, "Output"]
}, Closed]],
Cell[21421, 780, 85, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[21531, 786, 61, 1, 39, "Input"],
Cell[21595, 789, 167, 2, 55, "Output"]
}, Closed]],
Cell[21777, 794, 316, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[22118, 803, 62, 1, 39, "Input"],
Cell[22183, 806, 44, 1, 55, "Output"]
}, Closed]],
Cell[22242, 810, 167, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[22434, 817, 105, 2, 59, "Input"],
Cell[22542, 821, 177, 3, 37, "Output"]
}, Closed]],
Cell[22734, 827, 300, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[23059, 838, 63, 1, 39, "Input"],
Cell[23125, 841, 444, 10, 114, "Output"]
}, Closed]],
Cell[23584, 854, 149, 3, 55, "Text"],

Cell[CellGroupData[{
Cell[23758, 861, 67, 1, 40, "Input"],
Cell[23828, 864, 474, 10, 105, "Output"]
}, Closed]],
Cell[24317, 877, 140, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[24482, 884, 72, 1, 40, "Input"],
Cell[24557, 887, 459, 10, 105, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[25065, 903, 73, 0, 40, "Section"],
Cell[25141, 905, 171, 4, 33, "Text",
  CellTags->"Blank"],

Cell[CellGroupData[{
Cell[25337, 913, 43, 0, 56, "Subsection"],
Cell[25383, 915, 155, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[25563, 922, 169, 3, 79, "Input"],
Cell[25735, 927, 63, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[25847, 934, 52, 0, 56, "Subsection"],
Cell[25902, 936, 242, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[26169, 944, 158, 3, 79, "Input"],
Cell[26330, 949, 67, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[26446, 956, 58, 0, 56, "Subsection"],
Cell[26507, 958, 249, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[26781, 966, 159, 3, 79, "Input"],
Cell[26943, 971, 70, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[27062, 978, 61, 0, 56, "Subsection"],
Cell[27126, 980, 364, 7, 76, "Text"],

Cell[CellGroupData[{
Cell[27515, 991, 151, 3, 82, "Input"],
Cell[27669, 996, 57, 1, 35, "Output"]
}, Closed]],
Cell[27741, 1000, 90, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[27856, 1006, 152, 3, 82, "Input"],
Cell[28011, 1011, 51, 1, 35, "Output"]
}, Closed]],
Cell[28077, 1015, 118, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[28220, 1022, 153, 3, 82, "Input"],
Cell[28376, 1027, 52, 1, 35, "Output"]
}, Closed]],
Cell[28443, 1031, 275, 5, 47, "Text"],

Cell[CellGroupData[{
Cell[28743, 1040, 184, 3, 82, "Input"],
Cell[28930, 1045, 64, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[29043, 1052, 63, 0, 44, "Subsection"],
Cell[29109, 1054, 108, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[29242, 1061, 192, 3, 80, "Input"],
Cell[29437, 1066, 72, 1, 35, "Output"]
}, Closed]],
Cell[29524, 1070, 183, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[29732, 1078, 184, 3, 80, "Input"],
Cell[29919, 1083, 73, 1, 35, "Output"]
}, Closed]],
Cell[30007, 1087, 196, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[30228, 1095, 185, 3, 80, "Input"],
Cell[30416, 1100, 71, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[30536, 1107, 64, 0, 44, "Subsection"],
Cell[30603, 1109, 257, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[30885, 1117, 182, 3, 80, "Input"],
Cell[31070, 1122, 87, 1, 35, "Output"]
}, Closed]],
Cell[31172, 1126, 133, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[31330, 1133, 183, 3, 80, "Input"],
Cell[31516, 1138, 63, 1, 35, "Output"]
}, Closed]],
Cell[31594, 1142, 172, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[31791, 1149, 184, 3, 80, "Input"],
Cell[31978, 1154, 64, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[32103, 1162, 24, 0, 40, "Section"],
Cell[32130, 1164, 507, 9, 119, "Text"],
Cell[32640, 1175, 54, 1, 39, "Input"],

Cell[CellGroupData[{
Cell[32719, 1180, 73, 0, 56, "Subsection"],
Cell[32795, 1182, 528, 8, 75, "Text"],

Cell[CellGroupData[{
Cell[33348, 1194, 62, 1, 39, "Input"],
Cell[33413, 1197, 46, 1, 37, "Output"]
}, Closed]],
Cell[33474, 1201, 198, 4, 33, "Text",
  CellTags->"Partial evaluation1"],
Cell[33675, 1207, 192, 4, 75, "Input"],
Cell[33870, 1213, 108, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[34003, 1220, 50, 1, 39, "Input"],
Cell[34056, 1223, 119, 2, 47, "Output"]
}, Closed]],
Cell[34190, 1228, 1092, 28, 96, "Text"],

Cell[CellGroupData[{
Cell[35307, 1260, 77, 1, 39, "Input"],
Cell[35387, 1263, 140, 3, 47, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[35576, 1272, 70, 0, 56, "Subsection"],
Cell[35649, 1274, 147, 4, 33, "Text",
  CellTags->"$DisplayFunction"],

Cell[CellGroupData[{
Cell[35821, 1282, 63, 1, 40, "Input"],
Cell[35887, 1285, 83, 1, 35, "Output"]
}, Closed]],
Cell[35985, 1289, 371, 6, 50, "Text"],
Cell[36359, 1297, 444, 8, 205, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[36840, 1310, 91, 2, 45, "Subsection"],
Cell[36934, 1314, 241, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[37200, 1322, 191, 4, 145, "Input"],
Cell[37394, 1328, 63, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[37494, 1334, 67, 1, 40, "Input"],
Cell[37564, 1337, 45, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[37658, 1344, 69, 0, 45, "Subsection"],
Cell[37730, 1346, 374, 6, 50, "Text"],
Cell[38107, 1354, 86, 2, 60, "Input"],
Cell[38196, 1358, 43, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[38264, 1363, 43, 1, 40, "Input"],
Cell[38310, 1366, 75, 1, 35, "Output"]
}, Closed]],
Cell[38400, 1370, 294, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[38719, 1379, 79, 1, 40, "Input"],
Cell[38801, 1382, 100, 2, 35, "Output"]
}, Closed]],
Cell[38916, 1387, 117, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[39058, 1394, 48, 1, 40, "Input"],
Cell[39109, 1397, 55, 1, 35, "Output"]
}, Closed]],
Cell[39179, 1401, 154, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[39358, 1408, 91, 2, 60, "Input"],
Cell[39452, 1412, 76, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[39577, 1419, 48, 0, 45, "Subsection"],
Cell[39628, 1421, 1167, 31, 130, "Text"],
Cell[40798, 1454, 268, 5, 122, "Input"],

Cell[CellGroupData[{
Cell[41091, 1463, 53, 1, 40, "Input"],
Cell[41147, 1466, 52, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[41260, 1474, 37, 0, 40, "Section"],
Cell[41300, 1476, 600, 15, 75, "Text",
  CellTags->"ButtonProgramming"],
Cell[41903, 1493, 378, 8, 139, "Input"],
Cell[42284, 1503, 95, 2, 33, "Text"],
Cell[42382, 1507, 899, 16, 199, "Input"],

Cell[CellGroupData[{
Cell[43306, 1527, 99, 2, 56, "Subsection"],
Cell[43408, 1531, 809, 12, 117, "Text"],
Cell[44220, 1545, 153, 3, 59, "Input"],
Cell[44376, 1550, 726, 13, 96, "Text",
  CellTags->"Pure_Function_Example"],
Cell[45105, 1565, 634, 12, 219, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[45776, 1582, 44, 0, 45, "Subsection"],
Cell[45823, 1584, 113, 3, 30, "Text"],
Cell[45939, 1589, 257, 6, 50, "Text"],
Cell[46199, 1597, 304, 7, 50, "Text"],
Cell[46506, 1606, 299, 10, 30, "Text"],
Cell[46808, 1618, 335, 10, 50, "Text"],
Cell[47146, 1630, 338, 10, 50, "Text"],
Cell[47487, 1642, 368, 11, 50, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[47904, 1659, 30, 0, 40, "Section"],
Cell[47937, 1661, 1543, 26, 273, "Text",
  CellTags->"ButtonStyles"],
Cell[49483, 1689, 66, 1, 39, "Input"],
Cell[49552, 1692, 477, 8, 98, "Text"],
Cell[50032, 1702, 703, 14, 139, "Input"],
Cell[50738, 1718, 142, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[50905, 1725, 44, 0, 56, "Subsection"],
Cell[50952, 1727, 472, 9, 75, "Text"],
Cell[51427, 1738, 1404, 23, 259, "Input"],
Cell[52834, 1763, 46, 1, 39, "Input"],

Cell[CellGroupData[{
Cell[52905, 1768, 43, 0, 52, "Subsubsection"],
Cell[52951, 1770, 303, 5, 105, "Text"],

Cell[CellGroupData[{
Cell[53279, 1779, 41, 1, 40, "Input"],
Cell[53323, 1782, 42, 1, 40, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[53414, 1789, 46, 0, 45, "Subsubsection"],
Cell[53463, 1791, 327, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[53815, 1800, 41, 1, 43, "Input"],
Cell[53859, 1803, 42, 1, 40, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[53950, 1810, 50, 0, 45, "Subsubsection"],
Cell[54003, 1812, 383, 6, 85, "Text"],

Cell[CellGroupData[{
Cell[54411, 1822, 41, 1, 50, "Input"],
Cell[54455, 1825, 42, 1, 70, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[54546, 1832, 50, 0, 45, "Subsubsection"],
Cell[54599, 1834, 419, 7, 85, "Text"],

Cell[CellGroupData[{
Cell[55043, 1845, 41, 1, 50, "Input"],
Cell[55087, 1848, 42, 1, 70, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[55178, 1855, 54, 0, 45, "Subsubsection"],
Cell[55235, 1857, 439, 7, 85, "Text"],

Cell[CellGroupData[{
Cell[55699, 1868, 41, 1, 50, "Input"],
Cell[55743, 1871, 42, 1, 70, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[55846, 1879, 47, 0, 44, "Subsection"],
Cell[55896, 1881, 623, 9, 85, "Text"],
Cell[56522, 1892, 455, 13, 75, "Text"],
Cell[56980, 1907, 192, 4, 30, "Text"],
Cell[57175, 1913, 403, 9, 40, 32, 0, "StyleData", "EvaluateCell2", "All",
  StyleMenuListing->None,
  ButtonStyleMenuListing->Automatic],
Cell[57581, 1924, 295, 5, 47, "Text"],
Cell[57879, 1931, 712, 16, 90, "DisplayFormula"],
Cell[58594, 1949, 117, 3, 30, "Text"],
Cell[58714, 1954, 714, 16, 90, "DisplayFormula"],
Cell[59431, 1972, 1125, 25, 180, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[60605, 2003, 24, 0, 40, "Section"],
Cell[60632, 2005, 63, 0, 33, "Text"],
Cell[60698, 2007, 233, 4, 99, "Input"],
Cell[60934, 2013, 147, 4, 33, "Text",
  CellTags->"Cases"],

Cell[CellGroupData[{
Cell[61106, 2021, 67, 1, 39, "Input"],
Cell[61176, 2024, 81, 1, 37, "Output"]
}, Closed]],
Cell[61272, 2028, 183, 6, 38, "Text"],

Cell[CellGroupData[{
Cell[61480, 2038, 119, 3, 51, "Input"],
Cell[61602, 2043, 107, 2, 43, "Output"]
}, Closed]],
Cell[61724, 2048, 175, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[61924, 2055, 154, 4, 72, "Input"],
Cell[62081, 2061, 225, 4, 66, "Output"]
}, Closed]],
Cell[62321, 2068, 165, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[62511, 2075, 126, 3, 51, "Input"],
Cell[62640, 2080, 107, 2, 43, "Output"]
}, Closed]],
Cell[62762, 2085, 55, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[62842, 2089, 34, 1, 39, "Input"],
Cell[62879, 2092, 42, 1, 52, "Output"]
}, Closed]],
Cell[62936, 2096, 589, 10, 105, "Text"],

Cell[CellGroupData[{
Cell[63550, 2110, 128, 3, 46, "Input"],
Cell[63681, 2115, 51, 1, 41, "Output"]
}, Closed]],
Cell[63747, 2119, 422, 9, 66, "Text"],

Cell[CellGroupData[{
Cell[64194, 2132, 210, 5, 80, "Input",
  CellTags->"Cases"],
Cell[64407, 2139, 146, 2, 54, "Output"]
}, Closed]],
Cell[64568, 2144, 413, 11, 66, "Text"],

Cell[CellGroupData[{
Cell[65006, 2159, 167, 4, 56, "Input",
  CellTags->"Cases"],
Cell[65176, 2165, 185, 3, 54, "Output"]
}, Closed]],
Cell[65376, 2171, 277, 7, 48, "Text"],

Cell[CellGroupData[{
Cell[65678, 2182, 34, 0, 56, "Subsection"],
Cell[65715, 2184, 316, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[66056, 2193, 200, 3, 82, "Input"],
Cell[66259, 2198, 79, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[66399, 2206, 42, 0, 40, "Section"],
Cell[66444, 2208, 361, 10, 33, "Text",
  CellTags->"Clear"],
Cell[66808, 2220, 55, 0, 33, "Text"],
Cell[66866, 2222, 47, 1, 39, "Input"],
Cell[66916, 2225, 119, 3, 33, "Text"],
Cell[67038, 2230, 74, 1, 39, "Input"],
Cell[67115, 2233, 71, 0, 33, "Text"],
Cell[67189, 2235, 54, 1, 39, "Input"],
Cell[67246, 2238, 110, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[67381, 2245, 30, 0, 56, "Subsection"],
Cell[67414, 2247, 1314, 36, 296, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[68765, 2288, 33, 0, 56, "Subsection"],
Cell[68801, 2290, 1283, 40, 187, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[70121, 2335, 31, 0, 44, "Subsection"],
Cell[70155, 2337, 840, 18, 198, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[71044, 2361, 47, 0, 40, "Section"],
Cell[71094, 2363, 343, 9, 33, "Text"],

Cell[CellGroupData[{
Cell[71462, 2376, 185, 3, 79, "Input"],
Cell[71650, 2381, 48, 1, 38, "Output"]
}, Closed]],
Cell[71713, 2385, 413, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[72151, 2396, 117, 2, 59, "Input"],
Cell[72271, 2400, 48, 1, 38, "Output"]
}, Closed]],
Cell[72334, 2404, 141, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[72500, 2411, 56, 1, 40, "Input"],
Cell[72559, 2414, 82, 1, 38, "Output"]
}, Closed]],
Cell[72656, 2418, 99, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[72780, 2424, 56, 1, 39, "Input"],
Cell[72839, 2427, 82, 1, 38, "Output"]
}, Closed]],
Cell[72936, 2431, 345, 6, 54, "Text"],

Cell[CellGroupData[{
Cell[73306, 2441, 47, 1, 39, "Input"],
Cell[73356, 2444, 295, 4, 58, "Output"]
}, Closed]],
Cell[73666, 2451, 691, 20, 54, "Text"],
Cell[74360, 2473, 593, 14, 54, "Text",
  CellTags->{"MapIndexedExample", "CoefficientsToPolynomial"}],
Cell[74956, 2489, 877, 25, 61, "Input"],
Cell[75836, 2516, 127, 3, 30, "Text"],
Cell[75966, 2521, 375, 7, 83, "Input"],
Cell[76344, 2530, 183, 4, 48, "Text"],
Cell[76530, 2536, 271, 5, 61, "Input"],
Cell[76804, 2543, 90, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[76919, 2549, 199, 4, 61, "Input"],
Cell[77121, 2555, 79, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[77237, 2561, 209, 5, 62, "Input"],
Cell[77449, 2568, 92, 1, 38, "Output"]
}, Closed]],
Cell[77556, 2572, 299, 9, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[77892, 2586, 29, 0, 40, "Section"],
Cell[77924, 2588, 237, 6, 33, "Text",
  CellTags->"Complement"],

Cell[CellGroupData[{
Cell[78186, 2598, 236, 5, 99, "Input"],
Cell[78425, 2605, 43, 1, 37, "Output"]
}, Closed]],
Cell[78483, 2609, 249, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[78757, 2618, 101, 2, 39, "Input"],
Cell[78861, 2622, 46, 1, 37, "Output"]
}, Closed]],
Cell[78922, 2626, 119, 3, 33, "Text"],
Cell[79044, 2631, 449, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[79518, 2642, 222, 3, 79, "Input"],
Cell[79743, 2647, 52, 1, 37, "Output"]
}, Closed]],
Cell[79810, 2651, 296, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[80131, 2660, 107, 2, 39, "Input"],
Cell[80241, 2664, 47, 1, 37, "Output"]
}, Closed]],
Cell[80303, 2668, 161, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[80489, 2675, 289, 6, 119, "Input"],
Cell[80781, 2683, 44, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[80874, 2690, 26, 0, 40, "Section"],
Cell[80903, 2692, 364, 9, 55, "Text"],

Cell[CellGroupData[{
Cell[81292, 2705, 133, 3, 56, "Subsection"],
Cell[81428, 2710, 301, 5, 54, "Text"],
Cell[81732, 2717, 144, 3, 72, "Input"],

Cell[CellGroupData[{
Cell[81901, 2724, 69, 1, 39, "Input"],
Cell[81973, 2727, 53, 1, 37, "Output"]
}, Closed]],
Cell[82041, 2731, 358, 8, 54, "Text"],
Cell[82402, 2741, 146, 3, 79, "Input"],
Cell[82551, 2746, 57, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[82633, 2750, 514, 14, 180, "Input"],
Cell[83150, 2766, 484, 11, 74, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[83683, 2783, 69, 0, 56, "Subsection"],
Cell[83755, 2785, 1147, 18, 145, "Text",
  CellTags->"Compiled_Evaluation"],

Cell[CellGroupData[{
Cell[84927, 2807, 130, 3, 50, "Subsubsection"],
Cell[85060, 2812, 279, 5, 50, "Text"],
Cell[85342, 2819, 112, 2, 40, "Input"],
Cell[85457, 2823, 199, 5, 30, "Text"],
Cell[85659, 2830, 119, 3, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[85815, 2838, 174, 4, 45, "Subsubsection"],
Cell[85992, 2844, 556, 8, 67, "Text"],

Cell[CellGroupData[{
Cell[86573, 2856, 143, 3, 60, "Input"],
Cell[86719, 2861, 202, 3, 57, "Output"]
}, Closed]],
Cell[86936, 2867, 244, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[87205, 2875, 165, 4, 60, "Input"],
Cell[87373, 2881, 363, 5, 80, "Output"]
}, Closed]],
Cell[87751, 2889, 391, 8, 50, "Text"],
Cell[88145, 2899, 102, 2, 32, "Text"],
Cell[88250, 2903, 564, 15, 290, "Text"],
Cell[88817, 2920, 111, 2, 32, "Text"],
Cell[88931, 2924, 117, 4, 70, "Text"],
Cell[89051, 2930, 98, 2, 32, "Text"],
Cell[89152, 2934, 237, 6, 110, "Text"],
Cell[89392, 2942, 121, 2, 32, "Text"],
Cell[89516, 2946, 352, 8, 150, "Text"],
Cell[89871, 2956, 96, 2, 32, "Text"],
Cell[89970, 2960, 200, 5, 90, "Text"],
Cell[90173, 2967, 108, 2, 32, "Text"],
Cell[90284, 2971, 255, 7, 130, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[90576, 2983, 144, 2, 45, "Subsubsection"],
Cell[90723, 2987, 238, 4, 50, "Text"],
Cell[90964, 2993, 118, 2, 60, "Input"],

Cell[CellGroupData[{
Cell[91107, 2999, 40, 1, 40, "Input"],
Cell[91150, 3002, 38, 1, 35, "Output"]
}, Closed]],
Cell[91203, 3006, 209, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[91437, 3014, 115, 2, 60, "Input"],
Cell[91555, 3018, 38, 1, 35, "Output"]
}, Closed]],
Cell[91608, 3022, 277, 5, 50, "Text"],
Cell[91888, 3029, 83, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[91996, 3034, 40, 1, 40, "Input"],
Cell[92039, 3037, 38, 1, 35, "Output"]
}, Closed]],
Cell[92092, 3041, 556, 8, 85, "Text"],

Cell[CellGroupData[{
Cell[92673, 3053, 383, 10, 100, "Input"],
Cell[93059, 3065, 52, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[93160, 3072, 142, 2, 45, "Subsubsection"],
Cell[93305, 3076, 170, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[93500, 3083, 161, 4, 60, "Input"],
Cell[93664, 3089, 38, 1, 35, "Output"]
}, Closed]],
Cell[93717, 3093, 604, 9, 85, "Text"],

Cell[CellGroupData[{
Cell[94346, 3106, 131, 2, 60, "Input"],
Cell[94480, 3110, 38, 1, 35, "Output"]
}, Closed]],
Cell[94533, 3114, 177, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[94735, 3121, 169, 4, 60, "Input"],
Cell[94907, 3127, 39, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[94995, 3134, 175, 4, 45, "Subsubsection"],
Cell[95173, 3140, 485, 7, 67, "Text"],
Cell[95661, 3149, 146, 4, 40, "Input"],

Cell[CellGroupData[{
Cell[95832, 3157, 40, 1, 40, "Input"],
Cell[95875, 3160, 35, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[95959, 3167, 165, 4, 45, "Subsubsection"],
Cell[96127, 3173, 339, 6, 50, "Text"],
Cell[96469, 3181, 139, 3, 80, "Input"],
Cell[96611, 3186, 378, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[97014, 3196, 289, 7, 145, "Input"],
Cell[97306, 3205, 52, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[97407, 3212, 170, 4, 45, "Subsubsection"],
Cell[97580, 3218, 371, 6, 50, "Text"],
Cell[97954, 3226, 74, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[98053, 3231, 40, 1, 40, "Input"],
Cell[98096, 3234, 68, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[98237, 3243, 43, 0, 40, "Section"],
Cell[98283, 3245, 185, 7, 33, "Text",
  CellTags->"Condition"],

Cell[CellGroupData[{
Cell[98493, 3256, 46, 0, 56, "Subsection"],
Cell[98542, 3258, 250, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[98817, 3266, 153, 3, 79, "Input"],
Cell[98973, 3271, 35, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[99045, 3277, 153, 3, 79, "Input"],
Cell[99201, 3282, 36, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[99274, 3288, 153, 3, 79, "Input"],
Cell[99430, 3293, 36, 1, 37, "Output"]
}, Closed]],
Cell[99481, 3297, 234, 4, 54, "Text"],
Cell[99718, 3303, 56, 1, 39, "Input"],
Cell[99777, 3306, 136, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[99938, 3313, 142, 3, 79, "Input"],
Cell[100083, 3318, 41, 1, 37, "Output"]
}, Closed]],
Cell[100139, 3322, 132, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[100296, 3329, 158, 3, 80, "Input"],
Cell[100457, 3334, 44, 1, 35, "Output"]
}, Closed]],
Cell[100516, 3338, 405, 7, 67, "Text"],

Cell[CellGroupData[{
Cell[100946, 3349, 72, 2, 60, "Input"],
Cell[101021, 3353, 41, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[101111, 3360, 36, 0, 44, "Subsection"],
Cell[101150, 3362, 146, 3, 48, "Text"],
Cell[101299, 3367, 129, 2, 61, "Input"],
Cell[101431, 3371, 104, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[101560, 3378, 106, 2, 61, "Input"],
Cell[101669, 3382, 38, 1, 38, "Output"]
}, Closed]],
Cell[101722, 3386, 90, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[101837, 3392, 98, 2, 60, "Input"],
Cell[101938, 3396, 35, 1, 35, "Output"]
}, Closed]],
Cell[101988, 3400, 174, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[102187, 3407, 37, 1, 40, "Input"],
Cell[102227, 3410, 38, 1, 35, "Output"]
}, Closed]],
Cell[102280, 3414, 1347, 29, 180, "Text"],
Cell[103630, 3445, 174, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[103829, 3452, 37, 1, 40, "Input"],
Cell[103869, 3455, 38, 1, 35, "Output"]
}, Closed]],
Cell[103922, 3459, 201, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[104148, 3467, 81, 2, 60, "Input"],
Cell[104232, 3471, 35, 1, 35, "Output"]
}, Closed]],
Cell[104282, 3475, 140, 3, 30, "Text"],
Cell[104425, 3480, 186, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[104636, 3487, 37, 1, 40, "Input"],
Cell[104676, 3490, 38, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[104751, 3496, 81, 2, 60, "Input"],
Cell[104835, 3500, 35, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[104931, 3508, 24, 0, 40, "Section"],
Cell[104958, 3510, 106, 3, 33, "Text",
  CellTags->"Count"],

Cell[CellGroupData[{
Cell[105089, 3517, 102, 2, 39, "Input"],
Cell[105194, 3521, 161, 2, 37, "Output"]
}, Closed]],
Cell[105370, 3526, 111, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[105506, 3533, 50, 1, 39, "Input"],
Cell[105559, 3536, 35, 1, 37, "Output"]
}, Closed]],
Cell[105609, 3540, 130, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[105764, 3547, 139, 3, 79, "Input"],
Cell[105906, 3552, 70, 1, 37, "Output"],
Cell[105979, 3555, 70, 1, 37, "Output"],
Cell[106052, 3558, 70, 1, 37, "Output"]
}, Closed]],
Cell[106137, 3562, 59, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[106221, 3566, 55, 1, 39, "Input"],
Cell[106279, 3569, 35, 1, 37, "Output"]
}, Closed]],
Cell[106329, 3573, 128, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[106482, 3580, 295, 6, 139, "Input"],
Cell[106780, 3588, 50, 1, 37, "Output"],
Cell[106833, 3591, 50, 1, 38, "Output"],
Cell[106886, 3594, 50, 1, 38, "Output"],
Cell[106939, 3597, 50, 1, 38, "Output"],
Cell[106992, 3600, 50, 1, 38, "Output"],
Cell[107045, 3603, 50, 1, 38, "Output"]
}, Closed]],
Cell[107110, 3607, 73, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[107208, 3611, 58, 1, 40, "Input"],
Cell[107269, 3614, 36, 1, 38, "Output"]
}, Closed]],
Cell[107320, 3618, 128, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[107473, 3625, 334, 10, 231, "Input"],
Cell[107810, 3637, 161, 2, 59, "Output"],
Cell[107974, 3641, 70, 1, 38, "Output"],
Cell[108047, 3644, 70, 1, 38, "Output"],
Cell[108120, 3647, 70, 1, 38, "Output"],
Cell[108193, 3650, 50, 1, 38, "Output"],
Cell[108246, 3653, 50, 1, 38, "Output"],
Cell[108299, 3656, 50, 1, 38, "Output"],
Cell[108352, 3659, 50, 1, 38, "Output"],
Cell[108405, 3662, 50, 1, 38, "Output"],
Cell[108458, 3665, 50, 1, 38, "Output"]
}, Closed]],
Cell[108523, 3669, 294, 7, 48, "Text"],

Cell[CellGroupData[{
Cell[108842, 3680, 37, 0, 52, "Subsubsection"],
Cell[108882, 3682, 266, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[109173, 3691, 196, 4, 80, "Input"],
Cell[109372, 3697, 35, 1, 35, "Output"]
}, Closed]],
Cell[109422, 3701, 122, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[109569, 3708, 166, 3, 60, "Input"],
Cell[109738, 3713, 35, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[109834, 3721, 30, 0, 40, "Section"],
Cell[109867, 3723, 118, 3, 33, "Text",
  CellTags->"DeleteCases"],
Cell[109988, 3728, 85, 1, 39, "Input"],
Cell[110076, 3731, 172, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[110273, 3738, 57, 1, 39, "Input"],
Cell[110333, 3741, 72, 1, 37, "Output"]
}, Closed]],
Cell[110420, 3745, 301, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[110746, 3756, 65, 1, 39, "Input"],
Cell[110814, 3759, 60, 1, 37, "Output"]
}, Closed]],
Cell[110889, 3763, 117, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[111031, 3770, 62, 1, 39, "Input"],
Cell[111096, 3773, 72, 1, 37, "Output"]
}, Closed]],
Cell[111183, 3777, 71, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[111279, 3781, 70, 1, 39, "Input"],
Cell[111352, 3784, 56, 1, 37, "Output"]
}, Closed]],
Cell[111423, 3788, 106, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[111554, 3795, 65, 1, 39, "Input"],
Cell[111622, 3798, 56, 1, 37, "Output"]
}, Closed]],
Cell[111693, 3802, 115, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[111833, 3809, 80, 1, 39, "Input"],
Cell[111916, 3812, 60, 1, 37, "Output"]
}, Closed]],
Cell[111991, 3816, 294, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[112310, 3827, 34, 0, 56, "Subsection"],
Cell[112347, 3829, 173, 3, 30, "Text"],
Cell[112523, 3834, 123, 2, 60, "Input"],
Cell[112649, 3838, 122, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[112796, 3845, 87, 1, 40, "Input"],
Cell[112886, 3848, 51, 1, 35, "Output"]
}, Closed]],
Cell[112952, 3852, 128, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[113105, 3859, 86, 1, 40, "Input"],
Cell[113194, 3862, 48, 1, 35, "Output"]
}, Closed]],
Cell[113257, 3866, 110, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[113392, 3873, 88, 1, 40, "Input"],
Cell[113483, 3876, 51, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[113571, 3882, 105, 2, 40, "Input"],
Cell[113679, 3886, 48, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[113788, 3894, 26, 0, 40, "Section"],
Cell[113817, 3896, 143, 4, 33, "Text",
  CellTags->"Default details"],

Cell[CellGroupData[{
Cell[113985, 3904, 32, 0, 56, "Subsection"],
Cell[114020, 3906, 689, 13, 96, "Text"],

Cell[CellGroupData[{
Cell[114734, 3923, 186, 3, 79, "Input"],
Cell[114923, 3928, 41, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[115001, 3934, 75, 1, 39, "Input"],
Cell[115079, 3937, 41, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[115169, 3944, 34, 0, 56, "Subsection"],
Cell[115206, 3946, 138, 3, 33, "Text"],
Cell[115347, 3951, 312, 5, 119, "Input"],
Cell[115662, 3958, 203, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[115890, 3966, 46, 1, 39, "Input"],
Cell[115939, 3969, 46, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[116022, 3975, 49, 1, 39, "Input"],
Cell[116074, 3978, 52, 1, 55, "Output"]
}, Closed]],
Cell[116141, 3982, 412, 7, 50, "Text"],

Cell[CellGroupData[{
Cell[116578, 3993, 42, 1, 40, "Input"],
Cell[116623, 3996, 45, 1, 37, "Output"]
}, Closed]],
Cell[116683, 4000, 411, 7, 50, "Text"],

Cell[CellGroupData[{
Cell[117119, 4011, 44, 1, 40, "Input"],
Cell[117166, 4014, 52, 1, 50, "Output"]
}, Closed]],
Cell[117233, 4018, 209, 4, 30, "Text"],
Cell[117445, 4024, 69, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[117551, 4030, 36, 0, 45, "Subsection"],
Cell[117590, 4032, 320, 5, 50, "Text"],
Cell[117913, 4039, 273, 5, 122, "Input"],
Cell[118189, 4046, 144, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[118358, 4053, 46, 1, 40, "Input"],
Cell[118407, 4056, 46, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[118490, 4062, 54, 1, 40, "Input"],
Cell[118547, 4065, 58, 1, 50, "Output"]
}, Closed]],
Cell[118620, 4069, 393, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[119038, 4079, 42, 1, 40, "Input"],
Cell[119083, 4082, 45, 1, 37, "Output"]
}, Closed]],
Cell[119143, 4086, 421, 7, 67, "Text"],

Cell[CellGroupData[{
Cell[119589, 4097, 49, 1, 40, "Input"],
Cell[119641, 4100, 59, 1, 50, "Output"]
}, Closed]],
Cell[119715, 4104, 214, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[119954, 4112, 54, 1, 40, "Input"],
Cell[120011, 4115, 159, 3, 30, "Message"],
Cell[120173, 4120, 159, 3, 30, "Message"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[120393, 4130, 29, 0, 40, "Section"],
Cell[120425, 4132, 264, 7, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[120726, 4144, 22, 0, 40, "Section"],
Cell[120751, 4146, 241, 6, 33, "Text",
  CellTags->"Dot"],

Cell[CellGroupData[{
Cell[121017, 4156, 102, 2, 59, "Input"],
Cell[121122, 4160, 52, 1, 37, "Output"]
}, Closed]],
Cell[121189, 4164, 134, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[121348, 4171, 60, 1, 39, "Input"],
Cell[121411, 4174, 57, 1, 37, "Output"]
}, Closed]],
Cell[121483, 4178, 233, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[121741, 4189, 75, 1, 39, "Input"],
Cell[121819, 4192, 52, 1, 37, "Output"]
}, Closed]],
Cell[121886, 4196, 94, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[122005, 4202, 62, 0, 56, "Subsection"],
Cell[122070, 4204, 169, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[122264, 4211, 238, 4, 99, "Input"],
Cell[122505, 4217, 86, 1, 37, "Output"],
Cell[122594, 4220, 38, 1, 37, "Output"]
}, Closed]],
Cell[122647, 4224, 120, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[122792, 4231, 225, 4, 99, "Input"],
Cell[123020, 4237, 86, 1, 35, "Output"],
Cell[123109, 4240, 38, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[123196, 4247, 53, 0, 45, "Subsection"],
Cell[123252, 4249, 487, 13, 50, "Text"],

Cell[CellGroupData[{
Cell[123764, 4266, 174, 3, 80, "Input"],
Cell[123941, 4271, 149, 2, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[124139, 4279, 52, 0, 45, "Subsection"],
Cell[124194, 4281, 171, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[124390, 4289, 219, 4, 80, "Input"],
Cell[124612, 4295, 574, 9, 100, "Output"]
}, Closed]],
Cell[125201, 4307, 102, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[125328, 4314, 75, 1, 40, "Input"],
Cell[125406, 4317, 38, 1, 35, "Output"]
}, Closed]],
Cell[125459, 4321, 435, 10, 50, "Text"],

Cell[CellGroupData[{
Cell[125919, 4335, 316, 6, 100, "Input"],
Cell[126238, 4343, 38, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[126325, 4350, 64, 0, 45, "Subsection"],
Cell[126392, 4352, 375, 7, 67, "Text"],

Cell[CellGroupData[{
Cell[126792, 4363, 227, 4, 105, "Input"],
Cell[127022, 4369, 104, 2, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[127187, 4378, 27, 0, 40, "Section"],
Cell[127217, 4380, 296, 6, 54, "Text",
  CellTags->"Evaluate"],
Cell[127516, 4388, 252, 5, 119, "Input"],
Cell[127771, 4395, 143, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[127939, 4402, 49, 1, 39, "Input"],
Cell[127991, 4405, 54, 1, 37, "Output"]
}, Closed]],
Cell[128060, 4409, 350, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[128435, 4420, 59, 1, 39, "Input"],
Cell[128497, 4423, 55, 1, 37, "Output"]
}, Closed]],
Cell[128567, 4427, 118, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[128710, 4434, 59, 1, 39, "Input"],
Cell[128772, 4437, 56, 1, 37, "Output"]
}, Closed]],
Cell[128843, 4441, 367, 6, 54, "Text"],

Cell[CellGroupData[{
Cell[129235, 4451, 61, 1, 39, "Input"],
Cell[129299, 4454, 66, 1, 37, "Output"]
}, Closed]],
Cell[129380, 4458, 131, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[129536, 4465, 142, 2, 59, "Input"],
Cell[129681, 4469, 57, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[129775, 4475, 54, 0, 56, "Subsection"],
Cell[129832, 4477, 679, 13, 140, "Text"],
Cell[130514, 4492, 156, 3, 83, "Input"],
Cell[130673, 4497, 131, 3, 40, "Input"],
Cell[130807, 4502, 103, 2, 40, "Input"],
Cell[130913, 4506, 396, 7, 88, "Text"],
Cell[131312, 4515, 133, 3, 54, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[131494, 4524, 66, 0, 40, "Section"],
Cell[131563, 4526, 614, 12, 75, "Text",
  CellTags->"ExactNumberQ"],

Cell[CellGroupData[{
Cell[132202, 4542, 413, 7, 107, "Input"],
Cell[132618, 4551, 52, 1, 37, "Output"],
Cell[132673, 4554, 125, 2, 37, "Output"]
}, Closed]],
Cell[132813, 4559, 206, 4, 67, "Commentary"],

Cell[CellGroupData[{
Cell[133044, 4567, 379, 6, 67, "Input"],
Cell[133426, 4575, 70, 1, 37, "Output"],
Cell[133499, 4578, 104, 2, 37, "Output"]
}, Closed]],
Cell[133618, 4583, 83, 1, 48, "Commentary"],

Cell[CellGroupData[{
Cell[133726, 4588, 45, 1, 39, "Input"],
Cell[133774, 4591, 322, 9, 29, "Print",
  CellTags->"Info3292238823-5325569"]
}, Closed]],
Cell[134111, 4603, 159, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[134295, 4610, 344, 6, 68, "Input"],
Cell[134642, 4618, 101, 2, 37, "Output"],
Cell[134746, 4622, 69, 1, 37, "Output"]
}, Closed]],
Cell[134830, 4626, 296, 7, 67, "Commentary"],

Cell[CellGroupData[{
Cell[135151, 4637, 46, 1, 40, "Input"],
Cell[135200, 4640, 334, 9, 50, "Print",
  CellTags->"Info3242392617-9633741"]
}, Closed]],

Cell[CellGroupData[{
Cell[135571, 4654, 321, 5, 91, "Input"],
Cell[135895, 4661, 101, 2, 38, "Output"],
Cell[135999, 4665, 69, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[136117, 4672, 23, 0, 40, "Section"],
Cell[136143, 4674, 366, 10, 54, "Text",
  CellTags->"Flat"],

Cell[CellGroupData[{
Cell[136534, 4688, 126, 3, 79, "Input"],
Cell[136663, 4693, 44, 1, 37, "Output"]
}, Closed]],
Cell[136722, 4697, 947, 15, 117, "Text"],

Cell[CellGroupData[{
Cell[137694, 4716, 84, 2, 59, "Input"],
Cell[137781, 4720, 62, 1, 37, "Output"]
}, Closed]],
Cell[137858, 4724, 276, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[138159, 4735, 103, 1, 56, "Subsection",
  CellTags->"Attributes warning"],
Cell[138265, 4738, 460, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[138750, 4749, 245, 6, 99, "Input"],
Cell[138998, 4757, 54, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[139089, 4763, 140, 3, 39, "Input"],
Cell[139232, 4768, 38, 1, 37, "Output"]
}, Closed]],
Cell[139285, 4772, 194, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[139504, 4780, 246, 6, 100, "Input"],
Cell[139753, 4788, 44, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[139834, 4794, 136, 3, 40, "Input"],
Cell[139973, 4799, 38, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[140048, 4805, 130, 3, 50, "Subsubsection"],

Cell[CellGroupData[{
Cell[140203, 4812, 322, 8, 145, "Input"],
Cell[140528, 4822, 54, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[140619, 4828, 141, 3, 40, "Input"],
Cell[140763, 4833, 44, 1, 35, "Output"]
}, Closed]],
Cell[140822, 4837, 323, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[141170, 4847, 39, 1, 40, "Input"],
Cell[141212, 4850, 63, 1, 27, "Print",
  CellTags->"Info3242392618-3366990"],
Cell[141278, 4853, 503, 15, 65, "Print",
  CellTags->"Info3242392618-3366990"]
}, Closed]],
Cell[141796, 4871, 46, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[141867, 4876, 39, 1, 40, "Input"],
Cell[141909, 4879, 63, 1, 27, "Print",
  CellTags->"Info3242392618-7584819"],
Cell[141975, 4882, 437, 13, 30, "Print",
  CellTags->"Info3242392618-7584819"]
}, Closed]],
Cell[142427, 4898, 46, 1, 40, "Input"],
Cell[142476, 4901, 43, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[142544, 4905, 37, 1, 40, "Input"],
Cell[142584, 4908, 63, 1, 27, "Print",
  CellTags->"Info3242392618-6169565"]
}, Closed]],

Cell[CellGroupData[{
Cell[142684, 4914, 51, 1, 40, "Input"],
Cell[142738, 4917, 52, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[142851, 4925, 75, 0, 44, "Subsection"],
Cell[142929, 4927, 818, 12, 120, "Text"],

Cell[CellGroupData[{
Cell[143772, 4943, 141, 4, 105, "Input"],
Cell[143916, 4949, 47, 1, 35, "Output"]
}, Closed]],
Cell[143978, 4953, 540, 9, 85, "Text"],
Cell[144521, 4964, 290, 5, 105, "Input"],
Cell[144814, 4971, 169, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[145008, 4978, 63, 1, 40, "Input"],
Cell[145074, 4981, 41, 1, 35, "Output"]
}, Closed]],
Cell[145130, 4985, 200, 4, 47, "Text"],

Cell[CellGroupData[{
Cell[145355, 4993, 49, 1, 40, "Input"],
Cell[145407, 4996, 54, 1, 35, "Output"]
}, Closed]],
Cell[145476, 5000, 118, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[145619, 5007, 49, 1, 40, "Input"],
Cell[145671, 5010, 35, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[145767, 5018, 26, 0, 40, "Section"],
Cell[145796, 5020, 196, 4, 33, "Text",
  CellTags->"Flatten"],

Cell[CellGroupData[{
Cell[146017, 5028, 68, 1, 39, "Input"],
Cell[146088, 5031, 52, 1, 37, "Output"]
}, Closed]],
Cell[146155, 5035, 118, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[146298, 5042, 73, 1, 39, "Input"],
Cell[146374, 5045, 53, 1, 37, "Output"]
}, Closed]],
Cell[146442, 5049, 550, 8, 75, "Text"],

Cell[CellGroupData[{
Cell[147017, 5061, 209, 5, 59, "Input"],
Cell[147229, 5068, 107, 2, 37, "Output"]
}, Closed]],
Cell[147351, 5073, 265, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[147641, 5082, 187, 5, 59, "Input"],
Cell[147831, 5089, 81, 1, 37, "Output"]
}, Closed]],
Cell[147927, 5093, 284, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[148236, 5102, 175, 4, 59, "Input"],
Cell[148414, 5108, 59, 1, 37, "Output"]
}, Closed]],
Cell[148488, 5112, 231, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[148744, 5120, 193, 4, 59, "Input"],
Cell[148940, 5126, 79, 1, 38, "Output"]
}, Closed]],
Cell[149034, 5130, 127, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[149186, 5137, 215, 4, 61, "Input"],
Cell[149404, 5143, 79, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[149532, 5150, 23, 0, 40, "Section"],
Cell[149558, 5152, 132, 4, 33, "Text",
  CellTags->"Fold"],

Cell[CellGroupData[{
Cell[149715, 5160, 66, 3, 56, "Input"],
Cell[149784, 5165, 53, 1, 37, "Output"]
}, Closed]],
Cell[149852, 5169, 761, 16, 267, "Text"],

Cell[CellGroupData[{
Cell[150638, 5189, 74, 1, 39, "Input"],
Cell[150715, 5192, 51, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[150803, 5198, 78, 1, 39, "Input"],
Cell[150884, 5201, 47, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[150968, 5207, 123, 3, 39, "Input"],
Cell[151094, 5212, 41, 1, 37, "Output"]
}, Closed]],
Cell[151150, 5216, 193, 4, 44, "Text"],

Cell[CellGroupData[{
Cell[151368, 5224, 297, 5, 99, "Input"],
Cell[151668, 5231, 86, 1, 35, "Output"]
}, Closed]],
Cell[151769, 5235, 273, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[152067, 5244, 258, 5, 100, "Input"],
Cell[152328, 5251, 71, 1, 35, "Output"]
}, Closed]],
Cell[152414, 5255, 277, 5, 50, "Text",
  CellTags->"Partial evaluation 2"],
Cell[152694, 5262, 152, 3, 40, "Input"],
Cell[152849, 5267, 136, 3, 30, "Text"],
Cell[152988, 5272, 192, 4, 70, "Input"],
Cell[153183, 5278, 108, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[153316, 5285, 50, 1, 40, "Input"],
Cell[153369, 5288, 119, 2, 40, "Output"]
}, Closed]],
Cell[153503, 5293, 152, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[153680, 5300, 84, 1, 40, "Input"],
Cell[153767, 5303, 140, 3, 40, "Output"]
}, Closed]],
Cell[153922, 5309, 851, 19, 130, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[154810, 5333, 27, 0, 40, "Section"],
Cell[154840, 5335, 226, 5, 54, "Text",
  CellTags->"FoldList"],

Cell[CellGroupData[{
Cell[155091, 5344, 46, 1, 39, "Input"],
Cell[155140, 5347, 326, 9, 29, "Print",
  CellTags->"Info3242392636-8498059"]
}, Closed]],
Cell[155481, 5359, 437, 9, 54, "Text"],

Cell[CellGroupData[{
Cell[155943, 5372, 344, 7, 59, "Input"],
Cell[156290, 5381, 89, 1, 37, "Output"]
}, Closed]],
Cell[156394, 5385, 212, 6, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[156643, 5396, 25, 0, 40, "Section"],
Cell[156671, 5398, 139, 4, 33, "Text",
  CellTags->"Format"],

Cell[CellGroupData[{
Cell[156835, 5406, 406, 9, 219, "Input"],
Cell[157244, 5417, 96, 2, 38, "Output"]
}, Closed]],
Cell[157355, 5422, 67, 0, 33, "Text"],
Cell[157425, 5424, 115, 2, 59, "Input"],
Cell[157543, 5428, 316, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[157884, 5437, 524, 13, 239, "Input"],
Cell[158411, 5452, 68, 2, 55, "Output"]
}, Closed]],
Cell[158494, 5457, 117, 3, 33, "Text"],
Cell[158614, 5462, 147, 3, 83, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[158798, 5470, 24, 0, 40, "Section"],
Cell[158825, 5472, 378, 11, 33, "Text",
  CellTags->"FreeQ"],

Cell[CellGroupData[{
Cell[159228, 5487, 62, 1, 40, "Input"],
Cell[159293, 5490, 39, 1, 37, "Output"]
}, Closed]],
Cell[159347, 5494, 102, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[159474, 5501, 65, 1, 40, "Input"],
Cell[159542, 5504, 38, 1, 37, "Output"]
}, Closed]],
Cell[159595, 5508, 108, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[159728, 5515, 53, 1, 39, "Input"],
Cell[159784, 5518, 39, 1, 37, "Output"]
}, Closed]],
Cell[159838, 5522, 294, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[160157, 5533, 34, 0, 56, "Subsection"],
Cell[160194, 5535, 251, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[160470, 5543, 73, 1, 40, "Input"],
Cell[160546, 5546, 39, 1, 37, "Output"]
}, Closed]],
Cell[160600, 5550, 138, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[160763, 5557, 101, 2, 40, "Input"],
Cell[160867, 5561, 38, 1, 37, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[160966, 5569, 27, 0, 40, "Section"],
Cell[160996, 5571, 101, 3, 36, "Text",
  CellTags->"Function"],
Cell[161100, 5576, 336, 6, 77, "Text"],

Cell[CellGroupData[{
Cell[161461, 5586, 159, 3, 59, "Input"],
Cell[161623, 5591, 59, 1, 37, "Output"]
}, Closed]],
Cell[161697, 5595, 268, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[161990, 5604, 117, 2, 59, "Input"],
Cell[162110, 5608, 59, 1, 37, "Output"]
}, Closed]],
Cell[162184, 5612, 137, 3, 33, "Text"],
Cell[162324, 5617, 57, 1, 39, "Input"],

Cell[CellGroupData[{
Cell[162406, 5622, 63, 0, 56, "Subsection"],
Cell[162472, 5624, 96, 2, 33, "Text"],
Cell[162571, 5628, 47, 1, 39, "Input"],
Cell[162621, 5631, 424, 7, 76, "Text"],
Cell[163048, 5640, 182, 4, 99, "Input"],
Cell[163233, 5646, 76, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[163334, 5650, 45, 1, 40, "Input"],
Cell[163382, 5653, 48, 1, 35, "Output"]
}, Closed]],
Cell[163445, 5657, 290, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[163760, 5666, 55, 1, 40, "Input"],
Cell[163818, 5669, 53, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[163920, 5676, 133, 5, 44, "Subsection"],
Cell[164056, 5683, 47, 1, 40, "Input"],
Cell[164106, 5686, 92, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[164223, 5692, 115, 2, 60, "Input"],
Cell[164341, 5696, 48, 1, 35, "Output"]
}, Closed]],
Cell[164404, 5700, 508, 8, 67, "Text"],
Cell[164915, 5710, 179, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[165119, 5717, 43, 1, 40, "Input"],
Cell[165165, 5720, 48, 1, 35, "Output"]
}, Closed]],
Cell[165228, 5724, 366, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[165619, 5734, 40, 1, 40, "Input"],
Cell[165662, 5737, 79, 1, 35, "Output"]
}, Closed]],
Cell[165756, 5741, 442, 13, 50, "Text"],

Cell[CellGroupData[{
Cell[166223, 5758, 170, 3, 80, "Input"],
Cell[166396, 5763, 41, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[166486, 5770, 78, 0, 44, "Subsection"],
Cell[166567, 5772, 47, 1, 40, "Input"],
Cell[166617, 5775, 256, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[166898, 5784, 103, 2, 88, "Input"],
Cell[167004, 5788, 56, 1, 50, "Output"]
}, Closed]],
Cell[167075, 5792, 342, 6, 66, "Text"],
Cell[167420, 5800, 113, 2, 63, "Input"],

Cell[CellGroupData[{
Cell[167558, 5806, 51, 1, 63, "Input"],
Cell[167612, 5809, 56, 1, 50, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[167705, 5815, 35, 0, 52, "Subsubsection"],
Cell[167743, 5817, 47, 1, 40, "Input"],
Cell[167793, 5820, 374, 6, 85, "Text"],
Cell[168170, 5828, 115, 2, 63, "Input"],

Cell[CellGroupData[{
Cell[168310, 5834, 54, 1, 63, "Input"],
Cell[168367, 5837, 50, 1, 50, "Output"]
}, Closed]],
Cell[168432, 5841, 367, 10, 66, "Text"],

Cell[CellGroupData[{
Cell[168824, 5855, 40, 1, 40, "Input"],
Cell[168867, 5858, 36, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[168964, 5866, 55, 0, 44, "Subsection"],
Cell[169022, 5868, 47, 1, 40, "Input"],
Cell[169072, 5871, 486, 8, 65, "Text"],
Cell[169561, 5881, 145, 2, 60, "Input"],
Cell[169709, 5885, 125, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[169859, 5892, 95, 2, 60, "Input"],
Cell[169957, 5896, 47, 1, 35, "Output"]
}, Closed]],
Cell[170019, 5900, 148, 3, 30, "Text"],
Cell[170170, 5905, 491, 12, 105, "Input"],
Cell[170664, 5919, 139, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[170828, 5926, 95, 2, 60, "Input"],
Cell[170926, 5930, 47, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[171022, 5937, 61, 0, 44, "Subsection"],
Cell[171086, 5939, 47, 1, 40, "Input"],
Cell[171136, 5942, 241, 4, 50, "Text"],
Cell[171380, 5948, 227, 4, 60, "Input"],
Cell[171610, 5954, 120, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[171755, 5961, 89, 2, 60, "Input"],
Cell[171847, 5965, 41, 1, 35, "Output"]
}, Closed]],
Cell[171903, 5969, 118, 3, 30, "Text"],
Cell[172024, 5974, 184, 4, 40, "Input"],
Cell[172211, 5980, 54, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[172290, 5984, 89, 2, 60, "Input"],
Cell[172382, 5988, 41, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[172472, 5995, 58, 0, 44, "Subsection"],
Cell[172533, 5997, 57, 1, 40, "Input"],
Cell[172593, 6000, 1184, 22, 180, "Text",
  CellTags->"No_Argument_Functions"],

Cell[CellGroupData[{
Cell[173802, 6026, 213, 4, 82, "Input"],
Cell[174018, 6032, 128, 2, 35, "Output"]
}, Closed]],
Cell[174161, 6037, 162, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[174348, 6044, 77, 1, 40, "Input"],
Cell[174428, 6047, 53, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[174530, 6054, 49, 0, 44, "Subsection"],
Cell[174582, 6056, 49, 1, 40, "Input"],
Cell[174634, 6059, 324, 5, 50, "Text"],
Cell[174961, 6066, 130, 2, 40, "Input"],
Cell[175094, 6070, 54, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[175173, 6074, 54, 1, 40, "Input"],
Cell[175230, 6077, 60, 1, 30, "Print"],
Cell[175293, 6080, 93, 1, 35, "Output"]
}, Closed]]
}, Closed]],
Cell[175413, 6085, 205, 6, 41, "Subsection"]
}, Closed]],

Cell[CellGroupData[{
Cell[175655, 6096, 47, 0, 40, "Section"],
Cell[175705, 6098, 272, 6, 55, "Text",
  CellTags->{"Hold", "HoldAll"}],
Cell[175980, 6106, 133, 3, 79, "Input"],
Cell[176116, 6111, 132, 3, 33, "Text"],
Cell[176251, 6116, 47, 1, 39, "Input"],
Cell[176301, 6119, 167, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[176493, 6128, 209, 4, 99, "Input"],
Cell[176705, 6134, 390, 14, 37, "Output"]
}, Closed]],
Cell[177110, 6151, 522, 9, 119, "Text"],

Cell[CellGroupData[{
Cell[177657, 6164, 84, 2, 59, "Input"],
Cell[177744, 6168, 35, 1, 37, "Output"]
}, Closed]],
Cell[177794, 6172, 337, 6, 76, "Text"],

Cell[CellGroupData[{
Cell[178156, 6182, 91, 2, 56, "Subsection"],
Cell[178250, 6186, 67, 0, 33, "Text"],
Cell[178320, 6188, 108, 2, 39, "Input"],
Cell[178431, 6192, 104, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[178560, 6199, 81, 1, 40, "Input"],
Cell[178644, 6202, 1074, 15, 314, "Output"]
}, Closed]],
Cell[179733, 6220, 106, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[179864, 6227, 83, 1, 40, "Input"],
Cell[179950, 6230, 308, 4, 101, "Output"]
}, Closed]],
Cell[180273, 6237, 105, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[180403, 6244, 82, 1, 40, "Input"],
Cell[180488, 6247, 88, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[180637, 6255, 34, 0, 40, "Section"],
Cell[180674, 6257, 332, 6, 54, "Text",
  CellTags->"HoldAllComplete"],

Cell[CellGroupData[{
Cell[181031, 6267, 190, 3, 59, "Input"],
Cell[181224, 6272, 102, 2, 37, "Output"]
}, Closed]],
Cell[181341, 6277, 140, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[181506, 6284, 190, 3, 79, "Input"],
Cell[181699, 6289, 146, 2, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[181882, 6296, 73, 0, 56, "Subsection"],
Cell[181958, 6298, 67, 0, 33, "Text"],
Cell[182028, 6300, 108, 2, 39, "Input"],
Cell[182139, 6304, 116, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[182280, 6311, 89, 1, 39, "Input"],
Cell[182372, 6314, 112, 2, 37, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[182545, 6323, 27, 0, 40, "Section"],
Cell[182575, 6325, 62, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[182662, 6329, 71, 1, 39, "Input"],
Cell[182736, 6332, 465, 19, 38, "Output"]
}, Closed]],
Cell[183216, 6354, 67, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[183308, 6358, 47, 1, 39, "Input"],
Cell[183358, 6361, 37, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[183444, 6368, 30, 0, 40, "Section"],
Cell[183477, 6370, 116, 3, 33, "Text",
  CellTags->"HoldPattern"],

Cell[CellGroupData[{
Cell[183618, 6377, 65, 1, 39, "Input"],
Cell[183686, 6380, 38, 1, 37, "Output"]
}, Closed]],
Cell[183739, 6384, 383, 8, 98, "Text"],

Cell[CellGroupData[{
Cell[184147, 6396, 56, 1, 39, "Input"],
Cell[184206, 6399, 38, 1, 37, "Output"]
}, Closed]],
Cell[184259, 6403, 148, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[184432, 6410, 78, 1, 39, "Input"],
Cell[184513, 6413, 39, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[184589, 6419, 82, 1, 39, "Input"],
Cell[184674, 6422, 39, 1, 37, "Output"]
}, Closed]],
Cell[184728, 6426, 124, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[184877, 6433, 132, 2, 59, "Input"],
Cell[185012, 6437, 47, 1, 37, "Output"]
}, Closed]],
Cell[185074, 6441, 204, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[185303, 6449, 81, 1, 39, "Input"],
Cell[185387, 6452, 43, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[185467, 6458, 60, 1, 39, "Input"],
Cell[185530, 6461, 43, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[185610, 6467, 76, 1, 40, "Input"],
Cell[185689, 6470, 43, 1, 38, "Output"]
}, Closed]],
Cell[185747, 6474, 116, 3, 30, "Text"],
Cell[185866, 6479, 200, 4, 48, "Text"],
Cell[186069, 6485, 142, 2, 62, "Input"],
Cell[186214, 6489, 340, 9, 48, "Text"],

Cell[CellGroupData[{
Cell[186579, 6502, 67, 1, 41, "Input"],
Cell[186649, 6505, 41, 1, 38, "Output"]
}, Closed]],
Cell[186705, 6509, 223, 5, 49, "Text"],

Cell[CellGroupData[{
Cell[186953, 6518, 92, 1, 41, "Input"],
Cell[187048, 6521, 83, 1, 38, "Output"]
}, Closed]],
Cell[187146, 6525, 126, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[187297, 6532, 86, 1, 41, "Input"],
Cell[187386, 6535, 65, 1, 38, "Output"]
}, Closed]],
Cell[187466, 6539, 106, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[187597, 6546, 64, 1, 41, "Input"],
Cell[187664, 6549, 65, 1, 38, "Output"]
}, Closed]],
Cell[187744, 6553, 232, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[188001, 6561, 102, 2, 62, "Input"],
Cell[188106, 6565, 53, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[188196, 6571, 80, 1, 41, "Input"],
Cell[188279, 6574, 49, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[188377, 6581, 29, 0, 40, "Section"],

Cell[CellGroupData[{
Cell[188431, 6585, 101, 1, 56, "Subsection",
  CellTags->"Hyperlinks"],
Cell[188535, 6588, 1462, 22, 447, "Text"],
Cell[190000, 6612, 122, 3, 33, "Text"],
Cell[190125, 6617, 148, 6, 33, "Text"],
Cell[190276, 6625, 505, 12, 54, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[190818, 6642, 116, 3, 56, "Subsection"],
Cell[190937, 6647, 247, 4, 54, "Text"],
Cell[191187, 6653, 171, 6, 33, "Text"],
Cell[191361, 6661, 176, 4, 55, "Text"],
Cell[191540, 6667, 127, 5, 30, "Text"],
Cell[191670, 6674, 281, 6, 70, "Text"],
Cell[191954, 6682, 177, 7, 142, "Commentary"],
Cell[192134, 6691, 289, 7, 50, "Text"],
Cell[192426, 6700, 198, 7, 142, "Commentary"],
Cell[192627, 6709, 514, 11, 147, "Text"],
Cell[193144, 6722, 171, 6, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[193352, 6733, 93, 2, 44, "Subsection"],
Cell[193448, 6737, 1976, 35, 305, "Text"],
Cell[195427, 6774, 171, 6, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[195635, 6785, 60, 0, 44, "Subsection"],
Cell[195698, 6787, 659, 11, 290, "Text"],
Cell[196360, 6800, 214, 7, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[196611, 6812, 76, 0, 44, "Subsection"],
Cell[196690, 6814, 880, 28, 450, "Text",
  CellTags->"Email"],
Cell[197573, 6844, 217, 5, 37, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[197827, 6854, 32, 0, 44, "Subsection"],
Cell[197862, 6856, 306, 10, 30, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[198217, 6872, 24, 0, 40, "Section"],
Cell[198244, 6874, 384, 8, 54, "Text",
  CellTags->"Inner"],

Cell[CellGroupData[{
Cell[198653, 6886, 120, 2, 59, "Input"],
Cell[198776, 6890, 52, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[198865, 6896, 73, 1, 39, "Input"],
Cell[198941, 6899, 52, 1, 37, "Output"]
}, Closed]],
Cell[199008, 6903, 68, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[199101, 6907, 66, 1, 39, "Input"],
Cell[199170, 6910, 62, 1, 37, "Output"]
}, Closed]],
Cell[199247, 6914, 139, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[199411, 6921, 63, 1, 39, "Input"],
Cell[199477, 6924, 61, 1, 37, "Output"]
}, Closed]],
Cell[199553, 6928, 174, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[199752, 6935, 68, 1, 39, "Input"],
Cell[199823, 6938, 62, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[199922, 6944, 61, 0, 56, "Subsection"],
Cell[199986, 6946, 315, 8, 54, "Text"],
Cell[200304, 6956, 235, 8, 33, "Text"],

Cell[CellGroupData[{
Cell[200564, 6968, 239, 4, 99, "Input"],
Cell[200806, 6974, 38, 1, 38, "Output"]
}, Closed]],
Cell[200859, 6978, 268, 6, 48, "Text"],

Cell[CellGroupData[{
Cell[201152, 6988, 50, 1, 40, "Input"],
Cell[201205, 6991, 206, 3, 80, "Output"]
}, Closed]],
Cell[201426, 6997, 232, 7, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[201695, 7009, 120, 5, 44, "Subsection"],
Cell[201818, 7016, 241, 6, 48, "Text"],

Cell[CellGroupData[{
Cell[202084, 7026, 253, 4, 103, "Input"],
Cell[202340, 7032, 38, 1, 38, "Output"]
}, Closed]],
Cell[202393, 7036, 126, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[202544, 7043, 75, 1, 40, "Input"],
Cell[202622, 7046, 38, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[202721, 7054, 25, 0, 40, "Section"],
Cell[202749, 7056, 85, 1, 33, "Text",
  CellTags->"Insert"],
Cell[202837, 7059, 169, 3, 59, "Input"],
Cell[203009, 7064, 202, 5, 55, "Text"],

Cell[CellGroupData[{
Cell[203236, 7073, 111, 2, 39, "Input"],
Cell[203350, 7077, 123, 2, 37, "Output"]
}, Closed]],
Cell[203488, 7082, 415, 11, 54, "Text"],
Cell[203906, 7095, 301, 7, 54, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[204244, 7107, 24, 0, 40, "Section"],
Cell[204271, 7109, 442, 9, 77, "Text",
  CellTags->"Level"],

Cell[CellGroupData[{
Cell[204738, 7122, 226, 4, 79, "Input"],
Cell[204967, 7128, 66, 1, 37, "Output"]
}, Closed]],
Cell[205048, 7132, 429, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[205502, 7143, 177, 4, 59, "Input"],
Cell[205682, 7149, 66, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[205785, 7155, 34, 0, 56, "Subsection"],
Cell[205822, 7157, 154, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[206001, 7164, 69, 1, 39, "Input"],
Cell[206073, 7167, 93, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[206215, 7174, 55, 0, 56, "Subsection"],
Cell[206273, 7176, 229, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[206527, 7184, 191, 4, 93, "Input"],
Cell[206721, 7190, 131, 2, 66, "Output"]
}, Closed]],
Cell[206867, 7195, 111, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[207003, 7202, 68, 1, 40, "Input"],
Cell[207074, 7205, 87, 1, 65, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[207222, 7213, 38, 0, 40, "Section"],
Cell[207263, 7215, 1124, 22, 117, "Text",
  CellTags->"Level Specification"],

Cell[CellGroupData[{
Cell[208412, 7241, 43, 1, 39, "Input"],
Cell[208458, 7244, 422, 10, 49, "Print",
  CellTags->"Info3242392684-5465879"]
}, Closed]],
Cell[208895, 7257, 175, 4, 93, "Input"],
Cell[209073, 7263, 603, 11, 75, "Text"],

Cell[CellGroupData[{
Cell[209701, 7278, 66, 0, 56, "Subsection"],
Cell[209770, 7280, 263, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[210058, 7289, 47, 1, 39, "Input"],
Cell[210108, 7292, 102, 2, 66, "Output"]
}, Closed]],
Cell[210225, 7297, 117, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[210367, 7304, 47, 1, 39, "Input"],
Cell[210417, 7307, 157, 3, 66, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[210623, 7316, 78, 0, 56, "Subsection"],
Cell[210704, 7318, 247, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[210976, 7326, 49, 1, 39, "Input"],
Cell[211028, 7329, 82, 1, 65, "Output"]
}, Closed]],
Cell[211125, 7333, 185, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[211335, 7341, 50, 1, 40, "Input"],
Cell[211388, 7344, 36, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[211473, 7351, 78, 0, 45, "Subsection"],
Cell[211554, 7353, 298, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[211877, 7362, 52, 1, 40, "Input"],
Cell[211932, 7365, 168, 3, 65, "Output"]
}, Closed]],
Cell[212115, 7371, 153, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[212293, 7378, 52, 1, 40, "Input"],
Cell[212348, 7381, 236, 5, 65, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[212633, 7392, 63, 0, 45, "Subsection"],
Cell[212699, 7394, 254, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[212978, 7402, 83, 1, 50, "Subsubsection"],
Cell[213064, 7405, 264, 5, 50, "Text"],
Cell[213331, 7412, 312, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[213668, 7421, 57, 1, 40, "Input"],
Cell[213728, 7424, 43, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[213808, 7430, 45, 1, 40, "Input"],
Cell[213856, 7433, 84, 1, 50, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[213977, 7439, 54, 1, 40, "Input"],
Cell[214034, 7442, 92, 1, 50, "Output"]
}, Closed]],
Cell[214141, 7446, 153, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[214319, 7453, 54, 1, 40, "Input"],
Cell[214376, 7456, 74, 1, 65, "Output"]
}, Closed]],
Cell[214465, 7460, 279, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[214769, 7469, 55, 1, 40, "Input"],
Cell[214827, 7472, 36, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[214912, 7479, 68, 0, 45, "Subsubsection"],
Cell[214983, 7481, 390, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[215398, 7491, 52, 1, 40, "Input"],
Cell[215453, 7494, 144, 2, 65, "Output"]
}, Closed]],
Cell[215612, 7499, 240, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[215877, 7507, 52, 1, 40, "Input"],
Cell[215932, 7510, 256, 4, 65, "Output"]
}, Closed]],
Cell[216203, 7517, 106, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[216334, 7524, 81, 1, 40, "Input"],
Cell[216418, 7527, 38, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[216505, 7534, 118, 3, 45, "Subsubsection"],
Cell[216626, 7539, 139, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[216790, 7546, 57, 1, 40, "Input"],
Cell[216850, 7549, 180, 3, 65, "Output"]
}, Closed]],
Cell[217045, 7555, 127, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[217197, 7562, 62, 1, 40, "Input"],
Cell[217262, 7565, 80, 1, 55, "Output"]
}, Closed]],
Cell[217357, 7569, 150, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[217532, 7576, 113, 2, 40, "Input"],
Cell[217648, 7580, 38, 1, 35, "Output"]
}, Closed]],
Cell[217701, 7584, 238, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[217964, 7592, 57, 1, 40, "Input"],
Cell[218024, 7595, 36, 1, 35, "Output"]
}, Closed]],
Cell[218075, 7599, 99, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[218199, 7605, 62, 1, 40, "Input"],
Cell[218264, 7608, 139, 2, 55, "Output"]
}, Closed]]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[218476, 7618, 31, 0, 40, "Section"],
Cell[218510, 7620, 101, 1, 33, "Text",
  CellTags->"ListConvolve"],

Cell[CellGroupData[{
Cell[218636, 7625, 242, 4, 99, "Input"],
Cell[218881, 7631, 146, 2, 37, "Output"]
}, Closed]],
Cell[219042, 7636, 123, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[219190, 7643, 567, 16, 162, "Input"],
Cell[219760, 7661, 38, 1, 37, "Output"]
}, Closed]],
Cell[219813, 7665, 98, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[219936, 7671, 245, 4, 79, "Input"],
Cell[220184, 7677, 38, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[220259, 7683, 132, 4, 56, "Subsection"],
Cell[220394, 7689, 93, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[220512, 7695, 116, 2, 39, "Input"],
Cell[220631, 7699, 265, 4, 57, "Output"]
}, Closed]],
Cell[220911, 7706, 438, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[221374, 7717, 746, 20, 162, "Input"],
Cell[222123, 7739, 38, 1, 35, "Output"]
}, Closed]],
Cell[222176, 7743, 124, 3, 40, "Text"],

Cell[CellGroupData[{
Cell[222325, 7750, 106, 2, 40, "Input"],
Cell[222434, 7754, 265, 4, 57, "Output"]
}, Closed]],
Cell[222714, 7761, 425, 7, 65, "Text"],

Cell[CellGroupData[{
Cell[223164, 7772, 736, 20, 162, "Input"],
Cell[223903, 7794, 38, 1, 35, "Output"]
}, Closed]],
Cell[223956, 7798, 125, 3, 40, "Text"],

Cell[CellGroupData[{
Cell[224106, 7805, 111, 2, 40, "Input"],
Cell[224220, 7809, 377, 5, 77, "Output"]
}, Closed]],
Cell[224612, 7817, 418, 7, 65, "Text"],

Cell[CellGroupData[{
Cell[225055, 7828, 891, 23, 227, "Input"],
Cell[225949, 7853, 38, 1, 35, "Output"]
}, Closed]],
Cell[226002, 7857, 268, 6, 60, "Text"],

Cell[CellGroupData[{
Cell[226295, 7867, 111, 2, 40, "Input"],
Cell[226409, 7871, 146, 2, 35, "Output"]
}, Closed]],
Cell[226570, 7876, 418, 7, 65, "Text"],

Cell[CellGroupData[{
Cell[227013, 7887, 591, 17, 162, "Input"],
Cell[227607, 7906, 38, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[227694, 7913, 44, 0, 45, "Subsection"],
Cell[227741, 7915, 137, 5, 30, "Text"],

Cell[CellGroupData[{
Cell[227903, 7924, 112, 2, 40, "Input"],
Cell[228018, 7928, 365, 5, 77, "Output"]
}, Closed]],
Cell[228398, 7936, 331, 6, 47, "Text"],

Cell[CellGroupData[{
Cell[228754, 7946, 976, 14, 277, "Input"],
Cell[229733, 7962, 38, 1, 35, "Output"]
}, Closed]],
Cell[229786, 7966, 191, 6, 40, "Text"],

Cell[CellGroupData[{
Cell[230002, 7976, 137, 2, 40, "Input"],
Cell[230142, 7980, 377, 5, 77, "Output"]
}, Closed]],
Cell[230534, 7988, 331, 7, 47, "Text"],

Cell[CellGroupData[{
Cell[230890, 7999, 990, 14, 277, "Input"],
Cell[231883, 8015, 38, 1, 35, "Output"]
}, Closed]],
Cell[231936, 8019, 228, 7, 40, "Text"],

Cell[CellGroupData[{
Cell[232189, 8030, 121, 2, 40, "Input"],
Cell[232313, 8034, 377, 5, 77, "Output"]
}, Closed]],
Cell[232705, 8042, 124, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[232854, 8049, 974, 14, 277, "Input"],
Cell[233831, 8065, 38, 1, 35, "Output"]
}, Closed]],
Cell[233884, 8069, 294, 9, 40, "Text"],

Cell[CellGroupData[{
Cell[234203, 8082, 210, 4, 60, "Input"],
Cell[234416, 8088, 38, 1, 35, "Output"]
}, Closed]],
Cell[234469, 8092, 245, 7, 40, "Text"],

Cell[CellGroupData[{
Cell[234739, 8103, 254, 4, 60, "Input"],
Cell[234996, 8109, 38, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[235083, 8116, 53, 0, 45, "Subsection"],
Cell[235139, 8118, 193, 5, 30, "Text"],

Cell[CellGroupData[{
Cell[235357, 8127, 117, 2, 40, "Input"],
Cell[235477, 8131, 189, 3, 57, "Output"]
}, Closed]],
Cell[235681, 8137, 306, 9, 47, "Text"],

Cell[CellGroupData[{
Cell[236012, 8150, 120, 2, 40, "Input"],
Cell[236135, 8154, 189, 3, 57, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[236373, 8163, 48, 0, 45, "Subsection"],
Cell[236424, 8165, 74, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[236523, 8169, 474, 14, 162, "Input"],
Cell[237000, 8185, 127, 2, 35, "Output"]
}, Closed]],
Cell[237142, 8190, 128, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[237295, 8197, 224, 4, 82, "Input"],
Cell[237522, 8203, 38, 1, 27, "Output"]
}, Closed]],
Cell[237575, 8207, 279, 7, 40, "Text"],

Cell[CellGroupData[{
Cell[237879, 8218, 139, 2, 45, "Input"],
Cell[238021, 8222, 38, 1, 27, "Output"]
}, Closed]],
Cell[238074, 8226, 138, 4, 40, "Text"],

Cell[CellGroupData[{
Cell[238237, 8234, 86, 1, 27, "Input"],
Cell[238326, 8237, 123, 2, 35, "Output"]
}, Closed]],
Cell[238464, 8242, 128, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[238617, 8249, 381, 7, 147, "Input"],
Cell[239001, 8258, 38, 1, 35, "Output"]
}, Closed]],
Cell[239054, 8262, 180, 4, 40, "Text"],

Cell[CellGroupData[{
Cell[239259, 8270, 151, 2, 40, "Input"],
Cell[239413, 8274, 38, 1, 35, "Output"]
}, Closed]],
Cell[239466, 8278, 401, 7, 75, "Text"],
Cell[239870, 8287, 61, 1, 40, "Input"],
Cell[239934, 8290, 81, 1, 40, "Input"],
Cell[240018, 8293, 81, 1, 40, "Input"],
Cell[240102, 8296, 147, 3, 30, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[240298, 8305, 32, 0, 40, "Section"],
Cell[240333, 8307, 103, 1, 33, "Text",
  CellTags->"ListCorrelate"],

Cell[CellGroupData[{
Cell[240461, 8312, 232, 4, 99, "Input"],
Cell[240696, 8318, 146, 2, 37, "Output"]
}, Closed]],
Cell[240857, 8323, 124, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[241006, 8330, 568, 16, 162, "Input"],
Cell[241577, 8348, 38, 1, 37, "Output"]
}, Closed]],
Cell[241630, 8352, 98, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[241753, 8358, 245, 4, 79, "Input"],
Cell[242001, 8364, 38, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[242076, 8370, 132, 4, 56, "Subsection"],
Cell[242211, 8376, 94, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[242330, 8382, 117, 2, 39, "Input"],
Cell[242450, 8386, 265, 4, 57, "Output"]
}, Closed]],
Cell[242730, 8393, 438, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[243193, 8404, 747, 20, 162, "Input"],
Cell[243943, 8426, 38, 1, 35, "Output"]
}, Closed]],
Cell[243996, 8430, 125, 3, 40, "Text"],

Cell[CellGroupData[{
Cell[244146, 8437, 107, 2, 40, "Input"],
Cell[244256, 8441, 265, 4, 57, "Output"]
}, Closed]],
Cell[244536, 8448, 425, 7, 65, "Text"],

Cell[CellGroupData[{
Cell[244986, 8459, 737, 20, 162, "Input"],
Cell[245726, 8481, 38, 1, 35, "Output"]
}, Closed]],
Cell[245779, 8485, 126, 3, 40, "Text"],

Cell[CellGroupData[{
Cell[245930, 8492, 112, 2, 40, "Input"],
Cell[246045, 8496, 146, 2, 35, "Output"]
}, Closed]],
Cell[246206, 8501, 418, 7, 65, "Text"],

Cell[CellGroupData[{
Cell[246649, 8512, 892, 23, 227, "Input"],
Cell[247544, 8537, 39, 1, 27, "Output"]
}, Closed]],
Cell[247598, 8541, 270, 6, 57, "Text"],

Cell[CellGroupData[{
Cell[247893, 8551, 112, 2, 27, "Input"],
Cell[248008, 8555, 377, 5, 45, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[248422, 8565, 42, 1, 27, "Input"],
Cell[248467, 8568, 35, 1, 27, "Output"]
}, Closed]],
Cell[248517, 8572, 418, 7, 47, "Text"],

Cell[CellGroupData[{
Cell[248960, 8583, 892, 23, 175, "Input"],
Cell[249855, 8608, 38, 1, 27, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[249942, 8615, 44, 0, 45, "Subsection"],
Cell[249989, 8617, 137, 5, 30, "Text"],

Cell[CellGroupData[{
Cell[250151, 8626, 113, 2, 40, "Input"],
Cell[250267, 8630, 365, 5, 77, "Output"]
}, Closed]],
Cell[250647, 8638, 332, 6, 47, "Text"],

Cell[CellGroupData[{
Cell[251004, 8648, 1026, 15, 277, "Input"],
Cell[252033, 8665, 38, 1, 27, "Output"]
}, Closed]],
Cell[252086, 8669, 190, 6, 40, "Text"],

Cell[CellGroupData[{
Cell[252301, 8679, 152, 3, 27, "Input"],
Cell[252456, 8684, 377, 5, 45, "Output"]
}, Closed]],
Cell[252848, 8692, 331, 7, 47, "Text"],

Cell[CellGroupData[{
Cell[253204, 8703, 1053, 15, 220, "Input"],
Cell[254260, 8720, 38, 1, 27, "Output"]
}, Closed]],
Cell[254313, 8724, 239, 8, 40, "Text"],

Cell[CellGroupData[{
Cell[254577, 8736, 122, 2, 27, "Input"],
Cell[254702, 8740, 377, 5, 45, "Output"]
}, Closed]],
Cell[255094, 8748, 124, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[255243, 8755, 1037, 15, 220, "Input"],
Cell[256283, 8772, 38, 1, 27, "Output"]
}, Closed]],
Cell[256336, 8776, 294, 9, 40, "Text"],

Cell[CellGroupData[{
Cell[256655, 8789, 212, 4, 45, "Input"],
Cell[256870, 8795, 38, 1, 27, "Output"]
}, Closed]],
Cell[256923, 8799, 256, 8, 40, "Text"],

Cell[CellGroupData[{
Cell[257204, 8811, 256, 4, 45, "Input"],
Cell[257463, 8817, 38, 1, 27, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[257550, 8824, 53, 0, 45, "Subsection"],
Cell[257606, 8826, 193, 5, 30, "Text"],

Cell[CellGroupData[{
Cell[257824, 8835, 118, 2, 40, "Input"],
Cell[257945, 8839, 189, 3, 57, "Output"]
}, Closed]],
Cell[258149, 8845, 319, 11, 47, "Text"],

Cell[CellGroupData[{
Cell[258493, 8860, 121, 2, 40, "Input"],
Cell[258617, 8864, 189, 3, 57, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[258855, 8873, 49, 0, 45, "Subsection"],
Cell[258907, 8875, 72, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[259004, 8879, 475, 14, 162, "Input"],
Cell[259482, 8895, 127, 2, 35, "Output"]
}, Closed]],
Cell[259624, 8900, 126, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[259775, 8907, 166, 3, 60, "Input"],
Cell[259944, 8912, 38, 1, 27, "Output"]
}, Closed]],
Cell[259997, 8916, 292, 9, 40, "Text"],

Cell[CellGroupData[{
Cell[260314, 8929, 141, 2, 45, "Input"],
Cell[260458, 8933, 38, 1, 27, "Output"]
}, Closed]],
Cell[260511, 8937, 139, 4, 40, "Text"],

Cell[CellGroupData[{
Cell[260675, 8945, 87, 1, 27, "Input"],
Cell[260765, 8948, 123, 2, 27, "Output"]
}, Closed]],
Cell[260903, 8953, 126, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[261054, 8960, 320, 6, 97, "Input"],
Cell[261377, 8968, 38, 1, 27, "Output"]
}, Closed]],
Cell[261430, 8972, 181, 4, 40, "Text"],

Cell[CellGroupData[{
Cell[261636, 8980, 154, 2, 27, "Input"],
Cell[261793, 8984, 38, 1, 27, "Output"]
}, Closed]],
Cell[261846, 8988, 402, 7, 57, "Text"],
Cell[262251, 8997, 62, 1, 27, "Input"],
Cell[262316, 9000, 82, 1, 27, "Input"],
Cell[262401, 9003, 87, 1, 27, "Input"],
Cell[262491, 9006, 145, 3, 30, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[262685, 9015, 22, 0, 40, "Section"],
Cell[262710, 9017, 542, 12, 75, "Text",
  CellTags->"Map"],

Cell[CellGroupData[{
Cell[263277, 9033, 197, 4, 116, "Input"],
Cell[263477, 9039, 138, 2, 49, "Output"]
}, Closed]],
Cell[263630, 9044, 189, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[263844, 9052, 67, 1, 39, "Input"],
Cell[263914, 9055, 138, 2, 49, "Output"]
}, Closed]],
Cell[264067, 9060, 572, 10, 119, "Text"],

Cell[CellGroupData[{
Cell[264664, 9074, 62, 1, 39, "Input"],
Cell[264729, 9077, 150, 2, 55, "Output"]
}, Closed]],
Cell[264894, 9082, 429, 9, 76, "Text"],

Cell[CellGroupData[{
Cell[265348, 9095, 71, 1, 39, "Input"],
Cell[265422, 9098, 148, 2, 55, "Output"]
}, Closed]],
Cell[265585, 9103, 184, 5, 55, "Text"],

Cell[CellGroupData[{
Cell[265794, 9112, 53, 1, 52, "Input"],
Cell[265850, 9115, 115, 2, 65, "Output"]
}, Closed]],
Cell[265980, 9120, 113, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[266118, 9128, 61, 1, 40, "Input"],
Cell[266182, 9131, 158, 2, 50, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[266377, 9138, 34, 0, 55, "Subsection"],
Cell[266414, 9140, 603, 9, 85, "Text"],

Cell[CellGroupData[{
Cell[267042, 9153, 188, 3, 80, "Input"],
Cell[267233, 9158, 57, 1, 35, "Output"]
}, Closed]],
Cell[267305, 9162, 384, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[267714, 9172, 70, 1, 40, "Input"],
Cell[267787, 9175, 75, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[267923, 9183, 24, 0, 40, "Section"],
Cell[267950, 9185, 143, 4, 33, "Text",
  CellTags->"MapAt"],

Cell[CellGroupData[{
Cell[268118, 9193, 131, 2, 59, "Input"],
Cell[268252, 9197, 57, 1, 37, "Output"]
}, Closed]],
Cell[268324, 9201, 64, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[268413, 9205, 75, 1, 39, "Input"],
Cell[268491, 9208, 62, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[268602, 9215, 29, 0, 40, "Section"],
Cell[268634, 9217, 278, 5, 54, "Text",
  CellTags->"MapIndexed"],

Cell[CellGroupData[{
Cell[268937, 9226, 174, 3, 79, "Input"],
Cell[269114, 9231, 524, 19, 134, "Output"]
}, Closed]],
Cell[269653, 9253, 601, 12, 97, "Text"],

Cell[CellGroupData[{
Cell[270279, 9269, 88, 1, 39, "Input"],
Cell[270370, 9272, 500, 19, 134, "Output"]
}, Closed]],
Cell[270885, 9294, 104, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[271014, 9301, 83, 1, 39, "Input"],
Cell[271100, 9304, 469, 14, 134, "Output"]
}, Closed]],
Cell[271584, 9321, 130, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[271739, 9328, 85, 1, 40, "Input"],
Cell[271827, 9331, 457, 14, 122, "Output"]
}, Closed]],
Cell[272299, 9348, 230, 6, 30, "Text"],

Cell[CellGroupData[{
Cell[272554, 9358, 71, 1, 40, "Input"],
Cell[272628, 9361, 111, 2, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[272776, 9368, 111, 2, 40, "Input"],
Cell[272890, 9372, 133, 2, 35, "Output"]
}, Closed]],
Cell[273038, 9377, 379, 8, 50, "Text"],

Cell[CellGroupData[{
Cell[273442, 9389, 34, 0, 55, "Subsection"],
Cell[273479, 9391, 212, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[273716, 9399, 79, 1, 40, "Input"],
Cell[273798, 9402, 91, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[273950, 9410, 28, 0, 40, "Section"],
Cell[273981, 9412, 251, 6, 33, "Text",
  CellTags->"MapThread"],

Cell[CellGroupData[{
Cell[274257, 9422, 185, 3, 79, "Input"],
Cell[274445, 9427, 107, 2, 37, "Output"]
}, Closed]],
Cell[274567, 9432, 189, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[274781, 9440, 83, 1, 39, "Input"],
Cell[274867, 9443, 38, 1, 37, "Output"]
}, Closed]],
Cell[274920, 9447, 93, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[275038, 9453, 402, 7, 219, "Input"],
Cell[275443, 9462, 43, 1, 37, "Output"]
}, Closed]],
Cell[275501, 9466, 71, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[275597, 9470, 95, 2, 59, "Input"],
Cell[275695, 9474, 124, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[275856, 9481, 44, 1, 39, "Input"],
Cell[275903, 9484, 124, 2, 37, "Output"]
}, Closed]],
Cell[276042, 9489, 171, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[276238, 9496, 98, 2, 60, "Input"],
Cell[276339, 9500, 133, 2, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[276509, 9507, 44, 1, 40, "Input"],
Cell[276556, 9510, 133, 2, 35, "Output"]
}, Closed]],
Cell[276704, 9515, 312, 8, 70, "Text"],

Cell[CellGroupData[{
Cell[277041, 9527, 174, 3, 80, "Input"],
Cell[277218, 9532, 64, 1, 35, "Output"]
}, Closed]],
Cell[277297, 9536, 128, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[277450, 9543, 55, 1, 40, "Input"],
Cell[277508, 9546, 159, 2, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[277704, 9553, 155, 2, 60, "Input"],
Cell[277862, 9557, 286, 4, 57, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[278197, 9567, 28, 0, 40, "Section"],
Cell[278228, 9569, 410, 8, 54, "Text",
  CellTags->"MakeBoxes"],
Cell[278641, 9579, 1636, 26, 311, "Text"],
Cell[280280, 9607, 246, 4, 79, "Input"],
Cell[280529, 9613, 130, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[280684, 9620, 127, 2, 59, "Input"],
Cell[280814, 9624, 97, 2, 69, "Output"]
}, Closed]],
Cell[280926, 9629, 67, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[281018, 9633, 56, 1, 39, "Input"],
Cell[281077, 9636, 273, 5, 57, "Output"]
}, Closed]],
Cell[281365, 9644, 131, 3, 33, "Text"],
Cell[281499, 9649, 1033, 19, 274, "Text"],

Cell[CellGroupData[{
Cell[282557, 9672, 37, 0, 55, "Subsection"],
Cell[282597, 9674, 106, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[282728, 9681, 68, 1, 57, "Input"],
Cell[282799, 9684, 66, 1, 50, "Output"]
}, Closed]],
Cell[282880, 9688, 319, 5, 47, "Text"],
Cell[283202, 9695, 526, 10, 147, "Input"],
Cell[283731, 9707, 61, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[283817, 9711, 118, 2, 57, "Input"],
Cell[283938, 9715, 121, 2, 50, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[284120, 9724, 25, 0, 40, "Section"],
Cell[284148, 9726, 474, 8, 75, "Text",
  CellTags->"MatchQ"],

Cell[CellGroupData[{
Cell[284647, 9738, 99, 2, 39, "Input",
  CellTags->"MatchQ"],
Cell[284749, 9742, 47, 1, 37, "Output"]
}, Closed]],
Cell[284811, 9746, 187, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[285023, 9756, 174, 3, 119, "Input"],
Cell[285200, 9761, 60, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[285297, 9767, 118, 2, 79, "Input"],
Cell[285418, 9771, 54, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[285509, 9777, 154, 3, 59, "Input"],
Cell[285666, 9782, 54, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[285757, 9788, 327, 6, 139, "Input"],
Cell[286087, 9796, 74, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[286198, 9802, 90, 1, 39, "Input"],
Cell[286291, 9805, 47, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[286375, 9811, 371, 6, 188, "Input"],
Cell[286749, 9819, 87, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[286873, 9825, 130, 2, 61, "Input"],
Cell[287006, 9829, 38, 1, 38, "Output"]
}, Closed]],
Cell[287059, 9833, 295, 7, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[287391, 9845, 26, 0, 40, "Section"],
Cell[287420, 9847, 138, 4, 33, "Text",
  CellTags->"MemberQ"],

Cell[CellGroupData[{
Cell[287583, 9855, 126, 2, 59, "Input"],
Cell[287712, 9859, 38, 1, 37, "Output"]
}, Closed]],
Cell[287765, 9863, 191, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[287981, 9871, 66, 1, 40, "Input"],
Cell[288050, 9874, 39, 1, 37, "Output"]
}, Closed]],
Cell[288104, 9878, 252, 7, 33, "Text"],

Cell[CellGroupData[{
Cell[288381, 9889, 79, 1, 40, "Input"],
Cell[288463, 9892, 38, 1, 37, "Output"]
}, Closed]],
Cell[288516, 9896, 180, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[288721, 9906, 79, 1, 40, "Input"],
Cell[288803, 9909, 39, 1, 37, "Output"]
}, Closed]],
Cell[288857, 9913, 175, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[289057, 9923, 92, 1, 40, "Input"],
Cell[289152, 9926, 38, 1, 37, "Output"]
}, Closed]],
Cell[289205, 9930, 296, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[289526, 9941, 34, 0, 56, "Subsection"],
Cell[289563, 9943, 173, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[289761, 9950, 60, 1, 40, "Input"],
Cell[289824, 9953, 39, 1, 38, "Output"]
}, Closed]],
Cell[289878, 9957, 136, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[290039, 9964, 80, 1, 41, "Input"],
Cell[290122, 9967, 38, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[290221, 9975, 26, 0, 40, "Section"],
Cell[290250, 9977, 693, 13, 98, "Text",
  CellTags->"Message"],

Cell[CellGroupData[{
Cell[290968, 9994, 106, 2, 70, "Input"],
Cell[291077, 9998, 38, 1, 40, "Output"]
}, Closed]],
Cell[291130, 10002, 226, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[291381, 10012, 50, 1, 39, "Input"],
Cell[291434, 10015, 50, 1, 52, "Output"]
}, Closed]],
Cell[291499, 10019, 174, 3, 33, "Text"],
Cell[291676, 10024, 127, 2, 39, "Input"],
Cell[291806, 10028, 543, 8, 75, "Text"],
Cell[292352, 10038, 105, 2, 39, "Input"],
Cell[292460, 10042, 453, 11, 58, "Text"],

Cell[CellGroupData[{
Cell[292938, 10057, 62, 1, 63, "Input"],
Cell[293003, 10060, 56, 1, 37, "Output"]
}, Closed]],
Cell[293074, 10064, 489, 9, 54, "Text"],

Cell[CellGroupData[{
Cell[293588, 10077, 46, 0, 56, "Subsection"],
Cell[293637, 10079, 300, 5, 54, "Text"],
Cell[293940, 10086, 1474, 30, 385, "Input"],
Cell[295417, 10118, 88, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[295530, 10124, 136, 2, 60, "Input"],
Cell[295669, 10128, 41, 1, 35, "Output"],
Cell[295713, 10131, 41, 1, 35, "Output"]
}, Closed]],
Cell[295769, 10135, 163, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[295957, 10142, 87, 1, 40, "Input"],
Cell[296047, 10145, 88, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[296172, 10151, 93, 1, 40, "Input"],
Cell[296268, 10154, 101, 2, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[296418, 10162, 38, 0, 44, "Subsection"],
Cell[296459, 10164, 1584, 42, 175, "Text"],
Cell[298046, 10208, 150, 2, 82, "Input"],
Cell[298199, 10212, 147, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[298371, 10219, 48, 1, 40, "Input"],
Cell[298422, 10222, 138, 3, 27, "Message"],
Cell[298563, 10227, 49, 1, 38, "Output"]
}, Closed]],
Cell[298627, 10231, 240, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[298892, 10239, 44, 0, 52, "Subsubsection"],
Cell[298939, 10241, 102, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[299066, 10248, 63, 1, 40, "Input"],
Cell[299132, 10251, 112, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[299281, 10258, 68, 1, 40, "Input"],
Cell[299352, 10261, 121, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[299510, 10268, 68, 1, 40, "Input"],
Cell[299581, 10271, 156, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[299774, 10279, 67, 1, 40, "Input"],
Cell[299844, 10282, 147, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[300028, 10290, 67, 1, 40, "Input"],
Cell[300098, 10293, 146, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[300281, 10301, 74, 1, 40, "Input"],
Cell[300358, 10304, 171, 3, 46, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[300566, 10312, 73, 1, 40, "Input"],
Cell[300642, 10315, 166, 3, 46, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[300845, 10323, 73, 1, 40, "Input"],
Cell[300921, 10326, 165, 3, 46, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[301123, 10334, 74, 1, 40, "Input"],
Cell[301200, 10337, 158, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[301395, 10345, 74, 1, 40, "Input"],
Cell[301472, 10348, 162, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[301671, 10356, 79, 1, 40, "Input"],
Cell[301753, 10359, 180, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[301970, 10367, 79, 1, 40, "Input"],
Cell[302052, 10370, 171, 3, 27, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[302272, 10379, 42, 0, 45, "Subsubsection"],
Cell[302317, 10381, 95, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[302437, 10387, 62, 1, 40, "Input"],
Cell[302502, 10390, 152, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[302691, 10398, 64, 1, 40, "Input"],
Cell[302758, 10401, 130, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[302925, 10408, 67, 1, 40, "Input"],
Cell[302995, 10411, 138, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[303170, 10419, 67, 1, 40, "Input"],
Cell[303240, 10422, 154, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[303431, 10430, 68, 1, 40, "Input"],
Cell[303502, 10433, 175, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[303714, 10441, 68, 1, 40, "Input"],
Cell[303785, 10444, 188, 3, 50, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[304010, 10452, 68, 1, 40, "Input"],
Cell[304081, 10455, 184, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[304302, 10463, 67, 1, 40, "Input"],
Cell[304372, 10466, 157, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[304566, 10474, 66, 1, 40, "Input"],
Cell[304635, 10477, 129, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[304801, 10484, 67, 1, 40, "Input"],
Cell[304871, 10487, 145, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[305053, 10495, 68, 1, 40, "Input"],
Cell[305124, 10498, 159, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[305320, 10506, 68, 1, 40, "Input"],
Cell[305391, 10509, 142, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[305570, 10517, 68, 1, 40, "Input"],
Cell[305641, 10520, 155, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[305833, 10528, 67, 1, 40, "Input"],
Cell[305903, 10531, 153, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[306093, 10539, 67, 1, 40, "Input"],
Cell[306163, 10542, 127, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[306327, 10549, 69, 1, 40, "Input"],
Cell[306399, 10552, 147, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[306583, 10560, 67, 1, 40, "Input"],
Cell[306653, 10563, 190, 3, 50, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[306880, 10571, 68, 1, 40, "Input"],
Cell[306951, 10574, 180, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[307168, 10582, 69, 1, 40, "Input"],
Cell[307240, 10585, 131, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[307408, 10592, 67, 1, 40, "Input"],
Cell[307478, 10595, 160, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[307675, 10603, 68, 1, 40, "Input"],
Cell[307746, 10606, 151, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[307934, 10614, 66, 1, 40, "Input"],
Cell[308003, 10617, 147, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[308187, 10625, 67, 1, 40, "Input"],
Cell[308257, 10628, 156, 3, 27, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[308462, 10637, 32, 0, 45, "Subsubsection"],
Cell[308497, 10639, 88, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[308610, 10645, 61, 1, 40, "Input"],
Cell[308674, 10648, 147, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[308858, 10656, 68, 1, 40, "Input"],
Cell[308929, 10659, 146, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[309112, 10667, 67, 1, 40, "Input"],
Cell[309182, 10670, 152, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[309371, 10678, 68, 1, 40, "Input"],
Cell[309442, 10681, 165, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[309644, 10689, 68, 1, 40, "Input"],
Cell[309715, 10692, 166, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[309918, 10700, 68, 1, 40, "Input"],
Cell[309989, 10703, 161, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[310187, 10711, 68, 1, 40, "Input"],
Cell[310258, 10714, 154, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[310449, 10722, 67, 1, 40, "Input"],
Cell[310519, 10725, 140, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[310696, 10733, 67, 1, 40, "Input"],
Cell[310766, 10736, 152, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[310955, 10744, 66, 1, 40, "Input"],
Cell[311024, 10747, 146, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[311207, 10755, 68, 1, 40, "Input"],
Cell[311278, 10758, 120, 2, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[311435, 10765, 68, 1, 40, "Input"],
Cell[311506, 10768, 160, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[311703, 10776, 68, 1, 40, "Input"],
Cell[311774, 10779, 152, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[311963, 10787, 68, 1, 40, "Input"],
Cell[312034, 10790, 144, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[312215, 10798, 69, 1, 40, "Input"],
Cell[312287, 10801, 157, 3, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[312481, 10809, 67, 1, 40, "Input"],
Cell[312551, 10812, 116, 2, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[312704, 10819, 66, 1, 40, "Input"],
Cell[312773, 10822, 125, 2, 30, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[312935, 10829, 75, 1, 40, "Input"],
Cell[313013, 10832, 207, 3, 30, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[313269, 10841, 33, 0, 45, "Subsubsection"],
Cell[313305, 10843, 90, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[313420, 10849, 54, 1, 40, "Input"],
Cell[313477, 10852, 115, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[313629, 10859, 57, 1, 40, "Input"],
Cell[313689, 10862, 123, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[313849, 10869, 61, 1, 40, "Input"],
Cell[313913, 10872, 106, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[314056, 10879, 66, 1, 40, "Input"],
Cell[314125, 10882, 179, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[314341, 10890, 69, 1, 40, "Input"],
Cell[314413, 10893, 151, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[314601, 10901, 68, 1, 40, "Input"],
Cell[314672, 10904, 145, 3, 27, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[314866, 10913, 34, 0, 45, "Subsubsection"],
Cell[314903, 10915, 91, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[315019, 10921, 56, 1, 40, "Input"],
Cell[315078, 10924, 123, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[315238, 10931, 62, 1, 40, "Input"],
Cell[315303, 10934, 129, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[315469, 10941, 62, 1, 40, "Input"],
Cell[315534, 10944, 153, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[315724, 10952, 69, 1, 40, "Input"],
Cell[315796, 10955, 170, 3, 27, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[316015, 10964, 48, 0, 45, "Subsubsection"],
Cell[316066, 10966, 110, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[316201, 10973, 56, 1, 40, "Input"],
Cell[316260, 10976, 111, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[316408, 10983, 62, 1, 40, "Input"],
Cell[316473, 10986, 130, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[316640, 10993, 61, 1, 40, "Input"],
Cell[316704, 10996, 150, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[316891, 11004, 62, 1, 40, "Input"],
Cell[316956, 11007, 131, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[317124, 11014, 62, 1, 40, "Input"],
Cell[317189, 11017, 114, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[317340, 11024, 62, 1, 40, "Input"],
Cell[317405, 11027, 112, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[317554, 11034, 62, 1, 40, "Input"],
Cell[317619, 11037, 115, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[317771, 11044, 62, 1, 40, "Input"],
Cell[317836, 11047, 110, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[317983, 11054, 63, 1, 40, "Input"],
Cell[318049, 11057, 101, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[318187, 11064, 62, 1, 40, "Input"],
Cell[318252, 11067, 106, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[318395, 11074, 62, 1, 40, "Input"],
Cell[318460, 11077, 107, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[318604, 11084, 62, 1, 40, "Input"],
Cell[318669, 11087, 93, 1, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[318799, 11093, 68, 1, 40, "Input"],
Cell[318870, 11096, 115, 2, 27, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[319034, 11104, 36, 0, 45, "Subsubsection"],
Cell[319073, 11106, 99, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[319197, 11112, 56, 1, 40, "Input"],
Cell[319256, 11115, 137, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[319430, 11123, 61, 1, 40, "Input"],
Cell[319494, 11126, 156, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[319687, 11134, 63, 1, 40, "Input"],
Cell[319753, 11137, 116, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[319906, 11144, 61, 1, 40, "Input"],
Cell[319970, 11147, 132, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[320139, 11154, 62, 1, 40, "Input"],
Cell[320204, 11157, 144, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[320385, 11165, 63, 1, 40, "Input"],
Cell[320451, 11168, 154, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[320642, 11176, 61, 1, 40, "Input"],
Cell[320706, 11179, 107, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[320850, 11186, 62, 1, 40, "Input"],
Cell[320915, 11189, 132, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[321084, 11196, 67, 1, 40, "Input"],
Cell[321154, 11199, 118, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[321309, 11206, 66, 1, 40, "Input"],
Cell[321378, 11209, 156, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[321571, 11217, 67, 1, 40, "Input"],
Cell[321641, 11220, 210, 3, 50, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[321888, 11228, 68, 1, 40, "Input"],
Cell[321959, 11231, 217, 4, 50, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[322225, 11241, 33, 0, 45, "Subsubsection"],
Cell[322261, 11243, 96, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[322382, 11249, 57, 1, 40, "Input"],
Cell[322442, 11252, 140, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[322619, 11260, 62, 1, 40, "Input"],
Cell[322684, 11263, 139, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[322860, 11271, 62, 1, 40, "Input"],
Cell[322925, 11274, 148, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[323110, 11282, 69, 1, 40, "Input"],
Cell[323182, 11285, 199, 3, 50, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[323418, 11293, 70, 1, 40, "Input"],
Cell[323491, 11296, 199, 3, 50, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[323727, 11304, 68, 1, 40, "Input"],
Cell[323798, 11307, 161, 3, 27, "Message"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[324008, 11316, 38, 0, 45, "Subsubsection"],
Cell[324049, 11318, 95, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[324169, 11324, 103, 2, 40, "Input"],
Cell[324275, 11328, 138, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[324450, 11336, 56, 1, 40, "Input"],
Cell[324509, 11339, 106, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[324652, 11346, 55, 1, 40, "Input"],
Cell[324710, 11349, 86, 1, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[324833, 11355, 54, 1, 40, "Input"],
Cell[324890, 11358, 127, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[325054, 11365, 55, 1, 40, "Input"],
Cell[325112, 11368, 109, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[325258, 11375, 58, 1, 40, "Input"],
Cell[325319, 11378, 88, 1, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[325444, 11384, 63, 1, 40, "Input"],
Cell[325510, 11387, 116, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[325663, 11394, 62, 1, 40, "Input"],
Cell[325728, 11397, 103, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[325868, 11404, 62, 1, 40, "Input"],
Cell[325933, 11407, 119, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[326089, 11414, 61, 1, 40, "Input"],
Cell[326153, 11417, 156, 3, 46, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[326346, 11425, 62, 1, 40, "Input"],
Cell[326411, 11428, 125, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[326573, 11435, 61, 1, 40, "Input"],
Cell[326637, 11438, 111, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[326785, 11445, 62, 1, 40, "Input"],
Cell[326850, 11448, 147, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[327034, 11456, 61, 1, 40, "Input"],
Cell[327098, 11459, 114, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[327249, 11466, 63, 1, 40, "Input"],
Cell[327315, 11469, 120, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[327472, 11476, 65, 1, 40, "Input"],
Cell[327540, 11479, 108, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[327685, 11486, 64, 1, 40, "Input"],
Cell[327752, 11489, 130, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[327919, 11496, 63, 1, 40, "Input"],
Cell[327985, 11499, 138, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[328160, 11507, 62, 1, 40, "Input"],
Cell[328225, 11510, 119, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[328381, 11517, 62, 1, 40, "Input"],
Cell[328446, 11520, 125, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[328608, 11527, 65, 1, 40, "Input"],
Cell[328676, 11530, 116, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[328829, 11537, 60, 1, 40, "Input"],
Cell[328892, 11540, 118, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[329047, 11547, 61, 1, 40, "Input"],
Cell[329111, 11550, 150, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[329298, 11558, 63, 1, 40, "Input"],
Cell[329364, 11561, 116, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[329517, 11568, 63, 1, 40, "Input"],
Cell[329583, 11571, 103, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[329723, 11578, 67, 1, 40, "Input"],
Cell[329793, 11581, 126, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[329956, 11588, 68, 1, 40, "Input"],
Cell[330027, 11591, 121, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[330185, 11598, 66, 1, 40, "Input"],
Cell[330254, 11601, 125, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[330416, 11608, 67, 1, 40, "Input"],
Cell[330486, 11611, 152, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[330675, 11619, 68, 1, 40, "Input"],
Cell[330746, 11622, 174, 3, 46, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[330957, 11630, 70, 1, 40, "Input"],
Cell[331030, 11633, 139, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[331206, 11641, 68, 1, 40, "Input"],
Cell[331277, 11644, 103, 2, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[331417, 11651, 75, 1, 40, "Input"],
Cell[331495, 11654, 140, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[331672, 11662, 72, 1, 40, "Input"],
Cell[331747, 11665, 146, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[331930, 11673, 81, 1, 40, "Input"],
Cell[332014, 11676, 160, 3, 27, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[332211, 11684, 80, 1, 40, "Input"],
Cell[332294, 11687, 178, 3, 46, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[332509, 11695, 75, 1, 40, "Input"],
Cell[332587, 11698, 281, 4, 83, "Message"]
}, Closed]],

Cell[CellGroupData[{
Cell[332905, 11707, 234, 5, 103, "Input"],
Cell[333142, 11714, 103, 2, 27, "Message"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[333306, 11723, 59, 0, 44, "Subsection"],
Cell[333368, 11725, 171, 5, 86, "Text"],
Cell[333542, 11732, 229, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[333796, 11740, 106, 2, 61, "Input"],
Cell[333905, 11744, 40, 1, 38, "Output"]
}, Closed]],
Cell[333960, 11748, 500, 9, 103, "Text"],

Cell[CellGroupData[{
Cell[334485, 11761, 102, 2, 61, "Input"],
Cell[334590, 11765, 45, 1, 38, "Output"]
}, Closed]],
Cell[334650, 11769, 163, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[334838, 11776, 101, 2, 61, "Input"],
Cell[334942, 11780, 72, 1, 38, "Output"]
}, Closed]],
Cell[335029, 11784, 150, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[335204, 11791, 97, 2, 61, "Input"],
Cell[335304, 11795, 40, 1, 38, "Output"]
}, Closed]],
Cell[335359, 11799, 59, 0, 30, "Text"],
Cell[335421, 11801, 59, 1, 40, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[335529, 11808, 27, 0, 40, "Section"],
Cell[335559, 11810, 334, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[335918, 11821, 143, 2, 59, "Input"],
Cell[336064, 11825, 228, 3, 57, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[336341, 11834, 50, 0, 40, "Section"],
Cell[336394, 11836, 88, 1, 33, "Text",
  CellTags->"NHoldAll"],
Cell[336485, 11839, 100, 2, 59, "Input"],
Cell[336588, 11843, 88, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[336701, 11849, 67, 1, 60, "Input"],
Cell[336771, 11852, 76, 1, 52, "Output"]
}, Closed]],
Cell[336862, 11856, 144, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[337031, 11863, 79, 1, 60, "Input"],
Cell[337113, 11866, 141, 2, 52, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[337291, 11873, 94, 2, 56, "Subsection"],
Cell[337388, 11877, 67, 0, 33, "Text"],
Cell[337458, 11879, 108, 2, 39, "Input"],
Cell[337569, 11883, 192, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[337786, 11891, 82, 1, 39, "Input"],
Cell[337871, 11894, 43, 1, 37, "Output"]
}, Closed]],
Cell[337929, 11898, 203, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[338157, 11906, 83, 1, 39, "Input"],
Cell[338243, 11909, 71, 1, 37, "Output"]
}, Closed]],
Cell[338329, 11913, 176, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[338530, 11920, 84, 1, 40, "Input"],
Cell[338617, 11923, 208, 3, 80, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[338886, 11933, 30, 0, 40, "Section"],
Cell[338919, 11935, 466, 8, 75, "Text",
  CellTags->"OneIdentity"],

Cell[CellGroupData[{
Cell[339410, 11947, 56, 0, 56, "Subsection"],
Cell[339469, 11949, 160, 4, 33, "Text",
  CellTags->"OneIdentity-Default"],

Cell[CellGroupData[{
Cell[339654, 11957, 41, 1, 39, "Input"],
Cell[339698, 11960, 279, 8, 29, "Print",
  CellTags->"Info3242474880-2863980"],
Cell[339980, 11970, 576, 16, 69, "Print",
  CellTags->"Info3242474880-2863980"]
}, Closed]],
Cell[340571, 11989, 732, 13, 96, "Text"],

Cell[CellGroupData[{
Cell[341328, 12006, 275, 6, 79, "Input"],
Cell[341606, 12014, 52, 1, 57, "Output"]
}, Closed]],
Cell[341673, 12018, 178, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[341876, 12026, 357, 8, 119, "Input"],
Cell[342236, 12036, 59, 1, 57, "Output"]
}, Closed]],
Cell[342310, 12040, 244, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[342579, 12048, 374, 8, 119, "Input"],
Cell[342956, 12058, 74, 1, 55, "Output"]
}, Closed]],
Cell[343045, 12062, 115, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[343185, 12069, 122, 3, 82, "Input"],
Cell[343310, 12074, 279, 8, 27, "Print",
  CellTags->"Info3242474882-9613789"],
Cell[343592, 12084, 575, 16, 62, "Print",
  CellTags->"Info3242474882-9613789"]
}, Closed]],
Cell[344182, 12103, 288, 5, 47, "Text"],
Cell[344473, 12110, 408, 8, 47, "Text",
  CellTags->"OneIdentity-Default"],

Cell[CellGroupData[{
Cell[344906, 12122, 129, 3, 82, "Input"],
Cell[345038, 12127, 35, 1, 35, "Output"]
}, Closed]],
Cell[345088, 12131, 366, 6, 65, "Text"],

Cell[CellGroupData[{
Cell[345479, 12141, 149, 3, 82, "Input"],
Cell[345631, 12146, 41, 1, 35, "Output"]
}, Closed]],
Cell[345687, 12150, 360, 6, 65, "Text"],

Cell[CellGroupData[{
Cell[346072, 12160, 188, 3, 82, "Input"],
Cell[346263, 12165, 41, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[346353, 12172, 56, 0, 45, "Subsection"],
Cell[346412, 12174, 759, 14, 85, "Text",
  CellTags->"OneIdentity-Flat"],

Cell[CellGroupData[{
Cell[347196, 12192, 165, 3, 82, "Input"],
Cell[347364, 12197, 56, 1, 35, "Output"]
}, Closed]],
Cell[347435, 12201, 388, 6, 65, "Text"],

Cell[CellGroupData[{
Cell[347848, 12211, 160, 3, 82, "Input"],
Cell[348011, 12216, 53, 1, 35, "Output"]
}, Closed]],
Cell[348079, 12220, 240, 4, 47, "Text"],
Cell[348322, 12226, 167, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[348514, 12233, 40, 1, 40, "Input"],
Cell[348557, 12236, 374, 9, 50, "Print",
  CellTags->"Info3242474882-1460760"],
Cell[348934, 12247, 300, 8, 27, "Print",
  CellTags->"Info3242474882-1460760"]
}, Closed]],
Cell[349249, 12258, 391, 9, 47, "Text"],

Cell[CellGroupData[{
Cell[349665, 12271, 92, 1, 40, "Input"],
Cell[349760, 12274, 56, 1, 35, "Output"]
}, Closed]],
Cell[349831, 12278, 194, 4, 47, "Text"],

Cell[CellGroupData[{
Cell[350050, 12286, 167, 2, 60, "Input"],
Cell[350220, 12290, 62, 1, 35, "Output"]
}, Closed]],
Cell[350297, 12294, 94, 2, 30, "Text"],
Cell[350394, 12298, 65, 1, 40, "Input"],
Cell[350462, 12301, 1192, 40, 65, "Text"],

Cell[CellGroupData[{
Cell[351679, 12345, 190, 4, 105, "Input"],
Cell[351872, 12351, 54, 1, 35, "Output"]
}, Closed]],
Cell[351941, 12355, 974, 34, 102, "Text"],

Cell[CellGroupData[{
Cell[352940, 12393, 160, 4, 105, "Input"],
Cell[353103, 12399, 66, 1, 35, "Output"]
}, Closed]],
Cell[353184, 12403, 313, 5, 47, "Text"],

Cell[CellGroupData[{
Cell[353522, 12412, 166, 4, 105, "Input"],
Cell[353691, 12418, 50, 1, 35, "Output"]
}, Closed]],
Cell[353756, 12422, 525, 8, 85, "Text"],

Cell[CellGroupData[{
Cell[354306, 12434, 179, 4, 105, "Input"],
Cell[354488, 12440, 55, 1, 35, "Output"]
}, Closed]],
Cell[354558, 12444, 758, 17, 257, "Text"],

Cell[CellGroupData[{
Cell[355341, 12465, 204, 5, 82, "Input"],
Cell[355548, 12472, 370, 13, 27, "Print"],
Cell[355921, 12487, 370, 13, 27, "Print"],
Cell[356294, 12502, 370, 13, 27, "Print"],
Cell[356667, 12517, 362, 13, 27, "Print"],
Cell[357032, 12532, 362, 13, 27, "Print"],
Cell[357397, 12547, 362, 13, 27, "Print"],
Cell[357762, 12562, 362, 13, 27, "Print"],
Cell[358127, 12577, 354, 13, 27, "Print"],
Cell[358484, 12592, 354, 13, 27, "Print"],
Cell[358841, 12607, 354, 13, 27, "Print"],
Cell[359198, 12622, 51, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[359310, 12630, 56, 0, 40, "Section"],
Cell[359369, 12632, 391, 7, 54, "Text",
  CellTags->"Optional"],

Cell[CellGroupData[{
Cell[359785, 12643, 44, 0, 56, "Subsection"],
Cell[359832, 12645, 89, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[359946, 12651, 221, 5, 79, "Input"],
Cell[360170, 12658, 57, 1, 37, "Output"]
}, Closed]],
Cell[360242, 12662, 249, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[360516, 12670, 37, 1, 39, "Input"],
Cell[360556, 12673, 57, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[360662, 12680, 44, 0, 56, "Subsection"],
Cell[360709, 12682, 312, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[361046, 12691, 194, 3, 79, "Input"],
Cell[361243, 12696, 81, 1, 37, "Output"]
}, Closed]],
Cell[361339, 12700, 227, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[361591, 12708, 37, 1, 39, "Input"],
Cell[361631, 12711, 63, 1, 28, "Print",
  CellTags->"Info3285568764-5243668"],
Cell[361697, 12714, 443, 13, 29, "Print",
  CellTags->"Info3285568764-5243668"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[362189, 12733, 44, 0, 56, "Subsection"],
Cell[362236, 12735, 324, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[362585, 12745, 201, 3, 80, "Input"],
Cell[362789, 12750, 101, 2, 37, "Output"]
}, Closed]],
Cell[362905, 12755, 232, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[363162, 12764, 37, 1, 40, "Input"],
Cell[363202, 12767, 63, 1, 27, "Print",
  CellTags->"Info3285569129-8870368"],
Cell[363268, 12770, 447, 13, 30, "Print",
  CellTags->"Info3285569129-8870368"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[363764, 12789, 54, 0, 44, "Subsection"],
Cell[363821, 12791, 359, 9, 66, "Text"],
Cell[364183, 12802, 156, 3, 82, "Input"],
Cell[364342, 12807, 108, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[364475, 12814, 80, 2, 61, "Input"],
Cell[364558, 12818, 40, 1, 38, "Output"],
Cell[364601, 12821, 40, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[364702, 12829, 35, 0, 40, "Section"],

Cell[CellGroupData[{
Cell[364762, 12833, 37, 0, 56, "Subsection"],
Cell[364802, 12835, 287, 7, 54, "Text",
  CellTags->"Options"],

Cell[CellGroupData[{
Cell[365114, 12846, 45, 1, 39, "Input"],
Cell[365162, 12849, 172, 3, 29, "Print",
  CellTags->"Info3242474884-6448585"]
}, Closed]],
Cell[365349, 12855, 203, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[365577, 12863, 278, 5, 99, "Input"],
Cell[365858, 12870, 38, 1, 37, "Output"],
Cell[365899, 12873, 38, 1, 37, "Output"],
Cell[365940, 12876, 38, 1, 37, "Output"]
}, Closed]],
Cell[365993, 12880, 90, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[366108, 12886, 136, 2, 39, "Input"],
Cell[366247, 12890, 38, 1, 37, "Output"]
}, Closed]],
Cell[366300, 12894, 168, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[366493, 12901, 285, 5, 119, "Input"],
Cell[366781, 12908, 39, 1, 37, "Output"],
Cell[366823, 12911, 39, 1, 37, "Output"],
Cell[366865, 12914, 39, 1, 38, "Output"],
Cell[366907, 12917, 39, 1, 38, "Output"],
Cell[366949, 12920, 39, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[367037, 12927, 44, 0, 44, "Subsection"],
Cell[367084, 12929, 474, 10, 85, "Text"],
Cell[367561, 12941, 92, 1, 40, "Input"],
Cell[367656, 12944, 95, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[367776, 12950, 396, 8, 103, "Input"],
Cell[368175, 12960, 46, 1, 38, "Output"],
Cell[368224, 12963, 121, 3, 38, "Output"],
Cell[368348, 12968, 121, 3, 38, "Output"],
Cell[368472, 12973, 121, 3, 38, "Output"]
}, Closed]],
Cell[368608, 12979, 109, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[368742, 12986, 85, 1, 40, "Input"],
Cell[368830, 12989, 86, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[368965, 12996, 52, 0, 44, "Subsection"],
Cell[369020, 12998, 426, 12, 105, "Text"],
Cell[369449, 13012, 606, 11, 231, "Input"],
Cell[370058, 13025, 127, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[370210, 13032, 232, 4, 82, "Input"],
Cell[370445, 13038, 107, 2, 38, "Output"],
Cell[370555, 13042, 110, 2, 38, "Output"],
Cell[370668, 13046, 109, 2, 38, "Output"]
}, Closed]],
Cell[370792, 13051, 217, 4, 48, "Text"],
Cell[371012, 13057, 149, 3, 61, "Input"],
Cell[371164, 13062, 133, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[371322, 13069, 133, 3, 40, "Input"],
Cell[371458, 13074, 193, 3, 46, "Message"],
Cell[371654, 13079, 101, 2, 38, "Output"]
}, Closed]],
Cell[371770, 13084, 379, 7, 86, "Text"],
Cell[372152, 13093, 642, 11, 231, "Input"],
Cell[372797, 13106, 158, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[372980, 13113, 538, 10, 146, "Input"],
Cell[373521, 13125, 107, 2, 38, "Output"],
Cell[373631, 13129, 110, 2, 38, "Output"],
Cell[373744, 13133, 109, 2, 38, "Output"],
Cell[373856, 13137, 111, 2, 38, "Output"],
Cell[373970, 13141, 107, 2, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[374138, 13150, 27, 0, 40, "Section"],
Cell[374168, 13152, 82, 1, 33, "Text",
  CellTags->"Ordering"],

Cell[CellGroupData[{
Cell[374275, 13157, 46, 1, 39, "Input"],
Cell[374324, 13160, 549, 12, 69, "Print",
  CellTags->"Info3276836798-2710999"]
}, Closed]],
Cell[374888, 13175, 62, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[374975, 13179, 181, 3, 59, "Input"],
Cell[375159, 13184, 61, 1, 37, "Output"]
}, Closed]],
Cell[375235, 13188, 255, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[375515, 13196, 92, 2, 59, "Input"],
Cell[375610, 13200, 320, 7, 37, "Output"],
Cell[375933, 13209, 320, 7, 37, "Output"]
}, Closed]],
Cell[376268, 13219, 314, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[376607, 13228, 49, 1, 39, "Input"],
Cell[376659, 13231, 46, 1, 37, "Output"]
}, Closed]],
Cell[376720, 13235, 76, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[376821, 13239, 54, 1, 39, "Input"],
Cell[376878, 13242, 46, 1, 37, "Output"]
}, Closed]],
Cell[376939, 13246, 214, 8, 33, "Text"],

Cell[CellGroupData[{
Cell[377178, 13258, 54, 1, 39, "Input"],
Cell[377235, 13261, 43, 1, 38, "Output"]
}, Closed]],
Cell[377293, 13265, 278, 8, 48, "Text"],

Cell[CellGroupData[{
Cell[377596, 13277, 59, 1, 40, "Input"],
Cell[377658, 13280, 52, 1, 38, "Output"]
}, Closed]],
Cell[377725, 13284, 168, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[377918, 13291, 62, 1, 40, "Input"],
Cell[377983, 13294, 49, 1, 38, "Output"]
}, Closed]],
Cell[378047, 13298, 245, 4, 66, "Text"],

Cell[CellGroupData[{
Cell[378317, 13306, 64, 1, 40, "Input"],
Cell[378384, 13309, 61, 1, 38, "Output"]
}, Closed]],
Cell[378460, 13313, 129, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[378614, 13320, 99, 2, 61, "Input"],
Cell[378716, 13324, 320, 7, 38, "Output"],
Cell[379039, 13333, 320, 7, 38, "Output"]
}, Closed]],
Cell[379374, 13343, 160, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[379559, 13350, 180, 4, 61, "Input"],
Cell[379742, 13356, 61, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[379852, 13363, 28, 0, 40, "Section"],
Cell[379883, 13365, 165, 4, 33, "Text",
  CellTags->"Orderless"],

Cell[CellGroupData[{
Cell[380073, 13373, 146, 3, 79, "Input"],
Cell[380222, 13378, 50, 1, 37, "Output"]
}, Closed]],
Cell[380287, 13382, 163, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[380475, 13389, 50, 1, 39, "Input"],
Cell[380528, 13392, 51, 1, 37, "Output"]
}, Closed]],
Cell[380594, 13396, 191, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[380810, 13404, 92, 2, 59, "Input"],
Cell[380905, 13408, 40, 1, 37, "Output"]
}, Closed]],
Cell[380960, 13412, 440, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[381425, 13423, 118, 2, 59, "Input"],
Cell[381546, 13427, 59, 1, 37, "Output"]
}, Closed]],
Cell[381620, 13431, 585, 9, 96, "Text"],

Cell[CellGroupData[{
Cell[382230, 13444, 139, 2, 59, "Input"],
Cell[382372, 13448, 60, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[382481, 13455, 24, 0, 40, "Section"],
Cell[382508, 13457, 74, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[382607, 13461, 65, 1, 39, "Input"],
Cell[382675, 13464, 113, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[382825, 13471, 75, 1, 39, "Input"],
Cell[382903, 13474, 263, 4, 57, "Output"]
}, Closed]],
Cell[383181, 13481, 188, 4, 33, "Text",
  CellTags->"Outer"],
Cell[383372, 13487, 291, 5, 101, "Output"],
Cell[383666, 13494, 59, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[383750, 13498, 228, 4, 59, "Input"],
Cell[383981, 13504, 147, 2, 37, "Output"]
}, Closed]],
Cell[384143, 13509, 108, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[384276, 13516, 166, 4, 39, "Input"],
Cell[384445, 13522, 147, 2, 37, "Output"]
}, Closed]],
Cell[384607, 13527, 94, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[384726, 13533, 114, 2, 39, "Input"],
Cell[384843, 13537, 1404, 38, 94, "Output"]
}, Closed]],
Cell[386262, 13578, 97, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[386384, 13584, 105, 2, 40, "Input"],
Cell[386492, 13588, 795, 12, 208, "Output"]
}, Closed]],
Cell[387302, 13603, 93, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[387420, 13609, 120, 2, 61, "Input"],
Cell[387543, 13613, 1180, 30, 91, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[388760, 13648, 120, 2, 61, "Input"],
Cell[388883, 13652, 1180, 30, 91, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[390112, 13688, 23, 0, 40, "Section"],
Cell[390138, 13690, 209, 5, 33, "Text",
  CellTags->"Part"],

Cell[CellGroupData[{
Cell[390372, 13699, 51, 1, 39, "Input"],
Cell[390426, 13702, 38, 1, 37, "Output"]
}, Closed]],
Cell[390479, 13706, 109, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[390613, 13713, 59, 1, 39, "Input"],
Cell[390675, 13716, 38, 1, 37, "Output"]
}, Closed]],
Cell[390728, 13720, 206, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[390959, 13728, 344, 6, 119, "Input"],
Cell[391306, 13736, 424, 10, 114, "Output"]
}, Closed]],
Cell[391745, 13749, 339, 6, 54, "Text"],

Cell[CellGroupData[{
Cell[392109, 13759, 75, 1, 39, "Input"],
Cell[392187, 13762, 263, 8, 74, "Output"]
}, Closed]],
Cell[392465, 13773, 128, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[392618, 13780, 54, 1, 39, "Input"],
Cell[392675, 13783, 49, 1, 37, "Output"]
}, Closed]],
Cell[392739, 13787, 140, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[392904, 13794, 54, 1, 40, "Input"],
Cell[392961, 13797, 49, 1, 38, "Output"]
}, Closed]],
Cell[393025, 13801, 804, 13, 158, "Text"],

Cell[CellGroupData[{
Cell[393854, 13818, 125, 2, 61, "Input"],
Cell[393982, 13822, 419, 10, 111, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[394438, 13837, 125, 2, 61, "Input"],
Cell[394566, 13841, 415, 10, 111, "Output"]
}, Closed]],
Cell[394996, 13854, 116, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[395137, 13861, 70, 1, 40, "Input"],
Cell[395210, 13864, 351, 10, 111, "Output"]
}, Closed]],
Cell[395576, 13877, 117, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[395718, 13884, 169, 3, 61, "Input"],
Cell[395890, 13889, 423, 10, 113, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[396362, 13905, 28, 0, 40, "Section"],
Cell[396393, 13907, 317, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[396735, 13918, 47, 1, 39, "Input"],
Cell[396785, 13921, 1316, 22, 209, "Print",
  CellTags->"Info3242474896-7343620"]
}, Closed]],
Cell[398116, 13946, 218, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[398359, 13954, 89, 2, 59, "Input"],
Cell[398451, 13958, 268, 4, 57, "Output"]
}, Closed]],
Cell[398734, 13965, 99, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[398858, 13971, 53, 1, 39, "Input"],
Cell[398914, 13974, 347, 5, 77, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[399298, 13984, 54, 1, 39, "Input"],
Cell[399355, 13987, 129, 2, 37, "Output"]
}, Closed]],
Cell[399499, 13992, 211, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[399735, 14000, 56, 1, 39, "Input"],
Cell[399794, 14003, 272, 4, 57, "Output"]
}, Closed]],
Cell[400081, 14010, 191, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[400297, 14018, 56, 1, 40, "Input"],
Cell[400356, 14021, 272, 4, 80, "Output"]
}, Closed]],
Cell[400643, 14028, 128, 3, 30, "Text"],
Cell[400774, 14033, 341, 6, 167, "Input"],

Cell[CellGroupData[{
Cell[401140, 14043, 78, 1, 40, "Input"],
Cell[401221, 14046, 1314, 32, 91, "Output"]
}, Closed]],
Cell[402550, 14081, 125, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[402700, 14088, 92, 2, 61, "Input"],
Cell[402795, 14092, 113, 2, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[402945, 14099, 51, 1, 40, "Input"],
Cell[402999, 14102, 123, 2, 59, "Output"]
}, Closed]],
Cell[403137, 14107, 903, 21, 265, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[404077, 14133, 27, 0, 40, "Section"],
Cell[404107, 14135, 379, 7, 54, "Text",
  CellTags->"Position"],

Cell[CellGroupData[{
Cell[404511, 14146, 263, 5, 123, "Input"],
Cell[404777, 14153, 77, 1, 37, "Output"]
}, Closed]],
Cell[404869, 14157, 294, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[405188, 14166, 166, 3, 79, "Input"],
Cell[405357, 14171, 39, 1, 37, "Output"],
Cell[405399, 14174, 42, 1, 52, "Output"],
Cell[405444, 14177, 43, 1, 37, "Output"]
}, Closed]],
Cell[405502, 14181, 383, 6, 54, "Text"],

Cell[CellGroupData[{
Cell[405910, 14191, 52, 1, 39, "Input"],
Cell[405965, 14194, 166, 3, 66, "Output"]
}, Closed]],
Cell[406146, 14200, 139, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[406310, 14207, 57, 1, 39, "Input"],
Cell[406370, 14210, 38, 1, 37, "Output"]
}, Closed]],
Cell[406423, 14214, 124, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[406572, 14221, 52, 1, 40, "Input"],
Cell[406627, 14224, 36, 1, 38, "Output"]
}, Closed]],
Cell[406678, 14228, 297, 7, 48, "Text"],

Cell[CellGroupData[{
Cell[407000, 14239, 54, 0, 56, "Subsection"],
Cell[407057, 14241, 338, 8, 48, "Text"],

Cell[CellGroupData[{
Cell[407420, 14253, 54, 1, 40, "Input"],
Cell[407477, 14256, 77, 1, 38, "Output"]
}, Closed]],
Cell[407569, 14260, 139, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[407733, 14267, 57, 1, 40, "Input"],
Cell[407793, 14270, 56, 1, 38, "Output"]
}, Closed]],
Cell[407864, 14274, 105, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[407994, 14281, 59, 1, 40, "Input"],
Cell[408056, 14284, 48, 1, 38, "Output"]
}, Closed]],
Cell[408119, 14288, 154, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[408298, 14295, 62, 1, 40, "Input"],
Cell[408363, 14298, 60, 1, 38, "Output"]
}, Closed]],
Cell[408438, 14302, 110, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[408573, 14309, 72, 1, 40, "Input"],
Cell[408648, 14312, 77, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[408774, 14319, 57, 0, 44, "Subsection"],
Cell[408834, 14321, 87, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[408946, 14327, 192, 3, 82, "Input"],
Cell[409141, 14332, 111, 2, 38, "Output"]
}, Closed]],
Cell[409267, 14337, 91, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[409383, 14343, 52, 1, 40, "Input"],
Cell[409438, 14346, 74, 1, 38, "Output"]
}, Closed]],
Cell[409527, 14350, 315, 7, 48, "Text"],

Cell[CellGroupData[{
Cell[409867, 14361, 85, 1, 40, "Input"],
Cell[409955, 14364, 69, 1, 38, "Output"]
}, Closed]],
Cell[410039, 14368, 155, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[410219, 14375, 86, 1, 40, "Input"],
Cell[410308, 14378, 111, 2, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[410468, 14386, 34, 0, 44, "Subsection"],
Cell[410505, 14388, 640, 21, 66, "Text"],

Cell[CellGroupData[{
Cell[411170, 14413, 53, 1, 40, "Input"],
Cell[411226, 14416, 87, 1, 38, "Output"]
}, Closed]],
Cell[411328, 14420, 344, 6, 66, "Text"],

Cell[CellGroupData[{
Cell[411697, 14430, 69, 1, 40, "Input"],
Cell[411769, 14433, 36, 1, 38, "Output"]
}, Closed]],
Cell[411820, 14437, 266, 5, 49, "Text"],

Cell[CellGroupData[{
Cell[412111, 14446, 133, 2, 61, "Input"],
Cell[412247, 14450, 51, 1, 38, "Output"]
}, Closed]],
Cell[412313, 14454, 304, 6, 67, "Text"],

Cell[CellGroupData[{
Cell[412642, 14464, 82, 1, 40, "Input"],
Cell[412727, 14467, 36, 1, 38, "Output"]
}, Closed]],
Cell[412778, 14471, 208, 6, 53, "Subsubsection"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[413035, 14483, 37, 0, 40, "Section"],
Cell[413075, 14485, 448, 11, 54, "Text",
  CellTags->"Pattern"],
Cell[413526, 14498, 221, 4, 54, "Text"],
Cell[413750, 14504, 80, 1, 39, "Input"],
Cell[413833, 14507, 174, 5, 33, "Text"],

Cell[CellGroupData[{
Cell[414032, 14516, 55, 1, 40, "Input"],
Cell[414090, 14519, 64, 1, 38, "Output"]
}, Closed]],
Cell[414169, 14523, 147, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[414341, 14530, 48, 1, 40, "Input"],
Cell[414392, 14533, 49, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[414478, 14539, 55, 1, 40, "Input"],
Cell[414536, 14542, 56, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[414641, 14549, 64, 0, 40, "Section"],
Cell[414708, 14551, 374, 9, 54, "Text",
  CellTags->"PatternTest"],

Cell[CellGroupData[{
Cell[415107, 14564, 176, 3, 87, "Input"],
Cell[415286, 14569, 80, 1, 52, "Output"]
}, Closed]],
Cell[415381, 14573, 116, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[415522, 14580, 183, 3, 87, "Input"],
Cell[415708, 14585, 82, 1, 52, "Output"]
}, Closed]],
Cell[415805, 14589, 137, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[415967, 14596, 213, 4, 87, "Input"],
Cell[416183, 14602, 79, 1, 52, "Output"]
}, Closed]],
Cell[416277, 14606, 389, 8, 54, "Text"],

Cell[CellGroupData[{
Cell[416691, 14618, 200, 3, 87, "Input"],
Cell[416894, 14623, 89, 1, 52, "Output"]
}, Closed]],
Cell[416998, 14627, 169, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[417192, 14634, 215, 4, 87, "Input"],
Cell[417410, 14640, 87, 1, 47, "Output"]
}, Closed]],
Cell[417512, 14644, 154, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[417691, 14651, 159, 3, 82, "Input"],
Cell[417853, 14656, 43, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[417945, 14663, 25, 0, 40, "Section"],
Cell[417973, 14665, 1054, 25, 186, "Text",
  CellTags->"Random"],
Cell[419030, 14692, 109, 2, 63, "Input"],
Cell[419142, 14696, 193, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[419360, 14704, 60, 1, 39, "Input"],
Cell[419423, 14707, 54, 1, 37, "Output"]
}, Closed]],
Cell[419492, 14711, 147, 3, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[419676, 14719, 30, 0, 40, "Section"],

Cell[CellGroupData[{
Cell[419731, 14723, 49, 1, 39, "Input"],
Cell[419783, 14726, 476, 11, 49, "Print",
  CellTags->"Info3242474897-2101131"]
}, Closed]],
Cell[420274, 14740, 126, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[420425, 14747, 66, 1, 39, "Input"],
Cell[420494, 14750, 53, 1, 55, "Output"]
}, Closed]],
Cell[420562, 14754, 91, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[420678, 14760, 54, 1, 39, "Input"],
Cell[420735, 14763, 69, 1, 38, "Output"]
}, Closed]],
Cell[420819, 14767, 134, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[420978, 14774, 64, 1, 39, "Input"],
Cell[421045, 14777, 39, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[421121, 14783, 92, 1, 79, "Input"],
Cell[421216, 14786, 35, 1, 37, "Output"]
}, Closed]],
Cell[421266, 14790, 227, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[421518, 14798, 64, 1, 39, "Input"],
Cell[421585, 14801, 67, 1, 55, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[421701, 14808, 24, 0, 40, "Section"],
Cell[421728, 14810, 486, 9, 119, "Text",
  CellTags->"Range"],

Cell[CellGroupData[{
Cell[422239, 14823, 56, 1, 39, "Input"],
Cell[422298, 14826, 184, 3, 55, "Output"]
}, Closed]],
Cell[422497, 14832, 68, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[422590, 14836, 54, 1, 39, "Input"],
Cell[422647, 14839, 117, 2, 55, "Output"]
}, Closed]],
Cell[422779, 14844, 479, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[423283, 14855, 109, 2, 59, "Input"],
Cell[423395, 14859, 118, 2, 38, "Output"]
}, Closed]],
Cell[423528, 14864, 58, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[423611, 14868, 60, 1, 39, "Input"],
Cell[423674, 14871, 106, 2, 37, "Output"]
}, Closed]],
Cell[423795, 14876, 616, 12, 75, "Text"],

Cell[CellGroupData[{
Cell[424436, 14892, 151, 3, 39, "Input"],
Cell[424590, 14897, 125, 2, 57, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[424764, 14905, 64, 0, 40, "Section"],
Cell[424831, 14907, 402, 7, 54, "Text",
  CellTags->"Repeated RepeatedNull"],

Cell[CellGroupData[{
Cell[425258, 14918, 221, 4, 79, "Input"],
Cell[425482, 14924, 561, 15, 37, "Output"]
}, Closed]],
Cell[426058, 14942, 303, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[426386, 14951, 222, 4, 79, "Input"],
Cell[426611, 14957, 651, 17, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[427311, 14980, 26, 0, 40, "Section"],
Cell[427340, 14982, 529, 10, 119, "Text",
  CellTags->"Replace"],

Cell[CellGroupData[{
Cell[427894, 14996, 201, 3, 79, "Input"],
Cell[428098, 15001, 78, 1, 37, "Output"]
}, Closed]],
Cell[428191, 15005, 359, 8, 54, "Text"],

Cell[CellGroupData[{
Cell[428575, 15017, 90, 1, 39, "Input"],
Cell[428668, 15020, 105, 2, 37, "Output"]
}, Closed]],
Cell[428788, 15025, 86, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[428899, 15031, 87, 1, 39, "Input"],
Cell[428989, 15034, 78, 1, 37, "Output"]
}, Closed]],
Cell[429082, 15038, 207, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[429314, 15046, 90, 1, 39, "Input"],
Cell[429407, 15049, 84, 1, 37, "Output"]
}, Closed]],
Cell[429506, 15053, 150, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[429681, 15060, 90, 1, 39, "Input"],
Cell[429774, 15063, 84, 1, 37, "Output"]
}, Closed]],
Cell[429873, 15067, 149, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[430047, 15074, 102, 2, 39, "Input"],
Cell[430152, 15078, 84, 1, 37, "Output"]
}, Closed]],
Cell[430251, 15082, 353, 8, 54, "Text"],

Cell[CellGroupData[{
Cell[430629, 15094, 123, 3, 40, "Input"],
Cell[430755, 15099, 53, 1, 38, "Output"]
}, Closed]],
Cell[430823, 15103, 727, 14, 140, "Text"],

Cell[CellGroupData[{
Cell[431575, 15121, 155, 3, 40, "Input"],
Cell[431733, 15126, 90, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[431860, 15132, 76, 0, 56, "Subsection"],
Cell[431939, 15134, 473, 7, 103, "Text"],
Cell[432415, 15143, 275, 5, 103, "Input"],

Cell[CellGroupData[{
Cell[432715, 15152, 65, 1, 40, "Input"],
Cell[432783, 15155, 40, 1, 38, "Output"]
}, Closed]],
Cell[432838, 15159, 1126, 17, 251, "Text"],

Cell[CellGroupData[{
Cell[433989, 15180, 141, 3, 40, "Input"],
Cell[434133, 15185, 35, 1, 29, "Print"],
Cell[434171, 15188, 39, 1, 29, "Print"],
Cell[434213, 15191, 35, 1, 29, "Print"],
Cell[434251, 15194, 46, 1, 29, "Print"],
Cell[434300, 15197, 57, 1, 29, "Print"],
Cell[434360, 15200, 58, 1, 38, "Output"]
}, Closed]],
Cell[434433, 15204, 134, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[434592, 15211, 153, 2, 60, "Input"],
Cell[434748, 15215, 75, 1, 53, "Output"]
}, Closed]],
Cell[434838, 15219, 246, 7, 48, "Text"],

Cell[CellGroupData[{
Cell[435109, 15230, 128, 2, 60, "Input"],
Cell[435240, 15234, 76, 1, 53, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[435365, 15241, 34, 0, 44, "Subsection"],
Cell[435402, 15243, 323, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[435750, 15252, 161, 3, 40, "Input"],
Cell[435914, 15257, 34, 1, 29, "Print"],
Cell[435951, 15260, 35, 1, 29, "Print"],
Cell[435989, 15263, 35, 1, 29, "Print"],
Cell[436027, 15266, 39, 1, 29, "Print"],
Cell[436069, 15269, 35, 1, 29, "Print"],
Cell[436107, 15272, 34, 1, 29, "Print"],
Cell[436144, 15275, 38, 1, 29, "Print"],
Cell[436185, 15278, 35, 1, 29, "Print"],
Cell[436223, 15281, 46, 1, 29, "Print"],
Cell[436272, 15284, 57, 1, 29, "Print"],
Cell[436332, 15287, 58, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[436451, 15295, 46, 0, 40, "Section"],
Cell[436500, 15297, 113, 1, 33, "Text",
  CellTags->"ReplaceAll;ReplaceRepeated"],

Cell[CellGroupData[{
Cell[436638, 15302, 160, 3, 79, "Input"],
Cell[436801, 15307, 44, 1, 37, "Output"]
}, Closed]],
Cell[436860, 15311, 98, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[436983, 15317, 42, 1, 39, "Input"],
Cell[437028, 15320, 49, 1, 37, "Output"]
}, Closed]],
Cell[437092, 15324, 359, 8, 54, "Text"],

Cell[CellGroupData[{
Cell[437476, 15336, 74, 1, 60, "Input"],
Cell[437553, 15339, 44, 1, 60, "Output"]
}, Closed]],
Cell[437612, 15343, 253, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[437890, 15352, 80, 1, 39, "Input"],
Cell[437973, 15355, 44, 1, 37, "Output"]
}, Closed]],
Cell[438032, 15359, 177, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[438234, 15367, 138, 2, 39, "Input"],
Cell[438375, 15371, 72, 1, 37, "Output"]
}, Closed]],
Cell[438462, 15375, 315, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[438802, 15386, 149, 2, 64, "Input"],
Cell[438954, 15390, 76, 1, 53, "Output"]
}, Closed]],
Cell[439045, 15394, 237, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[439307, 15402, 119, 2, 40, "Input"],
Cell[439429, 15406, 90, 1, 38, "Output"]
}, Closed]],
Cell[439534, 15410, 206, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[439765, 15418, 118, 2, 40, "Input"],
Cell[439886, 15422, 125, 2, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[440048, 15429, 76, 0, 56, "Subsection"],
Cell[440127, 15431, 303, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[440455, 15440, 171, 3, 61, "Input"],
Cell[440629, 15445, 57, 1, 29, "Print"],
Cell[440689, 15448, 34, 1, 29, "Print"],
Cell[440726, 15451, 39, 1, 29, "Print"],
Cell[440768, 15454, 35, 1, 29, "Print"],
Cell[440806, 15457, 35, 1, 29, "Print"],
Cell[440844, 15460, 46, 1, 29, "Print"],
Cell[440893, 15463, 38, 1, 29, "Print"],
Cell[440934, 15466, 35, 1, 29, "Print"],
Cell[440972, 15469, 34, 1, 29, "Print"],
Cell[441009, 15472, 35, 1, 29, "Print"],
Cell[441047, 15475, 58, 1, 38, "Output"]
}, Closed]],
Cell[441120, 15479, 139, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[441284, 15486, 128, 2, 60, "Input"],
Cell[441415, 15490, 76, 1, 53, "Output"]
}, Closed]],
Cell[441506, 15494, 216, 6, 30, "Text"],

Cell[CellGroupData[{
Cell[441747, 15504, 153, 2, 60, "Input"],
Cell[441903, 15508, 75, 1, 53, "Output"]
}, Closed]],
Cell[441993, 15512, 350, 7, 66, "Text"],

Cell[CellGroupData[{
Cell[442368, 15523, 171, 4, 62, "Input"],
Cell[442542, 15529, 891, 29, 60, "Output"]
}, Closed]],
Cell[443448, 15561, 482, 11, 66, "Text"],

Cell[CellGroupData[{
Cell[443955, 15576, 212, 4, 62, "Input"],
Cell[444170, 15582, 1816, 46, 146, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[446047, 15635, 30, 0, 40, "Section"],
Cell[446080, 15637, 187, 6, 33, "Text"],
Cell[446270, 15645, 167, 3, 59, "Input"],
Cell[446440, 15650, 109, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[446574, 15657, 214, 4, 79, "Input"],
Cell[446791, 15663, 115, 2, 37, "Output"]
}, Closed]],
Cell[446921, 15668, 73, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[447019, 15672, 58, 1, 39, "Input"],
Cell[447080, 15675, 115, 2, 37, "Output"]
}, Closed]],
Cell[447210, 15680, 116, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[447351, 15687, 140, 2, 59, "Input"],
Cell[447494, 15691, 73, 1, 60, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[447604, 15697, 67, 1, 39, "Input"],
Cell[447674, 15700, 78, 1, 64, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[447801, 15707, 42, 0, 40, "Section"],
Cell[447846, 15709, 235, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[448106, 15717, 124, 2, 59, "Input"],
Cell[448233, 15721, 61, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[448331, 15727, 81, 1, 39, "Input"],
Cell[448415, 15730, 61, 1, 37, "Output"]
}, Closed]],
Cell[448491, 15734, 246, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[448762, 15742, 329, 5, 139, "Input"],
Cell[449094, 15749, 1960, 54, 198, "Output"]
}, Closed]],
Cell[451069, 15806, 99, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[451193, 15812, 82, 1, 39, "Input"],
Cell[451278, 15815, 1960, 54, 198, "Output"]
}, Closed]],
Cell[453253, 15872, 122, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[453400, 15879, 143, 2, 60, "Input"],
Cell[453546, 15883, 38, 1, 35, "Output"]
}, Closed]],
Cell[453599, 15887, 109, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[453733, 15894, 70, 1, 40, "Input"],
Cell[453806, 15897, 1960, 54, 180, "Output"]
}, Closed]],
Cell[455781, 15954, 97, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[455903, 15960, 73, 1, 40, "Input"],
Cell[455979, 15963, 1960, 54, 180, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[457988, 16023, 79, 2, 40, "Section"],
Cell[458070, 16027, 279, 5, 54, "Text",
  CellTags->"Rule;RuleDelayed"],

Cell[CellGroupData[{
Cell[458374, 16036, 185, 3, 59, "Input"],
Cell[458562, 16041, 110, 2, 38, "Output"]
}, Closed]],
Cell[458687, 16046, 333, 6, 54, "Text"],
Cell[459023, 16054, 118, 2, 59, "Input"],

Cell[CellGroupData[{
Cell[459166, 16060, 104, 2, 63, "Input"],
Cell[459273, 16064, 78, 1, 55, "Output"]
}, Closed]],
Cell[459366, 16068, 350, 6, 54, "Text"],

Cell[CellGroupData[{
Cell[459741, 16078, 173, 3, 59, "Input"],
Cell[459917, 16083, 77, 1, 37, "Output"]
}, Closed]],
Cell[460009, 16087, 518, 8, 75, "Text"],

Cell[CellGroupData[{
Cell[460552, 16099, 175, 3, 59, "Input"],
Cell[460730, 16104, 82, 1, 37, "Output"]
}, Closed]],
Cell[460827, 16108, 268, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[461120, 16117, 185, 3, 59, "Input"],
Cell[461308, 16122, 82, 1, 38, "Output"]
}, Closed]],
Cell[461405, 16126, 348, 6, 66, "Text"],

Cell[CellGroupData[{
Cell[461778, 16136, 85, 1, 45, "Input"],
Cell[461866, 16139, 111, 2, 54, "Output"]
}, Closed]],
Cell[461992, 16144, 623, 12, 103, "Text"],

Cell[CellGroupData[{
Cell[462640, 16160, 127, 2, 66, "Input"],
Cell[462770, 16164, 91, 1, 47, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[462910, 16171, 23, 0, 40, "Section"],
Cell[462936, 16173, 325, 6, 54, "Text",
  CellTags->"Scan"],
Cell[463264, 16181, 177, 3, 79, "Input"],
Cell[463444, 16186, 192, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[463661, 16194, 37, 1, 39, "Input"],
Cell[463701, 16197, 63, 1, 28, "Print",
  CellTags->"Info3242474919-8383725"],
Cell[463767, 16200, 445, 13, 30, "Print",
  CellTags->"Info3242474919-8383725"]
}, Closed]],
Cell[464227, 16216, 141, 3, 33, "Text"],
Cell[464371, 16221, 142, 2, 59, "Input"],

Cell[CellGroupData[{
Cell[464538, 16227, 37, 1, 39, "Input"],
Cell[464578, 16230, 63, 1, 28, "Print",
  CellTags->"Info3242474919-9355181"],
Cell[464644, 16233, 627, 19, 149, "Print",
  CellTags->"Info3242474919-9355181"]
}, Closed]],
Cell[465286, 16255, 338, 6, 54, "Text"],
Cell[465627, 16263, 155, 3, 59, "Input"],

Cell[CellGroupData[{
Cell[465807, 16270, 37, 1, 39, "Input"],
Cell[465847, 16273, 63, 1, 28, "Print",
  CellTags->"Info3242474920-7316245"],
Cell[465913, 16276, 627, 19, 149, "Print",
  CellTags->"Info3242474920-7316245"]
}, Closed]],
Cell[466555, 16298, 112, 3, 30, "Text"],
Cell[466670, 16303, 177, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[466872, 16310, 37, 1, 40, "Input"],
Cell[466912, 16313, 63, 1, 27, "Print",
  CellTags->"Info3242474920-3777955"],
Cell[466978, 16316, 591, 17, 105, "Print",
  CellTags->"Info3242474920-3777955"]
}, Closed]],
Cell[467584, 16336, 495, 10, 67, "Text"],
Cell[468082, 16348, 120, 2, 60, "Input"],

Cell[CellGroupData[{
Cell[468227, 16354, 37, 1, 40, "Input"],
Cell[468267, 16357, 63, 1, 27, "Print",
  CellTags->"Info3242474920-7649147"],
Cell[468333, 16360, 720, 23, 207, "Print",
  CellTags->"Info3242474920-7649147"]
}, Closed]],

Cell[CellGroupData[{
Cell[469090, 16388, 34, 0, 55, "Subsection"],
Cell[469127, 16390, 341, 6, 50, "Text"],
Cell[469471, 16398, 165, 3, 60, "Input"],

Cell[CellGroupData[{
Cell[469661, 16405, 37, 1, 40, "Input"],
Cell[469701, 16408, 63, 1, 27, "Print",
  CellTags->"Info3242474920-1486452"],
Cell[469767, 16411, 903, 29, 325, "Print",
  CellTags->"Info3242474920-1486452"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[470731, 16447, 27, 0, 40, "Section"],
Cell[470761, 16449, 536, 9, 75, "Text",
  CellTags->"Sequence"],

Cell[CellGroupData[{
Cell[471322, 16462, 189, 3, 79, "Input"],
Cell[471514, 16467, 62, 1, 37, "Output"]
}, Closed]],
Cell[471591, 16471, 426, 9, 54, "Text"],

Cell[CellGroupData[{
Cell[472042, 16484, 68, 1, 39, "Input"],
Cell[472113, 16487, 49, 1, 37, "Output"]
}, Closed]],
Cell[472177, 16491, 197, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[472399, 16499, 85, 1, 39, "Input"],
Cell[472487, 16502, 61, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[472597, 16509, 31, 0, 40, "Section"],
Cell[472631, 16511, 103, 1, 33, "Text",
  CellTags->"SequenceHold"],
Cell[472737, 16514, 297, 5, 76, "Text"],

Cell[CellGroupData[{
Cell[473059, 16523, 137, 2, 59, "Input"],
Cell[473199, 16527, 52, 1, 37, "Output"]
}, Closed]],
Cell[473266, 16531, 226, 4, 55, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[473529, 16540, 25, 0, 40, "Section"],
Cell[473557, 16542, 365, 9, 54, "Text"],

Cell[CellGroupData[{
Cell[473947, 16555, 113, 2, 59, "Input"],
Cell[474063, 16559, 318, 8, 57, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[474418, 16572, 59, 1, 40, "Input"],
Cell[474480, 16575, 404, 10, 55, "Output"]
}, Closed]],
Cell[474899, 16588, 380, 6, 54, "Text"],

Cell[CellGroupData[{
Cell[475304, 16598, 69, 1, 39, "Input"],
Cell[475376, 16601, 800, 22, 73, "Output"]
}, Closed]],
Cell[476191, 16626, 73, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[476289, 16630, 71, 1, 39, "Input"],
Cell[476363, 16633, 461, 12, 56, "Output"]
}, Closed]],
Cell[476839, 16648, 115, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[476979, 16655, 83, 1, 39, "Input"],
Cell[477065, 16658, 576, 16, 56, "Output"]
}, Closed]],
Cell[477656, 16677, 460, 8, 54, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[478153, 16690, 51, 0, 40, "Section"],
Cell[478207, 16692, 236, 4, 77, "Text"],

Cell[CellGroupData[{
Cell[478468, 16700, 230, 4, 79, "Input"],
Cell[478701, 16706, 144, 2, 38, "Output"]
}, Closed]],
Cell[478860, 16711, 234, 5, 77, "Text"],
Cell[479097, 16718, 103, 2, 39, "Input"],
Cell[479203, 16722, 183, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[479411, 16730, 116, 3, 80, "Input"],
Cell[479530, 16735, 46, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[479613, 16741, 126, 3, 79, "Input"],
Cell[479742, 16746, 74, 1, 38, "Output"]
}, Closed]],
Cell[479831, 16750, 141, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[479997, 16757, 177, 3, 59, "Input"],
Cell[480177, 16762, 112, 2, 37, "Output"]
}, Closed]],
Cell[480304, 16767, 497, 8, 75, "Text"],

Cell[CellGroupData[{
Cell[480826, 16779, 102, 2, 60, "Input"],
Cell[480931, 16783, 72, 1, 37, "Output"]
}, Closed]],
Cell[481018, 16787, 321, 5, 50, "Text"],

Cell[CellGroupData[{
Cell[481364, 16796, 153, 3, 82, "Input"],
Cell[481520, 16801, 56, 1, 37, "Output"]
}, Closed]],
Cell[481591, 16805, 135, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[481751, 16812, 44, 1, 40, "Input"],
Cell[481798, 16815, 68, 1, 27, "Print",
  CellTags->"Info3242474922-7671367"],
Cell[481869, 16818, 456, 13, 30, "Print",
  CellTags->"Info3242474922-7671367"]
}, Closed]],

Cell[CellGroupData[{
Cell[482362, 16836, 44, 1, 40, "Input"],
Cell[482409, 16839, 68, 1, 27, "Print",
  CellTags->"Info3242474922-1117472"],
Cell[482480, 16842, 443, 13, 30, "Print",
  CellTags->"Info3242474922-1117472"]
}, Closed]],
Cell[482938, 16858, 609, 9, 87, "Text"],
Cell[483550, 16869, 163, 3, 82, "Input"],
Cell[483716, 16874, 208, 4, 82, "Input"],
Cell[483927, 16880, 240, 4, 50, "Text"],

Cell[CellGroupData[{
Cell[484192, 16888, 147, 3, 80, "Input"],
Cell[484342, 16893, 48, 1, 37, "Output"]
}, Closed]],
Cell[484405, 16897, 156, 3, 50, "Text"],

Cell[CellGroupData[{
Cell[484586, 16904, 96, 2, 60, "Input"],
Cell[484685, 16908, 81, 1, 37, "Output"]
}, Closed]],
Cell[484781, 16912, 323, 7, 30, "Text"],

Cell[CellGroupData[{
Cell[485129, 16923, 82, 1, 55, "Subsection"],
Cell[485214, 16926, 422, 7, 67, "Text"],
Cell[485639, 16935, 153, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[485817, 16942, 39, 1, 40, "Input"],
Cell[485859, 16945, 46, 1, 35, "Output"]
}, Closed]],
Cell[485920, 16949, 801, 16, 85, "Text"],
Cell[486724, 16967, 111, 2, 60, "Input"],

Cell[CellGroupData[{
Cell[486860, 16973, 39, 1, 40, "Input"],
Cell[486902, 16976, 47, 1, 50, "Output"]
}, Closed]],
Cell[486964, 16980, 218, 4, 50, "Text"],
Cell[487185, 16986, 206, 5, 122, "Input"],

Cell[CellGroupData[{
Cell[487416, 16995, 63, 1, 40, "Input"],
Cell[487482, 16998, 51, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[487582, 17005, 45, 0, 45, "Subsection"],
Cell[487630, 17007, 146, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[487801, 17014, 129, 3, 80, "Input"],
Cell[487933, 17019, 40, 1, 37, "Output"]
}, Closed]],
Cell[487988, 17023, 193, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[488206, 17031, 85, 2, 60, "Input"],
Cell[488294, 17035, 40, 1, 37, "Output"]
}, Closed]],
Cell[488349, 17039, 326, 6, 50, "Text"],

Cell[CellGroupData[{
Cell[488700, 17049, 141, 4, 102, "Input"],
Cell[488844, 17055, 40, 1, 37, "Output"]
}, Closed]],
Cell[488899, 17059, 569, 9, 67, "Text"],
Cell[489471, 17070, 61, 1, 40, "Input"],
Cell[489535, 17073, 96, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[489656, 17079, 37, 1, 40, "Input"],
Cell[489696, 17082, 35, 1, 37, "Output"]
}, Closed]],
Cell[489746, 17086, 97, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[489868, 17092, 39, 1, 40, "Input"],
Cell[489910, 17095, 63, 1, 27, "Print",
  CellTags->"Info3284968730-3180209"],
Cell[489976, 17098, 423, 13, 30, "Print",
  CellTags->"Info3284968730-3180209"]
}, Closed]],

Cell[CellGroupData[{
Cell[490436, 17116, 39, 1, 40, "Input"],
Cell[490478, 17119, 63, 1, 27, "Print",
  CellTags->"Info3284968732-8841380"],
Cell[490544, 17122, 426, 13, 30, "Print",
  CellTags->"Info3284968732-8841380"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[491031, 17142, 42, 0, 40, "Section"],

Cell[CellGroupData[{
Cell[491098, 17146, 59, 0, 56, "Subsection"],
Cell[491160, 17148, 221, 5, 33, "Text",
  CellTags->"Simplify_FullSimplify"],

Cell[CellGroupData[{
Cell[491406, 17157, 120, 2, 59, "Input"],
Cell[491529, 17161, 55, 1, 37, "Output"]
}, Closed]],
Cell[491599, 17165, 127, 3, 33, "Text"],
Cell[491729, 17170, 1017, 20, 259, "Input"],
Cell[492749, 17192, 131, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[492905, 17199, 68, 1, 39, "Input"],
Cell[492976, 17202, 61, 1, 37, "Output"]
}, Closed]],
Cell[493052, 17206, 199, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[493276, 17214, 143, 3, 59, "Input"],
Cell[493422, 17219, 63, 1, 37, "Output"]
}, Closed]],
Cell[493500, 17223, 192, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[493717, 17231, 703, 12, 156, "Input"],
Cell[494423, 17245, 56, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[494528, 17252, 75, 0, 45, "Subsection"],
Cell[494606, 17254, 276, 5, 48, "Text"],

Cell[CellGroupData[{
Cell[494907, 17263, 121, 2, 60, "Input"],
Cell[495031, 17267, 63, 1, 38, "Output"]
}, Closed]],
Cell[495109, 17271, 185, 4, 48, "Text"],
Cell[495297, 17277, 761, 14, 320, "Input"],
Cell[496061, 17293, 105, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[496191, 17300, 72, 1, 40, "Input"],
Cell[496266, 17303, 55, 1, 38, "Output"]
}, Closed]],
Cell[496336, 17307, 889, 22, 85, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[497274, 17335, 55, 0, 40, "Section"],
Cell[497332, 17337, 230, 8, 33, "Text",
  CellTags->"Pure Functions"]
}, Closed]],

Cell[CellGroupData[{
Cell[497599, 17350, 23, 0, 40, "Section"],
Cell[497625, 17352, 515, 9, 75, "Text",
  CellTags->"Sort"],

Cell[CellGroupData[{
Cell[498165, 17365, 113, 2, 39, "Input"],
Cell[498281, 17369, 291, 6, 37, "Output"]
}, Closed]],
Cell[498587, 17378, 446, 7, 75, "Text"],

Cell[CellGroupData[{
Cell[499058, 17389, 117, 2, 39, "Input"],
Cell[499178, 17393, 300, 7, 37, "Output"]
}, Closed]],
Cell[499493, 17403, 449, 10, 54, "Text"],

Cell[CellGroupData[{
Cell[499967, 17417, 124, 2, 39, "Input"],
Cell[500094, 17421, 300, 7, 37, "Output"]
}, Closed]],
Cell[500409, 17431, 225, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[500659, 17439, 224, 5, 99, "Input"],
Cell[500886, 17446, 488, 16, 174, "Output"]
}, Closed]],
Cell[501389, 17465, 107, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[501521, 17472, 102, 2, 59, "Input"],
Cell[501626, 17476, 488, 16, 160, "Output"]
}, Closed]],
Cell[502129, 17495, 173, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[502327, 17502, 140, 3, 60, "Input"],
Cell[502470, 17507, 488, 16, 160, "Output"]
}, Closed]],
Cell[502973, 17526, 590, 10, 85, "Text"],

Cell[CellGroupData[{
Cell[503588, 17540, 210, 4, 82, "Input"],
Cell[503801, 17546, 488, 16, 160, "Output"]
}, Closed]],
Cell[504304, 17565, 121, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[504450, 17572, 122, 2, 60, "Input"],
Cell[504575, 17576, 65, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[504689, 17583, 24, 0, 40, "Section"],
Cell[504716, 17585, 132, 4, 33, "Text",
  CellTags->"Split"],

Cell[CellGroupData[{
Cell[504873, 17593, 43, 1, 39, "Input"],
Cell[504919, 17596, 464, 11, 49, "Print",
  CellTags->"Info3242474961-5860318"]
}, Closed]],

Cell[CellGroupData[{
Cell[505420, 17612, 144, 2, 59, "Input"],
Cell[505567, 17616, 90, 1, 37, "Output"]
}, Closed]],
Cell[505672, 17620, 458, 10, 54, "Text"],

Cell[CellGroupData[{
Cell[506155, 17634, 216, 4, 79, "Input"],
Cell[506374, 17640, 113, 2, 37, "Output"]
}, Closed]],
Cell[506502, 17645, 272, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[506799, 17654, 216, 6, 110, "Input"],
Cell[507018, 17662, 211, 3, 57, "Output"]
}, Closed]],
Cell[507244, 17668, 137, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[507406, 17675, 83, 1, 39, "Input"],
Cell[507492, 17678, 105, 2, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[507646, 17686, 56, 0, 40, "Section"],
Cell[507705, 17688, 705, 13, 119, "Text"],
Cell[508413, 17703, 187, 3, 61, "Input"],
Cell[508603, 17708, 133, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[508761, 17715, 87, 1, 40, "Input"],
Cell[508851, 17718, 80, 1, 37, "Output"]
}, Closed]],
Cell[508946, 17722, 275, 6, 33, "Text"],

Cell[CellGroupData[{
Cell[509246, 17732, 54, 1, 39, "Input"],
Cell[509303, 17735, 44, 1, 37, "Output"]
}, Closed]],
Cell[509362, 17739, 99, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[509486, 17745, 54, 1, 39, "Input"],
Cell[509543, 17748, 168, 3, 39, "Output"]
}, Closed]],
Cell[509726, 17754, 65, 0, 33, "Text"],
Cell[509794, 17756, 64, 1, 39, "Input"],

Cell[CellGroupData[{
Cell[509883, 17761, 235, 6, 56, "Subsection"],

Cell[CellGroupData[{
Cell[510143, 17771, 68, 1, 39, "Input"],
Cell[510214, 17774, 116, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[510367, 17781, 73, 1, 39, "Input"],
Cell[510443, 17784, 113, 2, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[510593, 17791, 77, 1, 39, "Input"],
Cell[510673, 17794, 116, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[510826, 17801, 89, 1, 40, "Input"],
Cell[510918, 17804, 115, 2, 35, "Output"]
}, Closed]],
Cell[511048, 17809, 158, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[511231, 17817, 117, 2, 60, "Input"],
Cell[511351, 17821, 59, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[511447, 17827, 54, 1, 40, "Input"],
Cell[511504, 17830, 57, 1, 55, "Output"]
}, Closed]],
Cell[511576, 17834, 90, 1, 40, "Input"],
Cell[511669, 17837, 513, 14, 50, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[512219, 17856, 145, 4, 45, "Subsection"],
Cell[512367, 17862, 116, 2, 60, "Input"],
Cell[512486, 17866, 168, 6, 30, "Text"],

Cell[CellGroupData[{
Cell[512679, 17876, 84, 2, 60, "Input"],
Cell[512766, 17880, 38, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[512841, 17886, 55, 1, 40, "Input"],
Cell[512899, 17889, 49, 1, 37, "Output"]
}, Closed]],
Cell[512963, 17893, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[513052, 17899, 158, 3, 55, "Subsection"],
Cell[513213, 17904, 65, 1, 40, "Input"],
Cell[513281, 17907, 510, 15, 80, "Input"],

Cell[CellGroupData[{
Cell[513816, 17926, 107, 2, 60, "Input"],
Cell[513926, 17930, 58, 1, 35, "Output"]
}, Closed]],
Cell[513999, 17934, 47, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[514071, 17938, 57, 1, 40, "Input"],
Cell[514131, 17941, 52, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[514220, 17947, 43, 1, 40, "Input"],
Cell[514266, 17950, 67, 1, 35, "Output"]
}, Closed]],
Cell[514348, 17954, 657, 15, 107, "Text"],
Cell[515008, 17971, 591, 17, 80, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[515636, 17993, 368, 8, 65, "Subsection"],
Cell[516007, 18003, 65, 1, 40, "Input"],
Cell[516075, 18006, 166, 4, 43, "Input"],

Cell[CellGroupData[{
Cell[516266, 18014, 74, 1, 40, "Input"],
Cell[516343, 18017, 58, 1, 37, "Output"]
}, Closed]],
Cell[516416, 18021, 302, 7, 48, "Text"],

Cell[CellGroupData[{
Cell[516743, 18032, 52, 1, 40, "Input"],
Cell[516798, 18035, 58, 1, 37, "Output"]
}, Closed]],
Cell[516871, 18039, 206, 4, 48, "Text"],
Cell[517080, 18045, 172, 4, 43, "Input"],

Cell[CellGroupData[{
Cell[517277, 18053, 60, 1, 40, "Input"],
Cell[517340, 18056, 78, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[517467, 18063, 104, 2, 45, "Subsection"],
Cell[517574, 18067, 523, 10, 67, "Text"],
Cell[518100, 18079, 65, 1, 40, "Input"],
Cell[518168, 18082, 756, 16, 170, "Input"],
Cell[518927, 18100, 165, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[519117, 18108, 103, 2, 40, "Input"],
Cell[519223, 18112, 104, 2, 35, "Output"]
}, Closed]],
Cell[519342, 18117, 313, 9, 30, "Text"],

Cell[CellGroupData[{
Cell[519680, 18130, 61, 1, 40, "Input"],
Cell[519744, 18133, 58, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[519839, 18139, 44, 1, 40, "Input"],
Cell[519886, 18142, 66, 1, 35, "Output"]
}, Closed]],
Cell[519967, 18146, 3460, 107, 55, "Text"],
Cell[523430, 18255, 168, 3, 30, "Text"],
Cell[523601, 18260, 125, 1, 30, "Text"],
Cell[523729, 18263, 59, 0, 30, "Text"],
Cell[523791, 18265, 188, 6, 40, "Input",
  Evaluatable->False],
Cell[523982, 18273, 39, 0, 30, "Text"],
Cell[524024, 18275, 215, 6, 40, "Input",
  Evaluatable->False],
Cell[524242, 18283, 86, 2, 30, "Text"],
Cell[524331, 18287, 334, 10, 40, "Input",
  Evaluatable->False],
Cell[524668, 18299, 127, 1, 30, "Text"],
Cell[524798, 18302, 89, 2, 30, "Text"],
Cell[524890, 18306, 1338, 29, 307, "Text"],
Cell[526231, 18337, 43, 0, 30, "Text"],
Cell[526277, 18339, 94, 3, 40, "Input",
  Evaluatable->False],
Cell[526374, 18344, 139, 3, 30, "Text"],
Cell[526516, 18349, 209, 6, 40, "Input",
  Evaluatable->False],
Cell[526728, 18357, 212, 6, 90, "Text"],
Cell[526943, 18365, 334, 10, 40, "Input",
  Evaluatable->False],
Cell[527280, 18377, 127, 3, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[527444, 18385, 97, 2, 45, "Subsection"],
Cell[527544, 18389, 310, 5, 50, "Text"],
Cell[527857, 18396, 588, 12, 165, "Input"],
Cell[528448, 18410, 113, 3, 30, "Text"],
Cell[528564, 18415, 52, 1, 40, "Input"],
Cell[528619, 18418, 164, 6, 30, "Text"],
Cell[528786, 18426, 46, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[528857, 18431, 73, 1, 40, "Input"],
Cell[528933, 18434, 76, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[529058, 18441, 102, 2, 45, "Subsection"],
Cell[529163, 18445, 951, 22, 275, "Input"],
Cell[530117, 18469, 151, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[530293, 18476, 111, 2, 40, "Input"],
Cell[530407, 18480, 109, 2, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[530577, 18489, 25, 0, 40, "Section"],
Cell[530605, 18491, 172, 6, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[530814, 18502, 25, 0, 40, "Section"],
Cell[530842, 18504, 398, 9, 77, "Text",
  CellTags->"TagBox"],

Cell[CellGroupData[{
Cell[531265, 18517, 44, 1, 39, "Input"],
Cell[531312, 18520, 356, 9, 29, "Print",
  CellTags->"Info3242475074-9991669"]
}, Closed]],
Cell[531683, 18532, 200, 4, 54, "Text"],
Cell[531886, 18538, 223, 4, 59, "Input"],
Cell[532112, 18544, 213, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[532350, 18552, 63, 1, 39, "Input"],
Cell[532416, 18555, 71, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[532524, 18562, 47, 1, 39, "Input"],
Cell[532574, 18565, 161, 5, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[532784, 18576, 24, 0, 40, "Section"],
Cell[532811, 18578, 144, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[532980, 18585, 119, 2, 59, "Input"],
Cell[533102, 18589, 177, 3, 55, "Output"]
}, Closed]],
Cell[533294, 18595, 107, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[533426, 18602, 62, 1, 39, "Input"],
Cell[533491, 18605, 183, 3, 55, "Output"]
}, Closed]],
Cell[533689, 18611, 305, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[534019, 18622, 57, 1, 39, "Input"],
Cell[534079, 18625, 177, 3, 55, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[534293, 18633, 57, 1, 39, "Input"],
Cell[534353, 18636, 183, 3, 55, "Output"]
}, Closed]],
Cell[534551, 18642, 303, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[534879, 18651, 58, 1, 39, "Input"],
Cell[534940, 18654, 428, 6, 57, "Output"]
}, Closed]],
Cell[535383, 18663, 106, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[535514, 18670, 82, 1, 39, "Input"],
Cell[535599, 18673, 1240, 36, 188, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[536888, 18715, 25, 0, 40, "Section"],
Cell[536916, 18717, 196, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[537137, 18725, 137, 2, 59, "Input"],
Cell[537277, 18729, 64, 1, 37, "Output"]
}, Closed]],
Cell[537356, 18733, 115, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[537496, 18740, 76, 1, 39, "Input"],
Cell[537575, 18743, 85, 1, 37, "Output"]
}, Closed]],
Cell[537675, 18747, 204, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[537904, 18755, 79, 1, 39, "Input"],
Cell[537986, 18758, 121, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[538144, 18765, 82, 1, 39, "Input"],
Cell[538229, 18768, 105, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[538371, 18775, 83, 1, 39, "Input"],
Cell[538457, 18778, 78, 1, 37, "Output"]
}, Closed]],
Cell[538550, 18782, 232, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[538807, 18790, 166, 4, 79, "Input"],
Cell[538976, 18796, 137, 2, 37, "Output"]
}, Closed]],
Cell[539128, 18801, 319, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[539472, 18810, 48, 1, 39, "Input"],
Cell[539523, 18813, 132, 2, 59, "Output"]
}, Closed]],
Cell[539670, 18818, 172, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[539867, 18825, 168, 4, 82, "Input"],
Cell[540038, 18831, 116, 2, 38, "Output"]
}, Closed]],
Cell[540169, 18836, 129, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[540323, 18843, 56, 1, 40, "Input"],
Cell[540382, 18846, 116, 2, 38, "Output"]
}, Closed]],
Cell[540513, 18851, 133, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[540671, 18858, 56, 1, 40, "Input"],
Cell[540730, 18861, 116, 2, 38, "Output"]
}, Closed]],
Cell[540861, 18866, 279, 5, 66, "Text"],
Cell[541143, 18873, 340, 7, 125, "Input"],
Cell[541486, 18882, 93, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[541604, 18888, 179, 4, 105, "Input"],
Cell[541786, 18894, 54, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[541889, 18901, 30, 0, 40, "Section"],
Cell[541922, 18903, 113, 3, 33, "Text",
  CellTags->"Trig option"],

Cell[CellGroupData[{
Cell[542060, 18910, 42, 1, 39, "Input"],
Cell[542105, 18913, 236, 4, 49, "Print",
  CellTags->"Info3242475074-3476455"]
}, Closed]],
Cell[542356, 18920, 891, 15, 183, "Text"],

Cell[CellGroupData[{
Cell[543272, 18939, 118, 2, 59, "Input"],
Cell[543393, 18943, 51, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[543481, 18949, 68, 1, 39, "Input"],
Cell[543552, 18952, 55, 1, 54, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[543644, 18958, 76, 1, 39, "Input"],
Cell[543723, 18961, 43, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[543815, 18968, 27, 0, 40, "Section"],
Cell[543845, 18970, 399, 7, 75, "Text",
  CellTags->"ToString"],
Cell[544247, 18979, 198, 4, 99, "Input"],
Cell[544448, 18985, 130, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[544603, 18992, 59, 1, 39, "Input"],
Cell[544665, 18995, 26, 0, 36, "Output"]
}, Closed]],
Cell[544706, 18998, 433, 7, 75, "Text"],
Cell[545142, 19007, 292, 6, 79, "Input"],

Cell[CellGroupData[{
Cell[545459, 19017, 46, 1, 39, "Input"],
Cell[545508, 19020, 54, 1, 37, "Output"]
}, Closed]],
Cell[545577, 19024, 72, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[545674, 19028, 37, 1, 39, "Input"],
Cell[545714, 19031, 36, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[545799, 19038, 21, 0, 40, "Section"],
Cell[545823, 19040, 138, 4, 33, "Text",
  CellTags->"Tr"],

Cell[CellGroupData[{
Cell[545986, 19048, 133, 2, 59, "Input"],
Cell[546122, 19052, 39, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[546198, 19058, 238, 4, 139, "Input"],
Cell[546439, 19064, 49, 1, 37, "Output"]
}, Closed]],
Cell[546503, 19068, 758, 18, 75, "Text"],

Cell[CellGroupData[{
Cell[547286, 19090, 52, 1, 39, "Input"],
Cell[547341, 19093, 51, 1, 37, "Output"]
}, Closed]],
Cell[547407, 19097, 95, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[547527, 19103, 261, 4, 79, "Input"],
Cell[547791, 19109, 46, 1, 37, "Output"]
}, Closed]],
Cell[547852, 19113, 99, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[547976, 19119, 39, 1, 39, "Input"],
Cell[548018, 19122, 41, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[548096, 19128, 48, 1, 39, "Input"],
Cell[548147, 19131, 41, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[548225, 19137, 78, 1, 40, "Input"],
Cell[548306, 19140, 41, 1, 37, "Output"]
}, Closed]],
Cell[548362, 19144, 43, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[548430, 19148, 48, 1, 40, "Input"],
Cell[548481, 19151, 52, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[548570, 19157, 70, 1, 40, "Input"],
Cell[548643, 19160, 52, 1, 37, "Output"]
}, Closed]],
Cell[548710, 19164, 43, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[548778, 19168, 48, 1, 40, "Input"],
Cell[548829, 19171, 103, 2, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[548969, 19178, 64, 1, 40, "Input"],
Cell[549036, 19181, 103, 2, 37, "Output"]
}, Closed]],
Cell[549154, 19186, 46, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[549225, 19190, 48, 1, 40, "Input"],
Cell[549276, 19193, 180, 3, 57, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[549493, 19201, 58, 1, 40, "Input"],
Cell[549554, 19204, 180, 3, 57, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[549783, 19213, 28, 0, 40, "Section"],
Cell[549814, 19215, 231, 5, 55, "Text"],

Cell[CellGroupData[{
Cell[550070, 19224, 286, 5, 99, "Input"],
Cell[550359, 19231, 901, 23, 94, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[551297, 19259, 82, 1, 39, "Input"],
Cell[551382, 19262, 901, 23, 94, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[552320, 19290, 105, 2, 39, "Input"],
Cell[552428, 19294, 901, 23, 94, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[553366, 19322, 74, 1, 39, "Input"],
Cell[553443, 19325, 901, 23, 94, "Output"]
}, Closed]],
Cell[554359, 19351, 109, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[554493, 19358, 68, 1, 39, "Input"],
Cell[554564, 19361, 812, 22, 94, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[555425, 19389, 30, 0, 40, "Section"],
Cell[555458, 19391, 359, 7, 54, "Text",
  CellTags->"Unevaluated"],

Cell[CellGroupData[{
Cell[555842, 19402, 64, 1, 40, "Input"],
Cell[555909, 19405, 90, 3, 37, "Output"]
}, Closed]],
Cell[556014, 19411, 477, 9, 98, "Text"],
Cell[556494, 19422, 199, 4, 79, "Input"],
Cell[556696, 19428, 183, 4, 33, "Text"],

Cell[CellGroupData[{
Cell[556904, 19436, 107, 2, 59, "Input"],
Cell[557014, 19440, 58, 1, 37, "Output"]
}, Closed]],
Cell[557087, 19444, 281, 10, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[557405, 19459, 25, 0, 40, "Section"],
Cell[557433, 19461, 214, 7, 33, "Text",
  CellTags->"Update"]
}, Closed]],

Cell[CellGroupData[{
Cell[557684, 19473, 27, 0, 40, "Section"],
Cell[557714, 19475, 356, 6, 54, "Text",
  CellTags->"Upvalues"],
Cell[558073, 19483, 130, 2, 59, "Input"],
Cell[558206, 19487, 208, 6, 33, "Text"],
Cell[558417, 19495, 62, 1, 39, "Input"],
Cell[558482, 19498, 72, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[558579, 19502, 73, 1, 66, "Input"],
Cell[558655, 19505, 105, 2, 55, "Output"]
}, Closed]],
Cell[558775, 19510, 760, 13, 96, "Text"],

Cell[CellGroupData[{
Cell[559560, 19527, 76, 1, 43, "Input"],
Cell[559639, 19530, 70, 1, 40, "Output"]
}, Closed]],
Cell[559724, 19534, 145, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[559894, 19541, 87, 1, 43, "Input"],
Cell[559984, 19544, 92, 1, 45, "Output"]
}, Closed]],
Cell[560091, 19548, 1705, 41, 182, "Text"],

Cell[CellGroupData[{
Cell[561821, 19593, 49, 1, 40, "Input"],
Cell[561873, 19596, 113, 2, 37, "Output"]
}, Closed]],
Cell[562001, 19601, 321, 5, 48, "Text"],
Cell[562325, 19608, 56, 1, 40, "Input"],
Cell[562384, 19611, 277, 9, 30, "Text"],
Cell[562664, 19622, 70, 1, 40, "Input"],
Cell[562737, 19625, 234, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[562996, 19633, 47, 1, 40, "Input"],
Cell[563046, 19636, 113, 2, 37, "Output"]
}, Closed]],
Cell[563174, 19641, 286, 5, 48, "Text"],

Cell[CellGroupData[{
Cell[563485, 19650, 54, 1, 40, "Input"],
Cell[563542, 19653, 52, 1, 37, "Output"]
}, Closed]],
Cell[563609, 19657, 164, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[563798, 19664, 50, 1, 40, "Input"],
Cell[563851, 19667, 52, 1, 38, "Output"]
}, Closed]],
Cell[563918, 19671, 1550, 32, 158, "Text"],

Cell[CellGroupData[{
Cell[565493, 19707, 71, 1, 61, "Input"],
Cell[565567, 19710, 72, 1, 53, "Output"]
}, Closed]],
Cell[565654, 19714, 548, 10, 105, "Text"],
Cell[566205, 19726, 56, 1, 40, "Input"],
Cell[566264, 19729, 513, 11, 67, "Text"],
Cell[566780, 19742, 70, 1, 40, "Input"],
Cell[566853, 19745, 515, 9, 67, "Text"],
Cell[567371, 19756, 63, 1, 40, "Input"],
Cell[567437, 19759, 496, 11, 67, "Text"],
Cell[567936, 19772, 188, 3, 83, "Input"],

Cell[CellGroupData[{
Cell[568149, 19779, 56, 1, 43, "Input"],
Cell[568208, 19782, 76, 1, 40, "Output"]
}, Closed]],
Cell[568299, 19786, 244, 4, 48, "Text"],
Cell[568546, 19792, 136, 2, 61, "Input"],

Cell[CellGroupData[{
Cell[568707, 19798, 56, 1, 43, "Input"],
Cell[568766, 19801, 58, 1, 40, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[568861, 19807, 112, 3, 56, "Subsection"],
Cell[568976, 19812, 679, 13, 67, "Text"],
Cell[569658, 19827, 197, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[569880, 19834, 74, 1, 40, "Input"],
Cell[569957, 19837, 35, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[570029, 19843, 48, 1, 40, "Input"],
Cell[570080, 19846, 89, 1, 35, "Output"]
}, Closed]],
Cell[570184, 19850, 97, 2, 30, "Text"],
Cell[570284, 19854, 149, 3, 80, "Input"],

Cell[CellGroupData[{
Cell[570458, 19861, 74, 1, 40, "Input"],
Cell[570535, 19864, 35, 1, 35, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[570607, 19870, 49, 1, 40, "Input"],
Cell[570659, 19873, 89, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[570797, 19880, 128, 3, 45, "Subsection"],
Cell[570928, 19885, 214, 3, 80, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[571191, 19894, 27, 0, 40, "Section"],
Cell[571221, 19896, 82, 1, 33, "Text",
  CellTags->"Verbatim"],

Cell[CellGroupData[{
Cell[571328, 19901, 46, 1, 39, "Input"],
Cell[571377, 19904, 423, 10, 49, "Print",
  CellTags->"Info3247899362-8348536"]
}, Closed]],
Cell[571815, 19917, 211, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[572051, 19925, 55, 1, 39, "Input"],
Cell[572109, 19928, 226, 6, 37, "Output"]
}, Closed]],
Cell[572350, 19937, 227, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[572602, 19945, 87, 1, 39, "Input"],
Cell[572692, 19948, 55, 1, 37, "Output"]
}, Closed]],
Cell[572762, 19952, 263, 5, 54, "Text"],

Cell[CellGroupData[{
Cell[573050, 19961, 110, 2, 39, "Input"],
Cell[573163, 19965, 43, 1, 37, "Output"]
}, Closed]],
Cell[573221, 19969, 132, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[573378, 19976, 186, 3, 59, "Input"],
Cell[573567, 19981, 61, 1, 37, "Output"]
}, Closed]],
Cell[573643, 19985, 328, 8, 54, "Text"],

Cell[CellGroupData[{
Cell[573996, 19997, 113, 2, 39, "Input"],
Cell[574112, 20001, 37, 1, 37, "Output"]
}, Closed]],
Cell[574164, 20005, 152, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[574341, 20012, 133, 2, 40, "Input"],
Cell[574477, 20016, 53, 1, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[574579, 20023, 31, 0, 40, "Section"],
Cell[574613, 20025, 90, 1, 33, "Text",
  CellTags->"$OutputForms"],

Cell[CellGroupData[{
Cell[574728, 20030, 50, 1, 39, "Input"],
Cell[574781, 20033, 179, 3, 29, "Print",
  CellTags->"Info3240648369-5591269"]
}, Closed]],

Cell[CellGroupData[{
Cell[574997, 20041, 103, 2, 39, "Input"],
Cell[575103, 20045, 295, 8, 84, "Output"]
}, Closed]],
Cell[575413, 20056, 76, 0, 33, "Text"],

Cell[CellGroupData[{
Cell[575514, 20060, 51, 1, 39, "Input"],
Cell[575568, 20063, 52, 1, 37, "Output"]
}, Closed]],
Cell[575635, 20067, 96, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[575756, 20073, 150, 2, 59, "Input"],
Cell[575909, 20077, 314, 4, 77, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[576260, 20086, 103, 2, 39, "Input"],
Cell[576366, 20090, 295, 8, 84, "Output"]
}, Closed]],
Cell[576676, 20101, 132, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[576833, 20108, 51, 1, 39, "Input"],
Cell[576887, 20111, 58, 1, 37, "Output"]
}, Closed]],
Cell[576960, 20115, 75, 0, 33, "Text"],
Cell[577038, 20117, 86, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[577161, 20123, 51, 0, 40, "Section"],
Cell[577215, 20125, 1392, 28, 296, "Text",
  CellTags->"$Pre;$Post"],

Cell[CellGroupData[{
Cell[578632, 20157, 30, 0, 56, "Subsection"],
Cell[578665, 20159, 587, 12, 209, "Text"],
Cell[579255, 20173, 50, 1, 82, "Input"],
Cell[579308, 20176, 203, 5, 37, "Text"],
Cell[579514, 20183, 349, 7, 59, "Input"],

Cell[CellGroupData[{
Cell[579888, 20194, 50, 1, 82, "Input"],
Cell[579941, 20197, 61, 1, 47, "Output"]
}, Closed]],
Cell[580017, 20201, 68, 0, 33, "Text"],
Cell[580088, 20203, 45, 1, 39, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[580170, 20209, 26, 0, 56, "Subsection"],
Cell[580199, 20211, 261, 5, 54, "Text"],
Cell[580463, 20218, 251, 6, 61, "Input"],
Cell[580717, 20226, 133, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[580875, 20233, 50, 1, 67, "Input"],
Cell[580928, 20236, 55, 1, 65, "Output"]
}, Closed]],
Cell[580998, 20240, 64, 0, 30, "Text"],
Cell[581065, 20242, 41, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[581143, 20248, 27, 0, 44, "Subsection"],
Cell[581173, 20250, 541, 8, 85, "Text"],
Cell[581717, 20260, 199, 4, 61, "Input"],
Cell[581919, 20266, 129, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[582073, 20273, 146, 3, 61, "Input"],
Cell[582222, 20278, 269, 8, 70, "Output"],
Cell[582494, 20288, 46, 1, 37, "Output"]
}, Closed]],
Cell[582555, 20292, 102, 3, 30, "Text"],
Cell[582660, 20297, 155, 2, 61, "Input"],
Cell[582818, 20301, 99, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[582942, 20307, 146, 3, 61, "Input"],
Cell[583091, 20312, 269, 8, 70, "Output"],
Cell[583363, 20322, 52, 1, 37, "Output"]
}, Closed]],
Cell[583430, 20326, 121, 3, 30, "Text"],
Cell[583554, 20331, 149, 2, 61, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[583740, 20338, 31, 0, 44, "Subsection"],
Cell[583774, 20340, 404, 6, 65, "Text"],
Cell[584181, 20348, 203, 4, 60, "Input"],
Cell[584387, 20354, 244, 4, 47, "Text"],

Cell[CellGroupData[{
Cell[584656, 20362, 146, 3, 60, "Input"],
Cell[584805, 20367, 269, 8, 70, "Output"],
Cell[585077, 20377, 46, 1, 35, "Output"]
}, Closed]],
Cell[585138, 20381, 72, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[585247, 20387, 62, 0, 44, "Subsection"],
Cell[585312, 20389, 63, 0, 30, "Text"],
Cell[585378, 20391, 173, 3, 60, "Input"],
Cell[585554, 20396, 275, 5, 47, "Text"],

Cell[CellGroupData[{
Cell[585854, 20405, 42, 1, 40, "Input"],
Cell[585899, 20408, 43, 1, 35, "Output"]
}, Closed]],
Cell[585957, 20412, 241, 4, 47, "Text"],

Cell[CellGroupData[{
Cell[586223, 20420, 98, 2, 60, "Input"],
Cell[586324, 20424, 39, 1, 35, "Output"]
}, Closed]],
Cell[586378, 20428, 207, 4, 47, "Text"],
Cell[586588, 20434, 154, 2, 60, "Input"],

Cell[CellGroupData[{
Cell[586767, 20440, 42, 1, 40, "Input"],
Cell[586812, 20443, 43, 1, 35, "Output"]
}, Closed]],
Cell[586870, 20447, 121, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[587016, 20454, 115, 2, 60, "Input"],
Cell[587134, 20458, 43, 1, 35, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[587238, 20466, 72, 1, 45, "Section"],

Cell[CellGroupData[{
Cell[587335, 20471, 32, 0, 56, "Subsection"],
Cell[587370, 20473, 300, 5, 48, "ExampleText",
  CellTags->{"ReplacePart", "Evaluate At"}],
Cell[587673, 20480, 179, 4, 39, "Input",
  CellTags->"ReplacePart"],
Cell[587855, 20486, 238, 7, 29, "ExampleText",
  CellTags->"ReplacePart"],

Cell[CellGroupData[{
Cell[588118, 20497, 140, 4, 39, "Input",
  CellTags->"ReplacePart"],
Cell[588261, 20503, 75, 2, 37, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[588385, 20511, 38, 0, 56, "Subsection"],
Cell[588426, 20513, 733, 14, 119, "Text",
  CellTags->"Evaluate Pattern"],
Cell[589162, 20529, 536, 16, 39, "Input"],
Cell[589701, 20547, 339, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[590065, 20558, 209, 5, 101, "Input"],
Cell[590277, 20565, 82, 2, 55, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[590408, 20573, 69, 0, 56, "Subsection"],
Cell[590480, 20575, 869, 16, 199, "Input"],
Cell[591352, 20593, 478, 15, 230, "Text"],
Cell[591833, 20610, 140, 3, 40, "Input"],
Cell[591976, 20615, 102, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[592103, 20622, 76, 1, 40, "Input"],
Cell[592182, 20625, 130, 2, 55, "Output"]
}, Closed]],
Cell[592327, 20630, 111, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[592463, 20637, 87, 1, 40, "Input"],
Cell[592553, 20640, 128, 2, 55, "Output"]
}, Closed]],
Cell[592696, 20645, 125, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[592846, 20652, 110, 2, 40, "Input"],
Cell[592959, 20656, 130, 2, 55, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[593138, 20664, 48, 0, 44, "Subsection"],
Cell[593189, 20666, 298, 6, 86, "Text"],

Cell[CellGroupData[{
Cell[593512, 20676, 281, 6, 103, "Input"],
Cell[593796, 20684, 38580, 738, 193, 4515, 313, "GraphicsData", "PostScript", \
"Graphics"]
}, Closed]],
Cell[632391, 21425, 523, 10, 85, "Text"],
Cell[632917, 21437, 213, 4, 82, "Input"],

Cell[CellGroupData[{
Cell[633155, 21445, 149, 4, 56, "Input",
  CellTags->"S5.12.1"],
Cell[633307, 21451, 658, 10, 146, "Output"]
}, Closed]],
Cell[633980, 21464, 342, 7, 66, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[634359, 21476, 38, 0, 44, "Subsection"],
Cell[634400, 21478, 205, 7, 30, "Text",
  CellTags->"FoldList_Example1"],

Cell[CellGroupData[{
Cell[634630, 21489, 374, 8, 146, "Input"],
Cell[635007, 21499, 72, 1, 38, "Output"]
}, Closed]],
Cell[635094, 21503, 106, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[635225, 21510, 207, 5, 82, "Input"],
Cell[635435, 21517, 78, 1, 29, "Print"],
Cell[635516, 21520, 76, 1, 29, "Print"],
Cell[635595, 21523, 70, 1, 29, "Print"],
Cell[635668, 21526, 61, 1, 29, "Print"],
Cell[635732, 21529, 49, 1, 29, "Print"]
}, Closed]],
Cell[635796, 21533, 124, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[635945, 21540, 78, 1, 40, "Input"],
Cell[636026, 21543, 556, 22, 111, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[636619, 21570, 94, 2, 61, "Input"],
Cell[636716, 21574, 45, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[636810, 21581, 40, 0, 44, "Subsection"],
Cell[636853, 21583, 46, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[636924, 21587, 324, 6, 167, "Input"],
Cell[637251, 21595, 55, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[637355, 21602, 63, 0, 44, "Subsection"],
Cell[637421, 21604, 48, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[637494, 21608, 368, 7, 167, "Input"],
Cell[637865, 21617, 61, 1, 41, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[637975, 21624, 75, 0, 44, "Subsection"],
Cell[638053, 21626, 278, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[638356, 21635, 202, 4, 82, "Input"],
Cell[638561, 21641, 370, 8, 60, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[638968, 21654, 133, 2, 61, "Input"],
Cell[639104, 21658, 146, 2, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[639299, 21666, 62, 0, 44, "Subsection"],
Cell[639364, 21668, 187, 4, 50, "Text"],
Cell[639554, 21674, 243, 5, 125, "Input"],
Cell[639800, 21681, 64, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[639889, 21685, 46, 1, 40, "Input"],
Cell[639938, 21688, 254, 4, 57, "Output"]
}, Closed]],
Cell[640207, 21695, 241, 5, 67, "Text"],

Cell[CellGroupData[{
Cell[640473, 21704, 72, 1, 40, "Input"],
Cell[640548, 21707, 65, 1, 35, "Output"]
}, Closed]],
Cell[640628, 21711, 458, 9, 190, "Input"],
Cell[641089, 21722, 97, 3, 50, "Text"],

Cell[CellGroupData[{
Cell[641211, 21729, 42, 1, 40, "Input"],
Cell[641256, 21732, 60, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[641365, 21739, 59, 0, 44, "Subsection"],
Cell[641427, 21741, 247, 7, 48, "Text"],
Cell[641677, 21750, 407, 8, 146, "Input"],
Cell[642087, 21760, 146, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[642258, 21767, 153, 3, 64, "Input"],
Cell[642414, 21772, 52, 1, 50, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[642503, 21778, 71, 1, 40, "Input"],
Cell[642577, 21781, 35, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[642649, 21787, 72, 1, 55, "Input"],
Cell[642724, 21790, 35, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[642796, 21796, 74, 1, 40, "Input"],
Cell[642873, 21799, 41, 1, 40, "Output"]
}, Closed]],
Cell[642929, 21803, 110, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[643064, 21810, 53, 1, 40, "Input"],
Cell[643120, 21813, 54, 1, 38, "Output"]
}, Closed]],
Cell[643189, 21817, 114, 3, 30, "Text"],
Cell[643306, 21822, 367, 7, 210, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[643710, 21834, 50, 0, 44, "Subsection"],
Cell[643763, 21836, 303, 5, 105, "Input"],

Cell[CellGroupData[{
Cell[644091, 21845, 171, 3, 82, "Input"],
Cell[644265, 21850, 459, 9, 87, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[644773, 21865, 99, 2, 44, "Subsection"],
Cell[644875, 21869, 398, 8, 67, "Text"],

Cell[CellGroupData[{
Cell[645298, 21881, 300, 5, 106, "Input"],
Cell[645601, 21888, 971, 24, 60, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[646609, 21917, 48, 0, 38, "Input"],
Cell[646660, 21919, 1620, 42, 186, "Output"]
}, Closed]],
Cell[648295, 21964, 445, 12, 220, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[648777, 21981, 69, 0, 44, "Subsection"],
Cell[648849, 21983, 268, 5, 47, "Text"],
Cell[649120, 21990, 213, 3, 82, "Input"],

Cell[CellGroupData[{
Cell[649358, 21997, 70, 1, 40, "Input"],
Cell[649431, 22000, 68, 1, 35, "Output"]
}, Closed]],
Cell[649514, 22004, 243, 4, 47, "Text"],
Cell[649760, 22010, 175, 4, 35, "Input"],
Cell[649938, 22016, 394, 8, 47, "Text"],
Cell[650335, 22026, 76, 1, 40, "Input"],
Cell[650414, 22029, 164, 3, 30, "Text"],
Cell[650581, 22034, 234, 5, 40, "Input"],
Cell[650818, 22041, 311, 5, 47, "Text"],
Cell[651132, 22048, 1280, 36, 147, "Input"],

Cell[CellGroupData[{
Cell[652437, 22088, 51, 1, 40, "Input"],
Cell[652491, 22091, 77, 1, 35, "Output"]
}, Closed]],
Cell[652583, 22095, 366, 8, 47, "Text",
  CellTags->"RelativePrimes_Fold"],
Cell[652952, 22105, 286, 5, 82, "Input"],

Cell[CellGroupData[{
Cell[653263, 22114, 77, 0, 52, "Subsubsection"],
Cell[653343, 22116, 470, 10, 110, "Text"],

Cell[CellGroupData[{
Cell[653838, 22130, 74, 1, 40, "Input"],
Cell[653915, 22133, 202, 3, 57, "Output"]
}, Closed]],
Cell[654132, 22139, 117, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[654274, 22146, 52, 1, 40, "Input"],
Cell[654329, 22149, 200, 3, 57, "Output"]
}, Closed]],
Cell[654544, 22155, 113, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[654682, 22162, 70, 1, 40, "Input"],
Cell[654755, 22165, 77, 1, 35, "Output"]
}, Closed]],
Cell[654847, 22169, 105, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[654977, 22176, 134, 3, 40, "Input"],
Cell[655114, 22181, 77, 1, 35, "Output"]
}, Closed]],
Cell[655206, 22185, 182, 4, 30, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[655437, 22195, 49, 0, 44, "Subsection"],
Cell[655489, 22197, 266, 6, 68, "Text",
  CellTags->"Algebra_Transformation"],

Cell[CellGroupData[{
Cell[655780, 22207, 187, 3, 61, "Input"],
Cell[655970, 22212, 64, 1, 38, "Output"]
}, Closed]],
Cell[656049, 22216, 366, 9, 66, "Text"],
Cell[656418, 22227, 291, 6, 61, "Input"],

Cell[CellGroupData[{
Cell[656734, 22237, 80, 1, 40, "Input"],
Cell[656817, 22240, 64, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[656930, 22247, 36, 0, 44, "Subsection"],
Cell[656969, 22249, 382, 9, 66, "Text",
  CellTags->"Together"],

Cell[CellGroupData[{
Cell[657376, 22262, 151, 2, 83, "Input"],
Cell[657530, 22266, 123, 2, 53, "Output"]
}, Closed]],
Cell[657668, 22271, 88, 1, 60, "Input"],
Cell[657759, 22274, 174, 3, 48, "Text"],
Cell[657936, 22279, 226, 4, 82, "Input"],
Cell[658165, 22285, 113, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[658303, 22292, 92, 1, 60, "Input"],
Cell[658398, 22295, 121, 2, 53, "Output"]
}, Closed]],
Cell[658534, 22300, 512, 10, 85, "Text"],

Cell[CellGroupData[{
Cell[659071, 22314, 120, 2, 62, "Input"],
Cell[659194, 22318, 115, 2, 38, "Output"]
}, Closed]],
Cell[659324, 22323, 99, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[659448, 22329, 83, 1, 40, "Input"],
Cell[659534, 22332, 69, 1, 38, "Output"]
}, Closed]],
Cell[659618, 22336, 522, 8, 103, "Text"],
Cell[660143, 22346, 1180, 22, 443, "Input"],
Cell[661326, 22370, 60, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[661411, 22374, 92, 1, 60, "Input"],
Cell[661506, 22377, 121, 2, 53, "Output"]
}, Closed]],
Cell[661642, 22382, 97, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[661764, 22388, 56, 1, 40, "Input"],
Cell[661823, 22391, 116, 2, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[661988, 22399, 51, 0, 44, "Subsection"],
Cell[662042, 22401, 90, 1, 30, "Text",
  CellTags->"Tensor_to_Matrix"],

Cell[CellGroupData[{
Cell[662157, 22406, 319, 5, 146, "Input"],
Cell[662479, 22413, 1166, 28, 130, "Output"]
}, Closed]],
Cell[663660, 22444, 278, 5, 66, "Text"],
Cell[663941, 22451, 424, 11, 130, "Output"],
Cell[664368, 22464, 90, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[664483, 22470, 386, 10, 61, "Input"],
Cell[664872, 22482, 443, 11, 130, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[665352, 22498, 176, 4, 61, "Input"],
Cell[665531, 22504, 443, 11, 130, "Output"]
}, Closed]],
Cell[665989, 22518, 104, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[666118, 22525, 926, 18, 316, "Input"],
Cell[667047, 22545, 4297, 91, 169, "Output"]
}, Closed]],
Cell[671359, 22639, 165, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[671549, 22646, 961, 27, 103, "Input"],
Cell[672513, 22675, 675, 13, 169, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[673237, 22694, 54, 0, 44, "Subsection"],
Cell[673294, 22696, 1267, 20, 235, "Text",
  CellTags->"Distribute - Application"],

Cell[CellGroupData[{
Cell[674586, 22720, 123, 2, 60, "Input"],
Cell[674712, 22724, 82, 1, 35, "Output"]
}, Closed]],
Cell[674809, 22728, 95, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[674929, 22734, 65, 1, 40, "Input"],
Cell[674997, 22737, 431, 6, 100, "Output"]
}, Closed]],
Cell[675443, 22746, 343, 6, 65, "Text"],

Cell[CellGroupData[{
Cell[675811, 22756, 80, 1, 40, "Input"],
Cell[675894, 22759, 163, 2, 35, "Output"]
}, Closed]],
Cell[676072, 22764, 266, 5, 47, "Text"],

Cell[CellGroupData[{
Cell[676363, 22773, 133, 3, 40, "Input"],
Cell[676499, 22778, 510, 7, 100, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[677058, 22791, 43, 0, 44, "Subsection"],
Cell[677104, 22793, 618, 14, 85, "Text",
  CellTags->"DeleteRepititions"],
Cell[677725, 22809, 236, 4, 103, "Input"],
Cell[677964, 22815, 56, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[678045, 22819, 92, 1, 40, "Input"],
Cell[678140, 22822, 49, 1, 38, "Output"]
}, Closed]],
Cell[678204, 22826, 221, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[678450, 22834, 110, 2, 40, "Input"],
Cell[678563, 22838, 55, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[678679, 22846, 41, 0, 40, "Section"],
Cell[678723, 22848, 1697, 41, 248, "Text",
  CellTags->"Evaluation-Process"],

Cell[CellGroupData[{
Cell[680445, 22893, 59, 0, 56, "Subsection"],
Cell[680507, 22895, 931, 15, 161, "Text"],

Cell[CellGroupData[{
Cell[681463, 22914, 142, 3, 79, "Input"],
Cell[681608, 22919, 124, 2, 28, "Message"],
Cell[681735, 22923, 51, 1, 37, "Output"]
}, Closed]],
Cell[681801, 22927, 326, 7, 77, "Text"],
Cell[682130, 22936, 357, 10, 70, "Text"],
Cell[682490, 22948, 143, 5, 70, "Text"],
Cell[682636, 22955, 303, 7, 91, "Text"],
Cell[682942, 22964, 1164, 25, 221, "Text"],
Cell[684109, 22991, 256, 9, 65, "Text"],

Cell[CellGroupData[{
Cell[684390, 23004, 185, 3, 82, "Input"],
Cell[684578, 23009, 51, 1, 38, "Output"]
}, Closed]],
Cell[684644, 23013, 320, 10, 84, "Text"],

Cell[CellGroupData[{
Cell[684989, 23027, 139, 2, 61, "Input"],
Cell[685131, 23031, 55, 1, 38, "Output"]
}, Closed]],
Cell[685201, 23035, 93, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[685319, 23041, 208, 3, 82, "Input"],
Cell[685530, 23046, 75, 1, 38, "Output"]
}, Closed]],
Cell[685620, 23050, 256, 6, 84, "Text"],

Cell[CellGroupData[{
Cell[685901, 23060, 182, 3, 82, "Input"],
Cell[686086, 23065, 62, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[686185, 23071, 57, 1, 40, "Input"],
Cell[686245, 23074, 62, 1, 38, "Output"]
}, Closed]],
Cell[686322, 23078, 333, 8, 102, "Text"],

Cell[CellGroupData[{
Cell[686680, 23090, 181, 3, 82, "Input"],
Cell[686864, 23095, 51, 1, 38, "Output"]
}, Closed]],
Cell[686930, 23099, 907, 21, 175, "Text"],
Cell[687840, 23122, 129, 2, 61, "Input"],
Cell[687972, 23126, 362, 8, 101, "Text"],
Cell[688337, 23136, 339, 12, 65, "Text"],
Cell[688679, 23150, 401, 10, 83, "Text"],
Cell[689083, 23162, 55, 1, 40, "Input"],
Cell[689141, 23165, 256, 8, 65, "Text"],
Cell[689400, 23175, 200, 6, 65, "Text"],
Cell[689603, 23183, 346, 10, 83, "Text"],
Cell[689952, 23195, 277, 7, 83, "Text"],
Cell[690232, 23204, 360, 8, 101, "Text",
  CellTags->"Unevaluated-Advanced"],

Cell[CellGroupData[{
Cell[690617, 23216, 167, 3, 82, "Input"],
Cell[690787, 23221, 55, 1, 38, "Output"]
}, Closed]],
Cell[690857, 23225, 184, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[691066, 23233, 187, 4, 61, "Input"],
Cell[691256, 23239, 120, 3, 38, "Output"]
}, Closed]],
Cell[691391, 23245, 128, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[691544, 23252, 183, 3, 82, "Input"],
Cell[691730, 23257, 45, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[691824, 23264, 35, 0, 44, "Subsection"],
Cell[691862, 23266, 261, 5, 66, "Text"],
Cell[692126, 23273, 262, 7, 167, "Input"],
Cell[692391, 23282, 68, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[692484, 23286, 50, 1, 40, "Input"],
Cell[692537, 23289, 62, 1, 38, "Output"]
}, Closed]],
Cell[692614, 23293, 214, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[692853, 23301, 604, 12, 210, "Input"],
Cell[693460, 23315, 46, 1, 29, "Print"],
Cell[693509, 23318, 48, 1, 29, "Print"],
Cell[693560, 23321, 52, 1, 29, "Print"],
Cell[693615, 23324, 56, 1, 29, "Print"],
Cell[693674, 23327, 46, 1, 29, "Print"],
Cell[693723, 23330, 48, 1, 29, "Print"],
Cell[693774, 23333, 52, 1, 29, "Print"],
Cell[693829, 23336, 48, 1, 29, "Print"],
Cell[693880, 23339, 48, 1, 29, "Print"],
Cell[693931, 23342, 62, 1, 38, "Output"]
}, Closed]],
Cell[694008, 23346, 158, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[694191, 23353, 379, 8, 188, "Input"],
Cell[694573, 23363, 38, 1, 38, "Output"]
}, Closed]],
Cell[694626, 23367, 86, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[694737, 23373, 832, 16, 273, "Input"],
Cell[695572, 23391, 46, 1, 29, "Print"],
Cell[695621, 23394, 46, 1, 29, "Print"],
Cell[695670, 23397, 46, 1, 29, "Print"],
Cell[695719, 23400, 52, 1, 29, "Print"],
Cell[695774, 23403, 54, 1, 29, "Print"],
Cell[695831, 23406, 38, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[695930, 23414, 47, 0, 40, "Section"],
Cell[695980, 23416, 1318, 29, 184, "Text",
  CellTags->"Definition-Storage"],

Cell[CellGroupData[{
Cell[697323, 23449, 32, 0, 56, "Subsection"],
Cell[697358, 23451, 155, 4, 33, "Text",
  CellTags->"DownValues"],

Cell[CellGroupData[{
Cell[697538, 23459, 170, 4, 99, "Input"],
Cell[697711, 23465, 85, 1, 38, "Output"]
}, Closed]],
Cell[697811, 23469, 126, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[697962, 23476, 136, 3, 79, "Input"],
Cell[698101, 23481, 43, 1, 38, "Output"],
Cell[698147, 23484, 83, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[698279, 23491, 30, 0, 56, "Subsection"],
Cell[698312, 23493, 128, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[698465, 23500, 170, 4, 99, "Input"],
Cell[698638, 23506, 90, 1, 37, "Output"]
}, Closed]],
Cell[698743, 23510, 95, 2, 33, "Text"],

Cell[CellGroupData[{
Cell[698863, 23516, 166, 3, 79, "Input"],
Cell[699032, 23521, 84, 1, 35, "Output"]
}, Closed]],
Cell[699131, 23525, 151, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[699307, 23532, 144, 3, 82, "Input"],
Cell[699454, 23537, 84, 1, 35, "Output"]
}, Closed]],
Cell[699553, 23541, 167, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[699745, 23548, 165, 3, 80, "Input"],
Cell[699913, 23553, 84, 1, 35, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[700046, 23560, 31, 0, 44, "Subsection"],
Cell[700080, 23562, 166, 4, 48, "Text",
  CellTags->"OwnValues"],
Cell[700249, 23568, 152, 3, 61, "Input"],
Cell[700404, 23573, 86, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[700515, 23579, 48, 1, 40, "Input"],
Cell[700566, 23582, 74, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[700689, 23589, 29, 0, 44, "Subsection"],
Cell[700721, 23591, 153, 4, 30, "Text",
  CellTags->"NValues"],
Cell[700877, 23597, 102, 2, 61, "Input"],
Cell[700982, 23601, 106, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[701113, 23608, 46, 1, 45, "Input"],
Cell[701162, 23611, 47, 1, 41, "Output"]
}, Closed]],
Cell[701224, 23615, 72, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[701321, 23619, 49, 1, 45, "Input"],
Cell[701373, 23622, 90, 1, 38, "Output"]
}, Closed]],
Cell[701478, 23626, 71, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[701574, 23630, 43, 1, 40, "Input"],
Cell[701620, 23633, 104, 2, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[701773, 23641, 31, 0, 44, "Subsection"],
Cell[701807, 23643, 153, 4, 30, "Text",
  CellTags->"SubValues"],
Cell[701963, 23649, 129, 2, 61, "Input"],

Cell[CellGroupData[{
Cell[702117, 23655, 45, 1, 40, "Input"],
Cell[702165, 23658, 109, 2, 38, "Output"]
}, Closed]],
Cell[702289, 23663, 393, 10, 63, "Commentary"],

Cell[CellGroupData[{
Cell[702707, 23677, 165, 3, 82, "Input"],
Cell[702875, 23682, 36, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[702948, 23688, 53, 1, 40, "Input"],
Cell[703004, 23691, 88, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[703141, 23698, 34, 0, 44, "Subsection"],
Cell[703178, 23700, 361, 8, 66, "Text",
  CellTags->"FormatValues"],
Cell[703542, 23710, 444, 10, 188, "Input"],
Cell[703989, 23722, 123, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[704137, 23729, 41, 1, 40, "Input"],
Cell[704181, 23732, 68, 2, 50, "Output"]
}, Closed]],
Cell[704264, 23737, 103, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[704392, 23744, 55, 1, 40, "Input"],
Cell[704450, 23747, 910, 24, 208, "Output"]
}, Closed]],
Cell[705375, 23774, 141, 3, 48, "Text"],
Cell[705519, 23779, 123, 2, 61, "Input"],
Cell[705645, 23783, 271, 6, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[705953, 23794, 35, 0, 44, "Subsection"],
Cell[705991, 23796, 410, 9, 66, "Text",
  CellTags->"DefaultValues"],

Cell[CellGroupData[{
Cell[706426, 23809, 128, 3, 82, "Input"],
Cell[706557, 23814, 79, 1, 38, "Output"],
Cell[706639, 23817, 80, 1, 38, "Output"],
Cell[706722, 23820, 83, 1, 38, "Output"]
}, Closed]],
Cell[706820, 23824, 103, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[706948, 23831, 54, 1, 40, "Input"],
Cell[707005, 23834, 154, 2, 59, "Output"]
}, Closed]],
Cell[707174, 23839, 436, 9, 104, "Text"],
Cell[707613, 23850, 220, 4, 82, "Input"],
Cell[707836, 23856, 108, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[707969, 23863, 50, 1, 40, "Input"],
Cell[708022, 23866, 187, 3, 59, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[708258, 23875, 30, 0, 44, "Subsection"],
Cell[708291, 23877, 95, 1, 30, "Text",
  CellTags->"Messages"],
Cell[708389, 23880, 227, 4, 82, "Input"],
Cell[708619, 23886, 160, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[708804, 23893, 46, 1, 40, "Input"],
Cell[708853, 23896, 242, 4, 80, "Output"]
}, Closed]],
Cell[709110, 23903, 134, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[709269, 23910, 39, 1, 40, "Input"],
Cell[709311, 23913, 89, 2, 29, "Print",
  CellTags->"Info3248519924-1535622"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[709461, 23922, 49, 0, 40, "Section"],
Cell[709513, 23924, 243, 4, 54, "Text"],

Cell[CellGroupData[{
Cell[709781, 23932, 196, 3, 79, "Input"],
Cell[709980, 23937, 42, 1, 37, "Output"]
}, Closed]],
Cell[710037, 23941, 220, 4, 67, "Commentary"],

Cell[CellGroupData[{
Cell[710282, 23949, 196, 3, 79, "Input"],
Cell[710481, 23954, 41, 1, 37, "Output"]
}, Closed]],
Cell[710537, 23958, 104, 3, 33, "Text"],

Cell[CellGroupData[{
Cell[710666, 23965, 216, 3, 79, "Input"],
Cell[710885, 23970, 40, 1, 37, "Output"]
}, Closed]],
Cell[710940, 23974, 445, 7, 86, "Commentary"],

Cell[CellGroupData[{
Cell[711410, 23985, 171, 3, 79, "Input"],
Cell[711584, 23990, 43, 1, 37, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[711664, 23996, 63, 1, 39, "Input"],
Cell[711730, 23999, 43, 1, 38, "Output"]
}, Closed]],
Cell[711788, 24003, 143, 3, 46, "Commentary"],

Cell[CellGroupData[{
Cell[711956, 24010, 188, 3, 82, "Input"],
Cell[712147, 24015, 42, 1, 38, "Output"]
}, Closed]],
Cell[712204, 24019, 277, 5, 80, "Commentary"],

Cell[CellGroupData[{
Cell[712506, 24028, 196, 3, 82, "Input"],
Cell[712705, 24033, 42, 1, 38, "Output"]
}, Closed]],
Cell[712762, 24037, 124, 3, 46, "Commentary"],

Cell[CellGroupData[{
Cell[712911, 24044, 65, 1, 40, "Input"],
Cell[712979, 24047, 87, 1, 38, "Output"]
}, Closed]],
Cell[713081, 24051, 264, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[713370, 24060, 49, 1, 40, "Input"],
Cell[713422, 24063, 70, 1, 38, "Output"]
}, Closed]],
Cell[713507, 24067, 127, 3, 46, "Commentary"],

Cell[CellGroupData[{
Cell[713659, 24074, 122, 2, 61, "Input"],
Cell[713784, 24078, 44, 1, 38, "Output"]
}, Closed]],
Cell[713843, 24082, 639, 12, 113, "Commentary"],

Cell[CellGroupData[{
Cell[714507, 24098, 197, 3, 82, "Input"],
Cell[714707, 24103, 105, 2, 38, "Output"]
}, Closed]],
Cell[714827, 24108, 408, 8, 80, "Commentary"],

Cell[CellGroupData[{
Cell[715260, 24120, 191, 4, 103, "Input"],
Cell[715454, 24126, 65, 1, 38, "Output"]
}, Closed]],
Cell[715534, 24130, 150, 5, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[715721, 24140, 43, 0, 40, "Section"],

Cell[CellGroupData[{
Cell[715789, 24144, 69, 0, 56, "Subsection"],
Cell[715861, 24146, 125, 3, 33, "Text"],
Cell[715989, 24151, 48, 1, 39, "Input"],
Cell[716040, 24154, 264, 5, 54, "Text"],
Cell[716307, 24161, 81, 3, 56, "Input"],
Cell[716391, 24166, 292, 5, 54, "Text"],
Cell[716686, 24173, 95, 3, 56, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[716818, 24181, 58, 0, 56, "Subsection"],
Cell[716879, 24183, 281, 6, 54, "Text",
  CellTags->"Lists_Tables"],

Cell[CellGroupData[{
Cell[717185, 24193, 224, 5, 99, "Input"],
Cell[717412, 24200, 486, 16, 174, "Output"]
}, Closed]],
Cell[717913, 24219, 334, 8, 66, "Text"],

Cell[CellGroupData[{
Cell[718272, 24231, 85, 2, 61, "Input"],
Cell[718360, 24235, 503, 16, 169, "Output"]
}, Closed]],
Cell[718878, 24254, 92, 2, 30, "Text"],

Cell[CellGroupData[{
Cell[718995, 24260, 100, 2, 61, "Input"],
Cell[719098, 24264, 487, 16, 169, "Output"]
}, Closed]],
Cell[719600, 24283, 92, 1, 30, "Text"],

Cell[CellGroupData[{
Cell[719717, 24288, 147, 3, 61, "Input"],
Cell[719867, 24293, 538, 16, 169, "Output"]
}, Closed]],
Cell[720420, 24312, 250, 4, 66, "Text"],

Cell[CellGroupData[{
Cell[720695, 24320, 155, 3, 61, "Input"],
Cell[720853, 24325, 384, 11, 73, "Output"]
}, Closed]],
Cell[721252, 24339, 193, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[721470, 24347, 148, 2, 61, "Input"],
Cell[721621, 24351, 354, 11, 73, "Output"]
}, Closed]],
Cell[721990, 24365, 207, 5, 48, "Text"],

Cell[CellGroupData[{
Cell[722222, 24374, 95, 2, 40, "Input"],
Cell[722320, 24378, 486, 16, 169, "Output"]
}, Closed]],
Cell[722821, 24397, 119, 4, 30, "Text"],

Cell[CellGroupData[{
Cell[722965, 24405, 103, 2, 40, "Input"],
Cell[723071, 24409, 393, 13, 111, "Output"]
}, Closed]],
Cell[723479, 24425, 227, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[723731, 24433, 127, 2, 61, "Input"],
Cell[723861, 24437, 393, 13, 111, "Output"]
}, Closed]],
Cell[724269, 24453, 215, 7, 49, "Text"],

Cell[CellGroupData[{
Cell[724509, 24464, 99, 2, 40, "Input"],
Cell[724611, 24468, 393, 13, 111, "Output"]
}, Closed]],
Cell[725019, 24484, 526, 14, 67, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[725594, 24504, 35, 0, 40, "Section"],
Cell[725632, 24506, 1496, 58, 54, "Text",
  CellTags->"Pattern-Matching"],

Cell[CellGroupData[{
Cell[727153, 24568, 35, 0, 56, "Subsection"],
Cell[727191, 24570, 113, 3, 59, "Input"],
Cell[727307, 24575, 152, 3, 59, "Input"],
Cell[727462, 24580, 182, 3, 59, "Input"],
Cell[727647, 24585, 115, 2, 59, "Input"],
Cell[727765, 24589, 169, 3, 59, "Input"],
Cell[727937, 24594, 207, 4, 59, "Input"],
Cell[728147, 24600, 123, 2, 59, "Input"],
Cell[728273, 24604, 164, 4, 59, "Input"],
Cell[728440, 24610, 149, 4, 59, "Input"],
Cell[728592, 24616, 153, 3, 59, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[728782, 24624, 55, 0, 56, "Subsection"],
Cell[728840, 24626, 751, 14, 151, "Text"],

Cell[CellGroupData[{
Cell[729616, 24644, 329, 7, 145, "Input"],
Cell[729948, 24653, 118, 2, 53, "Output"]
}, Closed]],
Cell[730081, 24658, 189, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[730295, 24666, 74, 1, 56, "Input"],
Cell[730372, 24669, 223, 6, 38, "Output"]
}, Closed]],
Cell[730610, 24678, 105, 3, 30, "Text"],

Cell[CellGroupData[{
Cell[730740, 24685, 121, 2, 40, "Input"],
Cell[730864, 24689, 159, 2, 62, "Output"]
}, Closed]],
Cell[731038, 24694, 277, 10, 30, "Text"],
Cell[731318, 24706, 365, 14, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[731720, 24725, 71, 0, 44, "Subsection"],
Cell[731794, 24727, 232, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[732051, 24735, 82, 1, 56, "Input"],
Cell[732136, 24738, 39, 1, 38, "Output"]
}, Closed]],
Cell[732190, 24742, 229, 6, 86, "Text"],
Cell[732422, 24750, 476, 13, 126, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[732935, 24768, 71, 0, 44, "Subsection"],
Cell[733009, 24770, 124, 3, 30, "Text"],
Cell[733136, 24775, 145, 2, 61, "Input"],
Cell[733284, 24779, 250, 8, 49, "Text"],

Cell[CellGroupData[{
Cell[733559, 24791, 98, 2, 61, "Input"],
Cell[733660, 24795, 107, 2, 38, "Output"]
}, Closed]],
Cell[733782, 24800, 178, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[733985, 24808, 255, 5, 103, "Input"],
Cell[734243, 24815, 74, 1, 38, "Output"]
}, Closed]],
Cell[734332, 24819, 944, 20, 178, "Text",
  CellTags->"s_Symbol"],
Cell[735279, 24841, 42, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[735346, 24846, 40, 1, 40, "Input"],
Cell[735389, 24849, 413, 14, 38, "Output"]
}, Closed]],
Cell[735817, 24866, 163, 3, 48, "Text"],

Cell[CellGroupData[{
Cell[736005, 24873, 219, 4, 103, "Input"],
Cell[736227, 24879, 286, 8, 38, "Output"]
}, Closed]],
Cell[736528, 24890, 202, 4, 48, "Text"],
Cell[736733, 24896, 523, 12, 61, "Input"],
Cell[737259, 24910, 64, 0, 30, "Text"],

Cell[CellGroupData[{
Cell[737348, 24914, 161, 4, 103, "Input"],
Cell[737512, 24920, 75, 1, 38, "Output"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[737648, 24928, 43, 0, 40, "Section"],

Cell[CellGroupData[{
Cell[737716, 24932, 92, 1, 56, "Subsection",
  CellTags->"Controlling Memory Usage"],
Cell[737811, 24935, 371, 8, 54, "Text"],
Cell[738185, 24945, 141, 5, 39, "Input",
  Evaluatable->False],
Cell[738329, 24952, 224, 4, 54, "Text"],
Cell[738556, 24958, 57, 1, 39, "Input"],
Cell[738616, 24961, 222, 6, 57, "Text"],
Cell[738841, 24969, 97, 2, 39, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[738975, 24976, 56, 0, 56, "Subsection"],
Cell[739034, 24978, 116, 3, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[739187, 24986, 41, 0, 56, "Subsection"],
Cell[739231, 24988, 313, 5, 54, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[739581, 24998, 71, 0, 56, "Subsection"],
Cell[739655, 25000, 125, 3, 33, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[739829, 25009, 39, 0, 40, "Section"],
Cell[739871, 25011, 1067, 20, 140, "Text",
  CellTags->"Tech Support"],
Cell[740941, 25033, 8477, 307, 1045, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[749455, 25345, 40, 0, 40, "Section"],
Cell[749498, 25347, 153, 4, 33, "Text",
  CellTags->"Speedy_Programming"],

Cell[CellGroupData[{
Cell[749676, 25355, 40, 0, 56, "Subsection"],
Cell[749719, 25357, 844, 18, 250, "Text"],

Cell[CellGroupData[{
Cell[750588, 25379, 401, 8, 159, "Input"],
Cell[750992, 25389, 892, 14, 137, "Output"]
}, Closed]],
Cell[751899, 25406, 286, 5, 54, "Text"],
Cell[752188, 25413, 428, 10, 159, "Input"],
Cell[752619, 25425, 135, 3, 30, "Text"],
Cell[752757, 25430, 79, 1, 40, "Input"],
Cell[752839, 25433, 585, 12, 142, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[753461, 25450, 48, 0, 46, "Subsection"],
Cell[753512, 25452, 642, 15, 217, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[754191, 25472, 40, 0, 46, "Subsection"],
Cell[754234, 25474, 386, 6, 85, "Text"],
Cell[754623, 25482, 374, 7, 167, "Input"],

Cell[CellGroupData[{
Cell[755022, 25493, 56, 1, 40, "Input"],
Cell[755081, 25496, 68, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[755186, 25502, 56, 1, 40, "Input"],
Cell[755245, 25505, 70, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[755352, 25511, 56, 1, 40, "Input"],
Cell[755411, 25514, 70, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[755530, 25521, 70, 0, 46, "Subsection"],
Cell[755603, 25523, 372, 7, 66, "Text",
  CellTags->"Linked-List"],

Cell[CellGroupData[{
Cell[756000, 25534, 212, 4, 82, "Input"],
Cell[756215, 25540, 67, 1, 38, "Output"]
}, Closed]],
Cell[756297, 25544, 307, 6, 67, "Text"],

Cell[CellGroupData[{
Cell[756629, 25554, 210, 4, 82, "Input"],
Cell[756842, 25560, 69, 1, 38, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[756948, 25566, 54, 1, 40, "Input"],
Cell[757005, 25569, 38, 1, 38, "Output"]
}, Closed]],
Cell[757058, 25573, 392, 8, 86, "Text"],

Cell[CellGroupData[{
Cell[757475, 25585, 275, 6, 125, "Input"],
Cell[757753, 25593, 316, 7, 59, "Output"]
}, Closed]],

Cell[CellGroupData[{
Cell[758106, 25605, 66, 1, 40, "Input"],
Cell[758175, 25608, 247, 4, 59, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[758471, 25618, 57, 0, 46, "Subsection"],
Cell[758531, 25620, 226, 4, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[758794, 25629, 64, 0, 46, "Subsection"],
Cell[758861, 25631, 661, 12, 178, "Text"],

Cell[CellGroupData[{
Cell[759547, 25647, 214, 4, 83, "Input"],
Cell[759764, 25653, 143, 2, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[759956, 25661, 52, 0, 46, "Subsection"],
Cell[760011, 25663, 225, 4, 48, "Text"],
Cell[760239, 25669, 123, 2, 60, "Input"],
Cell[760365, 25673, 247, 4, 48, "Text"],
Cell[760615, 25679, 142, 2, 60, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[760794, 25686, 83, 1, 46, "Subsection"],
Cell[760880, 25689, 568, 9, 121, "Text"],
Cell[761451, 25700, 468, 10, 161, "Input"],
Cell[761922, 25712, 250, 4, 66, "Text"],

Cell[CellGroupData[{
Cell[762197, 25720, 204, 4, 103, "Input"],
Cell[762404, 25726, 150, 2, 59, "Output"]
}, Closed]],
Cell[762569, 25731, 307, 5, 66, "Text"],

Cell[CellGroupData[{
Cell[762901, 25740, 261, 5, 105, "Input"],
Cell[763165, 25747, 212, 3, 80, "Output"]
}, Closed]],
Cell[763392, 25753, 201, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[763618, 25761, 190, 4, 82, "Input"],
Cell[763811, 25767, 500, 7, 208, "Output"]
}, Closed]],
Cell[764326, 25777, 580, 15, 122, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[764943, 25797, 74, 0, 46, "Subsection"],
Cell[765020, 25799, 453, 7, 103, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[765510, 25811, 39, 0, 46, "Subsection"],
Cell[765552, 25813, 1083, 24, 196, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[766672, 25842, 45, 0, 46, "Subsection"],
Cell[766720, 25844, 445, 9, 66, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[767202, 25858, 114, 3, 68, "Subsection"],
Cell[767319, 25863, 243, 7, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[767599, 25875, 101, 2, 46, "Subsection"],
Cell[767703, 25879, 854, 17, 158, "Text"],

Cell[CellGroupData[{
Cell[768582, 25900, 262, 6, 83, "Input"],
Cell[768847, 25908, 69, 1, 38, "Output"]
}, Closed]],
Cell[768931, 25912, 236, 4, 48, "Text"],

Cell[CellGroupData[{
Cell[769192, 25920, 372, 7, 167, "Input"],
Cell[769567, 25929, 70, 1, 38, "Output"]
}, Closed]],
Cell[769652, 25933, 332, 7, 104, "Text"],

Cell[CellGroupData[{
Cell[770009, 25944, 185, 3, 82, "Input"],
Cell[770197, 25949, 71, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[770317, 25956, 52, 0, 46, "Subsection"],
Cell[770372, 25958, 418, 9, 90, "Text"],
Cell[770793, 25969, 179, 4, 61, "Input"],
Cell[770975, 25975, 67, 0, 31, "Text"],

Cell[CellGroupData[{
Cell[771067, 25979, 74, 1, 40, "Input"],
Cell[771144, 25982, 74, 1, 38, "Output"]
}, Closed]],
Cell[771233, 25986, 252, 5, 50, "Text"],
Cell[771488, 25993, 84, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[771597, 25998, 63, 1, 40, "Input"],
Cell[771663, 26001, 57, 1, 38, "Output"]
}, Closed]],
Cell[771735, 26005, 851, 17, 128, "Text"],

Cell[CellGroupData[{
Cell[772611, 26026, 254, 4, 61, "Input"],
Cell[772868, 26032, 91, 1, 30, "Print"],
Cell[772962, 26035, 91, 1, 30, "Print"],
Cell[773056, 26038, 83, 1, 30, "Print"],
Cell[773142, 26041, 83, 1, 30, "Print"],
Cell[773228, 26044, 83, 1, 30, "Print"],
Cell[773314, 26047, 75, 1, 30, "Print"],
Cell[773392, 26050, 75, 1, 30, "Print"],
Cell[773470, 26053, 75, 1, 30, "Print"],
Cell[773548, 26056, 67, 1, 30, "Print"],
Cell[773618, 26059, 67, 1, 30, "Print"],
Cell[773688, 26062, 67, 1, 30, "Print"],
Cell[773758, 26065, 59, 1, 30, "Print"],
Cell[773820, 26068, 59, 1, 30, "Print"],
Cell[773882, 26071, 58, 1, 38, "Output"]
}, Closed]],
Cell[773955, 26075, 287, 5, 50, "Text"],
Cell[774245, 26082, 512, 10, 229, "Input"],

Cell[CellGroupData[{
Cell[774782, 26096, 75, 1, 40, "Input"],
Cell[774860, 26099, 74, 1, 38, "Output"]
}, Closed]],
Cell[774949, 26103, 89, 2, 31, "Text"],
Cell[775041, 26107, 84, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[775150, 26112, 63, 1, 40, "Input"],
Cell[775216, 26115, 55, 1, 38, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[775320, 26122, 45, 0, 46, "Subsection"],
Cell[775368, 26124, 1038, 25, 105, "Text"],
Cell[776409, 26151, 662, 19, 67, "Text",
  CellTags->"Fast Programming"],
Cell[777074, 26172, 369, 8, 123, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[777492, 26186, 40, 0, 40, "Section"],
Cell[777535, 26188, 443, 9, 54, "Text"],

Cell[CellGroupData[{
Cell[778003, 26201, 97, 2, 56, "Subsection"],
Cell[778103, 26205, 512, 13, 208, "Text",
  CellTags->"Slow_Functions"],

Cell[CellGroupData[{
Cell[778640, 26222, 45, 0, 54, "Subsubsection"],
Cell[778688, 26224, 612, 12, 179, "Input"],

Cell[CellGroupData[{
Cell[779325, 26240, 79, 1, 39, "Input"],
Cell[779407, 26243, 452, 12, 114, "Output"]
}, Closed]],
Cell[779874, 26258, 499, 10, 159, "Input"],

Cell[CellGroupData[{
Cell[780398, 26272, 73, 1, 40, "Input"],
Cell[780474, 26275, 450, 12, 105, "Output"]
}, Closed]],
Cell[780939, 26290, 483, 9, 165, "Input"],

Cell[CellGroupData[{
Cell[781447, 26303, 74, 1, 40, "Input"],
Cell[781524, 26306, 464, 12, 105, "Output"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[782037, 26324, 73, 0, 45, "Subsubsection"],
Cell[782113, 26326, 483, 7, 103, "Text"],
Cell[782599, 26335, 464, 10, 66, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[783112, 26351, 41, 0, 46, "Subsection"],
Cell[783156, 26353, 259, 7, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[783452, 26365, 34, 0, 46, "Subsection"],
Cell[783489, 26367, 113, 3, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[783639, 26375, 40, 0, 46, "Subsection"],
Cell[783682, 26377, 145, 3, 48, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[783864, 26385, 38, 0, 46, "Subsection"],
Cell[783905, 26387, 118, 3, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[784060, 26395, 60, 0, 46, "Subsection"],
Cell[784123, 26397, 67, 0, 30, "Text"],
Cell[784193, 26399, 85, 2, 30, "Text"],
Cell[784281, 26403, 121, 3, 30, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[784439, 26411, 90, 2, 46, "Subsection"],
Cell[784532, 26415, 435, 7, 85, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[785016, 26428, 76, 0, 40, "Section"],
Cell[785095, 26430, 336, 7, 54, "Text"],

Cell[CellGroupData[{
Cell[785456, 26441, 2290, 45, 615, "Subsubsection"],
Cell[787749, 26488, 206, 5, 55, "Text"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[788004, 26499, 40, 0, 40, "Section"],
Cell[788047, 26501, 156, 3, 33, "Text"],
Cell[788206, 26506, 154, 3, 33, "Text"],
Cell[788363, 26511, 176, 3, 33, "Text"],
Cell[788542, 26516, 186, 3, 33, "Text"],
Cell[788731, 26521, 229, 5, 33, "Text"],
Cell[788963, 26528, 177, 3, 33, "Text"],
Cell[789143, 26533, 229, 5, 33, "Text"],
Cell[789375, 26540, 186, 3, 33, "Text"],
Cell[789564, 26545, 198, 3, 33, "Text"],
Cell[789765, 26550, 166, 3, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[789968, 26558, 55, 0, 40, "Section"],
Cell[790026, 26560, 408, 7, 121, "Text"],
Cell[790437, 26569, 150, 4, 33, "Text"],
Cell[790590, 26575, 170, 3, 31, "Text"],
Cell[790763, 26580, 140, 3, 31, "Text"],
Cell[790906, 26585, 89, 1, 33, "Text"]
}, Closed]],

Cell[CellGroupData[{
Cell[791032, 26591, 47, 0, 40, "Section"],
Cell[791082, 26593, 331, 7, 68, "Commentary"],
Cell[791416, 26602, 79, 3, 68, "Commentary"],
Cell[791498, 26607, 177, 5, 68, "Commentary"],
Cell[791678, 26614, 224, 6, 68, "Commentary"],
Cell[791905, 26622, 67, 3, 68, "Commentary"],
Cell[791975, 26627, 269, 7, 108, "Commentary"]
}, Closed]]
}, Open  ]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

