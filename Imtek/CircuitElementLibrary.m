(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: CircuitElementLibrary.m *)
(* Context: *)
(* 
  Author:oliver ruebenkoenig, kai kratt *)
(* Date: 3.9. 2007, Freiburg *)
(* 
  Summary: This is the IMTEK circuit element library *)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.1.5 *)
(* 
  Mathematica Version: 5.2 *)
(* History:
  ;
  oliver: for mma6.0 fixed Arrow;
  kai: fixed some things. 7.6.06;
   *)
(* added new element: mutual inductance *)
(* 
  added new elements: controlled sources *)
(* added new element: diode *)
(* 
  Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* 
  Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Disclaimer *)

(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* This is the IMTEK circuit element library. 
      Extend graph to deal with circuit elements. *)

(* Copyright (C) 2005, oliver ruebenkoenig, kai kratt *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)



(* Start Package *)

BeginPackage["Imtek`CircuitElementLibrary`", "Imtek`Nodes`", "Imtek`Graph`"];





(* *)
(* documentation *)
(* *)

(* constructors *)

imsMakeCapacitance::usage = \
"imsMakeCapacitance[ id, incidentsIds, value, data ] returns an imsCapacitance with Integer id, a List of incidentsIds and  a value of the capacitance. Optionally data can be given.";\


imsCapacitance::usage = \
"imsCapacitance is the datastructure returned by imsMakeCapacitance.";

imsMakeResistance::usage = \
"imsMakeResistance[ id, incidentsIds, value, data ] returns an imsResistance with Integer id, a List of incidentsIds and a value of the resistor. Optionally data can be given.";\


imsResistance::usage = \
"imsResistance is the datastructure returned by imsMakeResistance.";

imsMakeInductance::usage = \
"imsMakeInductance[ id, incidentsIds, value, data ] returns an imsInductance with Integer id, a List of incidentsIds and a value of the inductance. Optionally data can be given.";\


imsInductance::usage = \
"imsInductance is the datastructure returned by imsMakeInductance.";

imsMakeMutualInductance::usage="imsMakeMutualInductance[ id, incidentsIds_{i11,i12,i21,i22}, value_{v1,v2,k}, data ] returns an imsMutualInductance with Integer id, a List of incidentsIds i11 and i12 for the inductances respectivly. A List of (real) inductances values v1 and v2 and k the coupling coefficient. The coupling coefficient is defined as 0 < k = M/Sqrt[v1*v2] < 1, where M is the mutual inductance. Optionally data can be given.";\


imsMutualInductance::usage = \
"imsMutualInductance is the datastructure returned by imsMakeMutualInductance.";\


imsMakeVoltageSource::usage = \
"imsMakeVoltageSource[ id, incidentsIds, value, data ] returns an imsVoltageSource with Integer id, a List of incidentsIds and a value of the voltage source, where value can either be a Integer, Real, Symbol or Function. Optionally data can be given.";\


imsVoltageSource::usage = \
"imsVoltageSource is the datastructure returned by imsMakeVoltageSource.";

imsMakeCurrentControlledCurrentSource::usage="imsMakeCurrentControlledCurrentSource[ id, incidentsIds_{i11,i12,i21,i22}, value, data ] returns an imsCurrentControlledCurrentSource with a integer id, a List of incidentsIds i11 and i12 for the input current and i21 and i22 for the output current. The two are related by value. This parameter is called current gain, which is the ratio of the output current to the input current. Optionally data can be given.";\


imsCurrentControlledCurrentSource::usage="imsCurrentControlledCurrentSource is the datastructure returned by imsMakeCurrentControlledCurrentSource";\


imsMakeCurrentControlledVoltageSource::usage="imsMakeCurrentControlledVoltageSource[ id, incidentsIds_{i11,i12,i21,i22},  value, data ] returns an imsCurrentControlledVoltageSource with a integer id, a List of incidentsIds i11 and i12 for the input current and i21 and i22 for the output voltage. The output voltage of this source depends on the current through the input terminals. The two are related by value. This parameter is called transresistance, which is the ratio of the output voltage to the input current. Its unit is Ohm. Optionally data can be given.";\


imsCurrentControlledVoltageSource::usage="imsCurrentControlledVoltageSource is the datastructure returned by imsMakeCurrentControlledVoltageSource";\


imsMakeVoltageControlledCurrentSource::usage="imsMakeVoltageControlledCurrentSource[ id, incidentsIds_{i11,i12,i21,i22}, value, data ] returns an imsVoltageControlledCurrentSource with a integer id, a List of incidentsIds i11 and i12 for the input voltage and i21 and i22 for the output current. The output current of this source depends on the voltage applied at the input terminals. The two are related by value. This parameter is called transconductance, which is the ratio of the output current to the input voltage. Its unit is Siemens. Optionally data can be given.";\


imsVoltageControlledCurrentSource::usage="imsVoltageControlledCurrentSource is the datastructure returned by imsMakeVoltageControlledCurrentSource";\


imsMakeVoltageControlledVoltageSource::usage="imsMakeVoltageControlledVoltageSource[ id, incidentsIds_{i11,i12,i21,i22}, value, data ] returns an imsVoltageControlledVoltageSource with a integer id, a List of incidentsIds i11 and i12 for the input voltage and i21 and i22 for the output voltage. The output voltage of this source depends on the voltage applied to its input terminal. The ratio of the output voltage to the input voltage determines its voltage gain which can be set by value. Optionally data can be given.";\


imsVoltageControlledVoltageSource::usage="imsVolrageControlledVoltageSource is the datastructure returned by imsMakeVoltageControlledVoltageSource";\


imsMakeCurrentSource::usage = \
"imsMakeCurrentSource[ id, incidentsIds, value, data ] returns an imsCurrentSource with Integer id, a List of incidentsIds and a value of the current source, where value can either be a Integer, Real, Symbol or Function. Optionally data can be given.";\


imsCurrentSource::usage = \
"imsCurrentSource is the datastructure returned by imsMakeCurrentSource.";

imsMakeWire::usage = \
"imsMakeWire[ id, incidentsIds, data ] returns an imsWire with Integer id and a List of incidentsIds. Optionally data can be given.";\


imsWire::usage = "imsWire is the datastructure returned by imsMakeWire.";

imsMakeGround::usage = \
"imsMakeGround [ id, incidentsIds, value, data ] returns an imsGround with Integer id and a List of one incidentsId. Value defaults to 0. Optionally data can be given.";\


imsGround::usage = \
"imsGround is the datastructure returned by imsMakeGround.";

imsMakeDiode::usage=
    "imsMakeDiode [ id, incidentsIds, { Vd, Is, Vt, n}, data ] returns an imsDiode with Integer id and a List of incidentsIds. Symbol Vd is the voltage across the diode. Saturation current Is defaults to 10^-12 A (silicon, temperature dependant), thermal voltage Vt defaults at room temperature to 25.8 mV, emission coefficient defaults to 1. Optionally data can be given.";\


imsDiode::usage="imsDiode is the datastructure returned by imsMakeDiode.";

(* selectors *)

imsGetIds::usage="imsGetIds[ elements ] returns the circuit element's id.";

imsGetIncidentsIds::usage="imsGetIncidentsIds[ elements ] returns the circuit element's incidentsIds.";\


imsGetValues::usage="imsGetValues[ elements ] returns the circuit element's value.";\


imsGetDatas::usage="imsGetDatas[ elements ] returns the circuit element's data, if any are present.";\


(* predicates *)

imsCircuitElementQ::usage \
="imsCircuitElementNodeQ[ expr ] returns True if expr is any imsCircuitElement.";\


imsDataCircuitElementQ::usage \
="imsDataCircuitElementQ[expr] returns True if expr is any imsCircuitElement with additional data set.";\


(* functions *)

imsCircuitElements::usage="imsCircuitElements[] returns a list of all available circuit elements.";\


imsDrawElements::usage="imsDrawElements[ element, nodes ] will draw the element consisting of nodes.";\





(* *)
(* options docu *)
(* *)



(* *)
(* error messages *)
(* *)



Begin["`Private`"];



(* *)
(* private imports *)
(* *)
If[ $VersionNumber \[LessEqual] 
    5.2, <<"Graphics`Arrow`", Null; ]



(* *)
(* implementation part *)
(* *)

(* constructor *)
(* *)

imsMakeCapacitance[ id_Integer, incidents_List, value_, data___ ] := 
    imsCapacitance[ id, incidents, value, data ];

imsMakeResistance[ id_Integer, incidents_List, value_, data___ ] := 
    imsResistance[ id, incidents, value, data ];

imsMakeInductance[ id_Integer, incidents_List, value_, data___ ] := 
    imsInductance[ id, incidents, value, data ];

imsMakeMutualInductance[ id_, incidents_List, value_, data___ ] := 
    imsMutualInductance[ id, incidents, value, data ];

imsMakeVoltageSource[ id_Integer, incidents_List, value_, data___ ] := 
    imsVoltageSource[ id, incidents, value, data ];

imsMakeCurrentSource[ id_Integer, incidents_List, value_, data___ ] := 
    imsCurrentSource[ id, incidents, value, data ];

imsMakeCurrentControlledCurrentSource[ id_Integer, incidents_List, value_, 
      data___ ] := 
    imsCurrentControlledCurrentSource[ id, incidents, value, data ];

imsMakeCurrentControlledVoltageSource[ id_Integer, incidents_List, value_, 
      data___ ] := 
    imsCurrentControlledVoltageSource[ id, incidents, value, data ];

imsMakeVoltageControlledCurrentSource[ id_Integer, incidents_List, value_, 
      data___ ] := 
    imsVoltageControlledCurrentSource[ id, incidents, value, data ];

imsMakeVoltageControlledVoltageSource[ id_Integer, incidents_List, value_, 
      data___ ] := 
    imsVoltageControlledVoltageSource[ id, incidents, value, data ];

imsMakeWire[ id_Integer, incidents_List, value_:0, data___] := 
    imsWire[ id, incidents, value, data ];

imsMakeGround[ id_Integer, incidents_List, value_:0, data___ ] := 
    imsGround[ id, incidents, value, data ];

imsMakeDiode[ id_Integer, 
      incidents_List, {symb_Symbol, Is_:10^-12, Vt_:0.0258, n_:1}, data___ ]:= 
    imsDiode[ id, incidents, {symb, Is, Vt, n}, data ];



(* *)
(* define your options *)
(* *)



(* selector *)
(* *)

imsGetIds[ e_ ] /; imsCircuitElementQ[ e ] := e[[1]];
  imsGetIncidentsIds[ e_ ] /; imsCircuitElementQ[ e ] := e[[2]];
  imsGetValues[ e_ ] /; imsCircuitElementQ[ e ] := e[[3]];
  imsGetDatas[ e_ ] /; 
        imsCircuitElementQ[ e ] && imsDataCircuitElementQ[ e ] := e[[4]];
  
  SetAttributes[ imsGetIncidentsIds, Listable ];
  SetAttributes[ imsGetIds, Listable ];
  SetAttributes[ imsGetValues, Listable ];
  SetAttributes[ imsGetDatas, Listable ];
  
  (*
    imsGetIds[ imsCapacitance[ id_, _, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsCapacitance[ _, incidents_, _, ___ ] ] := 
      incidents;
    imsGetValues[ imsCapacitance[ _, _, value_, ___ ] ] := value;
    imsGetDatas[ imsCapacitance[ _, _, _, data_ ] ] := data;
    
    imsGetIds[ imsResistance[ id_, _, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsResistance[ _, incidents_, _, ___ ] ] := 
      incidents;
    imsGetValues[ imsResistance[ _, _, value_, ___ ] ] := value;
    imsGetDatas[ imsResistance[ _, _, _, data_ ] ] := data;
    
    imsGetIds[ imsInductance[ id_, _, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsInductance[ _, incidents_, _, ___ ] ] := 
      incidents;
    imsGetValues[ imsInductance[ _, _, value_, ___ ] ] := value;
    imsGetDatas[ imsInductance[ _, _, _, data_ ] ] := data;
    
    imsGetIds[ imsVoltageSource[ id_, _, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsVoltageSource[ _, incidents_, _, ___ ] ] := 
      incidents;
    imsGetValues[ imsVoltageSource[ _, _, value_, ___ ] ] :=value;
    imsGetDatas[ imsVoltageSource[ _, _, _,data _ ] ] := data;
    
    imsGetIds[ imsCurrentSource[ id_, _, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsCurrentSource[ _, incidents_, _, ___ ] ] := 
      incidents;
    imsGetValues[ imsCurrentSource[ _, _, value_, ___ ] ] :=value;
    imsGetDatas[ imsCurrentSource[ _, _, _, data_ ] ] := data;
    
    imsGetIds[ imsWire[ id_, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsWire[ _, incidents_, ___ ] ] := incidents;
    imsGetDatas[ imsWire[ _, _, data_] ] := data;
    
    imsGetIds[ imsGround[ id_, _, _, ___ ] ] := id;
    imsGetIncidentsIds[ imsGround[ _, incidents_, _, _ ] ] := incidents;
    imsGetValues[ imsGround[ _, _, value_, _ ] ] := value;
    imsGetDatas[ imsGround[ _, _, _, data_ ] ] := data;
    
    *)



(* predicates *)
(* *)

imsCircuitElementQ[ e_ ] /; MemberQ[ imsCircuitElements[ ], Head[ e ] ]:= 
    True;
imsCircuitElementQ[ ___ ] := False;

imsDataCircuitElementQ[thisElement:e_[_,_,_,_]]/;
      imsCircuitElementQ[thisElement]:=True;
imsDataCircuitElementQ[___]:=False;



(* private functions *)
(* *)

(* public functions *)
(* *)

imsCircuitElements[] := { imsResistance, imsCapacitance, imsInductance, 
      imsMutualInductance, imsGround, imsWire, imsVoltageSource, 
      imsCurrentSource, imsCurrentControlledCurrentSource, 
      imsCurrentControlledVoltageSource, imsVoltageControlledCurrentSource, 
      imsVoltageControlledVoltageSource, imsDiode
       };



(* Mutators *)
(* *)





(* representors *)
(* *)
If[ $VersionNumber \[LessEqual] 5.2, 
  versionArrow[ v1_, v2_, opts___ ] := Arrow[ v1, v2, opts ],
  versionArrow[ v1_, v2_, opts___ ] := Arrow[ {v1, v2 } ]
  ]

imsDrawElements[ a_imsCapacitance, nodes_ ] := 
    Module[ { firstPoint , lastPoint, vectorNotUnit, lengthVector, vector, 
        vectorOrtho,p1, p2, p3, p4, p5, p6 },
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      
      vectorNotUnit = lastPoint - firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      p1 = firstPoint + vector * 0.45 * lengthVector;
      p2 = p1 + vectorOrtho * 0.1 * lengthVector;
      p3 = p1 - vectorOrtho * 0.1 * lengthVector;
      
      p4 = lastPoint - vector * 0.45 * lengthVector;
      p5 = p4 + vectorOrtho * 0.1 * lengthVector;
      p6 = p4 - vectorOrtho * 0.1 * lengthVector;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p2, p3 } ],
        
        Line[ { lastPoint, p4 } ],
        Line[ { p5, p6 } ]
        }
      ];

imsDrawElements[ a_imsResistance, nodes_ ] := 
    Module[ { firstPoint , lastPoint, vectorNotUnit, lengthVector, vector, 
        vectorOrtho,p1, p2, p3, p4, p5, p6 },
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      
      vectorNotUnit = lastPoint - firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      p1 = firstPoint + vector * 0.35 * lengthVector;
      p2 = p1 + vectorOrtho * 0.1 * lengthVector;
      p3 = p1 - vectorOrtho * 0.1 * lengthVector;
      
      p4 = lastPoint - vector * 0.35 * lengthVector;
      p5 = p4 + vectorOrtho * 0.1 * lengthVector;
      p6 = p4 - vectorOrtho * 0.1 * lengthVector;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p2, p3 } ],
        
        Line[ { p2, p5} ],
        Line[ { p3, p6} ],
        
        Line[ { lastPoint, p4 } ],
        Line[ { p5, p6 } ]
        }
      ];

imsDrawElements[ a_imsInductance, nodes_ ] := 
    Module[ { firstPoint , lastPoint, vectorNotUnit, lengthVector, vector, 
        vectorOrtho,p1, p2, p3, p4, p5, p6 },
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      
      vectorNotUnit = lastPoint - firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      p1 = firstPoint + vector * 0.35 * lengthVector;
      p2 = p1 + vectorOrtho * 0.1 * lengthVector;
      p3 = p1  - vectorOrtho * 0.1 * lengthVector;
      
      p4 = lastPoint - vector * 0.35 * lengthVector;
      p5 = p4 + vectorOrtho * 0.1 * lengthVector;
      p6 = p4 - vectorOrtho * 0.1 * lengthVector;
      
      {
        Line[ { firstPoint, p1 } ],
        Polygon[ {p2,p3, p6, p5} ],
        Line[ { lastPoint, p4 } ]
        }
      ];

imsDrawElements[ a_imsMutualInductance, nodes_ ] := 
  Module[ { firstPoint , secondPoint, thirdPoint, fourthPoint, 
      vectorNotUnit1, vectorNotUnit2, lengthVector1, lengthVector2, vector1, 
      vector2,  vectorOrtho1,vectorOrtho2, p11, p12, p13, p14, p15, p16, p21, 
      p22, p23, p24, p25, p26, m1, m2, ma },
    
    { firstPoint , secondPoint, thirdPoint, fourthPoint } = 
      imsGetCoords[ nodes ];
    
    vectorNotUnit1 = secondPoint - firstPoint;
    lengthVector1 = Sqrt[ vectorNotUnit1.vectorNotUnit1 ];
    vector1 = vectorNotUnit1  / lengthVector1;
    vectorOrtho1 = { -1, 1 } *  Reverse[ vector1 ];
    
    p11 = firstPoint + vector1 * 0.35 * lengthVector1;
    p12 = p11 + vectorOrtho1 * 0.1 * lengthVector1;
    p13 = p11  - vectorOrtho1 * 0.1 * lengthVector1;
    
    p14 = secondPoint - vector1 * 0.35 * lengthVector1;
    p15 = p14 + vectorOrtho1 * 0.1 * lengthVector1;
    p16 = p14 - vectorOrtho1 * 0.1 * lengthVector1;
    
    
    vectorNotUnit2 = fourthPoint - thirdPoint;
    lengthVector2 = Sqrt[ vectorNotUnit2.vectorNotUnit2 ];
    vector2 = vectorNotUnit2  / lengthVector2;
    vectorOrtho2 = { -1, 1 } *  Reverse[ vector2 ];
    
    p21 = thirdPoint + vector2 * 0.35 * lengthVector2;
    p22 = p21 + vectorOrtho2 * 0.1 * lengthVector2;
    p23 = p21  - vectorOrtho2 * 0.1 * lengthVector2;
    
    p24 = fourthPoint - vector2 * 0.35 * lengthVector2;
    p25 = p24 + vectorOrtho2 * 0.1 * lengthVector2;
    p26 = p24 - vectorOrtho2 * 0.1 * lengthVector2;
    
    diff = Sqrt[ (thirdPoint - firstPoint).(thirdPoint - firstPoint) ];
    
    m11 = 
      firstPoint + 0.45 * diff*vectorOrtho1 + 0.35 * vector1 * lengthVector1;
    m12 = 
      secondPoint + 0.45*diff*vectorOrtho1 - 0.35 * vector1 * lengthVector1;
    
    m21 = 
      thirdPoint - 0.45 * diff*vectorOrtho2 +  
        0.35 * vector2 * lengthVector2;
    m22 = 
      fourthPoint - 0.45 * diff*vectorOrtho2 - 
        0.35 * vector2 * lengthVector2;
    
    (* 
      m1 =  ( secondPoint + firstPoint ) / 2 + 
          vectorOrtho1 * 0.1 * lengthVector1;
      m2 = ( fourthPoint + thirdPoint ) / 2 - 
          vectorOrtho2 * 0.1 * lengthVector2;
      ma = ( ( fourthPoint + thirdPoint ) / 
                2  + ( secondPoint + firstPoint ) / 2) / 2; 
      *)
    
    {
      Line[ { firstPoint, p11 } ],
      Polygon[ {p12,p13, p16, p15} ],
      Line[ { secondPoint, p14 } ],
      (* Text[ "L1", m1, { -1, -1 },  
          TextStyle\[Rule]{FontSize\[Rule]14} ], *)
      
      Line[ { thirdPoint, p21 } ],
      Polygon[ {p22,p23, p26, p25} ],
      Line[ { fourthPoint, p24 } ],
      
      (* 
        Text[ "L2", m2, { 1, 1 },  TextStyle\[Rule]{FontSize\[Rule]14} ], 
        
        versionArrow [ m1, m2],
        versionArrow[ m2, m1 ],
        
        Text[ "M", ma, TextStyle\[Rule]{FontSize\[Rule]14}] 
        *)
      
      Line[ { m11, m12 } ],
      Line[ { m21, m22 }]
      }
    
    ]

imsDrawElements[ a_imsVoltageSource, nodes_ ] := 
    Module[ { firstPoint , lastPoint, vectorNotUnit, lengthVector, vector,
        vectorOrtho,  centerPoint, radius, p1, p2 },
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      
      vectorNotUnit = lastPoint - firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      p1 = 
        firstPoint + vector * 0.3 * lengthVector - 
          vectorOrtho * 0.15 * lengthVector;
      p2 = 
        lastPoint - vector * 0.3 * lengthVector - 
          vectorOrtho * 0.15 * lengthVector;
      
      centerPoint = ( firstPoint + lastPoint) / 2;
      radius = 0.1 * lengthVector;
      
      {
        Line[ { firstPoint, lastPoint } ],
        Circle[ centerPoint, radius ],
        versionArrow[ p1, p2, HeadScaling\[Rule]Relative ]
        }
      ];

imsDrawElements[ a_imsCurrentSource, nodes_ ] := 
    Module[ { firstPoint , lastPoint, vectorNotUnit, lengthVector, vector, 
        vectorOrtho,centerPoint, radius, p1, p2, p3, p4, p5 },
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      
      vectorNotUnit = lastPoint - firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      centerPoint = ( firstPoint + lastPoint) / 2;
      radius = 0.1 * lengthVector;
      
      p1 = firstPoint + vector * 0.4 * lengthVector;
      p2 = lastPoint - vector * 0.4 * lengthVector;
      p3 = centerPoint + vectorOrtho * 0.1 * lengthVector;
      p4 = centerPoint - vectorOrtho * 0.1 * lengthVector;
      p5 = firstPoint + vector * 0.8 * lengthVector;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p3, p4 } ],
        versionArrow[ p2,p5, HeadScaling\[Rule]Relative ],
        Line[ { p5, lastPoint } ],
        Circle[ centerPoint, radius ]
        }
      ];

imsDrawElements[ a_imsWire, nodes_ ] := Module[ { firstPoint , lastPoint},
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      Line[ { firstPoint, lastPoint} ]
      ];

imsDrawElements[ a_imsGround, nodes_ ] := 
    Module[ { individualPoint, p1, p2, p3},
      { individualPoint } = imsGetCoords[ nodes ];
      p1 = {individualPoint[[1]],individualPoint[[2]]-0.5};
      p2 = {individualPoint[[1]] - 0.4, p1[[2]]};
      p3 = {individualPoint[[1]] + 0.4, p1[[2]]};
      
      {
        Line[ {individualPoint, p1}],
        {
          Thickness[.01],Line[ { p2, p3} ]
          }
        }
      ];

imsDrawElements[ a_imsVoltageControlledVoltageSource, nodes_ ] := 
    Module[ { firstPoint , secondPoint, thirdPoint, fourthPoint, 
        vectorNotUnit, lengthVector, vector, vectorOrtho,vectorNotUnit2, 
        lengthVector2, vector2, vectorOrtho2,p1, p2, p3, p4, p5, p6,p7,p8,p9,
        p10,centerPoint1, centerPoint2, radius },
      
      { firstPoint , secondPoint, thirdPoint, fourthPoint } = 
        imsGetCoords[ nodes ];
      
      vectorNotUnit = secondPoint-firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      vectorNotUnit2 = fourthPoint-thirdPoint;
      lengthVector2 = Sqrt[ vectorNotUnit2.vectorNotUnit2 ];
      vector2 = vectorNotUnit2  / lengthVector2;
      vectorOrtho2 = { -1, 1 } *  Reverse[ vector2 ];
      
      p1 = firstPoint + vector * 0.35 * lengthVector;
      p2 = p1 + vectorOrtho * 0.05 * lengthVector;
      p3 = p1 - vectorOrtho * 0.05* lengthVector;
      
      p4 = secondPoint - vector * 0.35 * lengthVector;
      p5 = p4 + vectorOrtho * 0.05 * lengthVector;
      p6 = p4 - vectorOrtho * 0.05 * lengthVector;
      
      centerPoint1 = (firstPoint+secondPoint) / 2;
      centerPoint2 = ( thirdPoint + fourthPoint) / 2;
      radius = 0.1 * lengthVector;
      
      p7 = p2 - vectorOrtho * 0.15 * lengthVector;
      p8 = p5 - vectorOrtho * 0.15* lengthVector;
      
      p9= 
        centerPoint2 - vector2 *1.5*radius + 
          vectorOrtho2 * 0.15 * lengthVector2;
      p10 = 
        centerPoint2 + vector2 *1.5*radius + 
          vectorOrtho2 * 0.15 * lengthVector2;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p2, p3 } ],
        
        Line[ { p2, p5} ],
        Line[ { p3, p6} ],
        
        Line[ { secondPoint, p4 } ],
        Line[ { p5, p6 } ],
        
        versionArrow[ p7, p8, HeadScaling\[Rule]Relative ],
        versionArrow[ p9, p10, HeadScaling\[Rule]Relative ],
        
        (*
          Text[ "+", firstPoint, { -1, 1 } ],
          Text[ "-", secondPoint, { -1, -1 } ],
          Text[ "V", centerPoint1, {0, -1 } ],
          *)
        
        Line[ { thirdPoint, fourthPoint } ],
        Circle[ centerPoint2, radius ],
        
        (*
          Text[ "+", thirdPoint, { -1, 1 } ],
          Text[ "-", fourthPoint, { -1, -1 } ],
          *)
        
        versionArrow[ centerPoint1, centerPoint2 ]
        }
      ];

imsDrawElements[ a_imsCurrentControlledVoltageSource, nodes_ ] := 
    Module[ { firstPoint , secondPoint, thirdPoint, fourthPoint, 
        vectorNotUnit, lengthVector, vector, vectorOrtho,vectorNotUnit2, 
        lengthVector2, vector2, vectorOrtho2,p1, p2, p3, p4, p5, p6,p7,p8,p9, 
        centerPoint1, centerPoint2, radius },
      
      { firstPoint , secondPoint, thirdPoint, fourthPoint } = 
        imsGetCoords[ nodes ];
      
      vectorNotUnit = secondPoint-firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      vectorNotUnit2 = fourthPoint-thirdPoint;
      lengthVector2 = Sqrt[ vectorNotUnit2.vectorNotUnit2 ];
      vector2 = vectorNotUnit2  / lengthVector2;
      vectorOrtho2 = { -1, 1 } *  Reverse[ vector2 ];
      
      p1 = firstPoint + vector * 0.35 * lengthVector;
      p2 = p1 + vectorOrtho * 0.05 * lengthVector;
      p3 = p1 - vectorOrtho * 0.05 * lengthVector;
      
      p4 = secondPoint - vector * 0.35 * lengthVector;
      p5 = p4 + vectorOrtho * 0.05 * lengthVector;
      p6 = p4 - vectorOrtho * 0.05 * lengthVector;
      
      centerPoint1 = (firstPoint+secondPoint) / 2;
      centerPoint2 = ( thirdPoint + fourthPoint) / 2;
      radius = 0.1 * lengthVector;
      
      p7 = p1 - vector * 0.2 * lengthVector;
      p8= 
        centerPoint2 - vector2 *1.5*radius + 
          vectorOrtho2 * 0.15 * lengthVector2;
      p9 = 
        centerPoint2 + vector2 *1.5*radius + 
          vectorOrtho2 * 0.15 * lengthVector2;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p2, p3 } ],
        
        Line[ { p2, p5} ],
        Line[ { p3, p6} ],
        
        Line[ { secondPoint, p4 } ],
        Line[ { p5, p6 } ],
        
        versionArrow[ p1, p7, HeadScaling\[Rule]Relative ],
        versionArrow[ p8, p9, HeadScaling\[Rule]Relative ],
        
        (*
          Text[ "+", firstPoint, { -1, 1 } ],
          Text[ "-", secondPoint, { -1, -1 } ],
          Text[ "I", centerPoint1, {0, -1 } ],
          *)
        
        Line[ { thirdPoint, fourthPoint } ],
        Circle[ centerPoint2, radius ],
        
        (*
          Text[ "+", thirdPoint, { -1, 1 } ],
          Text[ "-", fourthPoint, { -1, -1 } ],
          *)
        
        versionArrow[ centerPoint1, centerPoint2 ]
        }
      ];

imsDrawElements[ a_imsVoltageControlledCurrentSource, nodes_ ] := 
    Module[ { firstPoint , secondPoint, thirdPoint, fourthPoint, 
        vectorNotUnit1,vectorNotUnit2,  lengthVector1,lengthVector2, vector1,
        vector2, vectorOrtho1,vectorOrtho2, p1, p2, p3, p4, p5, p6, p7, p8, 
        p9, p10,p11,p12,p13,p14, centerPoint1, centerPoint2, radius },
      
      { firstPoint , secondPoint, thirdPoint, fourthPoint } = 
        imsGetCoords[ nodes ];
      
      vectorNotUnit1 = secondPoint-firstPoint;
      lengthVector1 = Sqrt[ vectorNotUnit1.vectorNotUnit1 ];
      vector1 = vectorNotUnit1  / lengthVector1;
      vectorOrtho1 = { -1, 1 } *  Reverse[ vector1 ];
      
      vectorNotUnit2= fourthPoint-thirdPoint;
      lengthVector2= Sqrt[ vectorNotUnit2.vectorNotUnit2 ];
      vector2 = vectorNotUnit2  / lengthVector2;
      vectorOrtho2 = { -1, 1 } *  Reverse[ vector2 ];
      
      centerPoint1 = (firstPoint+secondPoint) / 2;
      centerPoint2 = ( thirdPoint + fourthPoint) / 2;
      radius = 0.1 * lengthVector2;
      
      p1 = firstPoint + vector1 * 0.35 * lengthVector1;
      p2 = p1 + vectorOrtho1 * 0.05 * lengthVector1;
      p3 = p1 - vectorOrtho1 * 0.05 * lengthVector1;
      p4 = secondPoint - vector1 * 0.35 * lengthVector1;
      p5 = p4 + vectorOrtho1 * 0.05 * lengthVector1;
      p6 = p4 - vectorOrtho1 * 0.05 * lengthVector1;
      
      p7 = thirdPoint + vector2 * 0.4 * lengthVector2;
      p8 = fourthPoint - vector2 * 0.4 * lengthVector2;
      p9 = centerPoint2 + vectorOrtho2 *radius;
      p10 = centerPoint2 - vectorOrtho2 *radius;
      
      p11 = centerPoint2 - vector2 *radius;
      p12 = centerPoint2 - vector2 *3*radius;
      p13 = p1 - vectorOrtho1 * 0.15 * lengthVector1;
      p14 = p4 - vectorOrtho1 * 0.15* lengthVector1;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p2, p3 } ],
        
        Line[ { p2, p5} ],
        Line[ { p3, p6} ],
        
        Line[ { secondPoint, p4 } ],
        Line[ { p5, p6 } ],
        
        versionArrow[ p11, p12, HeadScaling\[Rule]Relative ],
        versionArrow[ p13, p14, HeadScaling\[Rule]Relative ],
        
        (*
          Text[ "+", firstPoint, { -1, 1 } ],
          Text[ "-", secondPoint, { -1, -1 } ],
          Text[ "V", centerPoint1, {0, -1 } ],
          *)
        
        Line[ { thirdPoint, p7 } ],
        Line[ { p9, p10 } ],
        Line[ { p8, fourthPoint } ],
        Circle[ centerPoint2, radius ],
        
        (*
          Text[ "+", thirdPoint, { -1, 1 } ],
          Text[ "-", fourthPoint, { -1, -1 } ],
          *)
        
        versionArrow[ centerPoint1, centerPoint2 ]
        }
      ];

imsDrawElements[ a_imsCurrentControlledCurrentSource, nodes_ ] := 
    Module[ { firstPoint , secondPoint, thirdPoint, fourthPoint, 
        vectorNotUnit1,vectorNotUnit2,  lengthVector1,lengthVector2, vector1,
        vector2, vectorOrtho1,vectorOrtho2, p1, p2, p3, p4, p5, p6, p7, p8, 
        p9, p10,p11,p12,p13, centerPoint1, centerPoint2, radius },
      
      { firstPoint , secondPoint, thirdPoint, fourthPoint } = 
        imsGetCoords[ nodes ];
      
      vectorNotUnit1 = secondPoint-firstPoint;
      lengthVector1 = Sqrt[ vectorNotUnit1.vectorNotUnit1 ];
      vector1 = vectorNotUnit1  / lengthVector1;
      vectorOrtho1 = { -1, 1 } *  Reverse[ vector1 ];
      
      vectorNotUnit2= fourthPoint-thirdPoint;
      lengthVector2= Sqrt[ vectorNotUnit2.vectorNotUnit2 ];
      vector2 = vectorNotUnit2  / lengthVector2;
      vectorOrtho2 = { -1, 1 } *  Reverse[ vector2 ];
      
      centerPoint1 = (firstPoint+secondPoint) / 2;
      centerPoint2 = ( thirdPoint + fourthPoint) / 2;
      radius = 0.1 * lengthVector2;
      
      p1 = firstPoint + vector1 * 0.35 * lengthVector1;
      p2 = p1 + vectorOrtho1 * 0.05 * lengthVector1;
      p3 = p1 - vectorOrtho1 * 0.05 * lengthVector1;
      p4 = secondPoint - vector1 * 0.35 * lengthVector1;
      p5 = p4 + vectorOrtho1 * 0.05 * lengthVector1;
      p6 = p4 - vectorOrtho1 * 0.05 * lengthVector1;
      
      p7 = thirdPoint + vector2 * 0.4 * lengthVector2;
      p8 = fourthPoint - vector2 * 0.4 * lengthVector2;
      p9 = centerPoint2 + vectorOrtho2 * radius;
      p10 = centerPoint2 - vectorOrtho2 * radius;
      
      p11 = p1 - vector1 * 0.2 * lengthVector1;
      p12= centerPoint2 - vector2 *radius;
      p13= centerPoint2 - vector2 *3*radius;
      
      {
        Line[ { firstPoint, p1 } ],
        Line[ { p2, p3 } ],
        
        Line[ { p2, p5} ],
        Line[ { p3, p6} ],
        
        Line[ { secondPoint, p4 } ],
        Line[ { p5, p6 } ],
        
        versionArrow[ p1, p11, HeadScaling\[Rule]Relative ],
        versionArrow[ p12, p13, HeadScaling\[Rule]Relative ],
        
        (*
          Text[ "+", firstPoint, { -1, 1 } ],
          Text[ "-", secondPoint, { -1, -1 } ],
          Text[ "I", centerPoint1, {0, -1 } ],
          *)
        
        
        Line[ { thirdPoint, p7 } ],
        Line[ { p9, p10 } ],
        Line[ { p8, fourthPoint } ],
        Circle[ centerPoint2, radius ],
        
        (*
          Text[ "+", thirdPoint, { -1, 1 } ],
          Text[ "-", fourthPoint, { -1, -1 } ],
          *)
        
        versionArrow[ centerPoint1, centerPoint2 ]
        }
      ];

imsDrawElements[ a_imsDiode, nodes_ ] := 
    Module[ { firstPoint , lastPoint, vectorNotUnit, lengthVector, vector, 
        vectorOrtho,p1, p2, p3, p4, p5 },
      { firstPoint , lastPoint } = imsGetCoords[ nodes ];
      
      vectorNotUnit = lastPoint - firstPoint;
      lengthVector = Sqrt[ vectorNotUnit.vectorNotUnit ];
      vector = vectorNotUnit  / lengthVector;
      vectorOrtho = { -1, 1 } *  Reverse[ vector ];
      
      p1 = 
        firstPoint + vector * 1/3 * lengthVector + 
          vectorOrtho*0.2*lengthVector;
      p2 = 
        firstPoint + vector * 1/3* lengthVector - 
          vectorOrtho*0.2*lengthVector;
      
      p3 = 
        lastPoint - vector * 1/3 * lengthVector + 
          vectorOrtho*0.2*lengthVector;
      p4 = 
        lastPoint - vector * 1/3* lengthVector - 
          vectorOrtho*0.2*lengthVector;
      
      p5= lastPoint - vector*1/3*lengthVector;
      
      {
        Line[ { firstPoint, lastPoint } ],
        Line[ { p1, p2 } ],
        Line[ { p1, p5 } ],
        Line[ { p2, p5 } ],
        Line[ { p3,p4 } ]
        }
      ];



(* Begin Private *)
End[]



(* Protect[] *)
EndPackage[] 
