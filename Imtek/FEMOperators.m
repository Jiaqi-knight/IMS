(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: FEMOperators.m *)
(* Context: *)
(* 
  Author:oliver ruebenkoenig *)
(* Date: 25.1.2006, 
  Freiburg,Somewhere in the train from leipzig to freiburg *)
(* 
  Summary: This is the IMTEK template for writing a mathematica packages *)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.3.0 *)
(* 
  Mathematica Version: 5.2 *)
(* 
  History: *)
(* 
    well the transpose fix for convection operator was suspect - 
      in the end i figured a new operator ;-) *)
(* 
  in imsFEMLoad and imsNFEMLoad not all variables were declared, 
  this is fixed now *)
(* fixed Tranpose bug in old convection operator; *)
(* 
  added extended fem convection operator; *)
(* complete code rewrite: nD, 
  all elements, real integration over functions; *)
(* 
  Introduced the N* functions; *)
(* Changed the element names; *)
(* 
  Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* 
  Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* Fintie Element Operators *)

(* Copyright (C) 2004 Oliver Ruebenkoenig *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)



(* Start Package *)

BeginPackage["Imtek`FEMOperators`", "Imtek`MeshElementLibrary`", 
    "Imtek`Graph`", "Imtek`Nodes`", "Imtek`ShapeFunctions`",  
    "Imtek`Assembler`" ];





(* *)
(* documentation *)
(* *)
Needs["Imtek`Maintenance`"]
imsCreateObsoleteFunctionInterface[ FEMConvection, $Context ];
imsCreateObsoleteFunctionInterface[ FEMDiffusion, $Context ];
imsCreateObsoleteFunctionInterface[ FEMLoad, $Context ];
imsCreateObsoleteFunctionInterface[ FEMNeumann, $Context ];
imsCreateObsoleteFunctionInterface[ FEMReaction, $Context ];
imsCreateObsoleteFunctionInterface[ FEMTransientMatrix, $Context ];

imsCreateObsoleteFunctionInterface[ NFEMConvection, $Context ];
imsCreateObsoleteFunctionInterface[ NFEMDiffusion, $Context ];
imsCreateObsoleteFunctionInterface[ NFEMLoad, $Context ];
imsCreateObsoleteFunctionInterface[ NFEMNeumann, $Context ];
imsCreateObsoleteFunctionInterface[ NFEMReaction, $Context ];
imsCreateObsoleteFunctionInterface[ NFEMTransientMatrix, $Context ];


(* constructors *)

(* selectors *)

(* predicates *)

(* functions *)

imsFEMConvection::usage= \
"imsFEMConvection[ { inESM, inERHS }, element, nodes, \[Gamma] ] computes \[Gamma]\[Del]u. Where u is the unknown and \[Gamma] a function.";\


imsFEMConservativeFluxConvection::usage="imsFEMConservativeFluxConvection[ { inESM, inERHS }, element, nodes, \[Alpha] ] computes \[Del](-\[Alpha]u). Where u is the unknown and \[Alpha] a function.";\


imsFEMDiffusion::usage= \
"imsFEMDiffusion[ { inESM, inERHS }, element, nodes,  \[Sigma] ] computes \[Del]-\[Sigma]\[Del]u. Where u is the unknown and \[Sigma] a function.";\

imsFEMLoad::usage= \
"imsFEMLoad[ { inESM, inERHS }, element, nodes,  f ] computes load f.";

imsFEMNeumann::usage= \
"imsFEMNeumann[ { inESM, inERHS }, element, nodes ] computes Neumann contribution.";\


imsFEMReaction::usage = \
"imsFEMReaction[ { inESM, inERHS }, element, nodes, \[Beta] ] computes \[Beta]u. Where u is the unknown and \[Beta] a function.";\


imsFEMTransientMatrix::usage = 
    "imsFEMTransientMatrix[ { inEMM, inERHS }, element, nodes, \[Rho] ] computes \[Rho] \[PartialD]u/\[PartialD]t. Where u is the unknown function and \[Rho] is a function.";\



imsNFEMConvection::usage= \
"imsNFEMConvection computes a numerical equivalent of imsFEMConvection.";

imsNFEMConservativeFluxConvection::usage="imsNFEMConservativeFluxConvection computes a numerical equivalent of imsFEMConservativeFluxConvection.";\


imsNFEMDiffusion::usage= \
"imsNFEMDiffusion computes a numerical equivalent of imsFEMDiffusion.";

imsNFEMLoad::usage= \
"imsNFEMLoad computes a numerical equivalent of imsFEMLoad.";

imsNFEMNeumann::usage= \
"imsNFEMNeumann computes a numerical equivalent of imsFEMNeumann.";

imsNFEMReaction::usage = \
"imsNFEMReaction computes a numerical equivalent of imsFEMReaction.";

imsNFEMTransientMatrix::usage = \
"imsNFEMTransientMatrix computes a numerical equivalent of imsFEMTransientMatrix.";\





(* *)
(* options docu *)
(* *)







Begin["`Private`"];



(* private imports *)
(* this is only for the old FEMNeumann operator *)

Needs["Imtek`Point`"];



(* *)
(* implementation part *)
(* *)

(* constructor *)



(* *)
(* define your options *)
(* *)



(* selector *)



(* predicates *)





(* *)
(* private functions *)
(* *)





(* *)
(* public functions *)
(* *)



imsFEMDiffusion[ { inESM_, inERHS_ }, elem_, elementNodes_,  coefficient_ ]:=

        Block[
      {
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals,
        sfxyderiv, weight
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
       (* integration *)
      Do[
        (* deriv of sf *)
        
        sfxyderiv = Transpose[ jInverses[[ step ]] ]. sfrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  integrationWeight[[ step ]] * jDets[[ step ]];
        
        outESMvalues +=  
          Transpose[ sfxyderiv ] . coefficientVals[[ step ]] . sfxyderiv * 
            weight;
        ,
        { step, Length[ integrationWeight ] }
        ];
      
      Return[ { 
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS
          } ];
      ];



imsNFEMDiffusion[ { inESM_, inERHS_ }, elem_, elementNodes_,  coefficient_ ]:=

        Block[
      {
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals,
        sfxyderiv, weight
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsNIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsNIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsNIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
       (* integration *)
      Do[
        (* deriv of sf *)
        
        sfxyderiv = Transpose[ jInverses[[ step ]] ]. sfrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  integrationWeight[[ step ]] * jDets[[ step ]];
        
        outESMvalues +=  
          Transpose[ sfxyderiv ] . coefficientVals[[ step ]] . sfxyderiv * 
            weight;
        ,
        { step, Length[ integrationWeight ] }
        ];
      
      Return[ { 
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS
          } ];
      ];



imsFEMConvection[ { inESM_, inERHS_ }, elem_, elementNodes_, 
      coefficient_ ] := 
    Block[
      {
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals,
        sfxyderiv, weight
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      Do[ 
        (* deriv of sf *)
        
        sfxyderiv = Transpose[ jInverses[[ step ]] ]. sfrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  integrationWeight[[ step ]] * jDets[[ step ]];
        outESMvalues += 
          Transpose[ { sf[[ step ]] }  ] . (coefficientVals[[ step ]]. 
                  sfxyderiv) * weight;
        ,
        { step, Length[ integrationWeight ] }
        ];
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsNFEMConvection[ { inESM_, inERHS_ }, elem_, elementNodes_, 
      coefficient_ ] := 
    Block[
      {
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals,
        sfxyderiv, weight
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsNIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsNIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsNIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      Do[ 
        (* deriv of sf *)
        
        sfxyderiv = Transpose[ jInverses[[ step ]] ]. sfrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  integrationWeight[[ step ]] * jDets[[ step ]];
        outESMvalues += 
          Transpose[ { sf[[ step ]] }  ] . (coefficientVals[[ step ]]. 
                  sfxyderiv) * weight;
        ,
        { step, Length[ integrationWeight ] }
        ];
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsFEMConservativeFluxConvection[ { inESM_, inERHS_ }, elem_, elementNodes_, 
      coefficient_ ] := 
    Block[
      {
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals,
        sfxyderiv, weight
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      Do[ 
        (* deriv of sf *)
        
        sfxyderiv = Transpose[ jInverses[[ step ]] ]. sfrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  integrationWeight[[ step ]] * jDets[[ step ]];
        
        outESMvalues +=
          Transpose[ coefficientVals[[ step ]] . sfxyderiv ] . { 
                sf[[ step ]] } * weight;
        
        ,
        { step, Length[ integrationWeight ] }
        ];
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsNFEMConservativeFluxConvection[ { inESM_, inERHS_ }, elem_, elementNodes_, 
      coefficient_ ] := 
    Block[
      {
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals,
        sfxyderiv, weight
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsNIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsNIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsNIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      Do[ 
        (* deriv of sf *)
        
        sfxyderiv = Transpose[ jInverses[[ step ]] ]. sfrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  integrationWeight[[ step ]] * jDets[[ step ]];
        
        outESMvalues +=
          Transpose[ coefficientVals[[ step ]] . sfxyderiv ] . { 
                sf[[ step ]] } * weight;
        
        ,
        { step, Length[ integrationWeight ] }
        ];
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsFEMReaction[ { inESM_, inERHS_ }, elem_, elementNodes_,  
      coefficient_ ] := 
    Block[
      { 
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      
      outESMvalues += 
        Plus @@ ( 
            coefficientVals *  ( ( Transpose[  { # } ] . { # } )& /@ sf ) * 
              integrationWeight * jDets );
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsNFEMReaction[ { inESM_, inERHS_ }, elem_, elementNodes_,  
      coefficient_ ] := 
    Block[
      { 
        coords, marker, sfElement,
        outESMvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* shape functions *)
      
      sf = imsNIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsNIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsNIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      
      outESMvalues += 
        Plus @@ ( 
            coefficientVals *  ( ( Transpose[  { # } ] . { # } )& /@ sf ) * 
              integrationWeight * jDets );
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsFEMLoad[ { inESM_, inERHS_ }, elem_, elementNodes_,  coefficient_ ]:=
    
    Block[
      {
        coords, marker, sfElement,
        outERHSvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outERHSvalues = imsGetElementMatrixValues[ inERHS ];
      rows = imsGetElementMatrixRows[ inESM ];
      
      (* shape functions *)
      
      sf = imsIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      
      outERHSvalues += 
        Plus @@ ( coefficientVals * sf * integrationWeight * jDets );
      
      Return[ {
          inESM,
          imsMakeElementMatrix[ outERHSvalues, rows, { 1 } ]
          } ];
      ];



imsNFEMLoad[ { inESM_, inERHS_ }, elem_, elementNodes_,  coefficient_ ]:=
    
    Block[
      {
        coords, marker, sfElement,
        outERHSvalues, rows, cols,
        sf, sfrsderiv, integrationWeight,
        jacobians, jDets, jInverses,
        coefficientVals
        },
      
      (* element data *)
      coords = imsGetCoords[ elementNodes ];
      marker = imsGetMarkers[ elem ];
      sfElement = Head[ elem ];
      
      (* retrieve element parts *)
      
      outERHSvalues = imsGetElementMatrixValues[ inERHS ];
      rows = imsGetElementMatrixRows[ inESM ];
      
      (* shape functions *)
      
      sf = imsNIntegratedShapeFunction[ sfElement ];
      sfrsderiv = imsNIntegratedShapeFunctionDerivative[ sfElement ];
      integrationWeight = imsNIntegrationWeights[ sfElement ];
      
      (* mapping *)
      jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* function integration *)
      
      coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
            sf.coords );
      
      (* integration *)
      
      outERHSvalues += 
        Plus @@ ( coefficientVals * sf * integrationWeight * jDets );
      
      Return[ {
          inESM,
          imsMakeElementMatrix[ outERHSvalues, rows, { 1 } ]
          } ];
      ];



imsFEMTransientMatrix[ { inESM_, inERHS_ }, elem_, elementNodes_,  
    coefficient_ ] := 
  Block[
    {
      coords, marker, sfElement,
      outESMvalues, rows, cols,
      sf, sfrsderiv, integrationWeight,
      jacobians, jDets, jInverses,
      coefficientVals,
      sfxyderiv, weight
      },
    
    (* element data *)
    coords = imsGetCoords[ elementNodes ];
    marker = imsGetMarkers[ elem ];
    sfElement = Head[ elem ];
    
    (* retrieve element parts *)
    
    outESMvalues=imsGetElementMatrixValues[ inESM ];
    rows = imsGetElementMatrixRows[ inESM ];
    cols = imsGetElementMatrixColumns[ inESM ];
    
    (* shape functions *)
    sf = imsIntegratedShapeFunction[ sfElement ];
    sfrsderiv = imsIntegratedShapeFunctionDerivative[ sfElement ];
    integrationWeight = imsIntegrationWeights[ sfElement ];
    
    (* mapping *)
    jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
    jDets = Det[ # ]& /@ jacobians;
    jInverses = Inverse[ # ]& /@ jacobians;
    
    (* function integration *)
    
    coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
          sf.coords );
    
    (* integration *)
    
    outESMvalues += 
      Plus @@ ( 
          coefficientVals * ( Dot[ Transpose[ { # } ],{ # } ]& /@ sf  ) * 
            integrationWeight * jDets );
    
    Return[ {
        imsMakeElementMatrix[ outESMvalues, rows, cols ],
        inERHS } ];
    ]



imsNFEMTransientMatrix[ { inESM_, inERHS_ }, elem_, elementNodes_,  
    coefficient_ ] := 
  Block[
    {
      coords, marker, sfElement,
      outESMvalues, rows, cols,
      sf, sfrsderiv, integrationWeight,
      jacobians, jDets, jInverses,
      coefficientVals,
      sfxyderiv, weight
      },
    
    (* element data *)
    coords = imsGetCoords[ elementNodes ];
    marker = imsGetMarkers[ elem ];
    sfElement = Head[ elem ];
    
    (* retrieve element parts *)
    
    outESMvalues=imsGetElementMatrixValues[ inESM ];
    rows = imsGetElementMatrixRows[ inESM ];
    cols = imsGetElementMatrixColumns[ inESM ];
    
    (* shape functions *)
    sf = imsNIntegratedShapeFunction[ sfElement ];
    sfrsderiv = imsNIntegratedShapeFunctionDerivative[ sfElement ];
    integrationWeight = imsNIntegrationWeights[ sfElement ];
    
    (* mapping *)
    jacobians =  Transpose[ (#.coords)]& /@ sfrsderiv;
    jDets = Det[ # ]& /@ jacobians;
    jInverses = Inverse[ # ]& /@ jacobians;
    
    (* function integration *)
    
    coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
          sf.coords );
    
    (* integration *)
    
    outESMvalues += 
      Plus @@ ( 
          coefficientVals * ( Dot[ Transpose[ { # } ],{ # } ]& /@ sf  ) * 
            integrationWeight * jDets );
    
    Return[ {
        imsMakeElementMatrix[ outESMvalues, rows, cols ],
        inERHS } ];
    ]



imsFEMNeumann[ { inESM_, inERHS_ }, triElem_imsTriangleLinear1DOF, 
      elementNodes_ ] := 
    Module[
      { outERHSvalues, (* local element rhs is returned *)
        rhsRows, 
        neumannNodes, neumannVals, aTrianglesEdgeLength
        },
      
      (* *)
      (* retrieve element parts *)
      
      outERHSvalues = imsGetElementMatrixValues[ inERHS ];
      rhsRows = imsGetElementMatrixRows[ inERHS ];
      (* rhsCols = imsGetElementMatrixColumns[ inERHS ]; *)
      
      neumannNodes = 
        Flatten[ 
          Position[ 
            imsGetDatas[ elementNodes ], _?(#\[Equal] "Neumann" &)] ];
      
      If[
        (* boundary element *)
        Length[ neumannNodes ] \[Equal] 2,
        neumannVals = Flatten[ imsGetDatas[ triElem ] ];
        
        (* *)
        (* compute usefull triangle data *)
        
        aTrianglesEdgeLength = 
          imsDistance[ imsGetCoords[ elementNodes[[ neumannNodes ]] ] ];
        
        (* *)
        (* element matrix *)
        
        (* *)
        (* element rhs matrix *)
        
        outERHSvalues += 
          Partition[ aTrianglesEdgeLength /2 * neumannVals, 1 ],
        (* else *)
        Null
        ];
      
      Return[ { 
          inESM,
          imsMakeElementMatrix[ outERHSvalues, rhsRows, { 1 } ]
          } ];
      ];



imsNFEMNeumann[ { inESM_, inERHS_ }, triElem_imsTriangleLinear1DOF, 
      elementNodes_ ] := 
    Module[
      { outERHSvalues, (* local element rhs is returned *)
        rhsRows, 
        neumannNodes, neumannVals, aTrianglesEdgeLength
        },
      
      (* *)
      (* retrieve element parts *)
      
      outERHSvalues = imsGetElementMatrixValues[ inERHS ];
      rhsRows = imsGetElementMatrixRows[ inERHS ];
      (* rhsCols = imsGetElementMatrixColumns[ inERHS ]; *)
      
      neumannNodes = 
        Flatten[ 
          Position[ 
            imsGetDatas[ elementNodes ], _?(#\[Equal] "Neumann" &)] ];
      
      If[
        (* boundary element *)
        Length[ neumannNodes ] \[Equal] 2,
        neumannVals = Flatten[ imsGetDatas[ triElem ] ];
        
        (* *)
        (* compute usefull triangle data *)
        
        aTrianglesEdgeLength = 
          imsDistance[ imsGetCoords[ elementNodes[[ neumannNodes ]] ] ];
        
        (* *)
        (* element matrix *)
        
        (* *)
        (* element rhs matrix *)
        
        outERHSvalues += 
          Partition[ aTrianglesEdgeLength /2. * neumannVals, 1 ],
        (* else *)
        Null
        ];
      
      Return[ { 
          inESM,
          imsMakeElementMatrix[ outERHSvalues, rhsRows, { 1 } ]
          } ];
      ];





imsFEMConvection[ { inESM_, inERHS_ }, elem_, elementNodes_, coefficient_,
      testFunction_, quadPoints_, quadWeights_ ] := 
    Block[ {
        sfElement,testSFElement, sf, sfrsderiv,testSF, testSFrsderiv,
        outESMvalues, rows, cols,
         marker, coords,
        jacobians, jDets, jInverses,
        coefficientVals,
        testSFxyderiv, weight
        },
      
      (* element data *)
      sfElement = Head[ elem ];
      testSFElement = Head[ testFunction ];
      
      (* explicit integration *)
      
      sf = imsShapeFunction[ sfElement ] @@@ quadPoints;
      sfrsderiv = 
        Through[ imsShapeFunctionDerivative[ sfElement ][Sequence@@#]]&/@ 
          quadPoints;
      testSF = imsShapeFunction[ testSFElement ] @@@ quadPoints;
      testSFrsderiv = 
        Through[ imsShapeFunctionDerivative[ testSFElement ][Sequence@@#]]&/@ 
          quadPoints;
      
      (* retrieve element parts *)
      
      outESMvalues=imsGetElementMatrixValues[ inESM ];
      rows = imsGetElementMatrixRows[ inESM ];
      cols = imsGetElementMatrixColumns[ inESM ];
      
      (* *)
      marker = imsGetMarkers[ elem ];
      coords = imsGetCoords[ elementNodes ];
      
      If[
        ( Length[ imsGetIncidentsIds[ elem ] ] ) \[LessEqual] ( 
            Length[ imsGetIncidentsIds[ testFunction ] ] ),
        
        (* mapping *)
        
        jacobians =  Transpose[ (#.coords )]& /@ testSFrsderiv;
        
        (* function integration *)
        
        coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
              testSF.coords );
        ,
        
        (* mapping *)
        
        jacobians =  Transpose[ (#.coords )]& /@ sfrsderiv;
        
        (* function integration *)
        
        coefficientVals =( coefficient @@ Flatten[  { marker, # } ] )& /@ ( 
              sf.coords );
        ];
      
      jDets = Det[ # ]& /@ jacobians;
      jInverses = Inverse[ # ]& /@ jacobians;
      
      (* integration *)
      Do[ 
        (* deriv of sf *)
        
        testSFxyderiv = 
          Transpose[ jInverses[[ step ]] ]. testSFrsderiv[[ step ]];
        
        (* local K and L *)
        
        weight =  quadWeights[[ step ]] * jDets[[ step ]];
        
        outESMvalues += 
          Transpose[ { sf[[ step ]] }  ] . (coefficientVals[[ step ]]. 
                  testSFxyderiv) * weight;
        
        , { step, Length[ quadWeights ] }
        ];
      
      Return[ {
          imsMakeElementMatrix[ outESMvalues, rows, cols ],
          inERHS } ];
      ];



imsFEMConservativeFuxConvection[{inESM_,inERHS_},elem_,elementNodes_,
      coefficient_,testFunction_,quadPoints_,quadWeights_]:=Block[
      {sfElement,testSFElement,sf,sfrsderiv,testSF,testSFrsderiv,outESMvalues,
        rows,cols,marker,coords,jacobians,jDets,jInverses,coefficientVals,
        testSFxyderiv,weight},
      
      (*element data*)
      sfElement=Head[elem];
      testSFElement=Head[testFunction];
      
      (*explicit integration*)
      
      sf=imsShapeFunction[sfElement]@@@quadPoints;
      sfrsderiv=
        Through[imsShapeFunctionDerivative[sfElement][Sequence@@#]]&/@
          quadPoints;
      testSF=imsShapeFunction[testSFElement]@@@quadPoints;
      testSFrsderiv=
        Through[imsShapeFunctionDerivative[testSFElement][Sequence@@#]]&/@
          quadPoints;
      
      (*retrieve element parts*)
      
      outESMvalues=imsGetElementMatrixValues[inESM];
      rows=imsGetElementMatrixRows[inESM];
      cols=imsGetElementMatrixColumns[inESM];
      
      (**)
      marker=imsGetMarkers[elem];
      coords=imsGetCoords[elementNodes];
      If[(Length[imsGetIncidentsIds[elem]])\[LessEqual](Length[
              imsGetIncidentsIds[testFunction]]),
        
        (*mapping*)
        jacobians=Transpose[(#.coords)]&/@testSFrsderiv;
        (*function integration*)
        
        coefficientVals=(coefficient@@
                  Flatten[{marker,#}])&/@(testSF.coords);,
        
        (*mapping*)
        jacobians=Transpose[(#.coords)]&/@sfrsderiv;
        (*function integration*)
        
        coefficientVals=(coefficient@@Flatten[{marker,#}])&/@(sf.coords);
        ];
      
      jDets=Det[#]&/@jacobians;
      jInverses=Inverse[#]&/@jacobians;
      
      (*integration*)
      Do[
        (*deriv of sf*)
        
        sfxyderiv=Transpose[ jInverses[[step]] ].sfrsderiv[[step]];
        (*local K and L*)
        weight=quadWeights[[step]]*jDets[[step]];
        
        outESMvalues +=  
          Transpose[(coefficientVals[[step]].sfxyderiv)].{testSF[[step]]}*
            weight;
        
        ,{step,Length[quadWeights]}
        ];
      
      Return[{imsMakeElementMatrix[ outESMvalues ,rows,cols],inERHS}];
      ];



(* representors *)



End[] (* of Begin Private *)



(* Protect[] (* anything *) *)
EndPackage[] 
