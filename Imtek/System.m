(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)















(* Start Package *)

BeginPackage[
    "Imtek`System`",{"Imtek`Debug`","Imtek`BackwardCompatability`"}]; 



(* *)
(* documentation *)
(* *)
Needs["Imtek`Maintenance`"]
imsCreateObsoleteFunctionInterface[ MakeSystem, $Context ];
imsCreateObsoleteFunctionInterface[ GetInertia, $Context \
];imsCreateObsoleteFunctionInterface[ GetDamping, $Context \
];imsCreateObsoleteFunctionInterface[ GetStiffness, $Context \
];imsCreateObsoleteFunctionInterface[ GetLoad, $Context \
];imsCreateObsoleteFunctionInterface[ SetInertia, $Context \
];imsCreateObsoleteFunctionInterface[ SetDamping, $Context ];
imsCreateObsoleteFunctionInterface[ SetStiffness, $Context \
];imsCreateObsoleteFunctionInterface[ SetLoad, $Context \
];imsCreateObsoleteFunctionInterface[ StationaryQ, $Context \
];imsCreateObsoleteFunctionInterface[ FirstOrderQ, $Context \
];imsCreateObsoleteFunctionInterface[ SecondOrderQ, $Context \
];imsCreateObsoleteFunctionInterface[ ParametricStiffnessQ, $Context \
];imsCreateObsoleteFunctionInterface[ ParametricDampingQ, $Context \
];imsCreateObsoleteFunctionInterface[ ParametricStiffnessQ, $Context \
];imsCreateObsoleteFunctionInterface[ ParametricInertiaQ, $Context \
];imsCreateObsoleteFunctionInterface[ ParametricQ, $Context \
];imsCreateObsoleteFunctionInterface[ ToFirstOrder, $Context ];













(* *)
(* documentation *)
(* *)

(********** constructors **********)
(* 
  MakePolynomialSystem should be changed to "PolynomialSystem" only ... *)

imsSystem::usage = 
      "imsSystem is the expression returned by imsMakeSystem represents a data structure for storing systems of equations with polynomial nonlinearities.";\
 (* Core *)
  
  imsMakeSystem::usage=
      "imsMakeSystem[ l, { s, s2..sn }, { d, d2..dn }, { i, i2..in } ] creates a imsSystem data structure. l is a column load vector, s,d and i are stiffness, damping and inertia matrices respectively. The matrices d and i are optional. So are the matrices s2 to sn, d2 to dn and i2 to in. The column vectors l can have multiple columns.";\
 (* Convenience *)
  
  imsMakeSystemPolynomial::usage="imsMakeSystemPolynomial[ {DimJ, DimK, ...}, {imsPolynomMatrix[{J1, K1,..}, M1],.., imsPolynomialMatrix[{Jn, Kn,..}, Mn]}] creates an imsSystem data structure, but allows for polynomial systems. J1 is the list of occurences of time derivatives of x in the product, K1 is the same for the imputs u. Further lists may be given for extensions to other problems or parameters. DimJ is in this case the dimension of x, DimK that of u, and so on.";\
 (* Core *)
  
  imsPolynomMatrix::usage=
    "imsPolynomMatrix represents a data tructure for storing the coefficients of a matrix polynomial.";\
(*Core*)
  
  imsMakePolynomMatrix::usage="imsMakePolynomMatrix[{J1,K1,...},M1] creates an imsPolynomMatrix data structure. The J1,.. are the exponents of time derivatives of the various variables";\
 (* Core *)
  
  (********** selectors **********)
  
  imsGetInertia::usage="imsGetInertia[ system ] returns the system's inertia.";\
 (* Convenience *)
  
  imsGetDamping::usage="imsGetDamping[ system ] returns the system's damping.";\
 (* Convenience *)
  
  imsGetStiffness::usage="imsGetStiffness[ system ] returns the system's stiffness.";\
 (* Convenience *)
  
  imsGetLoad::usage="imsGetLoad[ system ] returns the systems load."; (* 
    Convenience *)
  
  imsGetSystemPolynomMatrix::usage="imsGetSystemPolynomMatrix[ system, {Ji, Ki,..} ] returns the imsPolynomMatrix tensor for the respective combinations of x und u time derivatives given by Ji, Ki,..";\
 (* Core *)
  
  imsGetPolynomMatrixExponents::usage="imsGetPolynomMatrixExponents[M] returns the exponent lists {Ji, Ki,..} of the imsPolynomMatrix M.";\
 (* Core *)
  
  imsGetPolynomMatrixValues::usage="imsGetPolynomMatrixValues[M] returns the coefficient tensor of the imsPolynomMatrix M.";\
 (* Core *)
  
  imsGetSystemPolynomMatrices::usage="imsGetSystemPolynomMatrices[ system, {Ji, Ki,..} ] returns all imsPolynomMatrices of a system for which the exponents match the pattern {Ji, Ki,..}.";\
 (* Core *)
  
  imsGetSystemSize::usage="imsGetSystemSize[ system ] returns the length of the state vector.";\
 (* Core *)
  
  imsGetSystemVariables::usage="imsGetSystemVariables[ system ] returns the dimension of parameter, input and state vectors.";\
 (* Core *)
  
  imsPolynomMatrixCanonicalExponents::usage="imsPolynomMatrixCanonicalExponents[ {Ji, Ki,..} ] returns the canonical form of the exponent lists {Ji, Ki,..}. It mainly strips trailing zeros and empty lists.";\
 (* Core *)
  
  (********** mutators **********)
  
  imsSetSystemMatrix::usage="imsSetSystemMatrix[ system, imsPolynomMatrix[{Ji,Ki},M] ] returns system with its M_JiKi.. object replaced by M or added. If M is empty, the matrix is simply deleted.";\
 (* Core *)
  (* 
    imsSetSystemParametricMatrix::usage=
      "imsSetSystemParametricMatrix[ system, {Ji, Ki,..}, M0, {M1, M2, ...} ] sets a matrix M0 and its parametric parts.";\
 IMHO not necessary to export. YMMV. *)
  
  imsSetInertia::usage="imsSetInertia[ system, {i, i2..in} ] returns system with its inertia replaced by {i, i2..in}.";\
 (* Convenience *)
  
  imsSetDamping::usage="imsSetDamping[ system, {d, d2..dn} ] returns system with its damping replaced by {d, d2..dn}.";\
 (* Convenience *)
  
  imsSetStiffness::usage="imsSetStiffness[ system, {s, s2..sn} ] returns system with its stiffness replaced by {s, s2..sn}.";\
 (* Convenience *)
  
  imsSetLoad::usage="imsSetLoad[ system, l ] returns system with its load replaced by column load vector l.";\
 (* Convenience *)
  
  imsPolynomMatrixContract::usage="imsPolynomMatrixContract[ M, { {i1, v1}, {i2, v2}, ... } ] calculates the product of M with the vi at indices ii, e.g. for i1=2 and i2=4: Mijkl v1j v2l. M may be an array or an imsPolynomMatrix.";\
 (* Core *)
  
  imsPolynomMatrixContractAll::usage=
      "imsPolynomMatrixContractAll[ pm, vc, vr, vu, vf ] calls imsPolynomMatrixContract such that all parameter levels are multiplied with vc, the row level with vr, the state levels with vu and the input levels with vf; A non-List for any of those means that this contraction is ignored.";\
 (* Convenience *)
  
  imsPolynomMatrixContractAllDerivatives::usage=
      "imsPolynomMatrixContractAllDerivatives[ pm, vc, vr, vu, vf ] calls imsPolynomMatrixContract such that all parameter levels with time derivative are multiplied with vc[[1]], the first time derivatives with vc[[2]] and so on, the row level with vr, the state levels with vu[[1]], the velocity levels with vu[[2]] and so on, the input levels with vf[[1]], the time derivatives of the input with vf[[2]] etc.; A non-List for any of those means that this contraction is ignored.";\

  (* Convenience *)
  
  (********** predicates **********)
  
  imsStationaryQ::usage = \
"imsStationaryQ[ system ] returns True if system is stationary."; (* 
    Convenience *)
  
  imsFirstOrderQ::usage = \
"imsFirstOrderQ[ system ] returns True if system is of first order."; (* 
    Convenience *)
  
  imsSecondOrderQ::usage = 
    "imsSecondOrderQ[ system ] returns True if system is of second order."; (* 
    Convenience *)
  
  imsParametricStiffnessQ::usage = \
"imsParametricStiffnessQ[ system ] returns True if system has more than one stiffness matrix.";\
 (* Convenience *)
  
  imsParametricDampingQ::usage = \
"imsParametricDampingQ[ system ] returns True if system has more than one damping matrix.";\
 (* Convenience *)
  
  imsParametricInertiaQ::usage = \
"imsParametricInertiaQ[ system ] returns True if system has more than one inertia matrix.";\
 (* Convenience *)
  
  imsParametricQ::usage = \
"imsParametricQ[ system ] returns True if system has parametric matrices."; (* 
    Convenience *)
  
  imsLinearQ::usage = \
"imsLinearQ[ system, function ] returns True if system is linear w.r.t function.";\
 (* Convenience *)
  
  imsPolynomMatrixContainsExponentsQ::usage="imsPolynomMatrixContainsExponentsQ[ M, {Ji, Ki,..} ] returns True if after canonicalization the exponents of the imsPolynomMatrix match {Ji, Ki,..}";\
 (* Core *)
  
  imsSystemContainsExponentsQ::usage="imsSystemContainsExponentsQ[ system, pattern ] returns True if pattern matches any of the system's matrices' exponents.";\
 (* Core *)
  
  imsSystemContainsOnlyExponentsQ::usage="imsSystemContainsExponentsQ[ system, pattern ] returns True if pattern matches all of the system's matrices' exponents.";\
 (* Core *)
  
  imsSystemContainsMoreExponentsQ::usage="imsSystemContainsMoreExponentsQ[ system ] returns True if there are more than the usual (possibly parametrized) load, stiffness, damping and inertia matrices.";\
 (* Core *)
  
  (********** functions **********)
  
  imsPolynomMatrixToMatrix::usage="imsPolynomMatrixToMatrix [ imsPolynomMatrix, xvar_Symbol ] converts a polynomial matrix to an object with lower tensor rank by moving all but one occurences of the state variable inside, creating possibly nonlinear matrix entries.";\
 (* Core *)
  
  imsToFirstOrder::usage = \
"imsToFirstOrder[ system ] transforms a second order system to a symmetric first order system.";\
 (* Core *)
  
  imsStiffnessToIdentity::usage="imsStiffnessToIdentity[system] transforms a system such that the stiffness matrix is the Identity matrix";\

  
  imsToSimpleSystem::usage=
      "imsToSimpleSystem[ imsSystem, xvar_Symbol ] converts a polynomial system to a standard inertia-damping-stiffness-load system with nonlinear matrices as a function of xvar. Currently does not convert time derivatives.";\

  
  imsLinearizeSystem::usage="imsLinearizeSystem[sys, op] returns a version of sys whose matrices are linearized in the state variable around operation point op. The matrix elements may not include the state variable."
\
  
  (* "not yet implemented:\n\nimsLinearizeSystem[sys, xvar, op] returns a version of sys whose stiffness is linearized in xvar[i] around operation point op. The matrix elements may not include the state variable." \
*)



imsSkipRows::usage="Option for imsPolynomMatrixContract which specifies if the index for rows should be skipped for contracting/projecting. Default: True";



(* *)
(* Error Messages *)
(* *)

imsSystem::"noinertia" = "`1` has no inertia.";
imsSystem::"nodamping" = "`1` has no damping.";
imsSystem::"nostiffness" = "`1` has no stiffness.";
imsSystem::"noload" = "`1` has no load.";





Begin["`Private`"];



myFirst[{}]:={};
myFirst[l___]:=First[l];
myLast[{}]:={};
myLast[l___]:=Last[l];

(* representors *)
Format[ sys_imsSystem  ] := Which[
        imsSystemContainsMoreExponentsQ[sys],
        "imsSystem[<<Poly>>"<>ToString[imsGetSystemVariables[sys]]<>","<>
          StringJoin[(" <"<>ToString[imsGetPolynomMatrixExponents[#]]<>">")&/@
              imsGetSystemPolynomMatrices[sys,_]],
        
        imsStationaryQ[ sys ], 
        "imsSystem["<> ToString[ 
            Length[ myFirst[ imsGetStiffness[ sys ] ] ] ] <> ", " <> 
          ToString[ { myLast[ Dimensions[ imsGetLoad[ sys ] ] ], 
              Length[ imsGetStiffness[ sys ] ], 0, 0 } ],
        
        imsFirstOrderQ[ sys ],
        "imsSystem["<> ToString[ 
            Length[ myFirst[ imsGetStiffness[ sys ] ] ] ] <> ", " <> 
          ToString[ { myLast[ Dimensions[ imsGetLoad[ sys ] ] ], 
              Length[ imsGetStiffness[ sys ] ], 
              Length[ imsGetDamping[ sys ] ], 0 } ],
        
        imsSecondOrderQ[ sys ],
        "imsSystem["<> ToString[ 
            Length[ myFirst[ imsGetStiffness[ sys ] ] ] ] <> ", " <> 
          ToString[ { myLast[ Dimensions[ imsGetLoad[ sys ] ] ], 
              Length[ imsGetStiffness[ sys ] ], 
              Length[ imsGetDamping[ sys ] ], 
              Length[ imsGetInertia[ sys ] ] } ],
        
        True,"imsSystem[..."
        ]<>"]";



imsPolynomMatrix/:a_?NumericQ*imsPolynomMatrix[be_,bv_]:=
    imsMakePolynomMatrix[be,a*bv];

imsSystem/:a_?NumericQ*imsSystem[be_,bv_]:=
    imsMakeSystemPolynomial[be,Expand[a*bv]];

Plus[imsPolynomMatrix[ae_,av_],imsPolynomMatrix[be_,bv_]]^:=
    imsMakePolynomMatrix[ae,av+bv]/;SameQ[ae,be];

imsSystem/:Plus[imsSystem[e_,m_],b_imsPolynomMatrix]:=
    imsMakeSystemPolynomial[e,m+b];

Plus[imsSystem[ae_,av_],imsSystem[be_,bv_]]^:=
    imsMakeSystemPolynomial[ae,av+bv]/;SameQ[ae,be];



(* *)
(* implementation part *)
(* *)

checkSystemConsitency[ { loadF_, matRest__ } ] :=
    SameQ @@ Join[ { Length[ loadF ] },  
        Last[ Dimensions[ # ] ]& /@ { matRest } ]; 
checkParametricConsistency[ mat__ ] := 
    SameQ @@ ( Dimensions[ # ]& /@ { mat } );

(* constructor *)



imsMakeSystem[ load_?MatrixQ, s_?MatrixQ ] := imsMakeSystem[ load, { s } ];
imsMakeSystem[ load_?MatrixQ, s_?MatrixQ, d_?MatrixQ ] := 
    imsMakeSystem[ load, { s }, { d } ];
imsMakeSystem[ load_?MatrixQ, s_?MatrixQ, d_?MatrixQ, m_ ?MatrixQ] := 
    imsMakeSystem[ load , { s }, { d }, { m } ];



imsMakeSystem[ l_, s:{ matS_, matSP___ } ]/; 
      checkSystemConsitency[ { l, matS } ] && 
        checkParametricConsistency[ { matS, matSP } ] :=
    imsSetLoad[
      imsSetStiffness[
        imsMakeSystemPolynomial[Join[
            
            If[Length[s]>1,{1},{0}],             (* 
              Number of parameters *)
            {Length[
                matS[[1]]],                        (* Length of x vector *)
  
                          Length[l[[1]]]}                             (* 
              Number of inputs *)
            ],{} 
          ],s],l];



imsMakeSystem[ l_, s:{ matS_, matSP___ }, d:{ matD_, matDP___ } ]/; 
      checkSystemConsitency[ { l, matS, matD } ] && 
        checkParametricConsistency[ { matS, matSP, matD, matDP } ]:= 
     imsSetDamping[imsMakeSystem[l,s],d];



imsMakeSystem[ l_,  s:{ matS_, matSP___ }, d:{ matD_, matDP___ }, 
        m:{ matM_, matMP___ } ]/; 
      checkSystemConsitency[ { l, matS, matD, matM } ] && 
        checkParametricConsistency[ { matS, matSP, matD, matDP, matM, 
            matMP } ]:= 
    imsSetInertia[imsMakeSystem[ l, s, d], m ];



imsMakeSystem[ l_,  s:{ matS_, matSP___ },{ }, m:{ matM_, matMP___ } ]/; 
      checkSystemConsitency[ { l, matS,  matM } ] && 
        checkParametricConsistency[ { matS, matSP, matM, matMP } ]:= 
    imsSetInertia[imsMakeSystem[ l, s], m ];



imsMakeSystemPolynomial[ dim_,m_List]:=imsSystem[dim,Plus@@m];
imsMakeSystemPolynomial[ dim_,m_]/;(Head[m]=!=List):=imsSystem[dim,m];

imsMakePolynomMatrix[exp_,m_]:=
    imsPolynomMatrix[imsPolynomMatrixCanonicalExponents[exp],m];



(* selector *)

imsGetParametricMatrix[sys_,e_]:=
    Return[Release[
        Join[{imsGetPolynomMatrixValues[
              imsGetSystemPolynomMatrix[sys,{{},e}]]},
          Flatten[(Hold/@imsGetPolynomMatrixValues[#])&/@
              imsGetSystemPolynomMatrices[sys,{{__},e,___}],1]]]];

imsGetInertia[sys_imsSystem]:=
    If[imsSystemContainsExponentsQ[sys,{{},{0,0,1}}],
      imsGetParametricMatrix[sys,{0,0,1}]//Return,
      Message[imsSystem::"noinertia",sys];Return[$Failed];];

imsGetDamping[ sys_imsSystem ] :=
    If[imsSystemContainsExponentsQ[sys,{{},{0,1}}],
      imsGetParametricMatrix[sys,{0,1}]//Return,
      If[imsSecondOrderQ[sys],Return[{}],
          Message[ imsSystem::"nodamping", sys ];Return[$Failed]];];

imsGetStiffness[ sys_imsSystem] :=
     
    If[imsSystemContainsExponentsQ[sys,{{},{1}}],
      Return[imsGetParametricMatrix[sys,{1}]],
      If[imsSecondOrderQ[sys]||imsFirstOrderQ[sys],Return[{}],
          Message[ imsSystem::"nostiffness", sys ];Return[$Failed]];];

(* Sign change! *)

imsGetLoad[ sys_imsSystem] := 
    If[imsSystemContainsExponentsQ[
        sys,{{},{},{1}}],-imsGetPolynomMatrixValues[
            imsGetSystemPolynomMatrix[sys,{{},{},{1}}]]//Return,
      Message[ imsSystem::"noload", sys ];Return[$Failed];];

imsPolynomMatrixCanonicalExponents[
      l_List]:=(l/.{{a:___,b:Except[0],Repeated[0]}\[Rule]{a,b}})/.{{Repeated[
                  0]}\[Rule]{}}/.{a:___,b:Except[{}],Repeated[{}]}\[Rule]{a,
            b}/.{Repeated[{}]}\[Rule]{};
imsPolynomMatrixCanonicalExponents[a_]:=a;

imsGetPolynomMatrixExponents[imsPolynomMatrix[e_,_]]:=e;
imsGetPolynomMatrixValues[imsPolynomMatrix[_,v_]]:=v//Return;
imsGetPolynomMatrixExponents[{}]:={};
imsGetPolynomMatrixValues[{}]:={};

imsGetSystemPolynomMatrix[sys_imsSystem,pattern_]:=
    Module[{r},
      If[Length[r=imsGetSystemPolynomMatrices[ sys, pattern ]]>0,r[[1]],{}]//
        Return];

imsGetSystemPolynomMatrices[ s:imsSystem[d_,sys_], 
      pattern_ ]:=
    (Cases[sys,
          imsPolynomMatrix[imsPolynomMatrixCanonicalExponents[pattern],_],{0,
            Infinity}]//Return);

imsGetSystemSize[ imsSystem[d_,___] ]:=d[[2]];
imsGetSystemVariables[ imsSystem[d_,___] ]:=d;



(* mutators *)

imsSetSystemMatrix[s_imsSystem,pm:imsPolynomMatrix[ee_,m_]]:=
        imsMakeSystemPolynomial[imsGetSystemVariables[s],
          If[m=!={},
            Append[imsGetSystemPolynomMatrices[s,
                Except[imsPolynomMatrixCanonicalExponents[ee]]],pm],
            imsGetSystemPolynomMatrices[s,
              Except[imsPolynomMatrixCanonicalExponents[ee]]]]];
    
    imsSetSystemParametricMatrix[s_imsSystem,e_,m_]:=
        imsSetSystemMatrix[If[Length[m]>1,
            imsSetSystemMatrix[s,imsPolynomMatrix[{{1},e},Drop[m,1]]],
            imsSetSystemMatrix[s,imsPolynomMatrix[{{1},e},{}]]
            ],imsPolynomMatrix[{{},e},m[[1]]]];
    
    imsSetInertia[s_imsSystem,m:{ matS_, matSP___ }]:=
      
      imsSetSystemParametricMatrix[s,{0,0,1},m];
    
    imsSetDamping[s_imsSystem,m:{ matS_, matSP___ }]:=
      
      imsSetSystemParametricMatrix[s,{0,1},m];
    
    imsSetStiffness[s_imsSystem,m:{ matS_, matSP___ }]:=
      
      imsSetSystemParametricMatrix[s,{1},m];
    
    (* Sign change! *)
    
    imsSetLoad[s:imsSystem[v_,d_],l_]:=
      imsSetSystemVariables[
        imsSetSystemMatrix[s,imsPolynomMatrix[{{},{},{1}},-l]],
        ReplacePart[v,Dimensions[l],{{2},{3}},{{1},{2}}]];
  
  imsSetSystemVariables[imsSystem[v_,d___],nv_]:=imsSystem[nv,d];



(* predicates *)

imsPolynomMatrixContainsExponentsQ[imsPolynomMatrix[d_,___],pattern_]:=
    MatchQ[d,imsPolynomMatrixCanonicalExponents[pattern]];

imsSystemContainsExponentsQ[s_imsSystem,pattern_]:=
    Length[imsGetSystemPolynomMatrices[ s, 
          imsPolynomMatrixCanonicalExponents[pattern] ]]>0;

imsSystemContainsOnlyExponentsQ[s_imsSystem,pattern_]:=
    And@@(imsPolynomMatrixContainsExponentsQ[#,pattern]&/@
          imsGetSystemPolynomMatrices[ s, _ ]);

imsStationaryQ[ s_imsSystem ] := 
    imsSystemContainsOnlyExponentsQ[s, {{___},{_}|{},___} |{{___}}|{}];
imsFirstOrderQ[ s_imsSystem ] := 
    imsSystemContainsOnlyExponentsQ[s, {{___},{_,_}|{_}|{},___}|{{___}}|{}]&&
      imsSystemContainsExponentsQ[s, {{___},{_,_},___} ];
imsSecondOrderQ[ s_imsSystem ] := 
    imsSystemContainsOnlyExponentsQ[
        s, {{___},{_,_,_}|{_,_}|{_}|{},___} |{{___}}|{}]&&
      imsSystemContainsExponentsQ[s, {{___},{_,_,_},___} ];
imsParametricStiffnessQ[ s_imsSystem ] := 
  imsSystemContainsExponentsQ[s,{{__},{1}}]
imsParametricDampingQ[ s_imsSystem ] := 
    imsSystemContainsExponentsQ[s,{{__},{0,1}}];
imsParametricInertiaQ[ s_imsSystem ] := 
    imsSystemContainsExponentsQ[s,{{__},{0,0,1}}];

imsParametricQ[ a_imsSystem ] := 
    imsParametricStiffnessQ[ a ] || imsParametricDampingQ[ a ] || 
      imsParametricInertiaQ[ a ];
imsParametricQ[ ___ ] := False;

(* Crude hack... When is a system nonlinear wrt f? 
      We assume f is one of the states. 
      Then we can have either matrices with two state (+velocity...) or input \
exponents (so the second+
            third+... exponent sublists have more than one entry in total) or \
we can have matrices with on state exponent and f somewhere inside, 
  or we can have matrices without state exponent, 
  but entries where f occurs in a nonlinear fashion, 
  i.e. not in a simple sum or some number times f *)

imsLinearQ[ s_imsSystem, f_ ]:=!(
        Or@@(((Plus@@Flatten[Drop[imsGetPolynomMatrixExponents[#],1]]+
                          If[MemberQ[
                              ArrayRules[imsGetPolynomMatrixValues[#]][[All,
                                  2]],f,{1,Infinity}],1,0])>1)&/@
                imsGetSystemPolynomMatrices[s,{{___},__}])
          ||
          
          Or@@(MemberQ[
                    Replace[
                      ArrayRules[imsGetPolynomMatrixValues[#]][[All,
                          2]],{Plus\[Rule]Sequence,
                        Times[c_/;NumberQ[c],b_]\[Rule]b},{1,Infinity}],
                    f,{2,Infinity}]&/@
                imsGetSystemPolynomMatrices[s,Except[{{___},__}]])
        );

imsSystemContainsMoreExponentsQ[
      sys_imsSystem]:=!imsSystemContainsOnlyExponentsQ[sys, 
        {{},{},{1}}                                 (* 
            load *)
          | {{},{1}}                                 (* 
            stiffness *)
          | {{1},{1}}             (* 
            stiffness par *)
          | {{},{0,1}}                          (* 
            damping *)
          | {{1},{0,1}}       (* 
            damping par *)
          | {{},{0,0,1}}                    (* 
            inertia *)
          | {{1},{0,0,1}} (* intertia par *)
        ];



Options[imsPolynomMatrixContract]=imsSkipRows\[Rule]True;





(* For BlockMatrix *)

If[ $VersionNumber \[LessEqual] 5.2, 
    Needs["LinearAlgebra`MatrixManipulation`"], Null ];
If[ $VersionNumber \[LessEqual] 5.2, 
  myBlockMatrix[data_] := BlockMatrix[data],
  myBlockMatrix[data_] := ArrayRules[ArrayFlatten[data]] ]



myExtract[l_,p_]:=
    If[Length[p]\[Equal]0,l,
      If[Length[l]\[GreaterEqual]First[p],myExtract[l[[First[p]]],Rest[p]],
        Null]];



imsToFirstOrder[ sys_imsSystem ] /; imsFirstOrderQ[ sys ]  := sys;

imsToFirstOrder[ sys_imsSystem ] /; 
      imsSecondOrderQ[ 
          sys ] && !imsParametricQ[ sys ]&&!imsSystemContainsMoreExponentsQ[ 
            sys ]:= Module[
      { l = imsGetLoad[ sys ],
        fs = First[ imsGetStiffness[ sys ] ],
        (* for mma6.0 this should be 0. zeros *)
        
        zeros = SparseArray[ {}, 
            Dimensions[ First[ imsGetStiffness[ sys ] ] ],0. ],
        fi = First[ imsGetInertia[ sys ] ]
        },
      imsMakeSystem[
        (* { F, 0 } *)
        
        Join[ l, 
          Table[ 0., 
            Evaluate[ Sequence @@ Partition[ Dimensions[ l ], 1 ] ] ] ],
        (* { { S, 0 }, { 0, -W=-M } } *)
        
        SparseArray[ myBlockMatrix[ { { fs, zeros },{ zeros, -fi } } ] ],
        (* { { D, M }, { W=M, 0 } } *) 
        SparseArray[ 
          myBlockMatrix[ { { First[ imsGetDamping[ sys ] ], fi },{ fi, 
                zeros } } ] ]
        ]
      ];



(*imsStiffnessToIdentity[
        sys_imsSystem]/; (*!imsParametricStiffnessQ[ 
              sys ]&&*)!imsSystemContainsMoreExponentsQ[ sys ]:=
    Module[{l,s,d,m,s1,sn={}},
      l=imsGetLoad[sys];
      s=imsGetStiffness[sys];
      d=If[imsSecondOrderQ[sys]||imsFirstOrderQ[sys],imsGetDamping[sys],{}];
      m=If[imsSecondOrderQ[sys], imsGetInertia[sys],{}];
      s1=LinearSolve[First[s]];
      Return[
        imsMakeSystem@@
          DeleteCases[{s1[l],
              Prepend[s1[#]&/@Drop[s,1],IdentityMatrix[Length[s[[1]]]]],
              s1[#]&/@d,s1[#]&/@m},{}]]
      ]*)

imsStiffnessToIdentity[sys_imsSystem]:=
  Module[{s=Inverse[First[imsGetStiffness[sys]]]},
    Return[
      imsMakeSystemPolynomial[ imsGetSystemVariables[sys],
        Append[imsPolynomMatrixContractAll[#,Null,s,Null,Null]&/@ 
            imsGetSystemPolynomMatrices[sys,Except[{{},{1}}]],
          imsMakePolynomMatrix[{{},{1}},IdentityMatrix[Length[s]]]]]]
    ]



(* private *)

imsLinearizePolynomMatrix[m_imsPolynomMatrix,op_]:=
  Module[{e=imsGetPolynomMatrixExponents[m],istart,iend},
    
    (*** Constant (parametric) matrices *)
    If[Length[e]<2,Return[{m}]];
    (*** Matrix without state, like B.u *)
    
    If[Length[e[[2]]]<1,Return[{m}]];
    (*** Already linear, like K.x *)
    If[e[[2]]\[Equal]{1},Return[{m}]]; 
    (* All following matrices have some nonlinear state contribution *)
    
    (* First index of state: Number of parameters + 1 *)
    
    istart=(Plus@@e[[1]])+1;
    (* Last index of state: the number above + number of states - 1 *)
    
    iend=istart+e[[2,1]]-1;
    
    (*** If we have something like d^nx/dt^n, kill all states, 
      otherwise leave one for stiffness matrix *)
    If[Length[e[[2]]]==1,
      (* No d^nx/dt^n *)
      Return[Append[imsPolynomMatrixContract[m,
                ({#,op})&/@#]&/@Subsets[Range[istart,iend],{iend-istart}],
          imsPolynomMatrixContract[m,Table[{j,op},{j,istart,iend}]]]
        ],
      (* with d^nx/dt^n *)
      
      Return[{imsPolynomMatrixContract[m,Table[{j,op},{j,istart,iend}]]}]
      ];
    ]



imsLinearizeSystem[sys_imsSystem,op_]:=
    imsMakeSystemPolynomial[imsGetSystemVariables[sys],
      Flatten[ imsLinearizePolynomMatrix[#,op]&/@
          imsGetSystemPolynomMatrices[sys,_],1]];

(*imsLinearizeSystem[sys_imsSystem,xvar_Symbol,op_List]:=
      Module[{},
        jacobian=
          SparseArray[(Rule[#[[All,1]],#[[All,2]]]&)[
              Flatten[MapIndexed[((*If[Mod[#2[[1]],100]\[Equal]0,
                            Print[#2[[1]]]];*)derivvars=
                        Transpose[
                          Union[Cases[#1,
                              b:xvar[a:_]\[Rule]{b,a},{0,\[Infinity]}]]];
                      row=#2[[1]];
                      
                      MapThread[{{row,#1},#2}&,{derivvars[[2]],
                          D[#1,{derivvars[[1]]}]}])&,func],1]],{Length[xvec],
              Length[xvec]}]];*)



imsPolynomMatrixToMatrix[p:imsPolynomMatrix[e_,v_],xvar_Symbol]:=
    Module[{tocontract=0,coffs,xe,n,i,j,enew},
      
      (*** Constant (parametric) matrices *)
      If[Length[e]<2,Return[p]];
      (*** Matrix without state, like B.u *)
      
      If[Length[e[[2]]]<1,Return[p]];
      
      (*** If we have something like dx/dt or if we have an input, 
        kill all states, otherwise leave one for stiffness matrix *)
      
      tocontract=If[Length[e[[2]]]>1||Length[e]>2,e[[2,1]],e[[2,1]]-1];
      If[tocontract<1,Return[p]];
      
      (*** Subtract killed indices from coefficient list *)
      enew=e; 
      enew[[2,1]]-=tocontract;
      (*** Before first index of state: Number of parameters + 1 (for rows) *)

            coffs=(Plus@@e[[1]])+1;
      n=Dimensions[v][[coffs+1]];
      xe=Array[xvar,n];
      i=Transpose[Table[{j,xe},{j,coffs+tocontract,coffs+1,-1}]]; 
      
      (* Start from back *) 
      Return[
        imsMakePolynomMatrix[enew,
          imsPolynomMatrixContract[v,
            Transpose[{Range[coffs+tocontract,coffs+1,-1],
                Table[xe,{j,coffs+1,coffs+tocontract}]}]]]];
      ];



imsToSimpleSystem[s_imsSystem, xvar_Symbol]:=
    imsMakeSystemPolynomial[imsGetSystemVariables[s],
      imsPolynomMatrixToMatrix[#,xvar]&/@imsGetSystemPolynomMatrices[s,_]];



imsPolynomMatrixContract[m_imsPolynomMatrix,
    w2:{{_Integer,_List|_SparseArray}...},opts___]:=
  Module[{e=imsGetPolynomMatrixExponents[m],exppos,csum,w=w2,wnorows,skiprows,
      a,b},
    imsDebugMessage["Imtek`System`imsPolynomMatrixContract", 2, 
      "Imtek`System`imsPolynomMatrixContract: exp: "<>ToString[
          imsGetPolynomMatrixExponents[m]]<>" | Dim m: "<>
        ToString[Dimensions[imsGetPolynomMatrixValues[m]]]<>" | w[[All,1]]: "<>
        ToString[w[[All,1]]]];
    
    skiprows=imsSkipRows/.{opts}/.Options[imsPolynomMatrixContract];
    
    (*** Convert exponents to position list. ***)
    (*** 
          Example: {{3},{0,0,1}} -> {{1,1},{1,1},{1,1},{2,3}} ***)
    
    exppos=Position[e,_?Positive];
    exppos=Flatten[Table[#,{e[[Sequence@@#]]}]&/@exppos,1];
    
    (*** Total number of parameter levels. ***)
    (*** 
          Example: {{2,1},{0,0,1}} \[Rule] 3 ***)
    csum=Plus@@e[[1]];
    
    (*** If skiprows, 
      then add 1 for equation rows to all indices of w greater than the \
number of parameters. ***)
    (*** Example for cnum 3: {{1,v1},{4,
              v2}} \[Rule]  {{1,v1},{5,v2}} ***)
    
    If[skiprows,w[[All,1]]=If[#>csum,#+1,#]&/@w[[All,1]]];
    
    (*** This is the indices of w with the rows index removed ***)
    (*** 
              Example for cnum 3: {{1,v1},{4,v2},{6,v3}} \[Rule] {{1,1},{5,
            2}} ***)
    
    wnorows=DeleteCases[{#[[1]],TensorRank[#[[2]]]}&/@
            w,{csum+1,_}]/.{({a_,b_}/;a>csum)\[Rule]{a-1,b}};
    
    (*** For each deleted index, 
      subtract one from the corresponding part of the exponents. ***)
    (*** 
              Example for wnorows {{1,1},{5,2}}: {{2,1},{0,0,
              1},{1}} \[Rule] {{1,1},{0,0,1},{1}} ***)
    
    Scan[If[#[[2]]\[Equal]1,e[[Sequence@@exppos[[#[[1]]]]]]--]&,wnorows];
    
    imsDebugMessage["Imtek`System`imsPolynomMatrixContract", 2, 
      "Imtek`System`imsPolynomMatrixContract: exppos: "<>ToString[exppos]<>" | w[[All,1]]: "<>
        ToString[w[[All,1]]]];
    
    imsMakePolynomMatrix[e,
      imsPolynomMatrixContract[imsGetPolynomMatrixValues[m],w]]];

imsPolynomMatrixContract[m:(_SparseArray|_List),
    w:{{_Integer,_List|_SparseArray}...}]:=(imsDebugMessage[
      "Imtek`System`imsPolynomMatrixContract", 2, 
      "Imtek`System`imsPolynomMatrixContract: Dim m: "<>ToString[
          Dimensions[m]]<>" | w[[All,1]]: "<>ToString[w[[All,1]]]];
    Fold[imsPolynomMatrixContractSingle[#1,#2]&,m,
      Sort[w,(#1[[1]]>#2[[1]])&]]);



imsPolynomMatrixContractSingle[m_,{i_,v_}]:=
  Module[{rm=TensorRank[m],rv=TensorRank[v],l},
    If[rv>1,
      l=Range[rm];l[[{i,rm}]]={rm,i};
      imsDebugMessage["Imtek`System`imsPolynomMatrixContractSingle", 2, 
        "Imtek`System`imsPolynomMatrixContractSingle: TR m: "<>ToString[rm]<>" | TR v: "<>
          ToString[rv]<>" | i: "<>ToString[i]<>" | l: "<>ToString[l]];
      Return[Transpose[Transpose[m,l].SparseArray[v],l]];,
      l=Drop[Insert[Range[rm],rm,i],-1];
      imsDebugMessage["Imtek`System`imsPolynomMatrixContractSingle", 2, 
        "Imtek`System`imsPolynomMatrixContractSingle: TR m: "<>ToString[rm]<>" | TR v: "<>
          ToString[rv]<>" | i: "<>ToString[i]<>" | l: "<>ToString[l]];
      Return[Transpose[m,l].SparseArray[v]];
      ];
    ];



imsPolynomMatrixContractAll[m_imsPolynomMatrix,vc_,vr_,vu_,vf_]:=
    Module[{e=imsGetPolynomMatrixExponents[m]},
      Return[
        imsPolynomMatrixContract[m,
          If[Length[e]==0,
            If[Head[vr]===List||Head[vr]===SparseArray,{1,vr},{}],
            Join[
              
              If[Head[vc]===List||Head[vc]===SparseArray,
                Table[{i,vc},{i,Plus@@e[[1]]}],{}],
              
              If[Head[vr]===List||
                  Head[vr]===SparseArray,{{Plus@@e[[1]]+1,vr}},{}],
              
              If[Length[e]>1&&Head[vu]===List||Head[vu]===SparseArray,
                Table[{i,vu},{i,Plus@@e[[1]]+2,
                    1+Plus@@Flatten[e[[{1,2}]]]}],{}],
              
              If[Length[e]>2&&Head[vf]===List||Head[vf]===SparseArray,
                Table[{i,vf},{i,2+Plus@@Flatten[e[[{1,2}]]],
                    1+Plus@@Flatten[e]}],{}]
              ]
            ],imsSkipRows\[Rule]False]
        ]
      ];



imsPolynomMatrixContractAllDerivatives[m_imsPolynomMatrix,vc_,vr_,vu_,vf_]:=
  Module[{e=imsGetPolynomMatrixExponents[m],exppos,w},
    
    (***Convert exponents to position list.***)(***
          Example:{{3},{0,0,1}}\[Rule]{{1,1},{1,1},{1,1},{2,3}}***)exppos=
      Position[e,_?Positive];
    exppos=Flatten[Table[#,{e[[Sequence@@#]]}]&/@exppos,1];
    
    (***Total number of parameter levels.***)(***
          Example:{{2,1},{0,0,1}}\[Rule]3***)
    csum=Plus@@e[[1]];
    
    (***Insert entry for matrix rows***)
    (***
          We put the row multiplicator to the end, but this doesn't matter***)

        exppos=Insert[exppos,{4},csum+1];
    
    w=
      MapIndexed[
        {#2[[1]],myExtract[{vc,vu,vf,vr},#1]}&,
        exppos
        ];
    
    imsDebugMessage["Imtek`System`imsPolynomMatrixContractAllDerivatives", 2, 
      "Imtek`System`imsPolynomMatrixContractAllDerivatives: e: "<>ToString[e]<>
        " | exppos: "<>ToString[exppos]<>" | w[[All,1]]: "<>
        ToString[w[[All,1]]]];
    
    Return[imsPolynomMatrixContract[m,DeleteCases[w,
          {_,Except[_List|_SparseArray]}],imsSkipRows\[Rule]False]];
    ];



(*imsTranspose[m_,l_]:=Module[{ar},
      imsDebugMessage["Imtek`System`imsTranspose", 2, 
        "Imtek`System`imsTranspose: ar[[1]]: "<>ToString[ar[[1]]]<>" | l: "<>
          ToString[l]];
      If[OrderedQ[l],Return[m]];
      ar=ArrayRules[m];
      ar[[All,1]]=ar[[All,1,l]];Return[SparseArray[ar,Dimensions[m][[l]]]]];*)



End[] (* of Begin Private *)





(* Protect[] (* anything *) *)
EndPackage[] 


































































































































































































