(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: Voxel.m *)
(* Context: *)
(* Author:jan korvink *)
(* 
  Date: 17.11.2005, 
  Freiburg, in Cafe Einstein *)
(* Summary: This handles voxels *)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.2.1 *)
(* 
  Mathematica Version: 5.2 *)
(* History: 
    Initial *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* 
  Limitations: *)
(* Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* Fintie Element Operators *)

(* Copyright (C) 2004 Oliver Ruebenkoenig *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)



(* Start Package *)
BeginPackage["Imtek`Voxel`" ];





(* *)
(* documentation *)
(* *)


(* constructors *)

imsMakeVoxelMesh::usage="imsMakeVoxelMesh[ \[Delta] , { nx , ny , nz } ] creates an empty voxel mesh with the given dimensions.\nimsMakeVoxelMesh[ \[Delta] , data ] creates a voxel mesh from the privided data. The dimensions of the mesh are automatically found.\nimsMakeVoxelMesh[ \[Delta] , { nx , ny , nz } , data ] creates a voxel mesh from the provided data. The data is not checked for consistency.";\


(* selectors *)

imsVoxelLength::usage="imsVoxelLength[ voxelmesh ] returns the side length of a voxel in the voxelmesh.";\


imsVoxelMeshDimensions::usage="imsVoxelMeshDimensions[ voxelmesh ] returns the array dimensions of the voxelmesh.";\


imsVoxelMeshData::usage="imsVoxelMeshData[ voxelmesh ] returns the pixel data of the voxelmesh.";\


imsSelectVoxelMeshPlane::usage="imsSelectVoxelMeshPlane[ { plane , index } , voxelmesh ] selects all voxels of voxelmesh that are coincident with the given indexed plane. Planes are specified by 1, 2, or 3, for x, y or z, and the index should lie within the dimensions of the voxelmesh.";\


(* predicates *)

(* functions *)

imsVoxelMesh::usage= \
"imsVoxelMesh[ \[Delta] , { nx , ny , nz } , data ] is a representation of a 3D voxel-based object. \[Delta] is the edge length of a voxel, {nx,ny,nz} is the dimension of the mesh, and data marks the voxels that are present in the mesh. Data can be a list of integer triplets, where each triplet is the coordinate of a voxel as follows:\n{{i,j,k}..}\n It can also be one of the following symbols:\n None, meaning that no voxel is present.\n All, meaning that all voxels are present.";\


imsGraphics3DToVoxel::usage= 
    "imsGraphics3DToVoxel[ g , \[Delta] ] creates a voxel-based representation of g. Currently, the following Graphics3D primitives are supported by the conversion routines: Point, Line, Polygon (but only those with 3 vertices). All other primitives are simply ignored.";\


imsWhichVoxel::usage= \
"imsWhichVoxel[ point , \[Delta] ] gives the voxel coordinates of a 3D point in a discrete space with voxel length \[Delta].";\


imsPointDrawFunction::usage="imsPointDrawFunction[ { i , j , k } , \[Delta] ] converts a voxel to a Graphics3D point.";\


imsCuboidDrawFunction::usage="imsCuboidDrawFunction[ { i , j , k } , \[Delta] ] converts a voxel to a Graphics3D cuboid.";\


imsDrawVoxel::usage="Is a symbol for a rule that specifies the function used to draw a voxel";\


imsDrawVoxelMesh::usage="imsDrawVoxelMesh[ voxelmesh ] draws a 3D picture of voxelmesh with each voxel represented by a point.\nimsDrawVoxelMesh[ voxelmesh , imsDrawVoxel->fn ] uses the function fn[ voxelcoord , \[Delta] ] to draw each voxel, where voxelcoord is the discrete position of the voxel in the mesh, and \[Delta] is the length of a voxel.";



(* *)
(* options docu *)
(* *)







Begin["`Private`"];



(* private imports *)
(* this is only for the old FEMNeumann operator *)

Needs["Utilities`FilterOptions`"];



(* *)
(* implementation part *)
(* *)

(* constructor *)

imsMakeVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer}]:=
    imsVoxelMesh[d,dim,None];

imsMakeVoxelMesh[d_?NumericQ,data:{{_Integer,_Integer,_Integer}..}]:=
    Module[{mins,newData},
      mins=(Min[#]&/@Transpose[data])-{1,1,1};
      newData=(#-mins)&/@data;
      imsVoxelMesh[d,Max[#]&/@Transpose[newData],newData]
      ];

imsMakeVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer},
      data:{{_Integer,_Integer,_Integer}..}]:=
    imsVoxelMesh[d,dim,data];

Format[ a_imsVoxelMesh,
      StandardForm ]:="\[SkeletonIndicator]imsVoxelMesh\[SkeletonIndicator]";




(* *)
(* define your options *)
(* *)



(* selector *)

imsVoxelLength[
      imsVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer},
        data___]]:=d;

imsVoxelMeshDimensions[
      imsVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer},
        data___]]:=dim;

imsVoxelMeshData[
      imsVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer},
        data___]]:=data;

imsSelectVoxelMeshPlane[{plane_Integer,index_Integer},
      imsVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer},
        data___]]:=Select[data,(#[[plane]]\[Equal]index)&];



(* predicates *)





(* *)
(* private functions *)
(* *)



\!\(\(lineInnerPoints[l : {pt1_, pt2_}, pixelLength_] := Module[{e1, n}, \[IndentingNewLine]e1 = pt2 - pt1; \[IndentingNewLine]n = Quotient[\@\(e1 . e1\), pixelLength/2.1]; \[IndentingNewLine]If[n \[Equal] 0, n = 1]; \[IndentingNewLine]e1 = e1/n; \[IndentingNewLine]Table[pt1 + j*e1, \[IndentingNewLine]{j, 1, n - 2}\[IndentingNewLine]]\[IndentingNewLine]];\)\)



\!\(\(triangleInnerPoints[t : {pt1_, pt2_, pt3_}, pixelLength_] := Module[{e1, e2, e3, l, n}, \[IndentingNewLine]e1 = pt2 - pt1; \[IndentingNewLine]e2 = pt2 - pt3; \[IndentingNewLine]e3 = pt3 - pt1; \[IndentingNewLine]n = Quotient[Max[{N[\@\(e1 . e1\)], N[\@\(e2 . e2\)], N[\@\(e3 . e3\)]}], pixelLength/2.1]; \[IndentingNewLine]If[n \[Equal] 0, n = 1]; \[IndentingNewLine]e1 = e1/n; \[IndentingNewLine]e2 = e2/n; \[IndentingNewLine]Flatten[Table[\[IndentingNewLine]e3 = \((pt3 + i*e2)\) - \((l = pt1 + i*e1)\); \[IndentingNewLine]If[\((n - i)\) > 0, e3 = e3/\((n - i)\)]; \[IndentingNewLine]Table[l + j*e3, \[IndentingNewLine]{j, 1, n - i - 2}\[IndentingNewLine]], {i, 1, n - 2}\[IndentingNewLine]], 1]\[IndentingNewLine]];\)\)



(* These arguments should be converted to voxels *)

(* unit cuboids *)

toVoxels[Cuboid[pmin:{_,_,_}],d_?NumericQ]:=
    toVoxels[Cuboid[pmin,pmin+{1.,1.,1.}],d];

(* general cuboids *)

toVoxels[Cuboid[pmin:{xm_,ym_,zm_},pmax:{xM_,yM_,zM_}],d_?NumericQ]:=
    Union[Join@@(toVoxels[#,
                d]&/@{Polygon[{{xm,ym,zm},{xM,ym,zm},{xM,yM,zm},{xm,yM,zm}}],
              Polygon[{{xm,ym,zM},{xM,ym,zM},{xM,yM,zM},{xm,yM,zM}}],
              Polygon[{{xm,ym,zm},{xM,ym,zm},{xM,ym,zM},{xm,ym,zM}}],
              Polygon[{{xm,yM,zm},{xM,yM,zm},{xM,yM,zM},{xm,yM,zM}}],
              Polygon[{{xm,ym,zm},{xm,yM,zm},{xm,yM,zM},{xm,ym,zM}}],
              Polygon[{{xM,ym,zm},{xM,yM,zm},{xM,yM,zM},{xM,ym,zM}}]})];

(* short lines *)

toVoxels[l:Line[{s:{_,_,_},e:{_,_,_}}],d_?NumericQ]:=
    Union[(imsWhichVoxel[#,d]&/@Join[{s},lineInnerPoints[{s,e},d],{e}])];

(* long lines *)

toVoxels[Line[pts:{{_,_,_},{_,_,_},({_,_,_})..}],d_?NumericQ]:=
    Join@@(toVoxels[Line[#],d]&/@Partition[pts,2,1]);

toVoxels[Point[c:{_?NumericQ,_?NumericQ,_?NumericQ}],
      d_?NumericQ]:={imsWhichVoxel[c,d]};

(* Triangles *)

toVoxels[t:Polygon[{pt1:{_,_,_},pt2:{_,_,_},pt3:{_,_,_}}],d_?NumericQ]:=
    Union[imsWhichVoxel[#,d]&/@
        Join[{pt1},{pt2},{pt3},lineInnerPoints[{pt1,pt2},d],
          lineInnerPoints[{pt2,pt3},d],lineInnerPoints[{pt3,pt1},d],
          triangleInnerPoints[{pt1,pt2,pt3},d]]];

(* Larger polygons (we erroneously assume they are convex!). 
      Here we clip off the first triangle and pass back the rest. *)

toVoxels[p:Polygon[pts:{{_,_,_},{_,_,_},{_,_,_},{_,_,_}..}],d_?NumericQ]:=
    Join[toVoxels[Polygon[pts[[{1,2,-1}]]],d],
      toVoxels[Polygon[Drop[pts,1]],d]];

(* These Graphics3D arguments will never be converted to voxels and will \
always be ignored *)
toVoxels[t_Text,d_]:=Sequence[];
toVoxels[l_AbsoluteDashing,d_]:=Sequence[];
toVoxels[l_AbsolutePointSize,d_]:=Sequence[];
toVoxels[l_AbsoluteThickness,d_]:=Sequence[];
toVoxels[l_CMYKColor,d_]:=Sequence[];
toVoxels[l_Dashing,d_]:=Sequence[];
toVoxels[l_EdgeForm,d_]:=Sequence[];
toVoxels[l_FaceForm,d_]:=Sequence[];
toVoxels[l_GrayLevel,d_]:=Sequence[];
toVoxels[l_Hue,d_]:=Sequence[];
toVoxels[l_PointSize,d_]:=Sequence[];
toVoxels[l_RGBColor,d_]:=Sequence[];
toVoxels[l_SurfaceColor,d_]:=Sequence[];
toVoxels[l_Thickness,d_]:=Sequence[];
toVoxels[l_,d_]:=Sequence[];



(* *)
(* public functions *)
(* *)



imsGraphics3DToVoxel[g_Graphics3D,d_?NumericQ]:=
    
    imsMakeVoxelMesh[d,
      Flatten[Cases[(toVoxels[#,d]&/@Flatten[g[[1]]]),Except[{}]],1]];



imsWhichVoxel[pt:{(_?NumericQ)..},
      d_?NumericQ]:=((Quotient@@#)&/@Transpose[{pt,{d,d,d}}])+{1,1,1};



imsPointDrawFunction[coord:{i_,j_,k_},length_]:=Point[length*coord];



imsCuboidDrawFunction[coord:{i_,j_,k_},length_]:=
    Cuboid[length*(coord-{1,1,1}),length*(coord)];



Options[imsDrawVoxelMesh]={imsDrawVoxel\[Rule]imsPointDrawFunction};
imsDrawVoxelMesh[ 
      vm:imsVoxelMesh[d_?NumericQ,dim:{nx_Integer,ny_Integer,nz_Integer},
          data:{{_Integer,_Integer,_Integer}..}] ,opts___]:=
    
    Block[{voxelDrawFunction,graphicsOpts,myOpts},
      graphicsOpts=FilterOptions[Graphics3D,opts];
      myOpts=FilterOptions[imsDrawVoxelMesh,opts];
      voxelDrawFunction=
        Evaluate[(imsDrawVoxel/.{myOpts})]/.Options[imsDrawVoxelMesh];
      Return[
        Graphics3D[voxelDrawFunction[#,d]&/@data,
          Join[{graphicsOpts},{PlotRange\[Rule]All}]]]
      ];





(* representors *)



End[] (* of Begin Private *)





(* Protect[] (* anything *) *)
EndPackage[] 
