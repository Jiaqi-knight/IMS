(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: SECMnew4.m *)
(* Context: *)
(* Author:Darius Koziol *)
(* 
  Date: 26.04.2004 *)
(* 
  Summary: This is the IMTEK template for writing a mathematica packages *)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.1 *)
(* 
  Mathematica Version: 4.2 *)
(* History: *)
(* Keywords: *)
(* Sources: *)
(* 
  Warnings: *)
(* Limitations: *)
(* Discussion: *)
(* Requirements: *)
(* 
  Examples: *)
(* *)

 Needs["Graphics`MultipleListPlot`"];



BeginPackage["Imtek`SimulationTools`SECM`"];





\!\(\*
  RowBox[{\(SECM::usage = "\<This package contains the following functions and initialisations:\n  MakePoint, MakeEasymeshVertex, MakeEasymeshMaterialPoint, MakeEasymeshPolygon, MakeEasymeshPolyLine, Easymesh, EasymeshData, EasymeshNodeList, EasymeshSideList, EasymeshElementList, WriteEasymeshInputData, RunEasymesh, ReadEasymesh, PlotMesh, GeometryFunction2DAxisSymmetric, GeometryData2DAxisSymmetric, EquationsystemSteadyState2DAxisSymmetric, EquationDataSteadyState, SteadyStateCalculation, CurrentFunction2DAxisSymmetric, EquationDataTransient, EquationsystTransient2DAxisSymmetric, TransientCalculation, EquationDataTransientCV, CvCalculation, AnsysElementGeometryFunction3D, GeometryData3D, GeometryTestForVoronoi3D, AnsysData, AnsysEquationSystemSteadyState3D, AnsysEquationSystemTrans3D, CurrentFunction3D, twoDEasymeshToThreeDFunction, ReadAnsysNodes, AnsysNodeData, ReadAnsysElements, AnsysElementData, EquationsystTransient2D, EquationsystSteadyState2D, CurrentPerDepthFunction2D, CVPlotData, Feldplot, WireFrameMeshWithBCNodes, WireFrameMeshWitRotation, NeumannBoundaryValues, DirichletBoundaryValues, ElectrodeReactionValues, InitialData, SpecificConstants\>";\), "\n", "\[IndentingNewLine]", \(Easymesh::usage = "\<Easymesh is a freeware 2D mesh generator for high quality Delaunay and Voronoi meshes.  \nEasymesh can be downloaded from:   http://www-dinma.univ.trieste.it/nirftc/research/easymesh/Default.htm\>";\), "\n", "\n", \(EasymeshData::usage = "\<EasymeshData[...] is the head of a data block that contains three arrays that describe the nodes, sides and elements of the mesh: EasyMeshData[n, s, e]. Also see EasymeshNodeList, EasymeshSideList and EasymeshElementList. For instructions on how to read EasymeshData from a generated file, see ReadEasymesh. \nEasymesh can be downloaded from:   http://www-dinma.univ.trieste.it/nirftc/research/easymesh/Default.htm\>";\), "\n", "\n", \(EasymeshNodeList::usage = "\<EasymeshNodeList[...] is the head of a data block that contains an entry for each of the nodes of the mesh. The entries are lists with the following structure: {nodenum, xcoord, ycoord, nodetag}.\>";\), "\n", "\n", \(EasymeshSideList::usage = "\<EasymeshSideList[...] is the head of a data block that contains an entry for each of the sides of the mesh. The entries are lists with the following structure: {sidenum, startnode, endnode, leftelement, rightelement, sidetag}.\>";\), "\n", "\n", \(EasymeshElementList::usage = "\<EasymeshElementList[...] is the head of a data block that contains an entry for each of the elements of the mesh. The entries are lists with the following structure: {elementnum, node1, node2, node3, neighbour1, neighbour2, neighbour3, side1, side2, side3, xcircumcenter, ycircumcenter, elementtag}.\>";\), "\n", "\n", \(WriteEasymeshInputData::usage = "\<WriteEasymeshInputData[easymeshPolygonInput, easymeshLineInput, easymeshMaterialPointInput] returns EasymeshInputData, a data block which has the structure as required by Easymesh as input data. Also see Easymesh, easymeshPolygonInput, easymeshLineInput, easymeshMaterialPointInput.\>";\), "\n", "\n", \(RunEasymesh::usage = "\<RunEasymesh[EasymeshInputData] runs Easymesh (a freeware 2D mesh generator for high quality Delaunay and Voronoi meshes) and returns fileName where the generated data is stored. To read the generated mesh data see ReadEasymesh. \nEasymesh can be downloaded from: http://www-dinma.univ.trieste.it/nirftc/research/easymesh/Default.htm\>";\), "\[IndentingNewLine]", "\n", \(ReadEasymesh::usage = "\<ReadEasymesh[fileName] attempts to read an Easymesh output file and returns an object of the type EasymeshData. If the file is not found, or is not readable, or contains data that makes little sense, the function returns a Null. Also see RunEasymesh, EasymeshData.\>";\), "\n", "\n", \(PlotMesh::usage = "\<PlotMesh[EasymeshData] plots an image of a finite volume mesh that is described by a single array of type EasymeshData, which is obtained from data generated by the freeware mesh generator Easymesh. Also see EasymeshData.\>";\), "\n", "\[IndentingNewLine]", \(GeometryFunction2DAxisSymmetric::usage = "\<GeometryFunction2DAxisSymmetric[EasymeshData] takes as argument EasymeshData and returns a data array of the type GeometryData. It contains all geometry data that is necessary to describe a 2D Voronoi mesh. Also see GeometryData.\>";\), "\n", "\n", \(GeometryData2DAxisSymmetric::usage = "\<GeometryData2DAxisSymmetric is a data array which contains 7 sublists {evb,esl,enn,totalnodes,rvs,evm,evv}. evb contains, for each element, a list with the lengths of the sides of the Voronoi boxes. esl contains for each element the side lengths. enn contains for each element the node numbers. totalnodes (not a list) is the number of nodes of the whole mesh. rvs is a list that contains the radius of all voronoi subcells. evm contains for each element the radius of the midpoints of the Voronoi sides. evv contains the volumes of the Voronoi subcells of each element.\>";\), "\n", "\n", \(EquationsystemSteadyState2DAxisSymmetric::usage = "\<EquationsystemSteadyStateAxisSymmetric[GeometryData, EasymeshData, DiffusionCoefficient, InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues] returns a data object with head EquationDataSteadyState which in turn contains the two components of a linear steady state matrix equation. The first part is the stiffness matrix E, the second the right hand side vector R. The matrix E is in sparse format. Also see GeometryData, EasymeshData, DiffusionCoefficient, InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues, EquationDataSteadyState. \>";\), "\n", "\n", 
    RowBox[{
      RowBox[{\(EquationDataSteadyState::usage\), "=", "\"\<EquationDataSteadyState contains of two lists \!\(\(TraditionalForm\`{\)\)stiffnessMatrix,rightHandSide}; the stiffnessMatrix is represented in the sparse format \!\(\(TraditionalForm\`{\)\)\!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`i\_1\),\!\(TraditionalForm\`j\_1\)\!\(TraditionalForm\`}\)-> \!\(TraditionalForm\`a\_1\), \!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`i\_2\),\!\(TraditionalForm\`j\_2\)\!\(TraditionalForm\`}\)->\!\(TraditionalForm\`a\_2\) \[Ellipsis] \!\(TraditionalForm\`}\), so that the entry at position \!\(TraditionalForm\`i\_k\),\!\(TraditionalForm\`j\_k\) has value \!\(TraditionalForm\`a\_k\) and all unspecified elements are taken to be zero.\>\""}], ";"}], "\n", "\n", \(SteadyStateCalculation::usage = "\<SteadyStateCalculation[EquationDataSteadyState] solves the sparse linear system described by EquationDataSteadyState. It returns a vector of concentrations. Also see EquationDataSteadyState.\>";\), "\n", "\n", \(CurrentFunction2DAxisSymmetric::usage = "\<CurrentFunctionAxisSymmetric[electrode, EasymeshData, concentrationDistribution] where 'electrode' is an integer which refers to the boundary condition marker on the electrode boundary, EasymeshData is the mesh data generated by Easymesh and concentrationDistribution is a two dimensional vector which contains of one or more vectors of concentration, one for each timestep.\>";\), "\n", "\n", 
    RowBox[{
      RowBox[{\(EquationDataTransient::usage\), "=", "\"\<EquationDataTransient has the following structure \!\(\(TraditionalForm\`{\)\)stiffnessMatrix,rightHandSide,initialConcentration,voronoiVolumes};  the stiffnessMatrix is represented in the sparse format \!\(\(TraditionalForm\`{\)\)\!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`i\_1\),\!\(TraditionalForm\`j\_1\)\!\(TraditionalForm\`}\)-> \!\(TraditionalForm\`a\_1\), \!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`i\_2\),\!\(TraditionalForm\`j\_2\)\!\(TraditionalForm\`}\)->\!\(TraditionalForm\`a\_2\) \[Ellipsis] \!\(TraditionalForm\`}\), so that the entry at position \!\(TraditionalForm\`i\_k\),\!\(TraditionalForm\`j\_k\) has value \!\(TraditionalForm\`a\_k\) and all unspecified elements are taken to be zero.\>\""}], ";"}], "\n", "\n", \(EquationsystTransient2DAxisSymmetric::usage = "\<EquationsystTransientAxisSymmetric[GeometryData, EasymeshData, DifusionCoefficient, \[CapitalDelta]t, InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues] returns EquationDataTransient which contains the components of a linear transient matrix equation, the stiffness matrix, the right hand side vector, a vector with the initial concentrations and an additional vector with the volumes of the Voronoi cells. The matrix E has sparse form. Also see GeometryData, EasymeshData, DiffusionCoefficient, InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues, EquationDataTransient.\>";\), "\[IndentingNewLine]", "\n", \(TransientCalculation::usage = "\<TransientCalculation[EquationDataTransient, totalTime, \[CapitalDelta]t] solves a time dependend sparse linear system. The timesteps are of the size \[CapitalDelta]t and the full simulation time is specified by totalTime.  The function returns a list with vectors of concentrations. Also see EquationDataTransient.\>";\), "\[IndentingNewLine]", "\n", \(EquationDataTransientCV::usage = "\<EquationDataTransientCV is same as EquationDataTransient except the ElectrodeReactionValues, they have to be variable. Also see ElectrodeReactionValues.\>";\), "\[IndentingNewLine]", "\n", \(CvCalculation::usage = "\<CvCalculation[EquationDataTransientCV, totalTime, \[CapitalDelta]t, startValue, endValue, potentialVariable] solves a time-dependent sparse linear system. The timesteps are of size \[CapitalDelta]t and the full simulation time is specified by totalTime. potentialVariable is the name of the variable used for the ElectrodeReactionValues (see EquationDataTransientCV). Its value starts with the startValue, extends to endValue and returns again to startValue. The loop is divided into totalTime/\[CapitalDelta]t equal steps. Also see EquationDataTransient and EquationDataTransientCV.\>";\), "\[IndentingNewLine]", "\n", \(AnsysElementGeometryFunction3D::usage = "\<AnsysElementGeometryFunction3D[AnsysData] takes as argument AnsysData and returns a data array of the type GeometryData3D. It contains all geometry data that is necessary to describe a 3D Voronoi mesh. Also see GeometryData3D.\>";\), "\n", "\n", \(GeometryData3D::usage = "\<GeometryData3D[...] contains, for every element in the mesh, a list with 7 sublists {{a,b,c,d,e,f,circumcenterCoords}, ...}. The six lists a to f, one per edge of the tetrahedron, have the structure {{startEdgeNode, endEdgeNode}, edgeLength, voronoiCellPartialArea}. The list circumcenterCoords holds the coordinates of the circumcenter of each element.\>";\), "\[IndentingNewLine]", "\n", \(GeometryTestForVoronoi3D::usage = "\<GeometryTestForVoronoi3D[AnsysData, GeometryData3D] tests whether the tetrahedral elements of the input mesh are truly Voronoi elements.\>";\), "\n", "\n", \(AnsysData::usage = "\<AnsysData[nodes, elements] is the head of a data block that contains two arrays that describe the nodes and elements of the mesh. The first list contains an entry for each of the nodes of the mesh. Each entry is a list with the following structure: {nodeNumber, xCoordinate, yCoordinate, zCoordinate, nodeTag}. The second list contains an entry for each of the elements of the mesh. Each entry is a list with the following structure: {elementNumber, node1, node2, node3, node4, elementTag}.\>";\), "\n", "\n", \(AnsysEquationSystemSteadyState3D::usage = "\<AnsysEquationSystemSteadyState3D[GeometryData3D, AnsysData, DiffusionCoefficient, ElectrodeReactionValues, DirichletBoundaryValues,InitialConcentrations] returns EquationDataSteadyState which contains two components of a linear steady state matrix equation, the stiffness matrix and the right hand side vector. The matrix E has sparse form. Also see GeometryData3D, AnsysData, DiffusionCoefficient, InitialConcentrations, ElectrodeReactionValues, DirichletBoundaryValues, EquationDataSteadyState.\>";\), "\n", "\n", \(AnsysEquationSystemTrans3D::usage = "\<AnsysEquationSystemTrans3D[GeometryData3D, AnsysData, DiffusionCoefficient, ElectrodeReactionValues, DirichletBoundaryValues, InitialConcentrations, \[CapitalDelta]t] returns EquationDataTransient which contains the components of a linear transient matrix equation, the stiffness matrix, the right hand side vector, a vector with the initial concentrations and an additional vector with the volumes of the Voronoi cells. The matrix E has sparse form. Also see GeometryData3D, AnsysData, DiffusionCoefficient, InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues, EquationDataTransient.\>";\), "\n", "\[IndentingNewLine]", \(CurrentFunction3D::usage = "\<currentFunction3D[AnsysData, electrode, GeometryData3D, concDistribution] calculates the current on a boundary which is marked as 'electrode'. The arguments are:
\nAnsysData is the mesh data generated by Ansys,
\n'electrode' is an integer which relates to the boundary condition marker on the electrode-boundary,
\nGeometryData3D is an array of mesh geometry information (see GeometryData3D), 
\nconcDistribution is a two dimensional vector which contains of one or more vectors of concentration, one for each timestep and
\nDiffusionCoefficient is a list of diffusion coefficients, one for each species of the reaction.\>";\), "\[IndentingNewLine]", "\[IndentingNewLine]", \(twoDEasymeshToThreeDFunction::usage = "\<twoDEasymeshToThreeDFunction[EasymeshData, thickness] takes as first argument EasymeshData, a 2D data array read from Easymesh output files and creates a 3D tetrahedron based mesh data object. Also see EasymeshData. Here 'thickness' defines the dimension in the z-direction. The new mesh has two layers of nodes, one layer with the z-coordinate set to zero, and the second layer with the z-coordinate = 'thickness'.\>";\), "\[IndentingNewLine]", "\n", \(MakePoint::usage = "\<MakePoint[x, y] takes the x- and y-coordinate as arguments and returns a object with the Head 'Point'.\>";\), "\[IndentingNewLine]", "\n", \(MakeEasymeshVertex::usage = "\<MakeEasymeshVertex[point, meshSize, nodeMarker, boundaryMarker] takes an object with Head Point, a dimensionless number that determines the size of the mesh around the node, a tag which is associated with the node, and a tag which is associated with the side that starts with this node. It returns an object with Head EasymeshVertex.\>";\), "\[IndentingNewLine]", "\n", \(MakeEasymeshMaterialPoint::usage = "\<MakeEasymeshMaterialPoint[Point, meshSize, materialNodeMarker] takes an object with the Head Point, a dimensionless number that determines the size of the mesh around the node, and a tag which is associated with the node and a zone of the mesh. It returns an object with the Head 'EasymeshMaterialPoint'.\>";\), "\[IndentingNewLine]", "\n", \(MakeEasymeshPolygon::usage = "\<MakeEasymeshPolygon[EasymeshVertex, EasymeshVertex, EasymeshVertex, \[Ellipsis]] takes three or more objects with Head 'EasymeshVertex' and returns an object with Head 'EasymeshPolygon'. The first and last EasymeshVertex are connected to form a closed polygon. Also see 'MakeEasymeshPolyLine'.\>";\), "\[IndentingNewLine]", "\n", \(MakeEasymeshPolyLine::usage = "\<MakeEasymeshPolyLine[EasymeshVertex, EasymeshVertex, \[Ellipsis]]  takes two or more objects with Head 'EasymeshVertex' and returns an object with Head 'EasymeshPolyLine'. The nodes will not be connected to a polygon. Also see 'MakeEasymeshPolygon'.\>";\), "\[IndentingNewLine]", "\n", \(ReadAnsysNodes::usage = "\<ReadAnsysNodes[fileName] attempts to read an Ansys node output file and, if successful, returns an object of the type AnsysNodeData. The list contains an entry for each of the nodes of the mesh. Each entry is a list with the following structure: {nodeNumber, xCoordinate, yCoordinate, zCoordinate, nodeTag}.\>";\), "\[IndentingNewLine]", "\n", \(AnsysNodeData::usage = "\<AnsysNodeData is a list which contains an entry for each of the nodes of the mesh. Each entry is a list with the following structure: {nodeNumber, xCoordinate, yCoordinate, zCoordinate, nodeTag}.\>";\), "\[IndentingNewLine]", "\n", \(ReadAnsysElements::usage = "\<ReadAnsysElements[fileName] attempts to read an Ansys element output file and, if successful, returns an object of the type AnsysElementData. The list contains an entry for each of the elements of the mesh. Each entry is a list with the following structure: {elementNumber, node1, node2, node3, node4, elementTag}.\>";\), "\[IndentingNewLine]", "\n", \(AnsysElementData::usage = "\<AnsysElementData is a list which contains an entry for each of the elements of the mesh. Each entry is a list with the following structure: {elementNumber, node1, node2, node3, node4, elementTag}.\>";\), "\[IndentingNewLine]", "\n", \(EquationsystTransient2D\ ::usage = "\<EquationDataTransient2D has the following structure {stiffnessMatrix,rightHandSide,initialConcentration,voronoiVolumes};  the stiffnessMatrix is represented in the sparse format {{i,j}\[Rule]val_ij, \[Ellipsis]}, so that the matrix entry at position (i,j) has value val_ij and all unspecified elements are taken to be zero.\>";\), "\[IndentingNewLine]", "\n", \(EquationsystSteadyState2D::usage = "\<EquationDataSteadyState2D contains of two lists {stiffnessMatrix,rightHandSide}; the stiffnessMatrix is represented in the sparse format {{i,j}\[Rule]val_ij,\[Ellipsis]}, so that the matrix entry at position (i,j) has value val_ij and all unspecified elements are taken to be zero.\>";\), "\[IndentingNewLine]", "\n", \(CurrentPerDepthFunction2D::usage = "\<CurrentPerDepthFunction2D[electrode, EasymeshData, concentrationDistribution] where 'electrode' is an integer which refers to the boundary condition marker on the electrode boundary, EasymeshData is the mesh data generated by Easymesh and concentrationDistribution is a two dimensional vector which contains of one or more vectors of concentration, one for each timestep. 'CurrentPerDepthFunction2D' returns a current per meter (this represents the depth of the simulation domain), and hence has to be multiplied with a length (the depth, of course) to get the right value and units.\>";\), "\[IndentingNewLine]", "\n", \(CVPlotData::usage = "\<CVPlotData[current] takes a list of currents, usually generated in a CV-calculation, and returns a list which can be displayed with 'MultipleListPlot'.\>";\), "\[IndentingNewLine]", "\n", \(Feldplot::usage = "\<Feldplot[EasymeshData, concentrationDistribution, timeStepInterval] takes EasymeshData, concentrationDistribution, which is a result either of an axi-symmetric or a 2D simulation, and 'timeStepInterval', which is an integer which indicates the selected time interval steps which will be plotted.\>";\), "\n", "\[IndentingNewLine]", \(WireFrameMeshWithBCNodes::usage = "\<wireFrameMeshWithBCNodes[Ansysdata] plots a 3D mesh using the data read from an Ansys-generated file. Boundary nodes whose tag is not equal to zero (tag =!= 0) are highlighted.\>";\), "\n", "\[IndentingNewLine]", \(WireFrameMeshWitRotation::usage = "\<wireFrameMeshWithRotation[Ansysdata] plots a 3D mesh using the data read from an Ansys-generated file. The plot allows real time rotations.\>";\), "\n", "\[IndentingNewLine]", \(NeumannBoundaryValues::usage = "\<NeumannBoundaryValues have the following structure:\n {{{boundaryTag1_Species1, NeumannValue1_Species1}, {boundaryTag2_Species_1, NeumannValue2_Species1}, \[Ellipsis]} , {{boundaryTag1_Species2, NeumannValue1_Species2}, {boundaryTag2_Species2, NeumannValue2_Species2}, \[Ellipsis]}, \[Ellipsis]} where boundaryTag1_Species1 means that this sublist refers to the boundary condition which is applied to species 1 on the boundary which is marked with boundaryTag1. On this boundary 1 the value 'NeumannValue1_Species1' will be applied to the first species.\>";\), "\n", "\[IndentingNewLine]", \(SpecificConstants::usage = "\<Some useful constants:
\n\nFaradayConst = 9.648456*10^7,
\nGasConst       = 8314,
\nStandardTemp   = 273.15,
\nButler_Volmer  = (Exp[\[Alpha]*1*9.648456*10^7(e-eo)/(8314*273.15)])-(Exp[(1-)\[Alpha]*1*9.648456*10^7(e-eo)/(8314*273.15)]).\>";\), "\n", "\[IndentingNewLine]", \(DirichletBoundaryValues::usage = "\<The DirichletBoundaryValues have the following structure:\n-{{boundaryTag1, {speciesNumber1,speciesNumber2, \[Ellipsis]}, {DirichletValueForSpecies1, DirichletValueForSpecies2, \[Ellipsis]}}, {boundaryTag2, \[Ellipsis]}, \[Ellipsis]} where boundaryTag1 means that this sublist refers to the boundary which is marked with boundaryTag1. On this boundary the species with 'speciesNumber1' has the Dirichlet value 'DirichletValueForSpecies1'. In the next sublist the next part of the boundary is considered.\>";\), "\n", "\[IndentingNewLine]", \(ElectrodeReactionValues::usage = "\<The ElectrodeReactionValues have the following structure:\n{{boundaryTag1, speciesNumber1, speciesNumber2, ElectrodeValueForSpecies1, ElectrodeValueForSpecies2} {boundaryTag2, \[Ellipsis]}, \[Ellipsis]} where boundaryTag1 means that this sublist refers to the boundary which is marked with boundaryTag1. On this boundary the species with 'speciesNumber1' has the electrode value 'DirichletValueForSpecies1'. ElectrodeReactionValues are applied as mixed boundary condition.\>";\), "\n", "\[IndentingNewLine]", \(InitialData::usage = "\<For the calculations the following initial data is needed:
\n initialConcentrations: {concentrationSpecies1, concentrationSpecies2, \[Ellipsis]}. The structure is a list of concentration values at the beginning of the calculation. The position in the list indicates the species to which it belongs.
\n \[CapitalDelta]t: the timestep for the transient (or CV) calculations is a real number.
\n tges: the whole simulation time for transient (or CV) simulations is a real number.
\n Dif: {DiffusionCoefficientSpecies1, DiffusionCoefficientSpecies2, \[Ellipsis]}. The diffusion coefficients are contained in a list of diffusion coefficient values, one for each species. The position in the list indicates the species to which it belongs.\>";\), "\[IndentingNewLine]", "\[IndentingNewLine]", \(McDonaldGeometryFunction::usage = "\<\>";\), "\[IndentingNewLine]", \(AnsysMcDonaldEquationSystemSteadyState3D::usage = "\<\>";\), "\[IndentingNewLine]", \(CurrentFunctionMcDonald3D::usage = "\<\>";\), "\[IndentingNewLine]", \(AnsysMcDonaldEquationSystemTrans3D::usage = "\<\>";\), "\[IndentingNewLine]", \(CurrentbyMatrix2DAxyssymetricFunction::usage = "\<\>";\), "\[IndentingNewLine]", \(CurrentbyMatrix2DAxyssymetricFunctionCV::usage = "\<\>";\), "\[IndentingNewLine]", \(CurrentThroughBoxFunction2DAxissymetr::usage = "\<\>";\), "\[IndentingNewLine]", \(CurrentThroughBoxFunction3D::usage = "\<\>";\), "\[IndentingNewLine]", \(ReadAnsysNodefile::usage = "\<\>";\), "\[IndentingNewLine]", \(ReadAnsisElementFile::usage = "\<\>";\), "\[IndentingNewLine]", \(WireFrameMeshWithBCNodesold::usage = "\<\>";\), "\[IndentingNewLine]", \(WireFrameMeshWitRotationold::usage = "\<\>";\), "\[IndentingNewLine]", "\[IndentingNewLine]", \(NodeinFlatFunction::usage = "\<NodeinFlatFunction[meshData,minVal,maxVal,koord], returns a list with nodenumber and two koordinates for each node. The variables minVal and maxVal define the boundaries of the gape which includes the nodes. The variable koord defines the koordinate that is constant (in the range of minVal and maxVal). It can have the 'values': x, y, z, X, Y or Z. \>";\), "\[IndentingNewLine]", "\[IndentingNewLine]", \(CvMultistepCalculation::usage = "\<CvMultistepCalculation[EquationDataTransientCV,{{Tges , \[CapitalDelta]t , \[CapitalDelta]Estart , \[CapitalDelta]Eend}..}, potentialVariable] solves a time-dependent sparse linear system. The timesteps are of size \[CapitalDelta]t (the value of \[CapitalDelta]t should be equal the value used for \[CapitalDelta]t in CvCalculation ) and the full simulation time of one step is specified by totalTime. potentialVariable is the name of the variable used for the ElectrodeReactionValues (see EquationDataTransientCV). Its value starts with the startValue and extends to endValue. The simulation is divided into totalTime/\[CapitalDelta]t equal steps. To simulate a full standart cv-loop you need two sublists, where \[CapitalDelta]Eend of sublist 1 is equal \[CapitalDelta]Estart of sublist 2. Also see EquationDataTransient and EquationDataTransientCV.\>";\), "\[IndentingNewLine]", "\[IndentingNewLine]", \(BoundarynodesFunction3D::usage = "\<BoundarynodesFunction[boundaryMarker, meshdata] returns a multi dimensional list with node data belonging to nodes which has the boundary tag boundaryMarker. The first sublist contains the node numbers. The second sublist contains the Coordinates of the nodes. The third, fourth and fifth lists contain the sorted X-,Y- and Z- coordinates. \>";\), "\[IndentingNewLine]", "\[IndentingNewLine]", \(CVPlotDataMultiList::usage = "\<CVPlotDataMultiList[current,NrLoops] takes a list of currents, usually generated in a CvMultistepCalculation, and the number of potential loops (= number of sublists in CvMultistepCalculation[... ,{{Tges , \[CapitalDelta]t , \[CapitalDelta]Estart , \[CapitalDelta]Eend}..}, ... ) and returns a list which can be displayed with 'MultipleListPlot'.\>";\)}]\)



Off[Developer`SparseLinearSolve::"luc"];
Off[Developer`SparseLinearSolve::"deprec"];
Off[General::"spell1"];







(* *)

MakePoint[ x_, y_ ] := Point[1.* x,1.* y ];

MakeEasymeshVertex[ p_Point, size_ , bcnode_Integer, bcedge_Integer ]:=
    EasymeshVertex[ p, 1.*size , bcnode, bcedge ];

MakeEasymeshMaterialPoint [ p_Point, size_ , materialCondition_Integer]:=
    EasymeshMaterialPoint [ p, 1.*size , materialCondition];

MakeEasymeshPolygon[ vertex__EasymeshVertex ]:=EasymeshPolygon[ vertex ];

MakeEasymeshPolyLine[ vertex__EasymeshVertex ]:=EasymeshPolyLine[ vertex ];




Begin["`Private`"];



Needs["Calculus`VectorAnalysis`"];
Needs["Graphics`MultipleListPlot`"];
Needs["DiscreteMath`ComputationalGeometry`"];



(* *)
(* define your options *)
(* *)
(* 
  Options[ myFunctio ] = { myOptionName \[Rule] myValue } *)



GetVertexData[EasymeshVertex[Point[x_,y_],size_,bcNode_, bcEdge_]]:={x,y,size,
      bcNode,bcEdge};
GetMaterialPointData[
      EasymeshMaterialPoint [ Point[ x_, y_ ] , size_ , 
        materialCondition_  ]]:={ x,y,size,materialCondition };



(* predicates *)






WriteEasymeshInputData[easymeshPolygonInput_,
      easymeshLineInput:{___EasymeshVertex},
      easymeshMaterialPointInput:{___Point}]:=
    
    Module[
      {polygonVerticesFunction,pointFunction,LineVerticesFunction,allPolygons,
        polygons,allLines,lines,points,easymeshData,
        allVerticesPerLineFunction,allVerticesPerPolygonFunction},
      
      allPolygons=Cases[easymeshPolygonInput,_EasymeshPolygon];
      allVerticesPerPolygonFunction[j_]:=Module[{onePolygon,polygonVertices},
          onePolygon=Cases[allPolygons[[j]],_EasymeshVertex];
          
          polygonVerticesFunction[i_]:=GetVertexData[onePolygon[[i]]];
          
          polygonVertices=polygonVerticesFunction/@Range[Length[onePolygon]];
          
          Return[polygonVertices];
          ];
      polygons=allVerticesPerPolygonFunction/@Range[Length[allPolygons]];
      
      
      allLines=Cases[easymeshLineInput,_EasymeshPolyLine];
      allVerticesPerLineFunction[j_]:=Module[{oneLine,lineVertices},
          oneLine=Cases[allLines[[j]],_EasymeshVertex];
          
          LineVerticesFunction[i_]:=GetVertexData[oneLine[[i]]];
          
          lineVertices=LineVerticesFunction/@Range[Length[oneLine]];
          
          Return[lineVertices];
          ];
      lines=allVerticesPerLineFunction/@Range[Length[allLines]];
      
      
      pointFunction[k_]:=
        GetMaterialPointData[easymeshMaterialPointInput[[k]]];
      points=pointFunction/@Range[Length[easymeshMaterialPointInput]];
      
      easymeshData=WriteEasymeshInput[polygons,lines,points];
      
      Return[easymeshData];
      ];




WriteEasymeshInput[polygone_,lines_,singlePoints_]:=
    
    Module[{i,j,convertToEasymeshFormatpointspolygone,pointslines,
        pointssinglePoints,sidepolygone,sidelines,pointInformation,
        sidePolygonInformationFunktion,sideListPolygon,
        sideLinesInformationFunktion,sideListLines,strukturFunktionPolygon,
        strukturPolygon,strukturFunktionLines,strukturLines,givePartII,vari11,
        structuredpolygonList,givePart22,vari22,structuredLineList,seitenline,
        linesseitenlist,xx,seitenpolygon,polygonseitenlistFunction,
        joinedSides,outSides,outputSides,sidepolygoneFunktion,pointspolygone,
        sidelinesFunktion},
      
      sidepolygoneFunktion[i_]:=
        polygone[[i,Range[Length[polygone[[i]]]],{1,2,5}]];
      
      sidelinesFunktion[i_]:=lines[[i,Range[Length[lines[[i]]]],{1,2,5}]];
      
      sidePolygonInformationFunktion[i_,j_]:=
        Flatten[{(Position[
                  pointInformation[[Range[Length[pointInformation]],{2,3}]],
                  sidepolygone[[i,j,{1,2}]]]-1),sidepolygone[[i,j,3]]}];
      
      sideLinesInformationFunktion[i_,j_]:=
        Flatten[{(Position[
                  pointInformation[[Range[Length[pointInformation]],{2,3}]],
                  sidelines[[i,j,{1,2}]]]-1),sidelines[[i,j,3]]}];
      
      strukturFunktionPolygon[i_]:=Length[sidepolygone[[i]]];
      
      strukturFunktionLines[i_]:=Length[sidelines[[i]]];
      
      givePartII[p_]:={Take[vari11,p],vari11=Drop[vari11,p];};
      
      givePart22[p_]:={Take[vari22,p],vari22=Drop[vari22,p];};
      
      linesseitenlist[j_]:=
        For[i=1,i<strukturLines[[j]],i++,
          xx=RotateLeft[
              Flatten[{Reverse[structuredLineList[[j,i]]],
                  structuredLineList[[j,i+1,1]]}]];
          seitenline=Append[seitenline,xx]];
      
      polygonseitenlistFunction[j_]:=
        For[i=1,i\[LessEqual]strukturPolygon[[j]],i++,
          Which[i<strukturPolygon[[j]],
            xx=RotateLeft[
                Flatten[{Reverse[structuredpolygonList[[j,i]]],
                    structuredpolygonList[[j,i+1,1]]}]];
            seitenpolygon=Append[seitenpolygon,xx],
            i\[Equal]strukturPolygon[[j]],
            xx=RotateLeft[
                Flatten[{Reverse[structuredpolygonList[[j,i]]],
                    structuredpolygonList[[j,1,1]]}]];
            seitenpolygon=Append[seitenpolygon,xx];]];
      
      pointspolygone=
        Flatten[polygone,1][[Range[Length[Flatten[polygone,1]]],{1,2,3,4}]];
      
      pointslines=
        Flatten[lines,1][[Range[Length[Flatten[lines,1]]],{1,2,3,4}]];
      
      pointssinglePoints=
        singlePoints[[Range[Length[singlePoints]],{1,2,3,4}]];
      
      sidepolygone=sidepolygoneFunktion/@Range[Length[polygone]];
      
      sidelines=sidelinesFunktion/@Range[Length[lines]];
      
      pointInformation=
        Transpose[
          Flatten[{{Range[0,
                  Length[Union[pointspolygone,pointslines,
                        pointssinglePoints]]-1]},
              Transpose[
                Union[pointspolygone,pointslines,pointssinglePoints]]},1]];
      
      sideListPolygon=
        Apply[sidePolygonInformationFunktion,#]&/@
          Flatten[Table[{i,j},{i,Length[sidepolygone]},{j,
                Length[sidepolygone[[i]]]}],1];
      
      sideListLines=
        Apply[sideLinesInformationFunktion,#]&/@
          Flatten[Table[{i,j},{i,Length[sidelines]},{j,
                Length[sidelines[[i]]]}],1];
      
      strukturPolygon=strukturFunktionPolygon/@Range[Length[sidepolygone]];
      
      strukturLines=strukturFunktionLines/@Range[Length[sidelines]];
      
      vari11=sideListPolygon;
      
      structuredpolygonList=
        Cases[Flatten[givePartII/@strukturPolygon,1],_List];
      
      vari22=sideListLines;
      
      structuredLineList=Cases[Flatten[givePart22/@strukturLines,1],_List];
      
      seitenline={};
      
      linesseitenlist/@Range[Length[strukturLines]];
      
      seitenpolygon={};
      
      polygonseitenlistFunction/@Range[Length[strukturPolygon]];
      
      joinedSides=Join[seitenpolygon,seitenline];
      
      outSides={};
      
      For[i=1,i\[LessEqual]Length[joinedSides],i++,
        If[MemberQ[outSides,joinedSides[[i]]],Null,
          outSides=Append[outSides,joinedSides[[i]]]]];
      
      outputSides=
        Transpose[
          Flatten[{{Range[0,Length[outSides]-1]},Transpose[outSides]},1]];
      
      Return[{pointInformation,outputSides}]];



RunEasymesh[
    geometyData:{pointInformation:{{_Real|_Integer,_Real|_Integer,_Real|_\
Integer,_Real|_Integer,_Integer}..},
        outputSides:{{_Real|_Integer,_Real|_Integer,_Real|_Integer,_Real|_\
Integer}..}..}]:=
  Module[
    {easyMeshBaseName,BuildEasyMeshBaseName,easyMeshFile},
    easyMeshBaseName=
      StringJoin["/tmp/",$UserName,
        PadRight[Characters[ToString[Random[Integer,99999999]]],8]];
    
    BuildEasyMeshBaseName[]:=
      easyMeshBaseName/;$OperatingSystem\[Equal]"Unix";
    BuildEasyMeshBaseName[]:=Block[{},Print["Not yet implemented"];Abort[]];
    easyMeshFile=StringJoin[easyMeshBaseName,".d"];
    Export[easyMeshFile,
      Join[{" "},{Length[geometyData[[1]]]" ""#Points#"},
        geometyData[[1]],{" "},{Length[geometyData[[2]]]" ""#Segments#"},
        geometyData[[2]]],"Table"];
    Run[StringJoin["easymesh ", easyMeshFile]];
    
    
    Return[easyMeshBaseName]
    ];



Off[Read::"readn"]

ReadEasymesh[fileName_String]:=
    Module[
      {readEasymeshFormat,easymeshNode,nodefile,easymeshSide,sidefile,
        easymeshElement,elementfile},
      easymeshNode=OpenRead[StringJoin[fileName,".n"]];
      
      Read[easymeshNode,{Number}];
      nodefile={};
      nodefile=ReadList[easymeshNode,{Number,Character,Real,Real,Number}];
      Close[easymeshNode];
      nodefile=Drop[Transpose[nodefile],{2,2}];
      nodefile[[1]]=nodefile[[1]]+1;
      nodefile=Transpose[nodefile];
      
      easymeshSide=OpenRead[StringJoin[fileName,".s"]];
      Read[easymeshSide,{Number}];
      sidefile={};
      sidefile=
        ReadList[
          easymeshSide,{Number,Character,Number,Number,Number,Number,
            Number}];
      Close[easymeshSide];
      sidefile=Drop[Transpose[sidefile],{2}];
      sidefile[[1]]=sidefile[[1]]+1;
      sidefile[[2]]=sidefile[[2]]+1;
      sidefile[[3]]=sidefile[[3]]+1;
      sidefile[[4]]=sidefile[[4]]+1;
      sidefile[[5]]=sidefile[[5]]+1;
      sidefile=Transpose[sidefile];
      
      easymeshElement=OpenRead[StringJoin[fileName,".e"]];
      Read[easymeshElement,{Number}];
      elementfile={};
      elementfile=
        ReadList[
          easymeshElement,{Number,Character,Number,Number,Number,Number,
            Number,Number,Number,Number,Number,Real,Real,Number}];
      Close[easymeshElement];
      elementfile=Drop[Transpose[elementfile],{2}];
      elementfile[[1]]=elementfile[[1]]+1;
      elementfile[[2]]=elementfile[[2]]+1;
      elementfile[[3]]=elementfile[[3]]+1;
      elementfile[[4]]=elementfile[[4]]+1;
      elementfile[[5]]=elementfile[[5]]+1;
      elementfile[[6]]=elementfile[[6]]+1;
      elementfile[[7]]=elementfile[[7]]+1;
      elementfile[[8]]=elementfile[[8]]+1;
      elementfile[[9]]=elementfile[[9]]+1;
      elementfile[[10]]=elementfile[[10]]+1;
      elementfile=Transpose[elementfile];
      
      
      Return[{nodefile,sidefile,elementfile}]
      ];





GeometryFunction2DAxisSymmetric[
      easymeshData:{nodeList:{({_Integer,_Real,_Real,_Integer})..},
          
          sideList:{({_Integer,_Integer,_Integer,_Integer,_Integer,_Integer})..}\
,
          
          elementList:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}}]:=
    
    Module[{nodeNumbersPerElement,coordinatesPerElementFunction,
        coordinatesPerElement,lengthOfElementsidesFunction,
        lengthOfElementsides,boxSideLengthFunction,boxSideLength,
        volumeOfVoronoiPart,radiusOfCelFunction,radiusOfCel,
        radiusOfFluxFunction,radiusOfFlux,numberOfNodes},
      
      nodeNumbersPerElement=easymeshData[[3]][[All,{2,3,4}]];
      
      numberOfNodes=easymeshData[[1,-1,1]];
      
      coordinatesPerElementFunction[i_]:=
        easymeshData\[LeftDoubleBracket]1\[RightDoubleBracket]\
\[LeftDoubleBracket]All,{2,3}\[RightDoubleBracket]\[LeftDoubleBracket]
          i\[RightDoubleBracket];
      coordinatesPerElement=
        coordinatesPerElementFunction/@nodeNumbersPerElement;
      
      lengthOfElementsides=
        Transpose[{Apply[
                Plus,(coordinatesPerElement[[All,1]]-
                      coordinatesPerElement[[All,2]])^2,{1}]^0.5,
            Apply[Plus,(coordinatesPerElement[[All,1]]-
                      coordinatesPerElement[[All,3]])^2,{1}]^0.5,
            Apply[Plus,(coordinatesPerElement[[All,2]]-
                      coordinatesPerElement[[All,3]])^2,{1}]^0.5}];
      
      boxSideLength=
        Transpose[{Apply[
                Plus,(((coordinatesPerElement[[All,1]]+
                              coordinatesPerElement[[All,2]])/2)-
                      easymeshData[[3]][[All,{11,12}]])^2,{1}]^0.5,
            Apply[Plus,(((coordinatesPerElement[[All,1]]+
                              coordinatesPerElement[[All,3]])/2)-
                      easymeshData[[3]][[All,{11,12}]])^2,{1}]^0.5,
            Apply[Plus,(((coordinatesPerElement[[All,2]]+
                              coordinatesPerElement[[All,3]])/2)-
                      easymeshData[[3]][[All,{11,12}]])^2,{1}]^0.5}];
      
      volumeOfVoronoiPart=boxSideLength*lengthOfElementsides/4;
      
      radiusOfCel=
        Transpose[{((((coordinatesPerElement[[All,1,1]]+
                            coordinatesPerElement[[All,2,1]])/2)+
                    easymeshData[[3,All,11]]+
                    coordinatesPerElement[[All,1,1]])/3),
            ((((coordinatesPerElement[[All,1,1]]+
                            coordinatesPerElement[[All,3,1]])/2)+
                    easymeshData[[3,All,11]]+
                    coordinatesPerElement[[All,1,1]])/3),
            
            ((((coordinatesPerElement[[All,1,1]]+
                            coordinatesPerElement[[All,2,1]])/2)+
                    easymeshData[[3,All,11]]+
                    coordinatesPerElement[[All,2,1]])/3),
            ((((coordinatesPerElement[[All,3,1]]+
                            coordinatesPerElement[[All,2,1]])/2)+
                    easymeshData[[3,All,11]]+
                    coordinatesPerElement[[All,2,1]])/3),
            
            ((((coordinatesPerElement[[All,1,1]]+
                            coordinatesPerElement[[All,3,1]])/2)+
                    easymeshData[[3,All,11]]+
                    coordinatesPerElement[[All,3,1]])/3),
            ((((coordinatesPerElement[[All,2,1]]+
                            coordinatesPerElement[[All,3,1]])/2)+
                    easymeshData[[3,All,11]]+
                    coordinatesPerElement[[All,3,1]])/3)}];
      
      radiusOfFlux=
        Transpose[{((((coordinatesPerElement[[All,1,1]]+
                            coordinatesPerElement[[All,2,1]])/2)+
                    easymeshData[[3,All,11]])/
                2),((((coordinatesPerElement[[All,1,1]]+
                            coordinatesPerElement[[All,3,1]])/2)+
                    easymeshData[[3,All,11]])/
                2),((((coordinatesPerElement[[All,2,1]]+
                            coordinatesPerElement[[All,3,1]])/2)+
                    easymeshData[[3,All,11]])/2)}];
      
      
      Return[{boxSideLength,lengthOfElementsides,nodeNumbersPerElement,
          numberOfNodes,radiusOfCel,radiusOfFlux,volumeOfVoronoiPart}]];



EquationsystemSteadyState2DAxisSymmetric[
    geometry:{boxSideLengthvariable:{({_Real,_Real,_Real})..},
        lengthOfElementsidesvariable:{({_Real,_Real,_Real})..},
        nodeNumbersPerElementvariable:{({_Integer,_Integer,_Integer})..},
        numberOfNodesvariable_Integer,
        radiusOfCelvariable:{({_Real,_Real,_Real,_Real,_Real,_Real})..},
        radiusOfFluxvariable:{({_Real,_Real,_Real})..},
        volumeOfVoronoiPartvariable:{({_Real,_Real,_Real})..}},
    
    easymeshData:{
        nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
        sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
        elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
    
    Dif:{(_Real|_Integer)..},
    initialConcentrations:{(_Real|_Integer)..},
    
    neumannBoundaryValues:{({{_Integer,(_Real|_Integer)},___})..},
    
    electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
              butvolmHin:_Real|_Power |_Symbol, 
              butvolmRueck :_Real|_Power |_Symbol  })..},
    
    dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_Real|\
_Integer}})..}
    ]:=
  
  Module[{sparseMatrixAValuesFunction,numberOfNodes,nodeNumbersPerElement,
      radiusOfCel,volumeOfVoronoiPart,radiusOfFlux,boxSideLength,
      lengthOfElementsides,a,sparseMatrixAValues,rightHandSideVector,
      rightHandSideVectorBuildingFunction,vectorOfConcentrations,nodeMarcs,
      neumannBCFunction,electrodeReactionsFunktion,electrodeReaction,aIndices,
      dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
      allDirichletNodes,dirichletLinesFunktion,dirichletLines,
      dirichletEliminationFunktion,diagonDirichl,dirichletRHSVariableFunction,
      dirichletRHSFunction,dirichletRHSVariable,sparseStiffnessMatrix,
      punktkombinationen,startMatrixFunction,startMatrix,
      concentrationFunction,elektrodenVariablen,elektrodenVariablenFunktion,
      punktkombinationenFunktion},
    
    boxSideLength=geometry[[1]];
    lengthOfElementsides=geometry[[2]];
    nodeNumbersPerElement=geometry[[3]];
    numberOfNodes=geometry[[4]];
    radiusOfCel=geometry[[5]];
    radiusOfFlux=geometry[[6]];
    volumeOfVoronoiPart=geometry[[7]];
    
    
    punktkombinationenFunktion[
        i_]:={(i-1)easymeshData[[1,-1,1]]+easymeshData[[2]][[All,{2,3}]],
        Map[RotateLeft,(i-1)easymeshData[[1,-1,1]]+
            easymeshData[[2]][[All,{2,3}]]],(i-1)easymeshData[[1,-1,1]]+
          Table[{k,k},{k,easymeshData[[1,-1,1]]}]};
    punktkombinationen=
      Flatten[punktkombinationenFunktion/@Range[Length[Dif]],2];
    
    startMatrixFunction[i_]:=
      a[i\[LeftDoubleBracket]1\[RightDoubleBracket],
          i\[LeftDoubleBracket]2\[RightDoubleBracket]]=0;
    startMatrix=startMatrixFunction/@punktkombinationen;
    (* durch die Startmatrix entfallen die If-
        Abfragen fuer den Matrixaufbau *)
    
    
    
    sparseMatrixAValuesFunction[i_]:=
      Module[{x,y,z,u,v,w,numberOfSpezFunction},
        
        
        x=radiusOfFlux[[i,1]]*(boxSideLength/lengthOfElementsides)[[i,1]];
        y=radiusOfFlux[[i,2]]*(boxSideLength/lengthOfElementsides)[[i,2]];
        z=radiusOfFlux[[i,3]]*(boxSideLength/lengthOfElementsides)[[i,3]];
        
        u=nodeNumbersPerElement[[i,1]];
        v=nodeNumbersPerElement[[i,2]];
        w=nodeNumbersPerElement[[i,3]];
        
        
        numberOfSpezFunction[j_]:=
          Module[{j1u=(j-1)*numberOfNodes+u,j1v=(j-1)*numberOfNodes+v,
              j1w=(j-1)*numberOfNodes+w,dj=Dif[[j]]},
            a[j1u,j1u]+=(x+y)*dj;
            a[j1v,j1v]+=(x+z)*dj;
            a[j1w,j1w]+=(y+z)*dj;
            
            a[j1u,j1v]=a[j1v,j1u]+=-(x)*dj;
            a[j1v,j1w]=a[j1w,j1v]+=-(z)*dj;
            a[j1u,j1w]=a[j1w,j1u]+=-(y)*dj;
            ];
        numberOfSpezFunction/@Range[Length[Dif]];
        ] ;
    sparseMatrixAValues=
      sparseMatrixAValuesFunction/@Range[Length[nodeNumbersPerElement]];
    
    
    rightHandSideVector=Table[0,{Length[Dif]*numberOfNodes}];
    
    vectorOfConcentrations=Table[0,{Length[Dif]*numberOfNodes}];
    nodeMarcs=easymeshData[[1]][[All,4]];
    
    neumannBCFunction[i_,j_,k_]:=
      If[nodeMarcs[[i]]==neumannBoundaryValues[[j,k,1]],
        a[(j-1)*numberOfNodes+i,(j-1)*numberOfNodes+i]+=
          neumannBoundaryValues[[j,k,2]]
        ];
    
    If[Length[neumannBoundaryValues[[1]]]>0,
      Apply[neumannBCFunction,#]&/@
          Flatten[Table[{i,j,k},{j,Length[Dif]},{i,Length[nodeMarcs]},{k,
                Length[neumannBoundaryValues[[1]]]}],2];
      ];
    
    
    electrodeReactionsFunktion[i_,j_]:=
      
      If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
          electrodeReactionValues[[j,4]];
        
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]=-(electrodeReactionValues[[j,5]]);
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[1,3]]]])*
            electrodeReactionValues[[j,5]];
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[j,
                        3]]]])*-electrodeReactionValues[[j,4]];
        ];
    elektrodenVariablenFunktion[i_]:=
      Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
    elektrodenVariablen=
      Flatten[elektrodenVariablenFunktion/@
          Range[Length[electrodeReactionValues]],3];
    (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
    
    electrodeReaction=
      Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
    
    aIndices=Level[#1,{2}]&@@@DownValues[a];
    
    dirichletBcNodesFunktion[i_]:=
      Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
    dirichletBcNodes=
      dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
    
    
    allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+dirichletBcNodes;
    allDirichletNodes=Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
    
    dirichletLinesFunktion[i_]:=
      Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
    dirichletLines=
      Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
    dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
    Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
    diagonDirichl[i_]:=a[i,i]=1;
    diagonDirichl/@Transpose[dirichletLines][[1]];           
    
    
    dirichletRHSVariableFunction[i_]:=
      Transpose[{Flatten[dirichletBcNodes],
          Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
    dirichletRHSVariable=
      Flatten[dirichletRHSVariableFunction/@
          Range[Length[initialConcentrations]],1];
    
    dirichletRHSFunction[i_,j_]:=
      rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=
        initialConcentrations[[j]];
    Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
    
    
    concentrationFunction[k_]:=Module[{diricFunction},
        diricFunction[i_,j_]:=
          vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                    Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
        Apply[diricFunction,#]&/@
          Transpose[{Flatten[
                Transpose[
                  Table[Flatten[
                      Position[nodeMarcs,dirichletBoundaries[[k,1]]]],{Length[
                        Flatten[
                          dirichletBoundaries[[k,2,
                              Range[Length[
                                  dirichletBoundaries[[k,
                                      2]]]]]]]]}]]](*das gibt die Nodenumbers*),
              Flatten[Table[
                  dirichletBoundaries[[k,2,
                      Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                      Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,
                              1]]]]]}]](*das gibt die Spezies*)}];];
    concentrationFunction/@Range[Length[dirichletBoundaries]];
    
    
    sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
    
    
    Return[{sparseStiffnessMatrix,vectorOfConcentrations}]
    ];



EquationsystTransient2DAxisSymmetric[
    geometry:{boxSideLengthvariable:{({_Real,_Real,_Real})..},
        lengthOfElementsidesvariable:{({_Real,_Real,_Real})..},
        nodeNumbersPerElementvariable:{({_Integer,_Integer,_Integer})..},
        numberOfNodesvariable_Integer,
        radiusOfCelvariable:{({_Real,_Real,_Real,_Real,_Real,_Real})..},
        radiusOfFluxvariable:{({_Real,_Real,_Real})..},
        volumeOfVoronoiPartvariable:{({_Real,_Real,_Real})..}},
    easymeshData:{
        nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
        sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
        elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
    Dif:{(_Real|_Integer)..},
    timeStep:(_Real|_Integer),
    initialConcentrations:{(_Real|_Integer)..},
    neumannBoundaryValues:{({{_Integer,(_Real|_Integer)},___})..},
    electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
              butvolmHin:_Real|_Power |_Symbol, 
              butvolmRueck :_Real|_Power |_Symbol  })..},
    dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_Real|\
_Integer}})..}]:=
  
  Module[{sparseMatrixAValuesFunction,numberOfNodes,nodeNumbersPerElement,
      radiusOfCel,volumeOfVoronoiPart,radiusOfFlux,boxSideLength,
      lengthOfElementsides,a,sparseMatrixAValues,rightHandSideVector,
      rightHandSideVectorBuildingFunction,vectorOfConcentrationsFunction,
      vectorOfConcentrations,nodeMarcs,neumannBCFunction,
      electrodeReactionsFunktion,electrodeReaction,aIndices,
      dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
      allDirichletNodes,dirichletLinesFunktion,dirichletLines,
      dirichletEliminationFunktion,diagonDirichl,dirichletRHSVariableFunction,
      dirichletRHSFunction,dirichletRHSVariable,sparseStiffnessMatrix,
      punktkombinationen,startMatrixFunction,startMatrix,vectorOfVolumes,
      concentrationFunction,elektrodenVariablenFunktion,elektrodenVariablen,
      punktkombinationenFunktion},
    
    boxSideLength=geometry[[1]];
    lengthOfElementsides=geometry[[2]];
    nodeNumbersPerElement=geometry[[3]];
    numberOfNodes=geometry[[4]];
    radiusOfCel=geometry[[5]];
    radiusOfFlux=geometry[[6]];
    volumeOfVoronoiPart=
      geometry[[7]]; (*** wenn volumeOfVoronoiPart=0 gesetzt wird, 
      dann haben wir den steady state Fall ***)
    
    punktkombinationenFunktion[
        i_]:={(i-1)easymeshData[[1,-1,1]]+easymeshData[[2]][[All,{2,3}]],
        Map[RotateLeft,(i-1)easymeshData[[1,-1,1]]+
            easymeshData[[2]][[All,{2,3}]]],(i-1)easymeshData[[1,-1,1]]+
          Table[{k,k},{k,easymeshData[[1,-1,1]]}]};
    punktkombinationen=
      Flatten[punktkombinationenFunktion/@Range[Length[Dif]],2];
    
    startMatrixFunction[i_]:=
      a[i\[LeftDoubleBracket]1\[RightDoubleBracket],
          i\[LeftDoubleBracket]2\[RightDoubleBracket]]=0;
    startMatrix=startMatrixFunction/@punktkombinationen;
    (* durch die Startmatrix entfallen die If-
        Abfragen fuer den Matrixaufbau *)
    
    
    rightHandSideVector=Table[0,{Length[Dif]*numberOfNodes}];
    sparseMatrixAValuesFunction[i_]:=
      Module[{x,y,z,u,v,w,numberOfSpezFunction,geom,r,s,t,transPart},
        
        geom=boxSideLength/lengthOfElementsides;
        
        (*  x=radiusOfFlux[[i,1]]*geom[[i,1]];
          y=radiusOfFlux[[i,2]]*geom[[i,2]];
          z=radiusOfFlux[[i,3]]*geom[[i,3]];  *)
        
        {x,y,z}=radiusOfFlux[[i]]*geom[[i]];
        
        transPart=volumeOfVoronoiPart/timeStep;
        
        r=
          transPart[[i,1]]radiusOfCel[[i,1]]+
            transPart[[i,2]]radiusOfCel[[i,2]];
        s=
          transPart[[i,1]]radiusOfCel[[i,3]]+
            transPart[[i,3]]radiusOfCel[[i,4]];
        t=
          transPart[[i,2]]radiusOfCel[[i,5]]+
            transPart[[i,3]]radiusOfCel[[i,6]];
        
        (*      u=nodeNumbersPerElement[[i,1]];
          v=nodeNumbersPerElement[[i,2]];
          w=nodeNumbersPerElement[[i,3]];    *)
        
        {u,v,w}=nodeNumbersPerElement[[i]];
        
        rightHandSideVectorBuildingFunction[j_]:=Module[{},
            rightHandSideVector[[(j-1)*numberOfNodes+u]]+=r;
            rightHandSideVector[[(j-1)*numberOfNodes+v]]+=s;
            rightHandSideVector[[(j-1)*numberOfNodes+w]]+=t;
            ];
        rightHandSideVectorBuildingFunction/@Range[Length[Dif]];
        
        vectorOfVolumes=rightHandSideVector*timeStep;
        
        numberOfSpezFunction[j_]:=
          Module[{j1u=(j-1)*numberOfNodes+u,j1v=(j-1)*numberOfNodes+v,
              j1w=(j-1)*numberOfNodes+w,dj=Dif[[j]]},
            a[j1u,j1u]+=(x+y)*dj+r;
            a[j1v,j1v]+=(x+z)*dj+s;
            a[j1w,j1w]+=(y+z)*dj+t;
            
            a[j1u,j1v]=a[j1v,j1u]+=-(x)*dj;
            a[j1v,j1w]=a[j1w,j1v]+=-(z)*dj;
            a[j1u,j1w]=a[j1w,j1u]+=-(y)*dj;
            ];
        numberOfSpezFunction/@Range[Length[Dif]];
        ] ;
    sparseMatrixAValues=
      sparseMatrixAValuesFunction/@Range[Length[nodeNumbersPerElement]];
    
    
    
    vectorOfConcentrationsFunction[i_]:=
      Table[initialConcentrations[[i]],{numberOfNodes}];
    
    vectorOfConcentrations=
      Flatten[vectorOfConcentrationsFunction/@
          Range[Length[initialConcentrations]]];
    
    nodeMarcs=easymeshData[[1]][[All,4]];
    
    neumannBCFunction[i_,j_,k_]:=
      If[nodeMarcs[[i]]==neumannBoundaryValues[[j,k,1]],
        a[(j-1)*numberOfNodes+i,(j-1)*numberOfNodes+i]+=
          neumannBoundaryValues[[j,k,2]]
        ];
    
    If[Length[neumannBoundaryValues[[1]]]>0,
      Apply[neumannBCFunction,#]&/@
          Flatten[Table[{i,j,k},{j,Length[Dif]},{i,Length[nodeMarcs]},{k,
                Length[neumannBoundaryValues[[1]]]}],2];
      ];
    
    
    electrodeReactionsFunktion[i_,j_]:=
      
      If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
          electrodeReactionValues[[j,4]];
        
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]=-(electrodeReactionValues[[j,5]]);
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[1,3]]]])*
            electrodeReactionValues[[j,5]];
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[j,
                        3]]]])*-electrodeReactionValues[[j,4]];
        ];
    elektrodenVariablenFunktion[i_]:=
      Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
    elektrodenVariablen=
      Flatten[elektrodenVariablenFunktion/@
          Range[Length[electrodeReactionValues]],3];
    (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
    
    electrodeReaction=
      Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
    
    aIndices=Level[#1,{2}]&@@@DownValues[a];
    
    dirichletBcNodesFunktion[i_]:=
      Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
    dirichletBcNodes=
      dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
    
    
    allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+dirichletBcNodes;
    allDirichletNodes=Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
    
    dirichletLinesFunktion[i_]:=
      Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
    dirichletLines=
      Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
    dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
    Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
    diagonDirichl[i_]:=a[i,i]=1;
    diagonDirichl/@Transpose[dirichletLines][[1]];           
    
    
    dirichletRHSVariableFunction[i_]:=
      Transpose[{Flatten[dirichletBcNodes],
          Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
    dirichletRHSVariable=
      Flatten[dirichletRHSVariableFunction/@
          Range[Length[initialConcentrations]],1];
    
    dirichletRHSFunction[i_,j_]:=
      rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=1;
    Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
    
    
    concentrationFunction[k_]:=Module[{diricFunction},
        diricFunction[i_,j_]:=
          vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                    Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
        Apply[diricFunction,#]&/@
          Transpose[{Flatten[
                Transpose[
                  Table[Flatten[
                      Position[nodeMarcs,dirichletBoundaries[[k,1]]]],{Length[
                        Flatten[
                          dirichletBoundaries[[k,2,
                              Range[Length[
                                  dirichletBoundaries[[k,
                                      2]]]]]]]]}]]](*das gibt die Nodenumbers*),
              Flatten[Table[
                  dirichletBoundaries[[k,2,
                      Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                      Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,
                              1]]]]]}]](*das gibt die Spezies*)}];];
    
    
    concentrationFunction/@Range[Length[dirichletBoundaries]];
    
    sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
    
    
    Return[{sparseStiffnessMatrix,rightHandSideVector,vectorOfConcentrations,
        vectorOfVolumes}]
    ];





CurrentFunction2DAxisSymmetric[dieElektrode_Integer,
    dritens:{nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
        sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
        elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
    concDistribution:{{(_Real)..}..}]:=
  Module[{sideMarcs,sideposition,pointNumbersFunction,pointNumbers,i,j,k,
      sidesToNeighboursFunction,sidesToNeighbours,nodeAndNeighbourFunction,
      nodeAndNeighbour,allCoordinatesFunction,allCoordinates,
      currentWithoutDifCoef,deltaTimesEveridgeFunktion,deltaTimesEveridge,
      elementNumberFunction,elementNumber,sortierenFunction,sortieren,
      startAndEndNodeFunktion,startAndEndNode,stromFunction,totalCurrent,
      voronoiLengthFunction,voronoiLength},
     (*dieElektrode=2;  bestimmt die Elektrode, 
      an der der Strom berechnet wird *)
    
    
    sideMarcs=Transpose[dritens[[2]]][[6]] ;(*gibt die Randmarker*)
    
    sideposition=
      Flatten[Position[sideMarcs,
          dieElektrode]];(*gibt die Positionen der elektrodenraender*)
    
    pointNumbersFunction[i_]:=
      dritens[[2]][[i]][[{2,3}]];(*gibt die Punktnummern der Electrode*)
    
    pointNumbers=Flatten[pointNumbersFunction/@sideposition];
    
    sidesToNeighboursFunction[i_]:=
      Transpose[
          Position[Transpose[dritens[[2]]][[{2,3}]],
            i]][[2]];(*gibt eine Liste der Seiten, 
      die den Electrodenpunkt enthalten*)
    
    sidesToNeighbours=sidesToNeighboursFunction/@pointNumbers;
    
    nodeAndNeighbourFunction[k_]:=
      Transpose[
          Transpose[
              dritens[[2]]][[{2,
                3}]]][[k]];(*gibt eine Liste mit dem Electrodenpunkt und \
seinen Nachbarn*)
    
    nodeAndNeighbour=nodeAndNeighbourFunction/@sidesToNeighbours;
    
    allCoordinatesFunction[j_]:=Module[{coordinateFunction,coordinate},
        coordinateFunction[
            i_]:=(Abs[
                Transpose[Transpose[dritens[[1]]][[{2,3}]]][[i]][[1]]-
                  Transpose[Transpose[dritens[[1]]][[{2,3}]]][[i]][[2]]]).{0,
              1};(*gibt die Differenz der Koordinaten des Punktes und seines \
Nachbarn mal der Normalenrichtung*)
        
        coordinate=coordinateFunction/@nodeAndNeighbour[[j]]
        ];
    allCoordinates=allCoordinatesFunction/@Range[Length[nodeAndNeighbour]];
    
    
    sortierenFunction[i_]:=Sort[i];
    sortieren=
      sortierenFunction/@
        Transpose[
          Transpose[
              dritens[[2]]][[{4,
                5}]]];(*die Elementnummern an beiden Seiten aller \
Punktverbindungen im Gebiet; 
      die Elementnummern sind sortiert um Randelemente behandeln zu koennen*)
\
    
    elementNumberFunction[i_]:=
      sortieren[[i]];(*gibt die Elemente zu beiden Seiten der \
Verbindungsseite*)
    
    elementNumber=elementNumberFunction/@sidesToNeighbours;
    
    startAndEndNodeFunktion[j_]:=
      Module[{startAndEndNodeFunktionII,startAndEndNodeII},
        startAndEndNodeFunktionII[i_]:=
          Transpose[
              Transpose[dritens[[2]]][[{2,3}]]][[sidesToNeighbours[[j,
                  i]]]];(*das sind die Punkte zur Seite*)
        
        startAndEndNodeII=
          startAndEndNodeFunktionII/@Range[Length[sidesToNeighbours[[j]]]];
        Return[startAndEndNodeII]
        ];
    startAndEndNode=
      startAndEndNodeFunktion/@Range[Length[sidesToNeighbours]];
    
    
    
    voronoiLengthFunction[j_]:=
      Module[{voronoiLengthFunctionII,voronoiLengthII},
        voronoiLengthFunctionII[i_]:=
          If[elementNumber[[j,i,1]]>0.1,
            Apply[Plus,(Transpose[
                          Transpose[
                              dritens[[3]]][[{11,12}]]][[elementNumber[[j,
                                i]][[1]]]]-
                      Transpose[
                          Transpose[
                              dritens[[3]]][[{11,12}]]][[elementNumber[[j,
                                i]][[2]]]])^2]^.5,
            Apply[Plus,((Transpose[
                                  Transpose[
                                      dritens[[1]]][[{2,
                                        3}]]][[startAndEndNode[[j,i]]]][[1]]+
                            Transpose[
                                  Transpose[
                                      dritens[[1]]][[{2,3}]]][[Transpose[
                                      Transpose[
                                        dritens[[2]]][[{2,
                                        3}]]][[sidesToNeighbours[[j,
                                        i]]]]]][[2]])/2-
                      Transpose[
                          Transpose[
                              dritens[[3]]][[{11,12}]]][[elementNumber[[j,
                                i]][[2]]]])^2]^.5];
        voronoiLengthII=
          voronoiLengthFunctionII/@Range[Length[elementNumber[[j]]]];
        Return[voronoiLengthII]
        ];
    voronoiLength=voronoiLengthFunction/@Range[Length[elementNumber]];
    
    stromFunction[k_]:=
      Module[{conzDifferenceFunction,conzDifference,conzTimesSij,
          gradientFunction,gradientsI,strom},
        
        conzDifferenceFunction[i_]:=
          Module[{conzDifferenceTwoFunction,conzDifferenceTwo},
            
            conzDifferenceTwoFunction[j_]:=
              k[[nodeAndNeighbour[[i,j,2]]]]-
                k[[nodeAndNeighbour[[i,j,
                        1]]]];(*gibt die Konzentrationsdifferenz  i=
                Hauptpunkt, j=Hauptpunkt und ein Nachbar*)
            
            conzDifferenceTwo=
              conzDifferenceTwoFunction/@Range[Length[nodeAndNeighbour[[i]]]]
            ];
        conzDifference=
          conzDifferenceFunction/@Range[Length[nodeAndNeighbour]];
        
        
        conzTimesSij=conzDifference*voronoiLength*\[Pi];
        
        gradientFunction[i_]:=
          Module[{gradientToOneNode,gradientToOneNodeFunction},
            
            gradientToOneNodeFunction[j_]:=
              
              If[allCoordinates[[i,j]]=!=0.,
                conzTimesSij[[i,j]]/allCoordinates[[i,j]],0.];
            
            gradientToOneNode=
              Apply[Plus,
                gradientToOneNodeFunction/@
                  Range[Length[nodeAndNeighbour[[i]]]]]
            ];
        gradientsI=
          gradientFunction/@
            Range[Length[
                nodeAndNeighbour]];(*gibt den Gradienten zum Punkt in der \
Normalenrichtung*)
        
        strom=Apply[Plus,gradientsI];
        
        Return[strom]
        ];
    
    currentWithoutDifCoef=stromFunction/@concDistribution;
    
    Return[currentWithoutDifCoef];
    ]





CurrentbyMatrix2DAxyssymetricFunction[equationSystemSteady_,concDistribution_,
      electrode_,meshData_]:=
    Module[{CurrentbyMatrix2DAxyssymetricFunctionII,current},
      
      CurrentbyMatrix2DAxyssymetricFunctionVV[concDistributionSteady_]:=
        Module[{NodesOnElectrode,matrixElementFunction,matrixElements,
            gradientFunction,currentII},
          
          
          NodesOnElectrode=Flatten[Position[meshData[[1,All,4]],electrode]]; (* 
            die Randpunkte *)
          
          
          matrixElementFunction[i_]:=
            Module[{rowOfNodesOnElectrode,columnOfNodesOnElectrode,
                diagonalElement,nonDiagonalElements,
                nonDiagonalSparsMatrixEntrys},
              
              rowOfNodesOnElectrode=
                Flatten[
                  Position[equationSystemSteady[[1,All,1,1]],
                    NodesOnElectrode[[i]]]];(* 
                die Zeileneintraege der Randpunkte incl. 
                    Diagonalelement *)
              
              
              columnOfNodesOnElectrode=
                Flatten[
                  Position[equationSystemSteady[[1,All,1,2]],
                    NodesOnElectrode[[i]]]];(* 
                die Spalteneintraege der Randpunkte incl. 
                    Diagonalelement *)
              
              
              diagonalElement=
                Intersection[rowOfNodesOnElectrode,columnOfNodesOnElectrode];(* 
                das Element, 
                das sowohl zur zeile wie auch zur Spalte gehoert. 
                    Diagonalelement *)
              
              
              nonDiagonalElements=
                DeleteCases[rowOfNodesOnElectrode,diagonalElement[[1]]];(* 
                Alle Zeilenelemente ohne dem Diagonalelement *)
              \

              
              nonDiagonalSparsMatrixEntrys=
                equationSystemSteady[[1,nonDiagonalElements]];
              
              Return[nonDiagonalSparsMatrixEntrys];
              ];
          
          
          
          matrixElements=
            Flatten[matrixElementFunction/@Range[Length[NodesOnElectrode]]];
          
          
          gradientFunction[
              j_]:=((concDistributionSteady[[matrixElements[[j,1]]]][[2]]-
                    concDistributionSteady[[matrixElements[[j,1]]]][[1]])*
                matrixElements[[j,2]]);
          
          
          currentII=((Apply[Plus,
                      gradientFunction/@
                        Range[Length[matrixElements]]])^2)*\[Pi];
          
          Return[currentII]
          
          ];
      
      current=CurrentbyMatrix2DAxyssymetricFunctionVV/@concDistribution;
      Return[current]
      
      ];










EquationsystTransient2D[
    geometry:{boxSideLengthvariable:{({_Real,_Real,_Real})..},
        lengthOfElementsidesvariable:{({_Real,_Real,_Real})..},
        nodeNumbersPerElementvariable:{({_Integer,_Integer,_Integer})..},
        numberOfNodesvariable_Integer,
        radiusOfCelvariable:{({_Real,_Real,_Real,_Real,_Real,_Real})..},
        radiusOfFluxvariable:{({_Real,_Real,_Real})..},
        volumeOfVoronoiPartvariable:{({_Real,_Real,_Real})..}},
    easymeshData:{
        nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
        sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
        elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
    Dif:{(_Real|_Integer)..},
    timeStep:(_Real|_Integer),
    initialConcentrations:{(_Real|_Integer)..},
    neumannBoundaryValues:{({{_Integer,(_Real|_Integer)},___})..},
    electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
              butvolmHin:_Real|_Power |_Symbol, 
              butvolmRueck :_Real|_Power |_Symbol  })..},
    dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_Real|\
_Integer}})..}]:=
  
  Module[{sparseMatrixAValuesFunction,numberOfNodes,nodeNumbersPerElement,
      radiusOfCel,volumeOfVoronoiPart,radiusOfFlux,boxSideLength,
      lengthOfElementsides,a,sparseMatrixAValues,rightHandSideVector,
      rightHandSideVectorBuildingFunction,vectorOfConcentrationsFunction,
      vectorOfConcentrations,nodeMarcs,neumannBCFunction,
      electrodeReactionsFunktion,electrodeReaction,aIndices,
      dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
      allDirichletNodes,dirichletLinesFunktion,dirichletLines,
      dirichletEliminationFunktion,diagonDirichl,dirichletRHSVariableFunction,
      dirichletRHSFunction,dirichletRHSVariable,sparseStiffnessMatrix,
      punktkombinationen,startMatrixFunction,startMatrix,vectorOfVolumes,
      concentrationFunction,elektrodenVariablenFunktion,elektrodenVariablen,
      punktkombinationenFunktion},
    
    boxSideLength=geometry[[1]];
    lengthOfElementsides=geometry[[2]];
    nodeNumbersPerElement=geometry[[3]];
    numberOfNodes=geometry[[4]];
    radiusOfCel=
      Table[{1,1,1,1,1,
          1},{Length[
            geometry[[5]]]}];     (*the radius of the axisymmetric Function \
has been set to 1 \[Rule] the function became 2D *)
    
    radiusOfFlux=Table[{1,1,1},{Length[geometry[[6]]]}];
    volumeOfVoronoiPart=
      geometry[[7]]; (*** wenn volumeOfVoronoiPart=0 gesetzt wird, 
      dann haben wir den steady state Fall ***)
    
    punktkombinationenFunktion[
        i_]:={(i-1)easymeshData[[1,-1,1]]+easymeshData[[2]][[All,{2,3}]],
        Map[RotateLeft,(i-1)easymeshData[[1,-1,1]]+
            easymeshData[[2]][[All,{2,3}]]],(i-1)easymeshData[[1,-1,1]]+
          Table[{k,k},{k,easymeshData[[1,-1,1]]}]};
    punktkombinationen=
      Flatten[punktkombinationenFunktion/@Range[Length[Dif]],2];
    
    startMatrixFunction[i_]:=
      a[i\[LeftDoubleBracket]1\[RightDoubleBracket],
          i\[LeftDoubleBracket]2\[RightDoubleBracket]]=0;
    startMatrix=startMatrixFunction/@punktkombinationen;
    (* durch die Startmatrix entfallen die If-
        Abfragen fuer den Matrixaufbau *)
    
    
    rightHandSideVector=Table[0,{Length[Dif]*numberOfNodes}];
    sparseMatrixAValuesFunction[i_]:=
      Module[{x,y,z,u,v,w,numberOfSpezFunction,geom,r,s,t,transPart},
        
        geom=boxSideLength/lengthOfElementsides;
        
        (*  x=radiusOfFlux[[i,1]]*geom[[i,1]];
          y=radiusOfFlux[[i,2]]*geom[[i,2]];
          z=radiusOfFlux[[i,3]]*geom[[i,3]];  *)
        
        {x,y,z}=radiusOfFlux[[i]]*geom[[i]];
        
        transPart=volumeOfVoronoiPart/timeStep;
        
        r=
          transPart[[i,1]]radiusOfCel[[i,1]]+
            transPart[[i,2]]radiusOfCel[[i,2]];
        s=
          transPart[[i,1]]radiusOfCel[[i,3]]+
            transPart[[i,3]]radiusOfCel[[i,4]];
        t=transPart[[i,2]]radiusOfCel[[i,5]]+
            transPart[[i,3]]radiusOfCel[[i,6]];
        
        (*      u=nodeNumbersPerElement[[i,1]];
          v=nodeNumbersPerElement[[i,2]];
          w=nodeNumbersPerElement[[i,3]];    *)
        
        {u,v,w}=nodeNumbersPerElement[[i]];
        
        rightHandSideVectorBuildingFunction[j_]:=Module[{},
            rightHandSideVector[[(j-1)*numberOfNodes+u]]+=r;
            rightHandSideVector[[(j-1)*numberOfNodes+v]]+=s;
            rightHandSideVector[[(j-1)*numberOfNodes+w]]+=t;
            ];
        rightHandSideVectorBuildingFunction/@Range[Length[Dif]];
        
        vectorOfVolumes=rightHandSideVector*timeStep;
        
        numberOfSpezFunction[j_]:=
          Module[{j1u=(j-1)*numberOfNodes+u,j1v=(j-1)*numberOfNodes+v,
              j1w=(j-1)*numberOfNodes+w,dj=Dif[[j]]},
            a[j1u,j1u]+=(x+y)*dj+r;
            a[j1v,j1v]+=(x+z)*dj+s;
            a[j1w,j1w]+=(y+z)*dj+t;
            
            a[j1u,j1v]=a[j1v,j1u]+=-(x)*dj;
            a[j1v,j1w]=a[j1w,j1v]+=-(z)*dj;
            a[j1u,j1w]=a[j1w,j1u]+=-(y)*dj;
            ];
        numberOfSpezFunction/@Range[Length[Dif]];
        ] ;
    sparseMatrixAValues=
      sparseMatrixAValuesFunction/@Range[Length[nodeNumbersPerElement]];
    
    
    
    vectorOfConcentrationsFunction[i_]:=
      Table[initialConcentrations[[i]],{numberOfNodes}];
    
    vectorOfConcentrations=
      Flatten[vectorOfConcentrationsFunction/@
          Range[Length[initialConcentrations]]];
    
    nodeMarcs=easymeshData[[1]][[All,4]];
    
    neumannBCFunction[i_,j_,k_]:=
      If[nodeMarcs[[i]]==neumannBoundaryValues[[j,k,1]],
        a[(j-1)*numberOfNodes+i,(j-1)*numberOfNodes+i]+=
          neumannBoundaryValues[[j,k,2]]
        ];
    
    If[Length[neumannBoundaryValues[[1]]]>0,
      Apply[neumannBCFunction,#]&/@
          Flatten[Table[{i,j,k},{j,Length[Dif]},{i,Length[nodeMarcs]},{k,
                Length[neumannBoundaryValues[[1]]]}],2];
      ];
    
    
    electrodeReactionsFunktion[i_,j_]:=
      
      If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
          electrodeReactionValues[[j,4]];
        
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]=-(electrodeReactionValues[[j,5]]);
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[1,3]]]])*
            electrodeReactionValues[[j,5]];
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[j,
                        3]]]])*-electrodeReactionValues[[j,4]];
        ];
    elektrodenVariablenFunktion[i_]:=
      Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
    elektrodenVariablen=
      Flatten[elektrodenVariablenFunktion/@
          Range[Length[electrodeReactionValues]],3];
    (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
    
    electrodeReaction=
      Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
    
    aIndices=Level[#1,{2}]&@@@DownValues[a];
    
    dirichletBcNodesFunktion[i_]:=
      Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
    dirichletBcNodes=
      dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
    
    
    allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+dirichletBcNodes;
    allDirichletNodes=Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
    
    dirichletLinesFunktion[i_]:=
      Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
    dirichletLines=
      Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
    dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
    Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
    diagonDirichl[i_]:=a[i,i]=1;
    diagonDirichl/@Transpose[dirichletLines][[1]];           
    
    
    dirichletRHSVariableFunction[i_]:=
      Transpose[{Flatten[dirichletBcNodes],
          Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
    dirichletRHSVariable=
      Flatten[dirichletRHSVariableFunction/@
          Range[Length[initialConcentrations]],1];
    
    dirichletRHSFunction[i_,j_]:=
      rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=1;
    Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
    
    
    concentrationFunction[k_]:=Module[{diricFunction},
        diricFunction[i_,j_]:=
          vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                    Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
        Apply[diricFunction,#]&/@
          Transpose[{Flatten[
                Transpose[
                  Table[Flatten[
                      Position[nodeMarcs,dirichletBoundaries[[k,1]]]],{Length[
                        Flatten[
                          dirichletBoundaries[[k,2,
                              Range[Length[
                                  dirichletBoundaries[[k,
                                      2]]]]]]]]}]]](*das gibt die Nodenumbers*),
              Flatten[Table[
                  dirichletBoundaries[[k,2,
                      Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                      Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,
                              1]]]]]}]](*das gibt die Spezies*)}];];
    
    
    concentrationFunction/@Range[Length[dirichletBoundaries]];
    
    sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
    
    
    Return[{sparseStiffnessMatrix,rightHandSideVector,vectorOfConcentrations,
        vectorOfVolumes}]
    ];



EquationsystSteadyState2D[
    geometry:{boxSideLengthvariable:{({_Real,_Real,_Real})..},
        lengthOfElementsidesvariable:{({_Real,_Real,_Real})..},
        nodeNumbersPerElementvariable:{({_Integer,_Integer,_Integer})..},
        numberOfNodesvariable_Integer,
        radiusOfCelvariable:{({_Real,_Real,_Real,_Real,_Real,_Real})..},
        radiusOfFluxvariable:{({_Real,_Real,_Real})..},
        volumeOfVoronoiPartvariable:{({_Real,_Real,_Real})..}},
    
    easymeshData:{
        nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
        sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
        elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
    
    Dif:{(_Real|_Integer)..},
    initialConcentrations:{(_Real|_Integer)..},
    
    neumannBoundaryValues:{({{_Integer,(_Real|_Integer)},___})..},
    
    electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
              butvolmHin:_Real|_Power |_Symbol, 
              butvolmRueck :_Real|_Power |_Symbol  })..},
    
    dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_Real|\
_Integer}})..}
    ]:=
  
  Module[{sparseMatrixAValuesFunction,numberOfNodes,nodeNumbersPerElement,
      radiusOfCel,volumeOfVoronoiPart,radiusOfFlux,boxSideLength,
      lengthOfElementsides,a,sparseMatrixAValues,rightHandSideVector,
      rightHandSideVectorBuildingFunction,vectorOfConcentrations,nodeMarcs,
      neumannBCFunction,electrodeReactionsFunktion,electrodeReaction,aIndices,
      dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
      allDirichletNodes,dirichletLinesFunktion,dirichletLines,
      dirichletEliminationFunktion,diagonDirichl,dirichletRHSVariableFunction,
      dirichletRHSFunction,dirichletRHSVariable,sparseStiffnessMatrix,
      punktkombinationen,startMatrixFunction,startMatrix,
      concentrationFunction,elektrodenVariablen,elektrodenVariablenFunktion,
      punktkombinationenFunktion},
    
    boxSideLength=geometry[[1]];
    lengthOfElementsides=geometry[[2]];
    nodeNumbersPerElement=geometry[[3]];
    numberOfNodes=geometry[[4]];
    radiusOfCel=
      Table[{1,1,1,1,1,
          1},{Length[
            geometry[[5]]]}];     (*the radius of the axisymmetric Function \
has been set to 1 \[Rule] the function became 2D *)
    
    radiusOfFlux=Table[{1,1,1},{Length[geometry[[6]]]}];
    volumeOfVoronoiPart=geometry[[7]];
    
    
    punktkombinationenFunktion[
        i_]:={(i-1)easymeshData[[1,-1,1]]+easymeshData[[2]][[All,{2,3}]],
        Map[RotateLeft,(i-1)easymeshData[[1,-1,1]]+
            easymeshData[[2]][[All,{2,3}]]],(i-1)easymeshData[[1,-1,1]]+
          Table[{k,k},{k,easymeshData[[1,-1,1]]}]};
    punktkombinationen=
      Flatten[punktkombinationenFunktion/@Range[Length[Dif]],2];
    
    startMatrixFunction[i_]:=
      a[i\[LeftDoubleBracket]1\[RightDoubleBracket],
          i\[LeftDoubleBracket]2\[RightDoubleBracket]]=0;
    startMatrix=startMatrixFunction/@punktkombinationen;
    (* durch die Startmatrix entfallen die If-
        Abfragen fuer den Matrixaufbau *)
    
    
    
    sparseMatrixAValuesFunction[i_]:=
      Module[{x,y,z,u,v,w,numberOfSpezFunction},
        
        
        x=radiusOfFlux[[i,1]]*(boxSideLength/lengthOfElementsides)[[i,1]];
        y=radiusOfFlux[[i,2]]*(boxSideLength/lengthOfElementsides)[[i,2]];
        z=radiusOfFlux[[i,3]]*(boxSideLength/lengthOfElementsides)[[i,3]];
        
        u=nodeNumbersPerElement[[i,1]];
        v=nodeNumbersPerElement[[i,2]];
        w=nodeNumbersPerElement[[i,3]];
        
        
        numberOfSpezFunction[j_]:=
          Module[{j1u=(j-1)*numberOfNodes+u,j1v=(j-1)*numberOfNodes+v,
              j1w=(j-1)*numberOfNodes+w,dj=Dif[[j]]},
            a[j1u,j1u]+=(x+y)*dj;
            a[j1v,j1v]+=(x+z)*dj;
            a[j1w,j1w]+=(y+z)*dj;
            
            a[j1u,j1v]=a[j1v,j1u]+=-(x)*dj;
            a[j1v,j1w]=a[j1w,j1v]+=-(z)*dj;
            a[j1u,j1w]=a[j1w,j1u]+=-(y)*dj;
            ];
        numberOfSpezFunction/@Range[Length[Dif]];
        ] ;
    sparseMatrixAValues=
      sparseMatrixAValuesFunction/@Range[Length[nodeNumbersPerElement]];
    
    
    rightHandSideVector=Table[0,{Length[Dif]*numberOfNodes}];
    
    vectorOfConcentrations=Table[0,{Length[Dif]*numberOfNodes}];
    nodeMarcs=easymeshData[[1]][[All,4]];
    
    neumannBCFunction[i_,j_,k_]:=
      If[nodeMarcs[[i]]==neumannBoundaryValues[[j,k,1]],
        a[(j-1)*numberOfNodes+i,(j-1)*numberOfNodes+i]+=
          neumannBoundaryValues[[j,k,2]]
        ];
    
    If[Length[neumannBoundaryValues[[1]]]>0,
      Apply[neumannBCFunction,#]&/@
          Flatten[Table[{i,j,k},{j,Length[Dif]},{i,Length[nodeMarcs]},{k,
                Length[neumannBoundaryValues[[1]]]}],2];
      ];
    
    
    electrodeReactionsFunktion[i_,j_]:=
      
      If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
          electrodeReactionValues[[j,4]];
        
        a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]=-(electrodeReactionValues[[j,5]]);
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[1,3]]]])*
            electrodeReactionValues[[j,5]];
        
        a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
              i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
              i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                Dif[[electrodeReactionValues[[j,
                        3]]]])*-electrodeReactionValues[[j,4]];
        ];
    elektrodenVariablenFunktion[i_]:=
      Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
    elektrodenVariablen=
      Flatten[elektrodenVariablenFunktion/@
          Range[Length[electrodeReactionValues]],3];
    (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
    
    electrodeReaction=
      Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
    
    aIndices=Level[#1,{2}]&@@@DownValues[a];
    
    dirichletBcNodesFunktion[i_]:=
      Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
    dirichletBcNodes=
      dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
    
    
    allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+dirichletBcNodes;
    allDirichletNodes=Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
    
    dirichletLinesFunktion[i_]:=
      Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
    dirichletLines=
      Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
    dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
    Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
    diagonDirichl[i_]:=a[i,i]=1;
    diagonDirichl/@Transpose[dirichletLines][[1]];           
    
    
    dirichletRHSVariableFunction[i_]:=
      Transpose[{Flatten[dirichletBcNodes],
          Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
    dirichletRHSVariable=
      Flatten[dirichletRHSVariableFunction/@
          Range[Length[initialConcentrations]],1];
    
    dirichletRHSFunction[i_,j_]:=
      rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=
        initialConcentrations[[j]];
    Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
    
    
    concentrationFunction[k_]:=Module[{diricFunction},
        diricFunction[i_,j_]:=
          vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                    Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
        Apply[diricFunction,#]&/@
          Transpose[{Flatten[
                Transpose[
                  Table[Flatten[
                      Position[nodeMarcs,dirichletBoundaries[[k,1]]]],{Length[
                        Flatten[
                          dirichletBoundaries[[k,2,
                              Range[Length[
                                  dirichletBoundaries[[k,
                                      2]]]]]]]]}]]](*das gibt die Nodenumbers*),
              Flatten[Table[
                  dirichletBoundaries[[k,2,
                      Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                      Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,
                              1]]]]]}]](*das gibt die Spezies*)}];];
    concentrationFunction/@Range[Length[dirichletBoundaries]];
    
    
    sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
    
    
    Return[{sparseStiffnessMatrix,vectorOfConcentrations}]
    ];





CurrentPerDepthFunction2D[dieElektrode_Integer,
    dritens:{nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
        sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
        elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
    concDistribution:{{(_Real)..}..}]:=
  Module[{sideMarcs,sideposition,pointNumbersFunction,pointNumbers,i,j,k,
      sidesToNeighboursFunction,sidesToNeighbours,nodeAndNeighbourFunction,
      nodeAndNeighbour,allCoordinatesFunction,allCoordinates,
      currentWithoutDifCoef,deltaTimesEveridgeFunktion,deltaTimesEveridge,
      elementNumberFunction,elementNumber,sortierenFunction,sortieren,
      startAndEndNodeFunktion,startAndEndNode,stromFunction,totalCurrent,
      voronoiLengthFunction,voronoiLength},
    
    
    sideMarcs=Transpose[dritens[[2]]][[6]] ;(*gibt die Randmarker*)
    
    sideposition=
      Flatten[Position[sideMarcs,
          dieElektrode]];(*gibt die Positionen der elektrodenraender*)
    
    pointNumbersFunction[i_]:=
      dritens[[2]][[i]][[{2,3}]];(*gibt die Punktnummern der Electrode*)
    
    pointNumbers=Flatten[pointNumbersFunction/@sideposition];
    
    sidesToNeighboursFunction[i_]:=
      Transpose[
          Position[Transpose[dritens[[2]]][[{2,3}]],
            i]][[2]];(*gibt eine Liste der Seiten, 
      die den Electrodenpunkt enthalten*)
    
    sidesToNeighbours=sidesToNeighboursFunction/@pointNumbers;
    
    nodeAndNeighbourFunction[k_]:=
      Transpose[
          Transpose[
              dritens[[2]]][[{2,
                3}]]][[k]];(*gibt eine Liste mit dem Electrodenpunkt und \
seinen Nachbarn*)
    
    nodeAndNeighbour=nodeAndNeighbourFunction/@sidesToNeighbours;
    
    allCoordinatesFunction[j_]:=Module[{coordinateFunction,coordinate},
        coordinateFunction[
            i_]:=(Abs[
                Transpose[Transpose[dritens[[1]]][[{2,3}]]][[i]][[1]]-
                  Transpose[Transpose[dritens[[1]]][[{2,3}]]][[i]][[2]]]).{0,
              1};(*gibt die Differenz der Koordinaten des Punktes und seines \
Nachbarn mal der Normalenrichtung*)
        
        coordinate=coordinateFunction/@nodeAndNeighbour[[j]]
        ];
    allCoordinates=allCoordinatesFunction/@Range[Length[nodeAndNeighbour]];
    
    
    sortierenFunction[i_]:=Sort[i];
    sortieren=
      sortierenFunction/@
        Transpose[
          Transpose[
              dritens[[2]]][[{4,
                5}]]];(*die Elementnummern an beiden Seiten aller \
Punktverbindungen im Gebiet; 
      die Elementnummern sind sortiert um Randelemente behandeln zu koennen*)
\
    
    elementNumberFunction[i_]:=
      sortieren[[i]];(*gibt die Elemente zu beiden Seiten der \
Verbindungsseite*)
    
    elementNumber=elementNumberFunction/@sidesToNeighbours;
    
    startAndEndNodeFunktion[j_]:=
      Module[{startAndEndNodeFunktionII,startAndEndNodeII},
        startAndEndNodeFunktionII[i_]:=
          Transpose[
              Transpose[dritens[[2]]][[{2,3}]]][[sidesToNeighbours[[j,
                  i]]]];(*das sind die Punkte zur Seite*)
        
        startAndEndNodeII=
          startAndEndNodeFunktionII/@Range[Length[sidesToNeighbours[[j]]]];
        Return[startAndEndNodeII]
        ];
    startAndEndNode=
      startAndEndNodeFunktion/@Range[Length[sidesToNeighbours]];
    
    
    
    voronoiLengthFunction[j_]:=
      Module[{voronoiLengthFunctionII,voronoiLengthII},
        voronoiLengthFunctionII[i_]:=
          If[elementNumber[[j,i,1]]>0.1,
            Apply[Plus,(Transpose[
                          Transpose[
                              dritens[[3]]][[{11,12}]]][[elementNumber[[j,
                                i]][[1]]]]-
                      Transpose[
                          Transpose[
                              dritens[[3]]][[{11,12}]]][[elementNumber[[j,
                                i]][[2]]]])^2]^.5,
            Apply[Plus,((Transpose[
                                  Transpose[
                                      dritens[[1]]][[{2,
                                        3}]]][[startAndEndNode[[j,i]]]][[1]]+
                            Transpose[
                                  Transpose[
                                      dritens[[1]]][[{2,3}]]][[Transpose[
                                      Transpose[
                                        dritens[[2]]][[{2,
                                        3}]]][[sidesToNeighbours[[j,
                                        i]]]]]][[2]])/2-
                      Transpose[
                          Transpose[
                              dritens[[3]]][[{11,12}]]][[elementNumber[[j,
                                i]][[2]]]])^2]^.5];
        voronoiLengthII=
          voronoiLengthFunctionII/@Range[Length[elementNumber[[j]]]];
        Return[voronoiLengthII]
        ];
    voronoiLength=voronoiLengthFunction/@Range[Length[elementNumber]];
    
    stromFunction[k_]:=
      Module[{conzDifferenceFunction,conzDifference,conzTimesSij,
          gradientFunction,gradientsI,strom},
        
        conzDifferenceFunction[i_]:=
          Module[{conzDifferenceTwoFunction,conzDifferenceTwo},
            
            conzDifferenceTwoFunction[j_]:=
              k[[nodeAndNeighbour[[i,j,2]]]]-
                k[[nodeAndNeighbour[[i,j,
                        1]]]];(*gibt die Konzentrationsdifferenz  i=
                Hauptpunkt, j=Hauptpunkt und ein Nachbar*)
            
            conzDifferenceTwo=
              conzDifferenceTwoFunction/@Range[Length[nodeAndNeighbour[[i]]]]
            ];
        conzDifference=
          conzDifferenceFunction/@Range[Length[nodeAndNeighbour]];
        
        
        conzTimesSij=conzDifference*voronoiLength;
        
        gradientFunction[i_]:=
          Module[{gradientToOneNode,gradientToOneNodeFunction},
            
            gradientToOneNodeFunction[j_]:=
              
              If[allCoordinates[[i,j]]=!=0.,
                conzTimesSij[[i,j]]/allCoordinates[[i,j]],0.];
            
            (* 
              geteilt durch allCoordinates beachtet die Normalenrichtung !!! *)
\
            
            
            gradientToOneNode=
              Apply[Plus,
                gradientToOneNodeFunction/@
                  Range[Length[nodeAndNeighbour[[i]]]]]
            ];
        gradientsI=
          gradientFunction/@
            Range[Length[
                nodeAndNeighbour]];(*gibt den Gradienten zum Punkt in der \
Normalenrichtung*)
        
        strom=Apply[Plus,gradientsI];
        
        Return[strom]
        ];
    
    currentWithoutDifCoef=stromFunction/@concDistribution;
    
    Return[currentWithoutDifCoef];
    ]








ReadAnsysNodes[ansisNodesFilename_]:=Block[
      {readTetgenFormat,tetgenNode,nodefile},
      
      (********* 
            the nodefile generated by tetgen is read *************)
      
      anNodefile=OpenRead[ansisNodesFilename];
      (**  The filename is given as a variable **)
      
      nodefile=ReadList[anNodefile,{Number,Real,Real,Real}];
      
      Close[anNodefile];
      
      appendFunkt[x_]:=Append[x,0];
      nodefile=appendFunkt/@nodefile;
      Return[nodefile]
      ];




ReadAnsysElements[ansisElementFilename_]:=Block[
      {anElementfile,anelefile},
      
      
      (********* 
            the elementfile generated by Ansis is read *************)
      
      anElementfile=OpenRead[ansisElementFilename];
      (**  The filename is given as a variable **)
      
      
      anelefile=
        ReadList[
          anElementfile,{Number,Number,Number,Number,Number,Number,Number,
            Number,Number,Number,Number,Number,Number,Number}];
      (** 
          the lines with the elementdata are red (exclusive the last \
commentline) **)
      
      Close[anElementfile];
      
      anelefile=anelefile[[All,{1,7,8,9,11,2}]];
      
      Return[anelefile]
      ];







ReadAnsysNodefile[ansisNodeFilename_]:=Block[
      {readTetgenFormat,tetgenNode,nodefile},
      
      (********* 
            the nodefile generated by tetgen is read *************)
      
      anNodefile=OpenRead[ansisNodeFilename];
      (**  The filename is given as a variable **)
      
      nodefile=ReadList[anNodefile,{Real,Real,Real,Real,Real,Real,Real}];
      
      Close[anNodefile];
      
      appendFunkt[x_]:=Append[x,0];
      nodefile=appendFunkt/@nodefile;
      nodefile[[All,{1,5}]]=Round[nodefile[[All,{1,5}]]];
      Return[nodefile[[All,{1,2,3,4,5}]]]
      ];




ReadAnsisElementFile[ansisElementFilename_]:=Block[
      {anElementfile,anelefile},
      
      
      (********* 
            the elementfile generated by Ansis is read *************)
      
      anElementfile=OpenRead[ansisElementFilename];
      (**  The filename is given as a variable **)
      
      
      anelefile=
        ReadList[
          anElementfile,{Number,Number,Number,Number,Number,Number,Number,
            Number,Number}];
      (** 
          the lines with the elementdata are red (exclusive the last \
commentline) **)
      
      Close[anElementfile];
      
      anelefile=Round[anelefile[[All,{1,2,3,4,6,2}]]];
      
      Return[anelefile]
      ];



AnsysElementGeometryFunction3D[
      ansisdata:{nodeList:{({_Integer,_Real,_Real,_Real,_Integer})..},
          
          elementList:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..}}]:=
    
    Module[{nodeData,ElementGeometryFunction,listOfGeometries},
      
      
      nodeData=ansisdata[[1]];
      ElementGeometryFunction[l_]:=
        Module[{nodenumbers,elementCoordinates,lengthOfEdges,edgeMidPoints,
            ElementVoronoiFunction,elementGeometryData,ElementVoronoiNodes},
          
          nodenumbers=ansisdata[[2,l,{2,3,4,5}]];
          
          elementCoordinates=
            nodeData[[ansisdata[[2,l]][[{2,3,4,5}]],{2,3,4}]];
          
          
          lengthOfEdges=
            {Apply[
                  Plus,(elementCoordinates[[1]]-
                        elementCoordinates[[2]])^2]^.5,
              
              Apply[Plus,(elementCoordinates[[1]]-
                        elementCoordinates[[3]])^2]^.5,
              
              Apply[Plus,(elementCoordinates[[1]]-
                        elementCoordinates[[4]])^2]^.5,
              
              Apply[Plus,(elementCoordinates[[2]]-
                        elementCoordinates[[3]])^2]^.5,
              
              Apply[Plus,(elementCoordinates[[2]]-
                        elementCoordinates[[4]])^2]^.5,
              
              Apply[Plus,(elementCoordinates[[3]]-
                        elementCoordinates[[4]])^2]^.5};
          
          edgeMidPoints=
            {(elementCoordinates[[1]]+elementCoordinates[[2]])/2,
              (elementCoordinates[[1]]+elementCoordinates[[3]])/2,
              (elementCoordinates[[1]]+elementCoordinates[[4]])/2,
              (elementCoordinates[[2]]+elementCoordinates[[3]])/2,
              (elementCoordinates[[2]]+elementCoordinates[[4]])/2,
              (elementCoordinates[[3]]+elementCoordinates[[4]])/2};
          
          
          ElementVoronoiFunction[elementCoordinates_]:=
            Module[{TriangleVoronoiPointFunction,
                TriangleVoronoiPointAndNormal,TriangleVoronoiPoint,
                crosspointElement,voronoiElementPoint},
              
              TriangleVoronoiPointFunction[i_] := 
                
                Module[{triangleMatrix,planeNormal1,normVect1,normal1,
                    normVect2,normal2,midpoint1,midpoint2,voronoiShort,t},
                  
                  triangleMatrix=i;
                  
                  (*normal gives the normal vectors of two of the triangle \
sides*)
                  
                  
                  planeNormal1=
                    CrossProduct[(triangleMatrix[[2]]-
                          triangleMatrix[[1]]),(triangleMatrix[[3]]-
                          triangleMatrix[[1]])];
                  
                  
                  normVect1=
                    CrossProduct[
                      planeNormal1,(triangleMatrix[[2]]-
                          triangleMatrix[[1]])];
                  normal1=normVect1/(Apply[Plus,normVect1^2]^.5);
                  
                  normVect2=
                    CrossProduct[
                      CrossProduct[(triangleMatrix[[2]]-
                            triangleMatrix[[1]]),(triangleMatrix[[3]]-
                            triangleMatrix[[1]])],(triangleMatrix[[3]]-
                          triangleMatrix[[1]])];
                  normal2=normVect2/(Apply[Plus,normVect2^2]^.5);
                  
                  midpoint1=(triangleMatrix[[1]]+triangleMatrix[[2]])/2;
                  midpoint2=(triangleMatrix[[1]]+triangleMatrix[[3]])/2;
                  
                  (*  
                    It is impossible to solve the eqation to find the \
crosspoint between two lines which are build by the normals on two triangle \
sides through the midpoints of this sides because of the nummerical error the \
straits are often not in one plane. This function calculates the point, 
                    where the straits have the smalest distance. (n11 means \
the first element of the first normal vector, 
                          m11 means the first element of the midpoint of the \
first triangle edge, etc. ) The whole calculation is the following: 
                        D[Plus@@({{m11+n11*t-m21-n21*k},{m12+n12*t-m22-
                                      n22*k},{m13+n13*t-m23-n23*k}}^2),k];
                    
                    D[Plus@@({{m11+n11*t-m21-n21*k},{m12+n12*t-m22-
                                  n22*k},{m13+n13*t-m23-n23*k}}^2),t];
                    
                    FullSimplify[
                      Solve[{{-2 n21 (m11-m21-k n21+n11 t)-2 n22 (m12-m22-
                                      k n22+n12 t)-2 n23 (m13-m23-k n23+
                                      n13 t)}\[Equal]0,{2 n11 (m11-m21-k n21+
                                      n11 t)+2 n12 (m12-m22-k n22+
                                      n12 t)+2 n13 (m13-m23-k n23+
                                      n13 t)}\[Equal]0},{k,t}]]; *); 
                  
                  
                  voronoiShort=
                    normal1*t+(triangleMatrix[[1]]+triangleMatrix[[2]])/
                          2/.t\[Rule]-(4 (midpoint1[[1]]normal2[[1]]-
                                      midpoint2[[1]] normal2[[1]]+
                                      midpoint1[[2]] normal2[[2]]-
                                      midpoint2[[2 ]]normal2[[2]]+
                                      midpoint1[[3]] normal2[[3]]-
                                      midpoint2[[3]] normal2[[3]]) \
(normal1[[1]] normal2[[1]]+normal1[[2]] normal2[[2]]+
                                      normal1[[3]] normal2[[3]])-4 \
(midpoint1[[1]] normal1[[1]]-midpoint2[[1]] normal1[[1]]+
                                      midpoint1[[2]] normal1[[2]]-
                                      midpoint2[[2]] normal1[[2]]+
                                      midpoint1[[3 ]]normal1[[3]]-
                                      midpoint2[[3]] normal1[[3]]) \
(normal2[[1]]^2+normal2[[2]]^2+normal2[[3]]^2))/(4 (normal1[[1]] normal2[[1]]+
                                      normal1[[2]] normal2[[2]]+
                                      normal1[[3]] normal2[[3]])^2-4 \
(normal1[[1]]^2+normal1[[2]]^2+normal1[[3]]^2) (normal2[[1]]^2+normal2[[2]]^2+
                                    normal2[[3]]^2));
                  
                  Return[{planeNormal1,voronoiShort}]
                  ];
              
              (***************************  
                    The triangle Voronoi Function is called  ******************************)

                            
              TriangleVoronoiPointAndNormal=
                TriangleVoronoiPointFunction/@{elementCoordinates[[{1,2,3}]],
                    elementCoordinates[[{1,2,4}]],
                    elementCoordinates[[{1,3,4}]],
                    elementCoordinates[[{2,3,4}]]};
              
              (***************************    
                    The Tetrahedron Voronoi node is calculeted     ******************************)
\
              
              TriangleVoronoiPoint=TriangleVoronoiPointAndNormal[[All,2]];
              
              
              crosspointElement=
                t\[Rule]-(4 (TriangleVoronoiPointAndNormal[[1,
                                        2]][[1]] \
TriangleVoronoiPointAndNormal[[2,1]][[1]]-
                                TriangleVoronoiPointAndNormal[[2,
                                        2]][[1]] \
TriangleVoronoiPointAndNormal[[2,1]][[1]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        2]][[2]] \
TriangleVoronoiPointAndNormal[[2,1]][[2]]-
                                TriangleVoronoiPointAndNormal[[2,
                                        
                                        2]][[2]] \
TriangleVoronoiPointAndNormal[[2,1]][[2]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        2]][[3]] \
TriangleVoronoiPointAndNormal[[2,1]][[3]]-
                                TriangleVoronoiPointAndNormal[[2,
                                        2]][[3]] \
TriangleVoronoiPointAndNormal[[2,1]][[3]]) (TriangleVoronoiPointAndNormal[[1,
                                        1]][[1]] \
TriangleVoronoiPointAndNormal[[2,1]][[1]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        1]][[2]] \
TriangleVoronoiPointAndNormal[[2,1]][[2]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        1]][[3]] \
TriangleVoronoiPointAndNormal[[2,
                                        1]][[3]])-4 \
(TriangleVoronoiPointAndNormal[[1,2]][[1]] TriangleVoronoiPointAndNormal[[1,
                                        1]][[1]]-
                                TriangleVoronoiPointAndNormal[[2,
                                        2]][[1]] \
TriangleVoronoiPointAndNormal[[1,1]][[1]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        2]][[2]] \
TriangleVoronoiPointAndNormal[[1,1]][[2]]-
                                TriangleVoronoiPointAndNormal[[2,
                                        2]][[2]] \
TriangleVoronoiPointAndNormal[[1,1]][[2]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        2]][[3]] \
TriangleVoronoiPointAndNormal[[1,1]][[3]]-
                                TriangleVoronoiPointAndNormal[[2,
                                        2]][[3]] \
TriangleVoronoiPointAndNormal[[1,1]][[3]]) (TriangleVoronoiPointAndNormal[[2,
                                        1]][[1]]^2+
                                TriangleVoronoiPointAndNormal[[2,1]][[2]]^2+
                                TriangleVoronoiPointAndNormal[[2,
                                        1]][[3]]^2))/(4 \
(TriangleVoronoiPointAndNormal[[1,1]][[1]] TriangleVoronoiPointAndNormal[[2,
                                        1]][[1]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        1]][[2]] \
TriangleVoronoiPointAndNormal[[2,1]][[2]]+
                                TriangleVoronoiPointAndNormal[[1,
                                        1]][[3]] \
TriangleVoronoiPointAndNormal[[2,
                                        1]][[3]])^2-4 \
(TriangleVoronoiPointAndNormal[[1,1]][[1]]^2+
                              TriangleVoronoiPointAndNormal[[1,1]][[2]]^2+
                              TriangleVoronoiPointAndNormal[[1,
                                      1]][[3]]^2) \
(TriangleVoronoiPointAndNormal[[2,1]][[1]]^2+
                              TriangleVoronoiPointAndNormal[[2,1]][[2]]^2+
                              TriangleVoronoiPointAndNormal[[2,1]][[3]]^2));
              
              voronoiElementPoint=
                TriangleVoronoiPointAndNormal[[1,1]]*t+
                    TriangleVoronoiPointAndNormal[[1,2]]/.crosspointElement;
              
              Return[{voronoiElementPoint,TriangleVoronoiPoint}]
              ];
          
          ElementVoronoiNodes=ElementVoronoiFunction[elementCoordinates];
          
          (* The node numbers of the edge, 
            the length of the edge and the voronoi edge areas in the order: \
{1,2};{1,3};{1,4};{2,3};{2,4};{3,4};  *)
          
          elementGeometryData={{nodenumbers[[{1,2}]],
                lengthOfEdges[[1]],((Apply[
                              Plus,(ElementVoronoiNodes[[1]]-
                                    ElementVoronoiNodes[[2,1]])^2]^.5)*(Apply[
                              Plus,(edgeMidPoints[[1]]-
                                    ElementVoronoiNodes[[2,
                                        1]])^2]^.5)+((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        2]])^2]^.5)*(Apply[
                                Plus,(edgeMidPoints[[1]]-
                                      ElementVoronoiNodes[[2,2]])^2])^.5))/
                  2},
              {nodenumbers[[{1,3}]],
                lengthOfEdges[[2]],(((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        1]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[2]]-
                                      ElementVoronoiNodes[[2,
                                        1]])^2])^.5)+((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        3]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[2]]-
                                      ElementVoronoiNodes[[2,3]])^2])^.5))/
                  2},
              {nodenumbers[[{1,4}]],
                lengthOfEdges[[3]],((Apply[
                              Plus,(ElementVoronoiNodes[[1]]-
                                    ElementVoronoiNodes[[2,3]])^2]^.5)*(Apply[
                              Plus,(edgeMidPoints[[3]]-
                                    ElementVoronoiNodes[[2,3]])^2]^.5)+(Apply[
                              Plus,(ElementVoronoiNodes[[1]]-
                                    ElementVoronoiNodes[[2,2]])^2]^.5)*(Apply[
                              Plus,(edgeMidPoints[[3]]-
                                    ElementVoronoiNodes[[2,2]])^2]^.5))/2},
              {nodenumbers[[{2,3}]],
                lengthOfEdges[[4]],(((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        1]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[4]]-
                                      ElementVoronoiNodes[[2,1]])^2])^.5)
                      +((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        4]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[4]]-
                                      ElementVoronoiNodes[[2,4]])^2])^.5))/
                  2},
              {nodenumbers[[{2,4}]],
                lengthOfEdges[[5]],(((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        4]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[5]]-
                                      ElementVoronoiNodes[[2,4]])^2])^.5)
                      +((Apply[Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        2]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[5]]-
                                      ElementVoronoiNodes[[2,2]])^2])^.5))/
                  2},
              {nodenumbers[[{3,4}]],
                lengthOfEdges[[6]],(((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        3]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[6]]-
                                      ElementVoronoiNodes[[2,3]])^2])^.5)
                      +((Apply[
                                Plus,(ElementVoronoiNodes[[1]]-
                                      ElementVoronoiNodes[[2,
                                        4]])^2])^.5*(Apply[
                                Plus,(edgeMidPoints[[6]]-
                                      ElementVoronoiNodes[[2,4]])^2])^.5))/2},
              ElementVoronoiNodes[[1]]};
          
          (*  returns for each edge of a tetrahedron the node numbers, 
            the length of the edge, 
            the area of the voronoi box  and the element-voronoi-
              node *)
          
          Return[elementGeometryData];
          
          ];
      listOfGeometries=
        ElementGeometryFunction/@Range[Length[ansisdata[[2]]]];
      
      Return[listOfGeometries]
      
      ];



GeometryTestForVoronoi3D[
    meshdata:{{{_Integer,_Real,_Real,_Real,_Integer}..},{{_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer}..}},
    geometryData:{({({{_Integer,_Integer},_Real,_Real})..,{_Real,_Real,_Real}}\
)..}]:=Module[{PointInTetrahedronFunction,isOrNotList,isOrnotFunction},
    
    
    PointInTetrahedronFunction[{V1:{x1_,y1_,z1_},V2:{x2_,y2_,z2_},
          V3:{x3_,y3_,z3_},V4:{x4_,y4_,z4_},P:{x_,y_,z_}}]:=
      
      Module[{D0,D1,D2,D3,D4,s1,s2,s3,s4,isDelaunay,vergleich,
          punktLiegtAufSeite,volumeOfTetrahedron},
        
        D0=Det[{{x1,y1,z1,1},{x2,y2,z2,1},{x3,y3,z3,1},{x4,y4,z4,1}}];
        D1=Det[{{x,y,z,1},{x2,y2,z2,1},{x3,y3,z3,1},{x4,y4,z4,1}}];
        D2=Det[{{x1,y1,z1,1},{x,y,z,1},{x3,y3,z3,1},{x4,y4,z4,1}}];
        D3=Det[{{x1,y1,z1,1},{x2,y2,z2,1},{x,y,z,1},{x4,y4,z4,1}}];
        D4=Det[{{x1,y1,z1,1},{x2,y2,z2,1},{x3,y3,z3,1},{x,y,z,1}}];
        
        vergleich[a_,b_]:=0/;(-10^-14< b< 10^-14);
        vergleich[a_,b_]:=1/;(a*b)>0;
        vergleich[a_,b_]:=-1/;(a*b)<0;
        
        s1=vergleich[D0,D1];
        s2=vergleich[D0,D2];
        s3=vergleich[D0,D3];
        s4=vergleich[D0,D4];
        
        isDelaunay=FreeQ[{s1,s2,s3,s4},-1];
        
        volumeOfTetrahedron=D0/6;
        
        punktLiegtAufSeite=Flatten[Position[{s1,s2,s3,s4},0]];
        (*wenn zwei Seiten ausgegeben werden, 
          dann liegt der Punkt auf der Kante
          *)
        
        Return[{volumeOfTetrahedron,isDelaunay,punktLiegtAufSeite}]
        ];
    
    isOrnotFunction[elementNr_]:=Module[{elementNodes,isOrNot},
        elementNodes=
          Append[meshdata[[1,meshdata[[2,elementNr,{2,3,4,5}]]]][[All,{2,3,
                  4}]],geometryData[[elementNr,-1]]];
        isOrNot=PointInTetrahedronFunction[elementNodes][[2]]; 
        Return[isOrNot]
        ];
    isOrNotList=isOrnotFunction/@Range[Length[geometryData]];
    numberOfNotVoronoiEle=Count[isOrNotList,False];
    NumberOfElements=Length[geometryData];
    Return[{ToString[numberOfNotVoronoiEle]<>" of "<>
          ToString[ NumberOfElements]<> 
          " elements, are not Voronoi elements"}]
    ]



AnsysEquationSystemSteadyState3D[
      listOfGeometries:{({({{_Integer,_Integer},_Real,_Real})..,{_Real,_Real,_\
Real}})..},
      tetgenData:{{{_Integer,_Real,_Real,_Real,_Integer}..},{{_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer}..}},
      
      Dif:{(_Real|_Integer)..},
      electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
                butvolmHin:_Real|_Power |_Symbol, 
                butvolmRueck :_Real|_Power |_Symbol  })..},
      dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_\
Real|_Integer}})..},
      initialConcentrations:{(_Real|_Integer)..}
      ]:=
    
    Module[{elementAssembleFunction,numberOfNodes,rightHandSideVector,
        nodeMarcs,electrodeReactionsFunktion,elektrodenVariablenFunktion,
        elektrodenVariablen,electrodeReaction,aIndices,
        dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
        allDirichletNodes,dirichletLinesFunktion,dirichletLines,
        dirichletEliminationFunktion,diagonDirichl,
        dirichletRHSVariableFunction,dirichletRHSVariable,
        dirichletRHSFunction,concentrationFunction,diricFunction,
        sparseStiffnessMatrix,a,allNodePairs,nodesPerElement,
        nodepairsForEverySpezies,sparseInitialisation,
        sparseDiagonalInitialisation,vectorOfConcentrations},
      
      diffcoef=Dif;
      numberOfNodes=tetgenData[[1,-1,1]];
      (******************** 
          Start sparse matrix initialization *********************)
      (** 
            this part produces all a[i,j]=
          0 which apeares in the final sparse matrix **)
      
      nodesPerElement=tetgenData[[2]][[All,{2,3,4,5}]];
      nodepairsForEverySpezies[spez_]:=
        Module[{nodePairsPerElement,nodePairs},
          
          nodePairsPerElement[
              i_]:={{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]}};
          
          nodePairs=nodePairsPerElement/@Range[Length[nodesPerElement]];
          Return[nodePairs];
          ];
      allNodePairs=nodepairsForEverySpezies/@Range[Length[diffcoef]];
      sparseInitialisation[i_]:=a[i[[1]],i[[2]]]=a[i[[2]],i[[1]]]=0;
      
      sparseInitialisation/@Union[Flatten[allNodePairs,2]];
      
      sparseDiagonalInitialisation[i_]:=a[i,i]=0;
      sparseDiagonalInitialisation/@
        Range[Length[tetgenData[[1]]]*Length[diffcoef]];
      
      
      (******************** 
          end sparse matrix initialization *********************)
      
      (******************** 
          Start AssembleFunction *********************)
      
      (*  
        the input for elementAssembleFunction is the list of geometries for \
one element, 
        the list of all diffusion coeficients and the number of nodes  *)
    \
  
      elementAssembleFunction[listOfGeom_,diffcoef_,numberOfNodes_]:=
        Module[{assembleFunction,i,voro1,voro2,voro3,voro4,voro5,voro6},
          (*this rows calculate the area of the voronoi box edge A[i,
                  j] over the distance between two points \[CapitalDelta][i,
                  j]: A[i,j]/\[CapitalDelta][i,j] *)
          i=listOfGeom;
          voro1=i[[1,3]]/i[[1,2]];
          voro2=i[[2,3]]/i[[2,2]];
          voro3=i[[3,3]]/i[[3,2]];
          voro4=i[[4,3]]/i[[4,2]];
          voro5=i[[5,3]]/i[[5,2]];
          voro6=i[[6,3]]/i[[6,2]];
          
          assembleFunction[spezNumber_]:=
            Module[{diffcoefOfSpez,multiSpez,voroDif1,voroDif2,voroDif3,
                voroDif4,voroDif5,voroDif6},
              
              diffcoefOfSpez=diffcoef[[spezNumber]];
              multiSpez=(spezNumber-1)*numberOfNodes;
              
              voroDif1=diffcoefOfSpez*voro1;
              
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,2]]]=
                a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,1]]]+=(-voroDif1);
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,1]]]+=voroDif1;
              a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,2]]]+=voroDif1;
              
              voroDif2=diffcoefOfSpez*voro2;
              
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,2]]]=
                a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,1]]]+=(-voroDif2);
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,1]]]+=voroDif2;
              a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,2]]]+=voroDif2;
              
              
              voroDif3=diffcoefOfSpez*voro3;
              
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,2]]]=
                a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,1]]]+=(-voroDif3);
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,1]]]+=voroDif3;
              a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,2]]]+=voroDif3;
              
              voroDif4=diffcoefOfSpez*voro4;
              
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,2]]]=
                a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,1]]]+=(-voroDif4);
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,1]]]+=voroDif4;
              a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,2]]]+=voroDif4;
              
              voroDif5=diffcoefOfSpez*voro5;
              
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,2]]]=
                a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,1]]]+=(-voroDif5);
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,1]]]+=voroDif5;
              a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,2]]]+=voroDif5;
              
              voroDif6=diffcoefOfSpez*voro6;
              
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,2]]]=
                a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,1]]]+=(-voroDif6);
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,1]]]+=voroDif6;
              a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,2]]]+=voroDif6;
              
              
              
              ];
          assembleFunction/@Range[Length[diffcoef]];
          ];
      
      
      Outer[elementAssembleFunction,
        listOfGeometries,{diffcoef},{numberOfNodes},1,1,1];
      
      (******************** 
          End AssembleFunction *********************)
      
      
      (******************** 
          Start rightHandSideVector *********************)
      
      rightHandSideVector=Table[0,{Length[diffcoef]*numberOfNodes}];
      
      vectorOfConcentrations=Table[0,{Length[diffcoef]*numberOfNodes}];
      
      (******************** End rightHandSideVector *********************)
   
         nodeMarcs=tetgenData[[1,All,5]];
      (******************** 
          Start of electrode reactions *********************)
      
      
      electrodeReactionsFunktion[i_,j_]:=
        
        If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
          
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
            electrodeReactionValues[[j,4]];
          
          
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]=-(electrodeReactionValues[[j,5]]);
          
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[1,3]]]])*
              electrodeReactionValues[[j,5]];
          
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[j,
                          3]]]])*-electrodeReactionValues[[j,4]];
          ];
      elektrodenVariablenFunktion[i_]:=
        Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
      elektrodenVariablen=
        Flatten[
          elektrodenVariablenFunktion/@Range[Length[electrodeReactionValues]],
          3];
      (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
      
      electrodeReaction=
        Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
      (******************** 
          End of electrode reactions *********************)
      
      (************************ Start Dirichlet **************************)
  
          aIndices=Level[#1,{2}]&@@@DownValues[a];
      
      dirichletBcNodesFunktion[i_]:=
        Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
      dirichletBcNodes=
        dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
      
      
      allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+
          dirichletBcNodes;
      allDirichletNodes=
        Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
      
      dirichletLinesFunktion[i_]:=
        Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
      dirichletLines=
        Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
      dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
      Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
      diagonDirichl[i_]:=a[i,i]=1;
      diagonDirichl/@Transpose[dirichletLines][[1]];           
      
      
      dirichletRHSVariableFunction[i_]:=
        Transpose[{Flatten[dirichletBcNodes],
            Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
      dirichletRHSVariable=
        Flatten[dirichletRHSVariableFunction/@
            Range[Length[initialConcentrations]],1];
      
      dirichletRHSFunction[i_,j_]:=
        rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=
          initialConcentrations[[j]];
      Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
      
      
      concentrationFunction[k_]:=Module[{diricFunction},
          
          diricFunction[i_,j_]:=
            vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                      Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
          Apply[diricFunction,#]&/@
            Transpose[{Flatten[
                  Transpose[
                    Table[Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,1]]]],{Length[
                          Flatten[
                            dirichletBoundaries[[k,2,
                                Range[
                                  Length[
                                    dirichletBoundaries[[k,
                                        2]]]]]]]]}]]](*das gibt die \
Nodenumbers*),Flatten[
                  Table[dirichletBoundaries[[k,2,
                        Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                        Flatten[
                          Position[nodeMarcs,
                            dirichletBoundaries[[k,
                                1]]]]]}]](*das gibt die Spezies*)}];];
      
      concentrationFunction/@Range[Length[dirichletBoundaries]];
      (******************** End of Dirichlet *********************)     
      
      sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
      
      Return[{sparseStiffnessMatrix,vectorOfConcentrations}]
      
      ];



AnsysEquationSystemTrans3D[
      listOfGeometries:{({({{_Integer,_Integer},_Real,_Real})..,{_Real,_Real,_\
Real}})..},
      tetgenData:{{{_Integer,_Real,_Real,_Real,_Integer}..},{{_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer}..}},
      Dif:{(_Real|_Integer)..},
      electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
                butvolmHin:_Real|_Power |_Symbol, 
                butvolmRueck :_Real|_Power |_Symbol  })..},
      dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_\
Real|_Integer}})..},
      initialConcentrations:{(_Real|_Integer)..},
      timeStep:(_Real|_Integer)]:=
    
    Module[{elementAssembleFunction,numberOfNodes,rightHandSideVector,
        nodeMarcs,electrodeReactionsFunktion,elektrodenVariablenFunktion,
        elektrodenVariablen,electrodeReaction,aIndices,
        dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
        allDirichletNodes,dirichletLinesFunktion,dirichletLines,
        dirichletEliminationFunktion,diagonDirichl,
        dirichletRHSVariableFunction,dirichletRHSVariable,
        dirichletRHSFunction,concentrationFunction,diricFunction,
        sparseStiffnessMatrix,vectorOfConcentrationsFunction,
        vectorOfConcentrations,a},
      
      diffcoef=Dif;
      numberOfNodes=tetgenData[[1,-1,1]];
      
      vectorOfConcentrationsFunction[i_]:=
        Table[initialConcentrations[[i]],{numberOfNodes}];
      vectorOfConcentrations=
        Flatten[vectorOfConcentrationsFunction/@
            Range[Length[initialConcentrations]]];
      
      (******************** 
          Start sparse matrix initialization *********************)
      (** 
            this part produces all a[i,j]=
          0 which apeares in the final sparse matrix **)
      
      
      nodesPerElement=tetgenData[[2]][[All,{2,3,4,5}]];
      nodepairsForEverySpezies[spez_]:=
        Module[{nodePairsPerElement,nodePairs},
          
          nodePairsPerElement[
              i_]:={{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]}};
          
          nodePairs=nodePairsPerElement/@Range[Length[nodesPerElement]];
          Return[nodePairs];
          ];
      allNodePairs=nodepairsForEverySpezies/@Range[Length[diffcoef]];
      sparseInitialisation[i_]:=a[i[[1]],i[[2]]]=a[i[[2]],i[[1]]]=0;
      
      sparseInitialisation/@Union[Flatten[allNodePairs,2]];
      
      sparseDiagonalInitialisation[i_]:=a[i,i]=0;
      sparseDiagonalInitialisation/@
        Range[Length[tetgenData[[1]]]*Length[diffcoef]];
      
      
      (******************** 
          end sparse matrix initialization *********************)
      
      (******************** 
          Start AssembleFunction *********************)
      
      (*  
        the input for elementAssembleFunction is the list of geometries for \
one element, 
        the list of all diffusion coeficients and the number of nodes  *)
    \
  
      (******************** 
          Start rightHandSideVector *********************)
      
      rightHandSideVector=Table[0,{Length[diffcoef]*numberOfNodes}];
      
      (******************** 
          End rightHandSideVector *********************)
      
      elementAssembleFunction[listOfGeom_,diffcoef_,numberOfNodes_]:=Module[
          {assembleFunction,i,voro1,voro2,voro3,voro4,voro5,voro6,volume1,
            volume2,volume3,volume4,volume5,volume6},
          (*this rows calculate the area of the voronoi box edge A[i,
                  j] over the distance between two points \[CapitalDelta][i,
                  j]: A[i,j]/\[CapitalDelta][i,j] *)
          
          i=listOfGeom;
          voro1=i[[1,3]]/i[[1,2]];
          voro2=i[[2,3]]/i[[2,2]];
          voro3=i[[3,3]]/i[[3,2]];
          voro4=i[[4,3]]/i[[4,2]];
          voro5=i[[5,3]]/i[[5,2]];
          voro6=i[[6,3]]/i[[6,2]];
          
          (*this lines calculate the volume of the voronoi box of one \
element, between each node pair ij*)
          volume1=i[[1,3]]*i[[1,2]]/6;
          volume2=i[[2,3]]*i[[2,2]]/6;
          volume3=i[[3,3]]*i[[3,2]]/6;
          volume4=i[[4,3]]*i[[4,2]]/6;
          volume5=i[[5,3]]*i[[5,2]]/6;
          volume6=i[[6,3]]*i[[6,2]]/6;
          
          assembleFunction[spezNumber_]:=Module[
              {diffcoefOfSpez,multiSpez,voroDif1,voroDif2,voroDif3,voroDif4,
                voroDif5,voroDif6},
              
              diffcoefOfSpez=diffcoef[[spezNumber]];
              multiSpez=(spezNumber-1)*numberOfNodes;
              
              voroDif1=diffcoefOfSpez*voro1;
              
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,2]]]=
                a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,1]]]+=(-voroDif1);
              
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,1]]]+=
                voroDif1+volume1/timeStep;
              
              a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,2]]]+=
                voroDif1+volume1/timeStep;
              rightHandSideVector[[multiSpez+i[[1,1,1]]]]+=volume1/timeStep;
              rightHandSideVector[[multiSpez+i[[1,1,2]]]]+=volume1/timeStep;
              
              voroDif2=diffcoefOfSpez*voro2;
              
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,2]]]=
                a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,1]]]+=(-voroDif2);
              
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,1]]]+=
                voroDif2+volume2/timeStep;
              
              a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,2]]]+=
                voroDif2+volume2/timeStep;
              rightHandSideVector[[multiSpez+i[[2,1,1]]]]+=volume2/timeStep;
              rightHandSideVector[[multiSpez+i[[2,1,2]]]]+=volume2/timeStep;
              
              voroDif3=diffcoefOfSpez*voro3;
              
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,2]]]=
                a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,1]]]+=(-voroDif3);
              
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,1]]]+=
                voroDif3+volume3/timeStep;
              
              a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,2]]]+=
                voroDif3+volume3/timeStep;
              rightHandSideVector[[multiSpez+i[[3,1,1]]]]+=volume3/timeStep;
              rightHandSideVector[[multiSpez+i[[3,1,2]]]]+=volume3/timeStep;
              
              
              voroDif4=diffcoefOfSpez*voro4;
              
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,2]]]=
                a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,1]]]+=(-voroDif4);
              
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,1]]]+=
                voroDif4+volume4/timeStep;
              
              a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,2]]]+=
                voroDif4+volume4/timeStep;
              rightHandSideVector[[multiSpez+i[[4,1,1]]]]+=volume4/timeStep;
              rightHandSideVector[[multiSpez+i[[4,1,2]]]]+=volume4/timeStep;
              
              
              voroDif5=diffcoefOfSpez*voro5;
              
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,2]]]=
                a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,1]]]+=(-voroDif5);
              
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,1]]]+=
                voroDif5+volume5/timeStep;
              
              a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,2]]]+=
                voroDif5+volume5/timeStep;
              rightHandSideVector[[multiSpez+i[[5,1,1]]]]+=volume5/timeStep;
              rightHandSideVector[[multiSpez+i[[5,1,2]]]]+=volume5/timeStep;
              
              
              voroDif6=diffcoefOfSpez*voro6;
              
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,2]]]=
                a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,1]]]+=(-voroDif6);
              
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,1]]]+=
                voroDif6+volume6/timeStep;
              
              a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,2]]]+=
                voroDif6+volume6/timeStep;
              rightHandSideVector[[multiSpez+i[[6,1,1]]]]+=volume6/timeStep;
              rightHandSideVector[[multiSpez+i[[6,1,2]]]]+=volume6/timeStep;
              
              
              
              ];
          assembleFunction/@Range[Length[diffcoef]];
          ];
      
      
      Outer[elementAssembleFunction,
        listOfGeometries,{diffcoef},{numberOfNodes},1,1,1];
      
      vectorOfVolumes=
        rightHandSideVector*
          timeStep;(*vectorOfVolumes is needed for model order reduction (C-
              vector)*)
      
      (******************** 
          End AssembleFunction *********************)
      
      
      nodeMarcs=tetgenData[[1,All,5]];
      (******************** 
          Start of electrode reactions *********************)
      
      
      electrodeReactionsFunktion[i_,j_]:=
        
        If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
          
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
            electrodeReactionValues[[j,4]];
          
          
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]=-(electrodeReactionValues[[j,5]]);
          
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[1,3]]]])*
              electrodeReactionValues[[j,5]];
          
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[j,
                          3]]]])*-electrodeReactionValues[[j,4]];
          ];
      elektrodenVariablenFunktion[i_]:=
        Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
      elektrodenVariablen=
        Flatten[elektrodenVariablenFunktion/@
            Range[Length[electrodeReactionValues]],3];
      (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
      
      electrodeReaction=
        Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
      (******************** 
          End of electrode reactions *********************)
      
      (************************ Start Dirichlet **************************)
  
          aIndices=Level[#1,{2}]&@@@DownValues[a];
      
      dirichletBcNodesFunktion[i_]:=
        Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
      dirichletBcNodes=
        dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
      
      
      allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+
          dirichletBcNodes;
      allDirichletNodes=
        Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
      
      dirichletLinesFunktion[i_]:=
        Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
      dirichletLines=
        Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
      dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
      Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
      diagonDirichl[i_]:=a[i,i]=1;
      diagonDirichl/@Transpose[dirichletLines][[1]];           
      
      
      dirichletRHSVariableFunction[i_]:=
        Transpose[{Flatten[dirichletBcNodes],
            Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
      dirichletRHSVariable=
        Flatten[dirichletRHSVariableFunction/@
            Range[Length[initialConcentrations]],1];
      
      dirichletRHSFunction[i_,j_]:=
        rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=1;
      Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
      
      
      concentrationFunction[k_]:=Module[{diricFunction},
          
          diricFunction[i_,j_]:=
            vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                      Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
          Apply[diricFunction,#]&/@
            Transpose[{Flatten[
                  Transpose[
                    Table[Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,1]]]],{Length[
                          Flatten[
                            dirichletBoundaries[[k,2,
                                Range[
                                  Length[
                                    dirichletBoundaries[[k,
                                        2]]]]]]]]}]]](*das gibt die \
Nodenumbers*),Flatten[
                  Table[dirichletBoundaries[[k,2,
                        Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                        Flatten[
                          Position[nodeMarcs,
                            dirichletBoundaries[[k,
                                1]]]]]}]](*das gibt die Spezies*)}];];
      
      concentrationFunction/@Range[Length[dirichletBoundaries]];
      (******************** End of Dirichlet *********************)     
      
      sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
      
      Return[{sparseStiffnessMatrix,rightHandSideVector,
          vectorOfConcentrations,vectorOfVolumes}]
      
      ];



twoDEasymeshToThreeDFunction[easymeshData:{
          nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
          
          sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
          
          elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,\
_Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
      delta:(_Real|_Integer)
      ]:=Module[{ansisdata,elements3Doutput,element2DTo3D,nodes3Doutput,
        node2DTo3D},
      
      
      node2DTo3D[theNodes_List]:=Module[{m},m=Length[theNodes];
          
          Join[(Join[Drop[#,-1],{delta},Take[#,-1]]&/@
                theNodes),(Join[Take[#,1]+m,Drop[Drop[#,-1],1],{0.0},
                    Take[#,-1]]&/@theNodes)]];
      
      nodes3Doutput=node2DTo3D[nodeListvariable];
      
      element2DTo3D[theNodes_List,theElements_List]:=
        Module[{m,mm},m=Length[theNodes];
          mm=Length[theElements];
          
          Join[({#\[LeftDoubleBracket]1\[RightDoubleBracket],#\
\[LeftDoubleBracket]2\[RightDoubleBracket],#\[LeftDoubleBracket]3\
\[RightDoubleBracket],#\[LeftDoubleBracket]4\[RightDoubleBracket],#\
\[LeftDoubleBracket]3\[RightDoubleBracket]+
                      m,#\[LeftDoubleBracket]-1\[RightDoubleBracket]}&/@
                theElements),
            ({#\[LeftDoubleBracket]1\[RightDoubleBracket]+
                      mm,#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]3\[RightDoubleBracket]+
                      m,#\[LeftDoubleBracket]4\[RightDoubleBracket],#\
\[LeftDoubleBracket]2\[RightDoubleBracket]+
                      m,#\[LeftDoubleBracket]-1\[RightDoubleBracket]}&/@
                theElements),
            ({#\[LeftDoubleBracket]1\[RightDoubleBracket]+2mm,#\
\[LeftDoubleBracket]2\[RightDoubleBracket]+
                      m,#\[LeftDoubleBracket]3\[RightDoubleBracket]+
                      m,#\[LeftDoubleBracket]4\[RightDoubleBracket],#\
\[LeftDoubleBracket]4\[RightDoubleBracket]+
                      m,#\[LeftDoubleBracket]-1\[RightDoubleBracket]}&/@
                theElements)]];
      
      elements3Doutput=element2DTo3D[nodeListvariable,elementListvariable];
      
      ansisdata={nodes3Doutput,elements3Doutput};
      
      Return[ansisdata]
      ];




CurrentFunction3D[
      meshdata:{{{_Integer,_Real,_Real,_Real,_Integer}..},{{_Integer,_Integer,\
_Integer,_Integer,_Integer,_Integer}..}},
      electrode_Integer,
      listOfGeometries:{({({{_Integer,_Integer},_Real,_Real})..,{_Real,_Real,_\
Real}})..},
      concList:{{(_Real)..}..}]:=
    Module[{geometryofBoundaryNodesFunction,boundaryNodes,
        geometryofBoundaryNodes,geometryofBCNodes,assembleFunction,
        cutrrentPerTimestep},
      
      geometryofBoundaryNodesFunction[k_]:=
        Module[{positionofBCNodesFunction,positionofBCNodes,sortNodesFunction,
            nodePairsWithGeometryFunction,nodePairsWithGeometry,sortNodes},
          
          
          positionofBCNodesFunction[i_]:=
            Position[listOfGeometries[[All,All,1]],i][[All,{1,2}]];
          positionofBCNodes=positionofBCNodesFunction[k];
          
          nodePairsWithGeometryFunction[{i_,j_}]:=listOfGeometries[[i,j]];
          
          nodePairsWithGeometry=
            nodePairsWithGeometryFunction/@positionofBCNodes;
          
          
          sortNodesFunction[{{x_Integer,y_Integer},m_,l_}]:={{y,x},m,l}/;
              x=!=k;
          
          sortNodesFunction[{{x_Integer,y_Integer},m_,l_}]:={{x,y},m,l}/;
              x==k;
          
          sortNodes=sortNodesFunction/@nodePairsWithGeometry;
          
          Return[sortNodes]
          ];
      
      boundaryNodes=Flatten[Position[meshdata[[1,All,5]],electrode]];
      
      geometryofBoundaryNodes=
        Partition[Flatten[geometryofBoundaryNodesFunction/@boundaryNodes],4];
      
      geometryofBCNodes=geometryofBoundaryNodes;
      
      assembleFunction[concentrations_]:=
        Module[{gradientTimesAreaFunction,gradientTimesArea},
          
          gradientTimesAreaFunction[
              i_]:=
            (concentrations[[geometryofBCNodes[[i,2]]]]-
                  concentrations[[geometryofBCNodes[[i,1]]]])*
              geometryofBCNodes[[i,4]]/geometryofBCNodes[[i,3]];
          
          
          gradientTimesArea=
            gradientTimesAreaFunction/@Range[Length[geometryofBCNodes]];
          
          Return[Apply[Plus,gradientTimesArea]]
          ];
      cutrrentPerTimestep=assembleFunction/@concList;
      Return[cutrrentPerTimestep]
      ];













McDonaldGeometryFunction[
      ansysdataMc:{nodeList:{({_Integer,_Real,_Real,_Real,_Integer})..},
          
          elementList:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..}}]:=
    Module[{elementMcDonaldGeometryFunction,elementMcDonaldGeometry},
      
      
      elementMcDonaldGeometryFunction[element_]:=
        Module[{outPut,outPutFunction,volumeOfMcDonaldSubzells,
            volumeOfMcDonaldSubzellsFunction,normalVectors,mcDonaldSubareas,
            edgeVector,edgeVectorFunction,edgeLength,edgeLengthFunction,
            edgeCenters,edgeCentersFunction,massPointTriangle,
            massPointTriangleFunction,trianglesNodes,massPointTet,nodePairs,
            nodeNumbers,edgeNormalVectors,areaDotEdgeFunction,areaDotEdge,
            reducedAreas},
          
          nodeNumbers=ansysdataMc[[2,element,{2,3,4,5}]];
          
          
          nodePairs={{nodeNumbers[[1]],nodeNumbers[[2]]},{nodeNumbers[[1]],
                nodeNumbers[[3]]},{nodeNumbers[[1]],
                nodeNumbers[[4]]},{nodeNumbers[[2]],
                nodeNumbers[[3]]},{nodeNumbers[[2]],
                nodeNumbers[[4]]},{nodeNumbers[[3]],nodeNumbers[[4]]}};
          
          massPointTet=Apply[Plus,ansysdataMc[[1,nodeNumbers,{2,3,4}]]]/4;
          
          
          trianglesNodes={{nodeNumbers[[1]],nodeNumbers[[2]],
                nodeNumbers[[3]]},{nodeNumbers[[1]],nodeNumbers[[2]],
                nodeNumbers[[4]]},{nodeNumbers[[1]],nodeNumbers[[3]],
                nodeNumbers[[4]]},{nodeNumbers[[2]],nodeNumbers[[3]],
                nodeNumbers[[4]]}};
          
          
          massPointTriangleFunction[nNumbers_]:=
            Apply[Plus,ansysdataMc[[1,nNumbers,{2,3,4}]]]/3;
          massPointTriangle=massPointTriangleFunction/@trianglesNodes;
          
          
          edgeCentersFunction[nNumbers_]:=
            Apply[Plus,ansysdataMc[[1,nNumbers,{2,3,4}]]]/2;
          edgeCenters=edgeCentersFunction/@nodePairs;
          
          
          edgeLengthFunction[nNumbers_]:=
            Apply[Plus,(ansysdataMc[[1,nNumbers[[1]],{2,3,4}]]-
                      ansysdataMc[[1,nNumbers[[2]],{2,3,4}]])^2]^.5;
          edgeLength=edgeLengthFunction/@nodePairs;
          
          
          edgeVectorFunction[
              nNumbers_]:=(ansysdataMc[[1,nNumbers[[1]],{2,3,4}]]-
                ansysdataMc[[1,nNumbers[[2]],{2,3,4}]]);
          edgeVector=edgeVectorFunction/@nodePairs;
          (*vector von massPointTet zu edgeCenters zwei mal benutzen x vector \
non edgeCenters zu massPointTriangle. 
                Das Kreuzprodukt des einen Paares muss orthogonal \
(dotproduct) zum dritten vector sein, 
            dann sind beide Flaechen in einer Ebene (Beweis wurde in \
Mathematica symbolisch durchgefuehrt)*)
          
          
          mcDonaldSubareas={((Apply[
                          Plus,(CrossProduct[(edgeCenters[[1]]-
                                    massPointTet),(edgeCenters[[1]]-
                                    massPointTriangle[[1]])])^2])^.5)/2+
                ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[1]]-
                                    massPointTet),(edgeCenters[[1]]-
                                    massPointTriangle[[2]])])^2])^.5)/2,
              
              ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[2]]-
                                    massPointTet),(edgeCenters[[2]]-
                                    massPointTriangle[[1]])])^2])^.5)/2+
                ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[2]]-
                                    massPointTet),(edgeCenters[[2]]-
                                    massPointTriangle[[3]])])^2])^.5)/2,
              
              ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[3]]-
                                    massPointTet),(edgeCenters[[3]]-
                                    massPointTriangle[[2]])])^2])^.5)/2+
                ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[3]]-
                                    massPointTet),(edgeCenters[[3]]-
                                    massPointTriangle[[3]])])^2])^.5)/2,
              
              ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[4]]-
                                    massPointTet),(edgeCenters[[4]]-
                                    massPointTriangle[[1]])])^2])^.5)/2+
                ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[4]]-
                                    massPointTet),(edgeCenters[[4]]-
                                    massPointTriangle[[4]])])^2])^.5)/2,
              
              ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[5]]-
                                    massPointTet),(edgeCenters[[5]]-
                                    massPointTriangle[[2]])])^2])^.5)/2+
                ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[5]]-
                                    massPointTet),(edgeCenters[[5]]-
                                    massPointTriangle[[4]])])^2])^.5)/2,
              
              ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[6]]-
                                    massPointTet),(edgeCenters[[6]]-
                                    massPointTriangle[[3]])])^2])^.5)/2+
                ((Apply[
                          Plus,(CrossProduct[(edgeCenters[[6]]-
                                    massPointTet),(edgeCenters[[6]]-
                                    massPointTriangle[[4]])])^2])^.5)/2};
          
          
          
          areaNormalVectors={(CrossProduct[(edgeCenters[[1]]-
                        massPointTet),(edgeCenters[[1]]-
                        massPointTriangle[[1]])])/
                ((Apply[
                        Plus,(CrossProduct[(edgeCenters[[1]]-
                                  massPointTet),(edgeCenters[[1]]-
                                  massPointTriangle[[1]])])^2])^.5),
              
              (CrossProduct[(edgeCenters[[2]]-massPointTet),(edgeCenters[[2]]-
                        massPointTriangle[[1]])])/((Apply[
                        Plus,(CrossProduct[(edgeCenters[[2]]-
                                  massPointTet),(edgeCenters[[2]]-
                                  massPointTriangle[[1]])])^2])^.5),
              
              (CrossProduct[(edgeCenters[[3]]-massPointTet),(edgeCenters[[3]]-
                        massPointTriangle[[2]])])/((Apply[
                        Plus,(CrossProduct[(edgeCenters[[3]]-
                                  massPointTet),(edgeCenters[[3]]-
                                  massPointTriangle[[2]])])^2])^.5),
              
              (CrossProduct[(edgeCenters[[4]]-massPointTet),(edgeCenters[[4]]-
                        massPointTriangle[[1]])])/((Apply[
                        Plus,(CrossProduct[(edgeCenters[[4]]-
                                  massPointTet),(edgeCenters[[4]]-
                                  massPointTriangle[[1]])])^2])^.5),
              
              (CrossProduct[(edgeCenters[[5]]-massPointTet),(edgeCenters[[5]]-
                        massPointTriangle[[2]])])/((Apply[
                        Plus,(CrossProduct[(edgeCenters[[5]]-
                                  massPointTet),(edgeCenters[[5]]-
                                  massPointTriangle[[2]])])^2])^.5),
              
              (CrossProduct[(edgeCenters[[6]]-massPointTet),(edgeCenters[[6]]-
                        massPointTriangle[[3]])])/((Apply[
                        Plus,(CrossProduct[(edgeCenters[[6]]-
                                  massPointTet),(edgeCenters[[6]]-
                                  massPointTriangle[[3]])])^2])^.5)};
          
          edgeNormalVectors=edgeVector/edgeLength;
          
          
          areaDotEdgeFunction[j_]:=
            Abs[DotProduct[areaNormalVectors[[j]],edgeNormalVectors[[j]]]];
          areaDotEdge=areaDotEdgeFunction/@{1,2,3,4,5,6};
          
          reducedAreas=mcDonaldSubareas*areaDotEdge;
          
          
          volumeOfMcDonaldSubzellsFunction[{{{x1_,y1_,z1_},{x2_,y2_,
                    z2_}},{x3_,y3_,z3_},{x4_,y4_,
                  z4_},{{x5_,y5_,z5_},{x6_,y6_,
                    z6_}}}]:={(Abs[
                      Det[{{x1,y1,z1,1},{x3,y3,z3,1},{x4,y4,z4,1},{x6,y6,z6,
                            1}}]]+Abs[
                      Det[{{x1,y1,z1,1},{x3,y3,z3,1},{x4,y4,z4,1},{x5,y5,z5,
                            1}}]])/6};
          (****volumeVariable={{ansysdataMc[[1,nodePairs[[1]],{2,3,4}]],
                  edgeCenters[[1]],massPointTet,massPointTriangle[[{1,2}]]},
                {ansysdataMc[[1,nodePairs[[2]],{2,3,4}]],edgeCenters[[2]],
                  massPointTet,massPointTriangle[[{1,3}]]},
                {ansysdataMc[[1,nodePairs[[3]],{2,3,4}]],edgeCenters[[3]],
                  massPointTet,massPointTriangle[[{2,3}]]},
                {ansysdataMc[[1,nodePairs[[4]],{2,3,4}]],edgeCenters[[4]],
                  massPointTet,massPointTriangle[[{1,4}]]},
                {ansysdataMc[[1,nodePairs[[5]],{2,3,4}]],edgeCenters[[5]],
                  massPointTet,massPointTriangle[[{2,4}]]},
                {ansysdataMc[[1,nodePairs[[6]],{2,3,4}]],edgeCenters[[6]],
                  massPointTet,massPointTriangle[[{3,4}]]}}****)
          
          volumeOfMcDonaldSubzells=
            volumeOfMcDonaldSubzellsFunction[{ansysdataMc[[1,
                    nodePairs[[1]],{2,3,4}]],edgeCenters[[1]],massPointTet,
                massPointTriangle[[{1,
                      2}]]}]; (*all 12 McDonald subvolumes in a tetrahedron \
have the same value*)
          
          
          outPutFunction[i_]:={nodePairs[[i]],edgeLength[[i]],
              reducedAreas[[i]],volumeOfMcDonaldSubzells[[1]]};
          outPut=outPutFunction/@{1,2,3,4,5,6};
          
          Return[outPut]
          ];
      
      elementMcDonaldGeometry=
        elementMcDonaldGeometryFunction/@Range[Length[elementList]];
      
      Return[elementMcDonaldGeometry]
      ];



AnsysMcDonaldEquationSystemSteadyState3D[listOfGeometries_,tetgenData_,Dif_,
      electrodeReactionValues_,dirichletBoundaries_,initialConcentrations_]:=
    Module[{elementAssembleFunction,numberOfNodes,rightHandSideVector,
        nodeMarcs,electrodeReactionsFunktion,elektrodenVariablenFunktion,
        elektrodenVariablen,electrodeReaction,aIndices,
        dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
        allDirichletNodes,dirichletLinesFunktion,dirichletLines,
        dirichletEliminationFunktion,diagonDirichl,
        dirichletRHSVariableFunction,dirichletRHSVariable,
        dirichletRHSFunction,concentrationFunction,diricFunction,
        sparseStiffnessMatrix,a,allNodePairs,nodesPerElement,
        nodepairsForEverySpezies,sparseInitialisation,
        sparseDiagonalInitialisation,vectorOfConcentrations},
      
      diffcoef=Dif;
      numberOfNodes=tetgenData[[1,-1,1]];
      (********************Start sparse matrix initialization*********************)(**
            this part produces all a[i,j]=
          0 which apeares in the final sparse matrix**)nodesPerElement=
        tetgenData[[2]][[All,{2,3,4,5}]];
      nodepairsForEverySpezies[spez_]:=
        Module[{nodePairsPerElement,nodePairs},
          nodePairsPerElement[
              i_]:={{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]}};
          nodePairs=nodePairsPerElement/@Range[Length[nodesPerElement]];
          Return[nodePairs];];
      allNodePairs=nodepairsForEverySpezies/@Range[Length[diffcoef]];
      sparseInitialisation[i_]:=a[i[[1]],i[[2]]]=a[i[[2]],i[[1]]]=0;
      sparseInitialisation/@Union[Flatten[allNodePairs,2]];
      sparseDiagonalInitialisation[i_]:=a[i,i]=0;
      sparseDiagonalInitialisation/@
        Range[Length[tetgenData[[1]]]*Length[diffcoef]];
      (********************
          end sparse matrix initialization*********************)
      
      elementAssembleFunction[listOfGeom_,diffcoef_,numberOfNodes_]:=
        Module[{assembleFunction,i,voro1,voro2,voro3,voro4,voro5,
            voro6},(*this rows calculate the area of the voronoi box edge A[i,
                  j] over the distance between two points \[CapitalDelta][i,
                  j]:A[i,j]/\[CapitalDelta][i,j]*)i=listOfGeom;
          voro1=i[[1,3]]/i[[1,2]];
          voro2=i[[2,3]]/i[[2,2]];
          voro3=i[[3,3]]/i[[3,2]];
          voro4=i[[4,3]]/i[[4,2]];
          voro5=i[[5,3]]/i[[5,2]];
          voro6=i[[6,3]]/i[[6,2]];
          
          assembleFunction[spezNumber_]:=
            Module[{diffcoefOfSpez,multiSpez,voroDif1,voroDif2,voroDif3,
                voroDif4,voroDif5,voroDif6},
              diffcoefOfSpez=diffcoef[[spezNumber]];
              multiSpez=(spezNumber-1)*numberOfNodes;
              voroDif1=diffcoefOfSpez*voro1;
              
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,2]]]=
                a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,1]]]+=(-voroDif1);
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,1]]]+=voroDif1;
              a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,2]]]+=voroDif1;
              voroDif2=diffcoefOfSpez*voro2;
              
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,2]]]=
                a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,1]]]+=(-voroDif2);
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,1]]]+=voroDif2;
              a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,2]]]+=voroDif2;
              voroDif3=diffcoefOfSpez*voro3;
              
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,2]]]=
                a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,1]]]+=(-voroDif3);
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,1]]]+=voroDif3;
              a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,2]]]+=voroDif3;
              voroDif4=diffcoefOfSpez*voro4;
              
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,2]]]=
                a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,1]]]+=(-voroDif4);
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,1]]]+=voroDif4;
              a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,2]]]+=voroDif4;
              voroDif5=diffcoefOfSpez*voro5;
              
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,2]]]=
                a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,1]]]+=(-voroDif5);
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,1]]]+=voroDif5;
              a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,2]]]+=voroDif5;
              voroDif6=diffcoefOfSpez*voro6;
              
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,2]]]=
                a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,1]]]+=(-voroDif6);
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,1]]]+=voroDif6;
              a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,2]]]+=voroDif6;];
          assembleFunction/@Range[Length[diffcoef]];];
      Outer[elementAssembleFunction,
        listOfGeometries,{diffcoef},{numberOfNodes},1,1,1];
      (********************End AssembleFunction*********************)
        Print[{stelle2,MemoryInUse[]}];
      (********************Start rightHandSideVector*********************)
   
         rightHandSideVector=Table[0,{Length[diffcoef]*numberOfNodes}];
      vectorOfConcentrations=Table[0,{Length[diffcoef]*numberOfNodes}];
      (********************End rightHandSideVector*********************)
     
       nodeMarcs=tetgenData[[1,All,5]];
      (********************Start of electrode reactions*********************)

            electrodeReactionsFunktion[i_,j_]:=
        If[nodeMarcs[[i]]\[Equal]electrodeReactionValues[[j,1]],
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
            electrodeReactionValues[[j,4]];
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]=-(electrodeReactionValues[[j,5]]);
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[1,3]]]])*
              electrodeReactionValues[[j,5]];
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[j,
                          3]]]])*-electrodeReactionValues[[j,4]];];
      elektrodenVariablenFunktion[i_]:=
        Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
      elektrodenVariablen=
        Flatten[elektrodenVariablenFunktion/@
            Range[Length[electrodeReactionValues]],3];
      (*Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte\
   
                     abgefragt dadurch werden viele Loops gespart*)
        electrodeReaction=
        Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;
      (********************
          End of electrode reactions*********************)
      (************************
          Start Dirichlet**************************)
      
      aIndices=Level[#1,{2}]&@@@DownValues[a];
      dirichletBcNodesFunktion[i_]:=
        Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
      dirichletBcNodes=
        dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
      allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+
          dirichletBcNodes;
      allDirichletNodes=
        Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
      dirichletLinesFunktion[i_]:=
        Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
      dirichletLines=
        Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
      dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
      Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
      diagonDirichl[i_]:=a[i,i]=1;
      diagonDirichl/@Transpose[dirichletLines][[1]];
      dirichletRHSVariableFunction[i_]:=
        Transpose[{Flatten[dirichletBcNodes],
            Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
      dirichletRHSVariable=
        Flatten[dirichletRHSVariableFunction/@
            Range[Length[initialConcentrations]],1];
      dirichletRHSFunction[i_,j_]:=
        rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=
          initialConcentrations[[j]];
      Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
      concentrationFunction[k_]:=
        Module[{diricFunction},
          diricFunction[i_,j_]:=
            vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                      Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
          
          Apply[diricFunction,#]&/@
            Transpose[{Flatten[
                  Transpose[
                    Table[Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,1]]]],{Length[
                          Flatten[
                            dirichletBoundaries[[k,2,
                                Range[
                                  Length[
                                    dirichletBoundaries[[k,
                                        2]]]]]]]]}]]](*das gibt die\
         
                                   Nodenumbers*),
                Flatten[
                  Table[dirichletBoundaries[[k,2,
                        Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                        Flatten[
                          Position[nodeMarcs,
                            dirichletBoundaries[[k,
                                1]]]]]}]](*das gibt die Spezies*)}];];
      concentrationFunction/@Range[Length[dirichletBoundaries]];
      (********************End of Dirichlet*********************)
      
      sparseStiffnessMatrix=Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
      Return[{sparseStiffnessMatrix,vectorOfConcentrations}]];











AnsysMcDonaldEquationSystemTrans3D[
      listOfGeometries:{({({{_Integer,_Integer},_Real,_Real,_Real})..})..},
      tetgenData:{{{_Integer,_Real,_Real,_Real,_Integer}..},{{_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer}..}},
      Dif:{(_Real|_Integer)..},
      electrodeReactionValues:{({   _Integer, _Integer, _Integer,   
                butvolmHin:_Real|_Power |_Symbol, 
                butvolmRueck :_Real|_Power |_Symbol  })..},
      dirichletBoundaries:{({_Integer,{_Integer,_Integer},{_Real|_Integer,_\
Real|_Integer}})..},
      initialConcentrations:{(_Real|_Integer)..},
      timeStep:(_Real|_Integer)]:=
    
    Module[{elementAssembleFunction,numberOfNodes,rightHandSideVector,
        nodeMarcs,electrodeReactionsFunktion,elektrodenVariablenFunktion,
        elektrodenVariablen,electrodeReaction,aIndices,
        dirichletBcNodesFunktion,dirichletBcNodes,allDirichletNodesFunction,
        allDirichletNodes,dirichletLinesFunktion,dirichletLines,
        dirichletEliminationFunktion,diagonDirichl,
        dirichletRHSVariableFunction,dirichletRHSVariable,
        dirichletRHSFunction,concentrationFunction,diricFunction,
        sparseStiffnessMatrix,vectorOfConcentrationsFunction,
        vectorOfConcentrations,a},
      
      diffcoef=Dif;
      numberOfNodes=tetgenData[[1,-1,1]];
      
      vectorOfConcentrationsFunction[i_]:=
        Table[initialConcentrations[[i]],{numberOfNodes}];
      vectorOfConcentrations=
        Flatten[vectorOfConcentrationsFunction/@
            Range[Length[initialConcentrations]]];
      
      (******************** 
          Start sparse matrix initialization *********************)
      (** 
            this part produces all a[i,j]=
          0 which apeares in the final sparse matrix **)
      
      
      nodesPerElement=tetgenData[[2]][[All,{2,3,4,5}]];
      nodepairsForEverySpezies[spez_]:=
        Module[{nodePairsPerElement,nodePairs},
          
          nodePairsPerElement[
              i_]:={{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,1]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,2]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]},{(spez-1)*numberOfNodes+
                  nodesPerElement[[i,3]],(spez-1)*numberOfNodes+
                  nodesPerElement[[i,4]]}};
          
          nodePairs=nodePairsPerElement/@Range[Length[nodesPerElement]];
          Return[nodePairs];
          ];
      allNodePairs=nodepairsForEverySpezies/@Range[Length[diffcoef]];
      sparseInitialisation[i_]:=a[i[[1]],i[[2]]]=a[i[[2]],i[[1]]]=0;
      
      sparseInitialisation/@Union[Flatten[allNodePairs,2]];
      
      sparseDiagonalInitialisation[i_]:=a[i,i]=0;
      sparseDiagonalInitialisation/@
        Range[Length[tetgenData[[1]]]*Length[diffcoef]];
      
      
      (******************** 
          end sparse matrix initialization *********************)
      
      (******************** 
          Start AssembleFunction *********************)
      
      (*  
        the input for elementAssembleFunction is the list of geometries for \
one element, 
        the list of all diffusion coeficients and the number of nodes  *)
    \
  
      (******************** 
          Start rightHandSideVector *********************)
      
      rightHandSideVector=Table[0,{Length[diffcoef]*numberOfNodes}];
      
      (******************** 
          End rightHandSideVector *********************)
      
      elementAssembleFunction[listOfGeom_,diffcoef_,numberOfNodes_]:=Module[
          {assembleFunction,i,voro1,voro2,voro3,voro4,voro5,voro6,volume1,
            volume2,volume3,volume4,volume5,volume6},
          (*this rows calculate the area of the voronoi box edge A[i,
                  j] over the distance between two points \[CapitalDelta][i,
                  j]: A[i,j]/\[CapitalDelta][i,j] *)
          
          i=listOfGeom;
          voro1=i[[1,3]]/i[[1,2]];
          voro2=i[[2,3]]/i[[2,2]];
          voro3=i[[3,3]]/i[[3,2]];
          voro4=i[[4,3]]/i[[4,2]];
          voro5=i[[5,3]]/i[[5,2]];
          voro6=i[[6,3]]/i[[6,2]];
          
          (*this lines calculate the volume of the voronoi box of one \
element, between each node pair ij*)
          
          volume1=volume2=volume3=volume4=volume5=volume6=i[[1,4]];
          
          assembleFunction[spezNumber_]:=Module[
              {diffcoefOfSpez,multiSpez,voroDif1,voroDif2,voroDif3,voroDif4,
                voroDif5,voroDif6},
              
              diffcoefOfSpez=diffcoef[[spezNumber]];
              multiSpez=(spezNumber-1)*numberOfNodes;
              
              voroDif1=diffcoefOfSpez*voro1;
              
              a[multiSpez+i[[1,1,1]],multiSpez+i[[1,1,2]]]=
                a[multiSpez+i[[1,1,2]],multiSpez+i[[1,1,1]]]+=(-voroDif1);
              
              a[multiSpez+i[[1,1,1]],
                  multiSpez+i[[1,1,1]]]+=(voroDif1+volume1/timeStep);
              
              a[multiSpez+i[[1,1,2]],
                  multiSpez+i[[1,1,2]]]+=(voroDif1+volume1/timeStep);
              rightHandSideVector[[multiSpez+i[[1,1,1]]]]+=volume1/timeStep;
              rightHandSideVector[[multiSpez+i[[1,1,2]]]]+=volume1/timeStep;
              
              voroDif2=diffcoefOfSpez*voro2;
              
              a[multiSpez+i[[2,1,1]],multiSpez+i[[2,1,2]]]=
                a[multiSpez+i[[2,1,2]],multiSpez+i[[2,1,1]]]+=(-voroDif2);
              
              a[multiSpez+i[[2,1,1]],
                  multiSpez+i[[2,1,1]]]+=(voroDif2+volume2/timeStep);
              
              a[multiSpez+i[[2,1,2]],
                  multiSpez+i[[2,1,2]]]+=(voroDif2+volume2/timeStep);
              rightHandSideVector[[multiSpez+i[[2,1,1]]]]+=volume2/timeStep;
              rightHandSideVector[[multiSpez+i[[2,1,2]]]]+=volume2/timeStep;
              
              voroDif3=diffcoefOfSpez*voro3;
              
              a[multiSpez+i[[3,1,1]],multiSpez+i[[3,1,2]]]=
                a[multiSpez+i[[3,1,2]],multiSpez+i[[3,1,1]]]+=(-voroDif3);
              a[multiSpez+i[[3,1,1]],
                  multiSpez+i[[3,1,1]]]+=(voroDif3+volume3/timeStep);
              
              a[multiSpez+i[[3,1,2]],
                  multiSpez+i[[3,1,2]]]+=(voroDif3+volume3/timeStep);
              rightHandSideVector[[multiSpez+i[[3,1,1]]]]+=volume3/timeStep;
              rightHandSideVector[[multiSpez+i[[3,1,2]]]]+=volume3/timeStep;
              
              
              voroDif4=diffcoefOfSpez*voro4;
              
              a[multiSpez+i[[4,1,1]],multiSpez+i[[4,1,2]]]=
                a[multiSpez+i[[4,1,2]],multiSpez+i[[4,1,1]]]+=(-voroDif4);
              
              a[multiSpez+i[[4,1,1]],
                  multiSpez+i[[4,1,1]]]+=(voroDif4+volume4/timeStep);
              
              a[multiSpez+i[[4,1,2]],
                  multiSpez+i[[4,1,2]]]+=(voroDif4+volume4/timeStep);
              rightHandSideVector[[multiSpez+i[[4,1,1]]]]+=volume4/timeStep;
              rightHandSideVector[[multiSpez+i[[4,1,2]]]]+=volume4/timeStep;
              
              
              voroDif5=diffcoefOfSpez*voro5;
              
              a[multiSpez+i[[5,1,1]],multiSpez+i[[5,1,2]]]=
                a[multiSpez+i[[5,1,2]],multiSpez+i[[5,1,1]]]+=(-voroDif5);
              
              a[multiSpez+i[[5,1,1]],
                  multiSpez+i[[5,1,1]]]+=(voroDif5+volume5/timeStep);
              
              a[multiSpez+i[[5,1,2]],
                  multiSpez+i[[5,1,2]]]+=(voroDif5+volume5/timeStep);
              rightHandSideVector[[multiSpez+i[[5,1,1]]]]+=volume5/timeStep;
              rightHandSideVector[[multiSpez+i[[5,1,2]]]]+=volume5/timeStep;
              
              
              voroDif6=diffcoefOfSpez*voro6;
              
              a[multiSpez+i[[6,1,1]],multiSpez+i[[6,1,2]]]=
                a[multiSpez+i[[6,1,2]],multiSpez+i[[6,1,1]]]+=(-voroDif6);
              
              a[multiSpez+i[[6,1,1]],
                  multiSpez+i[[6,1,1]]]+=(voroDif6+volume6/timeStep);
              
              a[multiSpez+i[[6,1,2]],
                  multiSpez+i[[6,1,2]]]+=(voroDif6+volume6/timeStep);
              rightHandSideVector[[multiSpez+i[[6,1,1]]]]+=volume6/timeStep;
              rightHandSideVector[[multiSpez+i[[6,1,2]]]]+=volume6/timeStep;
              
              
              
              ];
          assembleFunction/@Range[Length[diffcoef]];
          ];
      
      
      Outer[elementAssembleFunction,
        listOfGeometries,{diffcoef},{numberOfNodes},1,1,1];
      
      vectorOfVolumes=
        rightHandSideVector*
          timeStep;(*vectorOfVolumes is needed for model order reduction (C-
              vector)*)
      
      (******************** 
          End AssembleFunction *********************)
      
      
      nodeMarcs=tetgenData[[1,All,5]];
      (******************** 
          Start of electrode reactions *********************)
      
      
      electrodeReactionsFunktion[i_,j_]:=
        
        If[nodeMarcs[[i]]==electrodeReactionValues[[j,1]],
          
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+i]+=
            electrodeReactionValues[[j,4]];
          
          
          a[(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]=-(electrodeReactionValues[[j,5]]);
          
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i]+=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[1,3]]]])*
              electrodeReactionValues[[j,5]];
          
          
          a[(electrodeReactionValues[[j,3]]-1)*numberOfNodes+
                i,(electrodeReactionValues[[j,2]]-1)*numberOfNodes+
                i]=(Dif[[electrodeReactionValues[[j,2]]]]/
                  Dif[[electrodeReactionValues[[j,
                          3]]]])*-electrodeReactionValues[[j,4]];
          ];
      elektrodenVariablenFunktion[i_]:=
        Outer[List,Position[nodeMarcs,electrodeReactionValues[[i,1]]],{i}];
      elektrodenVariablen=
        Flatten[elektrodenVariablenFunktion/@
            Range[Length[electrodeReactionValues]],3];
      (* Durch die Elektrodevariablen werden nur noch die Elektrodenpunkte \
abgefragt dadurch werden viele Loops gespart *)
      
      electrodeReaction=
        Apply[electrodeReactionsFunktion,#]&/@elektrodenVariablen;  
      (******************** 
          End of electrode reactions *********************)
      
      (************************ Start Dirichlet **************************)
  
          aIndices=Level[#1,{2}]&@@@DownValues[a];
      
      dirichletBcNodesFunktion[i_]:=
        Flatten[Position[nodeMarcs,dirichletBoundaries[[i,1]]]];
      dirichletBcNodes=
        dirichletBcNodesFunktion/@Range[Length[dirichletBoundaries]];
      
      
      allDirichletNodesFunction[j_]:=(j-1)*Length[nodeMarcs]+
          dirichletBcNodes;
      allDirichletNodes=
        Flatten[allDirichletNodesFunction/@Range[Length[Dif]]];
      
      dirichletLinesFunktion[i_]:=
        Flatten[{Select[aIndices,#[[1]]\[Equal]i&]},1];
      dirichletLines=
        Union[Flatten[dirichletLinesFunktion/@allDirichletNodes,1]];
      dirichletEliminationFunktion[i_,j_]:=a[i,j]=.;
      Apply[dirichletEliminationFunktion,#]&/@dirichletLines;
      diagonDirichl[i_]:=a[i,i]=1;
      diagonDirichl/@Transpose[dirichletLines][[1]];           
      
      
      dirichletRHSVariableFunction[i_]:=
        Transpose[{Flatten[dirichletBcNodes],
            Table[i,{Length[Flatten[dirichletBcNodes]]}]}];
      dirichletRHSVariable=
        Flatten[dirichletRHSVariableFunction/@
            Range[Length[initialConcentrations]],1];
      
      dirichletRHSFunction[i_,j_]:=
        rightHandSideVector[[(j-1)*Length[nodeMarcs]+i]]=1;
      Apply[dirichletRHSFunction,#]&/@dirichletRHSVariable;
      
      
      concentrationFunction[k_]:=Module[{diricFunction},
          
          diricFunction[i_,j_]:=
            vectorOfConcentrations[[(dirichletBoundaries[[k,2,j]]-1)*
                      Length[nodeMarcs]+i]]=dirichletBoundaries[[k,3,j]];
          Apply[diricFunction,#]&/@
            Transpose[{Flatten[
                  Transpose[
                    Table[Flatten[
                        Position[nodeMarcs,
                          dirichletBoundaries[[k,1]]]],{Length[
                          Flatten[
                            dirichletBoundaries[[k,2,
                                Range[
                                  Length[
                                    dirichletBoundaries[[k,
                                        2]]]]]]]]}]]](*das gibt die \
Nodenumbers*),Flatten[
                  Table[dirichletBoundaries[[k,2,
                        Range[Length[dirichletBoundaries[[k,2]]]]]],{Length[
                        Flatten[
                          Position[nodeMarcs,
                            dirichletBoundaries[[k,
                                1]]]]]}]](*das gibt die Spezies*)}];];
      
      concentrationFunction/@Range[Length[dirichletBoundaries]];
      (******************** End of Dirichlet *********************)     
      
      sparseStiffnessMatrix= Level[#1,{2}]\[Rule]#2&@@@DownValues[a];
      
      Return[{sparseStiffnessMatrix,rightHandSideVector,
          vectorOfConcentrations,vectorOfVolumes}]
      
      ];




CurrentFunctionMcDonald3D[
      meshdata:{{{_Integer,_Real,_Real,_Real,_Integer}..},{{_Integer,_Integer,\
_Integer,_Integer,_Integer,_Integer}..}},
      electrode_Integer,
      listOfGeometries:{({({{_Integer,_Integer},_Real,_Real,_Real})..})..},
      concList:{{(_Real)..}..}]:=
    
    Module[{geometryofBoundaryNodesFunction,boundaryNodes,
        geometryofBoundaryNodes,geometryofBCNodes,assembleFunction,
        cutrrentPerTimestep},
      
      geometryofBoundaryNodesFunction[k_]:=
        Module[{positionofBCNodesFunction,positionofBCNodes,sortNodesFunction,
            nodePairsWithGeometryFunction,nodePairsWithGeometry,sortNodes},
          
          
          positionofBCNodesFunction[i_]:=
            Position[listOfGeometries[[All,All,1]],i][[All,{1,2}]];
          positionofBCNodes=positionofBCNodesFunction[k];
          
          nodePairsWithGeometryFunction[{i_,j_}]:=listOfGeometries[[i,j]];
          
          nodePairsWithGeometry=
            nodePairsWithGeometryFunction/@positionofBCNodes;
          
          
          sortNodesFunction[{{x_Integer,y_Integer},m_,l_,n_}]:={{y,x},m,l,n}/;
              x=!=k;
          
          sortNodesFunction[{{x_Integer,y_Integer},m_,l_,n_}]:={{x,y},m,l,n}/;
              x==k;
          
          sortNodes=sortNodesFunction/@nodePairsWithGeometry;
          
          Return[sortNodes]
          ];
      
      boundaryNodes=Flatten[Position[meshdata[[1,All,5]],electrode]];
      
      geometryofBoundaryNodes=
        Partition[Flatten[geometryofBoundaryNodesFunction/@boundaryNodes],5];
      
      geometryofBCNodes=geometryofBoundaryNodes;
      
      assembleFunction[concentrations_]:=
        Module[{gradientTimesAreaFunction,gradientTimesArea},
          
          gradientTimesAreaFunction[
              i_]:=
            (concentrations[[geometryofBCNodes[[i,2]]]]-
                  concentrations[[geometryofBCNodes[[i,1]]]])*
              geometryofBCNodes[[i,4]]/geometryofBCNodes[[i,3]];
          
          
          gradientTimesArea=
            gradientTimesAreaFunction/@Range[Length[geometryofBCNodes]];
          
          Return[Apply[Plus,gradientTimesArea]]
          ];
      cutrrentPerTimestep=assembleFunction/@concList;
      Return[cutrrentPerTimestep]
      ];





SteadyStateCalculation[
      equationElements:{sparseMatrix:{({_Integer,_Integer}\[Rule]_)..},
          rightHandVector:{(_Real|_Integer)..}}]:=
    Module[{concentrationsVerteilung,matrixA,vectorE},
      
      matrixA=equationElements[[1]];
      vectorE=equationElements[[2]];
      
      concentrationsVerteilung=Developer`SparseLinearSolve[matrixA,vectorE];
      
      Return[{concentrationsVerteilung}];
      ];



TransientCalculation[{sparseMatrix:{({_Integer,_Integer}\[Rule]_)..},
        rightHandVector:{(_Real|_Integer)..},
        initialConcentrations:{(_Real|_Integer)..},
        elementVolumes:{(_Real|_Integer)..}},tges:(_Real|_Integer),
      timeStep:(_Real|_Integer)]:=
    
    Module[{concentrationsVerteilung,vectorOfConcentrations},
      
      vectorOfConcentrations=initialConcentrations;
      concentrationsVerteilung=
        Table[vectorOfConcentrations=
            Developer`SparseLinearSolve[
              sparseMatrix,(rightHandVector*vectorOfConcentrations)],{tges/
              timeStep}];
      Return[concentrationsVerteilung];
      ];



CvCalculation[ 
      equationElements:{sparseMatrix:{({_Integer,_Integer}\[Rule]_)..},
          rightHandVector:{(_Real|_Integer)..},
          initialConcentrations:{(_Real|_Integer)..},
          elementVolumes:{(_Real|_Integer)..}},Tges_ , deltaT_ , 
      deltaEstart_ , deltaEend_ ,deltaE_ ]:=
    Module[{concentrationsVerteilung,vectorOfConcentrations,potentialSteps,
        potentialList,i},
      
      potentialSteps=(deltaEend-deltaEstart)/(Tges/ deltaT) ;
      potentialList=
        Join[Table[i,{i,deltaEstart,deltaEend,potentialSteps}],
          Reverse[Table[i,{i,deltaEstart,deltaEend,potentialSteps}]]];
      
      vectorOfConcentrations=equationElements[[3]];
      
      concentrationsVerteilung=
        Table[vectorOfConcentrations=
            Developer`SparseLinearSolve[
              equationElements[[1]]/.deltaE\[Rule]
                  potentialList[[i]],(equationElements[[2]]*
                  vectorOfConcentrations) ],{i,Length[potentialList]}];
      
      Return[concentrationsVerteilung];
      ];



CvMultistepCalculation[ 
      equationElements:{sparseMatrix:{({_Integer,_Integer}\[Rule]_)..},
          rightHandVector:{(_Real|_Integer)..},
          initialConcentrations:{(_Real|_Integer)..},
          elementVolumes:{(_Real|_Integer)..}},
      timePotentialList:{{(_Real|_Integer) , (_Real|_Integer) , \
(_Real|_Integer) , (_Real|_Integer)}..},deltaE_ ]:=
    
    Module[{concentrationsVerteilung,vectorOfConcentrations,potentialSteps,
        potentialList,i},
      
      PotentialListFunction[cv1_]:=Module[{potentialSteps,potentialList},
          
          potentialSteps=(cv1[[4]]-cv1[[3]])/(cv1[[1]]/ cv1[[2]]) ;
          potentialList1=Table[i,{i,cv1[[3]],cv1[[4]],potentialSteps}];
             Return[potentialList1]
          ];
      potentialList=Flatten[PotentialListFunction/@timePotentialList];
      
      vectorOfConcentrations=equationElements[[3]];
      
      concentrationsVerteilung=
        Table[vectorOfConcentrations=
            Developer`SparseLinearSolve[
              equationElements[[1]]/.deltaE\[Rule]
                  potentialList[[i]],(equationElements[[2]]*
                  vectorOfConcentrations) ],{i,Length[potentialList]}];
      
      Return[concentrationsVerteilung];
      ];





PointInBox[box_,point_]:=Module[{testFunction3,testresult},
        
        testFunction3[{x0_,y0_,deltaX_,deltaY_},{a_,x_,y_,b_}]:={a,-1}/;
            x0>x||x>(x0+deltaX)||y0>y||y>(y0+deltaY);
        
        testFunction3[{x0_,y0_,deltaX_,deltaY_},{a_,x_,y_,b_}]:={a,0}/;
            x\[Equal]x0||
              x\[Equal](x0+deltaX)&&y0\[LessEqual]y\[LessEqual](y0+deltaY);
        
        testFunction3[{x0_,y0_,deltaX_,deltaY_},{a_,x_,y_,b_}]:={a,0}/;
            y\[Equal]y0||
              y\[Equal](y0+deltaY)&&x0\[LessEqual]x\[LessEqual](x0+deltaX);
        
        testFunction3[{x0_,y0_,deltaX_,deltaY_},{a_,x_,y_,b_}]:={a,1}/;
            x>x0&&x<(x0+deltaX)&&y0<y&&y<(y0+deltaY);
        
        testFunction3[{x0_,y0_,z0_,deltaX_,deltaY_,deltaZ_},{a_,x_,y_,z_,
              b_}]:={a,-1}/;
            x0>x||x>(x0+deltaX)||y0>y||y>(y0+deltaY)||z0>z||z>(z0+deltaZ);
        
        testFunction3[{x0_,y0_,z0_,deltaX_,deltaY_,deltaZ_},{a_,x_,y_,z_,
              b_}]:={a,0}/;
            x\[Equal]x0||
              x\[Equal](x0+deltaX)&&y0\[LessEqual]y\[LessEqual](y0+deltaY)&&
                z0\[LessEqual]z\[LessEqual](z0+deltaZ);
        
        testFunction3[{x0_,y0_,z0_,deltaX_,deltaY_,deltaZ_},{a_,x_,y_,z_,
              b_}]:={a,0}/;
            y\[Equal]y0||
              y\[Equal](y0+deltaY)&&x0\[LessEqual]x\[LessEqual](x0+deltaX)&&
                z0\[LessEqual]z\[LessEqual](z0+deltaZ);
        
        testFunction3[{x0_,y0_,z0_,deltaX_,deltaY_,deltaZ_},{a_,x_,y_,z_,
              b_}]:={a,0}/;
            z\[Equal]z0||
              z\[Equal](z0+deltaZ)&&x0\[LessEqual]x\[LessEqual](x0+deltaX)&&
                y0\[LessEqual]y\[LessEqual](y0+deltaY);
        
        testFunction3[{x0_,y0_,z0_,deltaX_,deltaY_,deltaZ_},{a_,x_,y_,z_,
              b_}]:={a,1}/;
            x>x0&&x<(x0+deltaX)&&y0<y||y<(y0+deltaY)&&z0<z||z<(z0+deltaZ);
        
        testresult=testFunction3[box,point];
        
        Return[testresult];
        
        ]/;(Length[box]\[Equal]4&&
            Length[point]\[Equal]4)||(Length[box]\[Equal]6&&
            Length[point]\[Equal]5);

PointInBox::"inputData"="argument badly conditioned";
PointInBox[___]:=Message[PointInBox::"inputData"];



BoundaryElementTest[nodeNumbers_,testedNodes_]:=
  
  Module[{boundaryElementTestFunction,boundaryElement},
    
    testedNodesList=testedNodes[[All,2]][[nodeNumbers]];
    
    boundaryElementTestFunction[{nodes:{a_,b_,c_,d_},tags:{e_,f_,g_,h_}}]:=
      raus/;(Count[tags,1]\[Equal]0&&Count[tags,0]=!=4)||
          Count[tags,1]\[Equal]4;
    boundaryElementTestFunction[{nodes:{a_,b_,c_,d_},
          tags:{e_,f_,g_,h_}}]:={nodes,tags};
    boundaryElementTestFunction[{nodes:{a_,b_,c_},tags:{e_,f_,g_}}]:=
      raus/;(Count[tags,1]\[Equal]0&&Count[tags,0]=!=3)||
          Count[tags,1]\[Equal]3;
    boundaryElementTestFunction[{nodes:{a_,b_,c_},tags:{e_,f_,g_}}]:={nodes,
        tags};
    
    boundaryElement=
      boundaryElementTestFunction[{nodeNumbers,testedNodesList}];
    
    Return[boundaryElement]
    
    ]




CurrentThroughBoxFunction2DAxissymetr[fixedNode_,meshData_,geometrys2D_,
    concDistributionSteady_]:=
  
  Module[{TestElementOnBoundary,elementsOnBoundary,
      ElementMatrixAssembleFunction2D,elementMatrixAssemble,
      ElementCurrentFunction,elementCurrentList,positionsOfInnerNodes,
      CurrentPerElementandNodeFunction,currentThroughBox},
    
    
    testFunction[i_]:=PointInBox[fixedNode,meshData[[1,i]]];
    testedNodes2D=testFunction/@Range[Length[meshData[[1]]]];
    
    ElementsOnBox=BoundaryElementTest[meshData[[3,1,{2,3,4}]],testedNodes2D];
    
    TestElementOnBoundary[meshData2D_,testedNodes2D_]:=
      Module[{testedElementFunction,testedElement},
        
        testedElementFunction[i_]:=
          BoundaryElementTest[meshData2D[[3,1,{2,3,4}]],testedNodes2D];
        testedElement=
          testedElementFunction/@Range[Length[meshData2D[[3,1,{2,3,4}]]]];
        
        Return[testedElement]
        ];
    
    elementsOnBoundary=
      DeleteCases[TestElementOnBoundary[meshData,testedNodes2D],_Symbol];
    
    ElementMatrixAssembleFunction2D[
        geometry:{boxSideLengthvariable:{({_Real,_Real,_Real})..},
            lengthOfElementsidesvariable:{({_Real,_Real,_Real})..},
            nodeNumbersPerElementvariable:{({_Integer,_Integer,_Integer})..},
            numberOfNodesvariable_Integer,
            radiusOfCelvariable:{({_Real,_Real,_Real,_Real,_Real,_Real})..},
            radiusOfFluxvariable:{({_Real,_Real,_Real})..},
            volumeOfVoronoiPartvariable:{({_Real,_Real,_Real})..}}
        
        ]:=
      
      Module[{sparseMatrixAValuesFunction,numberOfNodes,nodeNumbersPerElement,
          radiusOfCel,radiusOfFlux,boxSideLength,lengthOfElementsides,
          sparseMatrixAValues},
        
        boxSideLength=geometry[[1]];
        lengthOfElementsides=geometry[[2]];
        nodeNumbersPerElement=geometry[[3]];
        numberOfNodes=geometry[[4]];
        radiusOfCel=geometry[[5]];
        radiusOfFlux=geometry[[6]];
        
        
        sparseMatrixAValuesFunction[i_]:=
          Module[{x,y,z,u,v,w,numberOfSpezFunction},
            
            
            
            x=radiusOfFlux[[i,1]]*(boxSideLength/lengthOfElementsides)[[i,
                    1]];
            
            y=radiusOfFlux[[i,2]]*(boxSideLength/lengthOfElementsides)[[i,
                    2]];
            
            z=radiusOfFlux[[i,3]]*(boxSideLength/lengthOfElementsides)[[i,
                    3]];
            
            u=nodeNumbersPerElement[[i,1]];
            v=nodeNumbersPerElement[[i,2]];
            w=nodeNumbersPerElement[[i,3]];
            
            
            Return[{i,{u,v,
                  w},{{(x+y),-(x),-(y)},{-(x),(x+z),-(z)},{-(y),-(z),(y+
                        z)}}}]
            
            ] ;
        sparseMatrixAValues=
          sparseMatrixAValuesFunction/@Range[Length[nodeNumbersPerElement]];
        
        Return[sparseMatrixAValues]
        ];
    
    elementMatrixAssemble=ElementMatrixAssembleFunction2D[geometrys2D];
    
    ElementCurrentFunction[concDistribution_,elementMatrix_]:=
      Module[{EachTimestepFunction,EachTimestepCurrents},
        
        EachTimestepFunction[timestep_]:=
          Module[{concDistributionOfTimestep,
              ElementCurrentPerTimestepFunction,elementCurrentPerTimestep},
            
            concDistributionOfTimestep=concDistribution[[timestep]];
            
            
            ElementCurrentPerTimestepFunction[elementNumber_]:=
              Module[{nodeNumbersPerElement,elementCurrentInner},
                
                nodeNumbersPerElement=elementMatrix[[elementNumber]][[2]];
                
                
                elementCurrentInner=(elementMatrix[[elementNumber]][[3]]).(\
concDistributionOfTimestep[[nodeNumbersPerElement]]);
                
                Return[{nodeNumbersPerElement,elementCurrentInner}];
                ];
            
            
            elementCurrentPerTimestep=
              ElementCurrentPerTimestepFunction/@
                Range[Length[elementMatrix]];
            
            Return[elementCurrentPerTimestep];
            
            ];
        EachTimestepCurrents=
          EachTimestepFunction/@Range[Length[concDistribution]];
        
        Return[EachTimestepCurrents]
        
        ];
    elementCurrentList=
      ElementCurrentFunction[concDistributionSteady,elementMatrixAssemble];
    
    positionsOfInnerNodes=Position[elementsOnBoundary[[All,2]],1];
    
    CurrentPerElementandNodeFunction[i_]:=
      elementCurrentList[[1,positionsOfInnerNodes[[i,1]],2,
          positionsOfInnerNodes[[i,2]]]];
    currentThroughBox=
      Apply[Plus,
        CurrentPerElementandNodeFunction/@
          Range[Length[positionsOfInnerNodes]]];
    
    Return[currentThroughBox]
    
    ]



BoundarynodesFunction3D[boundaryMarker_,
      ansysdata_]:=
    {ansysdata[[1]][[Flatten[
              Position[ansysdata[[1]][[All,-1]],boundaryMarker]]]][[All,1]],
      ansysdata[[1]][[Flatten[
              Position[ansysdata[[1]][[All,-1]],boundaryMarker]]]][[All,{2,3,
            4}]],Sort[
        ansysdata[[1]][[Flatten[
                Position[ansysdata[[1]][[All,-1]],boundaryMarker]]]][[All,
            2]]],Sort[
        ansysdata[[1]][[Flatten[
                Position[ansysdata[[1]][[All,-1]],boundaryMarker]]]][[All,
            3]]],Sort[
        ansysdata[[1]][[Flatten[
                Position[ansysdata[[1]][[All,-1]],boundaryMarker]]]][[All,
            4]]]};



CurrentThroughBoxFunction3D[fixedNode3D_,ansisdata2to3_,
      listOfGeometriesMcDonald_,concDistributionSteady3DMcDonald_]:=
    Module[{testFunction,testedNodes3D,TestElementOnBoundary,
        elementsOnBoundary,ReducedListOfGeometries3DFunction,
        reducedListOfGeometries3D,ElementMatrixAssembleFunction,
        elementMatrixAssemble,ElementCurrentFunction,ElementCurrentList,
        positionsOfInnerNodes,CurrentPerElementandNodeFunction,wholeCurrent},
      
      
      testFunction[i_]:=PointInBox[fixedNode3D,ansisdata2to3[[1,i]]];
      testedNodes3D=testFunction/@Range[Length[ansisdata2to3[[1]]]];
      
      
      TestElementOnBoundary[ansisdata3D_,testedNodes_]:=
        Module[{testedElementFunction,testedElement},
          
          
          testedElementFunction[i_]:=
            BoundaryElementTest[ansisdata3D[[2,All,{2,3,4,5}]][[i]],
              testedNodes3D];
          
          testedElement=
            testedElementFunction/@
              Range[Length[ansisdata3D[[2,All,{2,3,4,5}]]]];
          
          Return[testedElement]
          ];
      elementsOnBoundary=
        DeleteCases[
          TestElementOnBoundary[ansisdata2to3,testedNodes3D],_Symbol];
      
      
      ReducedListOfGeometries3DFunction[listOfGeometries3D_,ansisdata3D_,
          elementsOnBoundary_]:=
        Module[{BoundaryElementNumberFunction,
            reducedListOfGeometriesMcDonald},
          
          
          BoundaryElementNumberFunction[ansisdata_]:=
            Module[{positionNumbers,eachBoundaryElementNumberFunction},
              
              
              eachBoundaryElementNumberFunction[i_]:=
                Position[ansisdata[[2,All,{2,3,4,5}]],
                  elementsOnBoundary[[i,1]]];
              
              positionNumbers=
                eachBoundaryElementNumberFunction/@
                  Range[Length[elementsOnBoundary]];
              Return[positionNumbers]
              ];
          
          reducedListOfGeometriesMcDonald=
            listOfGeometries3D[[Flatten[
                  BoundaryElementNumberFunction[ansisdata3D]]]];
          Return[reducedListOfGeometriesMcDonald]
          ];
      reducedListOfGeometries3D=
        ReducedListOfGeometries3DFunction[listOfGeometriesMcDonald,
          ansisdata2to3,elementsOnBoundary];
      
      
      ElementMatrixAssembleFunction[listOfGeometries3D_]:=
        Module[{ElementMatrixFunction,ElementMatrix},
          
          
          ElementMatrixFunction[i_]:=
            
            Module[{elementData,nodeNumbers,voro1,voro2,voro3,voro4,voro5,
                voro6,elementMatrixInner},
              
              elementData=listOfGeometries3D[[i]];
              
              nodeNumbers={elementData[[1,1,1]],elementData[[1,1,2]],
                  elementData[[2,1,2]],elementData[[3,1,2]]};
              voro1=elementData[[1,3]]/elementData[[1,2]];
              voro2=elementData[[2,3]]/elementData[[2,2]];
              voro3=elementData[[3,3]]/elementData[[3,2]];
              voro4=elementData[[4,3]]/elementData[[4,2]];
              voro5=elementData[[5,3]]/elementData[[5,2]];
              voro6=elementData[[6,3]]/elementData[[6,2]];
              
              
              elementMatrixInner={{-(voro1+voro2+voro3),voro1,voro2,
                    voro3},{voro1,-(voro1+voro4+voro5),voro4,voro5},{voro2,
                    voro4,-(voro2+voro4+voro6),voro6},{voro3,voro5,
                    voro6,-(voro3+voro5+voro6)}};
              Return[{i,nodeNumbers,elementMatrixInner}]
              ];
          
          ElementMatrix=
            ElementMatrixFunction/@Range[Length[listOfGeometries3D]];
          Return[ElementMatrix]
          ];
      elementMatrixAssemble=
        ElementMatrixAssembleFunction[reducedListOfGeometries3D];
      
      
      ElementCurrentFunction[concDistribution_,elementMatrix_]:=
        Module[{EachTimestepFunction,EachTimestepCurrents},
          
          
          EachTimestepFunction[timestep_]:=
            Module[{concDistributionOfTimestep,
                ElementCurrentPerTimestepFunction,elementCurrentPerTimestep},
              
              concDistributionOfTimestep=concDistribution[[timestep]];
              
              ElementCurrentPerTimestepFunction[elementNumber_]:=
                Module[{nodeNumbersPerElement,elementCurrentInner},
                  
                  nodeNumbersPerElement=elementMatrix[[elementNumber]][[2]];
                  
                  elementCurrentInner=(elementMatrix[[elementNumber]][[3]]).(\
concDistributionOfTimestep[[nodeNumbersPerElement]]);
                  Return[{nodeNumbersPerElement,elementCurrentInner}];
                  ];
              
              elementCurrentPerTimestep=
                ElementCurrentPerTimestepFunction/@
                  Range[Length[elementMatrix]];
              Return[elementCurrentPerTimestep];
              ];
          
          EachTimestepCurrents=
            EachTimestepFunction/@Range[Length[concDistribution]];
          Return[EachTimestepCurrents]
          ];
      ElementCurrentList=
        ElementCurrentFunction[concDistributionSteady3DMcDonald,
          elementMatrixAssemble];
      
      positionsOfInnerNodes=Position[elementsOnBoundary[[All,2]],1];
      
      CurrentPerElementandNodeFunction[i_]:=
        ElementCurrentList[[1,positionsOfInnerNodes[[i,1]],2,
            positionsOfInnerNodes[[i,2]]]];
      wholeCurrent=
        Apply[Plus,
          CurrentPerElementandNodeFunction/@
            Range[Length[positionsOfInnerNodes]]];
      
      Return[wholeCurrent]
      ];





NodeinFlatFunction[ansysdata_,a_,b_,koord_]:=
    Module[{NodeinFlatFunctionInner,NodeinFlat,kordinate},
      kordinate[h_]:=Module[{},k=1;]/;koord\[Equal]x||koord\[Equal]X;
      kordinate[h_]:=Module[{},k=2;]/;koord\[Equal]y||koord\[Equal]Y;
      kordinate[h_]:=Module[{},k=3;]/;koord\[Equal]z||koord\[Equal]Z;
      kordinate[h_]:=Module[{},k=0;];
      kordinate[h];
      flaechenNodes[x_]:=
        ansysdata[[1,x,{1,2,3}]]/;
          k\[Equal]3&&ansysdata[[1,x,k+1]]\[GreaterEqual]a&&
            b\[GreaterEqual]ansysdata[[1,x,k+1]];
      flaechenNodes[x_]:=
        ansysdata[[1,x,{1,2,4}]]/;
          k\[Equal]2&&ansysdata[[1,x,k+1]]\[GreaterEqual]a&&
            b\[GreaterEqual]ansysdata[[1,x,k+1]];
      flaechenNodes[x_]:=
        ansysdata[[1,x,{1,3,4}]]/;
          k\[Equal]1&&ansysdata[[1,x,k+1]]\[GreaterEqual]a&&
            b\[GreaterEqual]ansysdata[[1,x,k+1]];
      flaechenNodes[x_]:=p;
      NodeinFlat=flaechenNodes/@Range[Length[ansysdata[[1]]]];
      Return[DeleteCases[NodeinFlat,_Symbol]]];





PlotMesh[easymeshData:{nodeList:{({_Integer,_Real,_Real,_Integer})..},
          
          sideList:{({_Integer,_Integer,_Integer,_Integer,_Integer,_Integer})..}\
,
          
          elementList:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}}]:=
    \

    Module[
      {easymeshMeshGraphics,linienPlotFunkt,liste333,voronoilinienPlotFunkt,
        liste222,voronoiBoundaryNodesFunction,voronoiBoundaryNodes,
        voronoiNeighbours,voronoiBoundaryPlotFunkt,voronoiBoundaryPlot,
        delaunayBoundaryNodesFunction,delaunayBoundaryNodes},
      
      linienPlotFunkt[i_]:=
        Line[{easymeshData[[1,easymeshData[[2,i,2]],{2,3}]],
            easymeshData[[1,easymeshData[[2,i,3]],{2,3}]]}];
      liste333=linienPlotFunkt/@Range[Length[easymeshData[[2]]]];
      
      Off[Part::"partd"];
      voronoilinienPlotFunkt[i_]:=
        Line[{easymeshData[[3,easymeshData[[2,i,4]],{11,12}]],
            easymeshData[[3,easymeshData[[2,i,5]],{11,12}]]}];
      liste222=voronoilinienPlotFunkt/@Range[Length[easymeshData[[2]]]];
      
      voronoiBoundaryNodesFunction[i_]:=
        Apply[Plus,easymeshData[[1,i,{2,3}]]]/2;
      voronoiBoundaryNodes=
        voronoiBoundaryNodesFunction/@
          easymeshData[[2,
              Flatten[Position[Transpose[easymeshData[[2]]][[5]],0]],{2,
                3}]](*randpunkte Voronoi*);
      voronoiNeighbours=
        easymeshData[[3,
            easymeshData[[2,
                Flatten[Position[Transpose[easymeshData[[2]]][[5]],0]],
                4]],{11,12}]];
      voronoiBoundaryPlotFunkt[i_]:=
        Line[{voronoiBoundaryNodes[[i]],voronoiNeighbours[[i]]}];
      voronoiBoundaryPlot=
        voronoiBoundaryPlotFunkt/@Range[Length[voronoiNeighbours]];(* 
        Liste mit den zwei Punkten einer VoronoiRandSeite *)
      
      delaunayBoundaryNodesFunction[i_]:=Line[easymeshData[[1,i,{2,3}]]];
      delaunayBoundaryNodes=
        delaunayBoundaryNodesFunction/@
          Append[easymeshData[[2,
                Flatten[Position[Transpose[easymeshData[[2]]][[5]],0]],{2,
                  3}]],Flatten[
              easymeshData[[2,
                  Flatten[Position[Transpose[easymeshData[[2]]][[4]],0]],{2,
                    3}]],1]];
      
      Off[Graphics::"gpt"];
      
      StylePrint[Length[easymeshData[[1]]]"Nodes","Title"];
      
      Show[
        Graphics[{RGBColor[0,0,0],liste333},PlotLabel\[Rule]" Delaunay mesh",
          TextStyle\[Rule]{FontSize\[Rule]16},AspectRatio\[Rule]Automatic]];
      
      Show[
        Graphics[{RGBColor[1,0,0],liste222,RGBColor[1,0,0],
            voronoiBoundaryPlot,RGBColor[1,0,0],delaunayBoundaryNodes},
          PlotLabel\[Rule]"Voronoi mesh",TextStyle\[Rule]{FontSize\[Rule]16},
          AspectRatio\[Rule]Automatic]];
      Show[Graphics[{
            RGBColor[0,0,0],liste333,RGBColor[1,0,0],liste222,RGBColor[1,0,0],
            voronoiBoundaryPlot},PlotLabel\[Rule]"both meshes",
          TextStyle\[Rule]{FontSize\[Rule]16},AspectRatio\[Rule]Automatic]];
      
      ];



CVPlotData[ cvStrom:{(_Real|_Integer)..} ]:=Module[{geteilt},
      
      geteilt=Partition[cvStrom,Length[cvStrom]/2];
      
      Return[{geteilt[[1]],Reverse[geteilt[[2]]]}];
      
      ];



CVPlotDataMultiList[ cvStrom:{(_Real|_Integer)..} ,n_Integer]:=
    Module[{geteilt},
      
      geteilt=Partition[cvStrom,Length[cvStrom]/n];
      
      Return[
        Join[Reverse/@Take[geteilt,{2,Length[geteilt],2}],
          Take[geteilt,{1,Length[geteilt],2}]]]
      ];





SurfacePlotData[meshData:{
          nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
          
          sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
          
          elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,\
_Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
      concDistribution:{{(_Real)..}..},timestep_Integer ]:=
    
    Module[{coord,data11},
      coord=Transpose[Transpose[meshData[[1]]][[{2,3}]]];
      data11=
        Partition[
          Flatten[Transpose[{coord,(Partition[
                      100*concDistribution[[timestep]],
                      Length[coord]][[2]])}]],3];
      Return[data11];
      ];



wireFrameMeshold[pointOfView_,
      ansisdata:{n:{{_Real,_Real,_Real,_Real,_Real}..},
          e:{{_Real,_Real,_Real,_Real,_Real,_Real}..}}]:=
    Module[{nodeCoordRules,BCNodes},
      nodeCoordRules=((Rule[#\[LeftDoubleBracket]1\[RightDoubleBracket],{#\
\[LeftDoubleBracket]2\[RightDoubleBracket],#\[LeftDoubleBracket]3\
\[RightDoubleBracket],#\[LeftDoubleBracket]4\[RightDoubleBracket]}])&/@n);
      BCNodes=
        Point[#]&/@(Drop[#,1]&/@(Drop[#,-1]&/@
                  Select[n,(#\[LeftDoubleBracket]-1\[RightDoubleBracket]>
                          0)&]));
      Graphics3D[{PointSize[.02],(Line[
                    Join[Drop[#,{1,6,
                          5}],{#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]4\[RightDoubleBracket],#\[LeftDoubleBracket]3\
\[RightDoubleBracket],#\[LeftDoubleBracket]5\[RightDoubleBracket]}]]&/@
                e)/.nodeCoordRules,RGBColor[1,0,0],BCNodes},pointOfView,
        Boxed\[Rule]False,Axes\[Rule]True,PlotRange\[Rule]All]
      ];
WireFrameMeshWithBCNodesold[pointOfView_,tetgenData_]:=
    Module[{},<<Default3D`;wireFrameMeshold[pointOfView,tetgenData]//Show;];

WireFrameMeshWitRotationold[pointOfView_,tetgenData_]:=
    Module[{},<<RealTime3D`;wireFrameMeshold[pointOfView,tetgenData]//Show;];




wireFrameMesh[pointOfView_,
      ansisdata:{n:{{_Integer,_Real,_Real,_Real,_Integer}..},
          e:{{_Integer,_Integer,_Integer,_Integer,_Integer,_Integer}..}}]:=
    Module[{nodeCoordRules,BCNodes},
      nodeCoordRules=((Rule[#\[LeftDoubleBracket]1\[RightDoubleBracket],{#\
\[LeftDoubleBracket]2\[RightDoubleBracket],#\[LeftDoubleBracket]3\
\[RightDoubleBracket],#\[LeftDoubleBracket]4\[RightDoubleBracket]}])&/@n);
      BCNodes=
        Point[#]&/@(Drop[#,1]&/@(Drop[#,-1]&/@
                  Select[n,(#\[LeftDoubleBracket]-1\[RightDoubleBracket]>
                          0)&]));
      Graphics3D[{PointSize[.02],(Line[
                    Join[Drop[#,{1,6,
                          5}],{#\[LeftDoubleBracket]2\[RightDoubleBracket],#\
\[LeftDoubleBracket]4\[RightDoubleBracket],#\[LeftDoubleBracket]3\
\[RightDoubleBracket],#\[LeftDoubleBracket]5\[RightDoubleBracket]}]]&/@
                e)/.nodeCoordRules,RGBColor[1,0,0],BCNodes},pointOfView,
        Boxed\[Rule]False,Axes\[Rule]True,PlotRange\[Rule]All]
      ];

WireFrameMeshWithBCNodes[pointOfView_,tetgenData_]:=
    Module[{},<<Default3D`;wireFrameMesh[pointOfView,tetgenData]//Show;];

WireFrameMeshWitRotation[pointOfView_,tetgenData_]:=
    Module[{},<<RealTime3D`;wireFrameMesh[pointOfView,tetgenData]//Show;];



Feldplot[meshData:{
          nodeListvariable:{({_Integer,_Real,_Real,_Integer})..},
          
          sideListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,_\
Integer})..},
          
          elementListvariable:{({_Integer,_Integer,_Integer,_Integer,_Integer,\
_Integer,_Integer,_Integer,_Integer,_Integer,_Real,_Real,_Integer})..}},
      concDistribution:{{(_Real)..}..},plotFrequency_Integer]:=
    Module[{coord,ele,v,vals},
      coord=Transpose[Transpose[meshData[[1]]][[{2,3}]]];
      ele=Transpose[Transpose[meshData[[3]]][[{2,3,4}]]];
      For[v=1,v\[LessEqual]Length[concDistribution],v+=plotFrequency,
        vals=
          Partition[concDistribution[[v]],
                Length[coord]][[1(*gibt die Nummer der Spezie*)]]*.87;
        Show[
          Graphics[
            Transpose[{Map[GrayLevel,
                  Map[(vals[[#[[1]]]]+vals[[#[[2]]]]+vals[[#[[3]]]])/3.&,
                    ele]],
                
                Map[Polygon,
                  Map[{coord[[#[[1]]]],coord[[#[[2]]]],coord[[#[[3]]]]}&,
                    ele]]}],AspectRatio\[Rule]Automatic]]
        ];
      ];































































































































































































End[] (* of Begin Private *)



(* Protect[] (* anything *) *)
EndPackage[] 
