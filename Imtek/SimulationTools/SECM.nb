(************** Content-type: application/mathematica **************
                     CreatedBy='Mathematica 5.0'

                    Mathematica-Compatible Notebook

This notebook can be used with any Mathematica-compatible
application, such as Mathematica, MathReader or Publicon. The data
for the notebook starts with the line containing stars above.

To get the notebook into a Mathematica-compatible application, do
one of the following:

* Save the data starting with the line of stars above into a file
  with a name ending in .nb, then open the file inside the
  application;

* Copy the data starting with the line of stars above to the
  clipboard, then use the Paste menu command inside the application.

Data for notebooks contains only printable 7-bit ASCII and can be
sent directly in email or through ftp in text mode.  Newlines can be
CR, LF or CRLF (Unix, Macintosh or MS-DOS style).

NOTE: If you modify the data for this notebook not in a Mathematica-
compatible application, you must delete the line below containing
the word CacheID, otherwise Mathematica-compatible applications may
try to use invalid cache data.

For more information on notebooks and Mathematica-compatible 
applications, contact Wolfram Research:
  web: http://www.wolfram.com
  email: info@wolfram.com
  phone: +1-217-398-0700 (U.S.)

Notebook reader applications are available free of charge from 
Wolfram Research.
*******************************************************************)

(*CacheID: 232*)


(*NotebookFileLineBreakTest
NotebookFileLineBreakTest*)
(*NotebookOptionsPosition[    725500,      13512]*)
(*NotebookOutlinePosition[    726490,      13543]*)
(*  CellTagsIndexPosition[    726446,      13539]*)
(*WindowFrame->Normal*)



Notebook[{

Cell[CellGroupData[{
Cell["SECM Package", "Subtitle"],

Cell[CellGroupData[{

Cell["Introduction", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Title : \ SECMnew4 . 
          m\ *) \)\(\[IndentingNewLine]\)\( (*\ \(Context\)\(:\)\ *) \)\(\
\[IndentingNewLine]\)\( (*\ 
      Author : Darius\ Koziol\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Date : \ 26.04  .2004\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Summary : \ 
        This\ is\ the\ IMTEK\ template\ for\ writing\ a\ mathematica\ \
packages\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Package\ \(Copyright : \ GNU\ GPL\)\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Package\ \(Version : \ 0.1\)\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Mathematica\ \(Version : \ 
          4.2\)\ *) \)\(\[IndentingNewLine]\)\( (*\ \(History\)\(:\)\ *) \)\(\
\[IndentingNewLine]\)\( (*\ \(Keywords\)\(:\)\ *) \)\(\[IndentingNewLine]\)\( \
(*\ \(Sources\)\(:\)\ *) \)\(\[IndentingNewLine]\)\( (*\ \(Warnings\)\(:\)\ \
*) \)\(\[IndentingNewLine]\)\( (*\ \(Limitations\)\(:\)\ *) \)\(\
\[IndentingNewLine]\)\( (*\ \(Discussion\)\(:\)\ *) \)\(\[IndentingNewLine]\)\
\( (*\ \(Requirements\)\(:\)\ *) \)\(\[IndentingNewLine]\)\( (*\ \(Examples\)\
\(:\)\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\ \)\(Needs["\<Graphics`MultipleListPlot`\>"];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Start Package", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(BeginPackage["\<Imtek`SimulationTools`SECM`\>"];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Documentation // Error - Messages", "Section",
  InitializationCell->True],

Cell[CellGroupData[{

Cell["Docu", "Subsection",
  InitializationCell->True],

Cell[BoxData[{
    RowBox[{\(SECM::usage = "\<This package contains the following functions \
and initialisations:\n  MakePoint, MakeEasymeshVertex, \
MakeEasymeshMaterialPoint, MakeEasymeshPolygon, MakeEasymeshPolyLine, \
Easymesh, EasymeshData, EasymeshNodeList, EasymeshSideList, \
EasymeshElementList, WriteEasymeshInputData, RunEasymesh, ReadEasymesh, \
PlotMesh, GeometryFunction2DAxisSymmetric, GeometryData2DAxisSymmetric, \
EquationsystemSteadyState2DAxisSymmetric, EquationDataSteadyState, \
SteadyStateCalculation, CurrentFunction2DAxisSymmetric, \
EquationDataTransient, EquationsystTransient2DAxisSymmetric, \
TransientCalculation, EquationDataTransientCV, CvCalculation, \
AnsysElementGeometryFunction3D, GeometryData3D, GeometryTestForVoronoi3D, \
AnsysData, AnsysEquationSystemSteadyState3D, AnsysEquationSystemTrans3D, \
CurrentFunction3D, twoDEasymeshToThreeDFunction, ReadAnsysNodes, \
AnsysNodeData, ReadAnsysElements, AnsysElementData, EquationsystTransient2D, \
EquationsystSteadyState2D, CurrentPerDepthFunction2D, CVPlotData, Feldplot, \
WireFrameMeshWithBCNodes, WireFrameMeshWitRotation, NeumannBoundaryValues, \
DirichletBoundaryValues, ElectrodeReactionValues, InitialData, \
SpecificConstants\>";\), "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(Easymesh::usage = "\<Easymesh is a freeware 2D mesh generator \
for high quality Delaunay and Voronoi meshes.  \nEasymesh can be downloaded \
from:   http://www-dinma.univ.trieste.it/nirftc/research/easymesh/Default.htm\
\>";\), "\n"}], "\n", 
    RowBox[{\(EasymeshData::usage = "\<EasymeshData[...] is the head of a \
data block that contains three arrays that describe the nodes, sides and \
elements of the mesh: EasyMeshData[n, s, e]. Also see EasymeshNodeList, \
EasymeshSideList and EasymeshElementList. For instructions on how to read \
EasymeshData from a generated file, see ReadEasymesh. \nEasymesh can be \
downloaded from:   \
http://www-dinma.univ.trieste.it/nirftc/research/easymesh/Default.htm\>";\), 
      "\n"}], "\n", 
    RowBox[{\(EasymeshNodeList::usage = "\<EasymeshNodeList[...] is the head \
of a data block that contains an entry for each of the nodes of the mesh. The \
entries are lists with the following structure: {nodenum, xcoord, ycoord, \
nodetag}.\>";\), "\n"}], "\n", 
    RowBox[{\(EasymeshSideList::usage = "\<EasymeshSideList[...] is the head \
of a data block that contains an entry for each of the sides of the mesh. The \
entries are lists with the following structure: {sidenum, startnode, endnode, \
leftelement, rightelement, sidetag}.\>";\), "\n"}], "\n", 
    RowBox[{\(EasymeshElementList::usage = "\<EasymeshElementList[...] is the \
head of a data block that contains an entry for each of the elements of the \
mesh. The entries are lists with the following structure: {elementnum, node1, \
node2, node3, neighbour1, neighbour2, neighbour3, side1, side2, side3, \
xcircumcenter, ycircumcenter, elementtag}.\>";\), "\n"}], "\n", 
    RowBox[{\(WriteEasymeshInputData::usage = \
"\<WriteEasymeshInputData[easymeshPolygonInput, easymeshLineInput, \
easymeshMaterialPointInput] returns EasymeshInputData, a data block which has \
the structure as required by Easymesh as input data. Also see Easymesh, \
easymeshPolygonInput, easymeshLineInput, easymeshMaterialPointInput.\>";\), 
      "\n"}], "\n", 
    RowBox[{\(RunEasymesh::usage = "\<RunEasymesh[EasymeshInputData] runs \
Easymesh (a freeware 2D mesh generator for high quality Delaunay and Voronoi \
meshes) and returns fileName where the generated data is stored. To read the \
generated mesh data see ReadEasymesh. \nEasymesh can be downloaded from: \
http://www-dinma.univ.trieste.it/nirftc/research/easymesh/Default.htm\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(ReadEasymesh::usage = "\<ReadEasymesh[fileName] attempts to \
read an Easymesh output file and returns an object of the type EasymeshData. \
If the file is not found, or is not readable, or contains data that makes \
little sense, the function returns a Null. Also see RunEasymesh, \
EasymeshData.\>";\), "\n"}], "\n", 
    RowBox[{\(PlotMesh::usage = "\<PlotMesh[EasymeshData] plots an image of a \
finite volume mesh that is described by a single array of type EasymeshData, \
which is obtained from data generated by the freeware mesh generator \
Easymesh. Also see EasymeshData.\>";\), "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(GeometryFunction2DAxisSymmetric::usage = \
"\<GeometryFunction2DAxisSymmetric[EasymeshData] takes as argument \
EasymeshData and returns a data array of the type GeometryData. It contains \
all geometry data that is necessary to describe a 2D Voronoi mesh. Also see \
GeometryData.\>";\), "\n"}], "\n", 
    RowBox[{\(GeometryData2DAxisSymmetric::usage = \
"\<GeometryData2DAxisSymmetric is a data array which contains 7 sublists \
{evb,esl,enn,totalnodes,rvs,evm,evv}. evb contains, for each element, a list \
with the lengths of the sides of the Voronoi boxes. esl contains for each \
element the side lengths. enn contains for each element the node numbers. \
totalnodes (not a list) is the number of nodes of the whole mesh. rvs is a \
list that contains the radius of all voronoi subcells. evm contains for each \
element the radius of the midpoints of the Voronoi sides. evv contains the \
volumes of the Voronoi subcells of each element.\>";\), "\n"}], "\n", 
    RowBox[{\(EquationsystemSteadyState2DAxisSymmetric::usage = \
"\<EquationsystemSteadyStateAxisSymmetric[GeometryData, EasymeshData, \
DiffusionCoefficient, InitialConcentrations, NeumannBoundaryValues, \
ElectrodeReactionValues, DirichletBoundaryValues] returns a data object with \
head EquationDataSteadyState which in turn contains the two components of a \
linear steady state matrix equation. The first part is the stiffness matrix \
E, the second the right hand side vector R. The matrix E is in sparse format. \
Also see GeometryData, EasymeshData, DiffusionCoefficient, \
InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, \
DirichletBoundaryValues, EquationDataSteadyState. \>";\), "\n"}], "\n", 
    RowBox[{
      RowBox[{
        RowBox[{\(EquationDataSteadyState::usage\), "=", 
          "\"\<EquationDataSteadyState contains of two lists \
\!\(\(TraditionalForm\`{\)\)stiffnessMatrix,rightHandSide}; the \
stiffnessMatrix is represented in the sparse format \
\!\(\(TraditionalForm\`{\)\)\!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`\
i\_1\),\!\(TraditionalForm\`j\_1\)\!\(TraditionalForm\`}\)-> \
\!\(TraditionalForm\`a\_1\), \
\!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`i\_2\),\!\(TraditionalForm\`\
j\_2\)\!\(TraditionalForm\`}\)->\!\(TraditionalForm\`a\_2\) \[Ellipsis] \
\!\(TraditionalForm\`}\), so that the entry at position \
\!\(TraditionalForm\`i\_k\),\!\(TraditionalForm\`j\_k\) has value \
\!\(TraditionalForm\`a\_k\) and all unspecified elements are taken to be \
zero.\>\""}], ";"}], "\n"}], "\n", 
    RowBox[{\(SteadyStateCalculation::usage = \
"\<SteadyStateCalculation[EquationDataSteadyState] solves the sparse linear \
system described by EquationDataSteadyState. It returns a vector of \
concentrations. Also see EquationDataSteadyState.\>";\), "\n"}], "\n", 
    RowBox[{\(CurrentFunction2DAxisSymmetric::usage = \
"\<CurrentFunctionAxisSymmetric[electrode, EasymeshData, \
concentrationDistribution] where 'electrode' is an integer which refers to \
the boundary condition marker on the electrode boundary, EasymeshData is the \
mesh data generated by Easymesh and concentrationDistribution is a two \
dimensional vector which contains of one or more vectors of concentration, \
one for each timestep.\>";\), "\n"}], "\n", 
    RowBox[{
      RowBox[{
        RowBox[{\(EquationDataTransient::usage\), "=", 
          "\"\<EquationDataTransient has the following structure \
\!\(\(TraditionalForm\`{\)\)stiffnessMatrix,rightHandSide,\
initialConcentration,voronoiVolumes};  the stiffnessMatrix is represented in \
the sparse format \
\!\(\(TraditionalForm\`{\)\)\!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`\
i\_1\),\!\(TraditionalForm\`j\_1\)\!\(TraditionalForm\`}\)-> \
\!\(TraditionalForm\`a\_1\), \
\!\(\(TraditionalForm\`{\)\)\!\(TraditionalForm\`i\_2\),\!\(TraditionalForm\`\
j\_2\)\!\(TraditionalForm\`}\)->\!\(TraditionalForm\`a\_2\) \[Ellipsis] \
\!\(TraditionalForm\`}\), so that the entry at position \
\!\(TraditionalForm\`i\_k\),\!\(TraditionalForm\`j\_k\) has value \
\!\(TraditionalForm\`a\_k\) and all unspecified elements are taken to be \
zero.\>\""}], ";"}], "\n"}], "\n", 
    RowBox[{\(EquationsystTransient2DAxisSymmetric::usage = \
"\<EquationsystTransientAxisSymmetric[GeometryData, EasymeshData, \
DifusionCoefficient, \[CapitalDelta]t, InitialConcentrations, \
NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues] \
returns EquationDataTransient which contains the components of a linear \
transient matrix equation, the stiffness matrix, the right hand side vector, \
a vector with the initial concentrations and an additional vector with the \
volumes of the Voronoi cells. The matrix E has sparse form. Also see \
GeometryData, EasymeshData, DiffusionCoefficient, InitialConcentrations, \
NeumannBoundaryValues, ElectrodeReactionValues, DirichletBoundaryValues, \
EquationDataTransient.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(TransientCalculation::usage = \
"\<TransientCalculation[EquationDataTransient, totalTime, \[CapitalDelta]t] \
solves a time dependend sparse linear system. The timesteps are of the size \
\[CapitalDelta]t and the full simulation time is specified by totalTime.  The \
function returns a list with vectors of concentrations. Also see \
EquationDataTransient.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(EquationDataTransientCV::usage = "\<EquationDataTransientCV is \
same as EquationDataTransient except the ElectrodeReactionValues, they have \
to be variable. Also see ElectrodeReactionValues.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(CvCalculation::usage = \
"\<CvCalculation[EquationDataTransientCV, totalTime, \[CapitalDelta]t, \
startValue, endValue, potentialVariable] solves a time-dependent sparse \
linear system. The timesteps are of size \[CapitalDelta]t and the full \
simulation time is specified by totalTime. potentialVariable is the name of \
the variable used for the ElectrodeReactionValues (see \
EquationDataTransientCV). Its value starts with the startValue, extends to \
endValue and returns again to startValue. The loop is divided into totalTime/\
\[CapitalDelta]t equal steps. Also see EquationDataTransient and \
EquationDataTransientCV.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(AnsysElementGeometryFunction3D::usage = \
"\<AnsysElementGeometryFunction3D[AnsysData] takes as argument AnsysData and \
returns a data array of the type GeometryData3D. It contains all geometry \
data that is necessary to describe a 3D Voronoi mesh. Also see \
GeometryData3D.\>";\), "\n"}], "\n", 
    RowBox[{\(GeometryData3D::usage = "\<GeometryData3D[...] contains, for \
every element in the mesh, a list with 7 sublists \
{{a,b,c,d,e,f,circumcenterCoords}, ...}. The six lists a to f, one per edge \
of the tetrahedron, have the structure {{startEdgeNode, endEdgeNode}, \
edgeLength, voronoiCellPartialArea}. The list circumcenterCoords holds the \
coordinates of the circumcenter of each element.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(GeometryTestForVoronoi3D::usage = \
"\<GeometryTestForVoronoi3D[AnsysData, GeometryData3D] tests whether the \
tetrahedral elements of the input mesh are truly Voronoi elements.\>";\), 
      "\n"}], "\n", 
    RowBox[{\(AnsysData::usage = "\<AnsysData[nodes, elements] is the head of \
a data block that contains two arrays that describe the nodes and elements of \
the mesh. The first list contains an entry for each of the nodes of the mesh. \
Each entry is a list with the following structure: {nodeNumber, xCoordinate, \
yCoordinate, zCoordinate, nodeTag}. The second list contains an entry for \
each of the elements of the mesh. Each entry is a list with the following \
structure: {elementNumber, node1, node2, node3, node4, elementTag}.\>";\), 
      "\n"}], "\n", 
    RowBox[{\(AnsysEquationSystemSteadyState3D::usage = \
"\<AnsysEquationSystemSteadyState3D[GeometryData3D, AnsysData, \
DiffusionCoefficient, ElectrodeReactionValues, \
DirichletBoundaryValues,InitialConcentrations] returns \
EquationDataSteadyState which contains two components of a linear steady \
state matrix equation, the stiffness matrix and the right hand side vector. \
The matrix E has sparse form. Also see GeometryData3D, AnsysData, \
DiffusionCoefficient, InitialConcentrations, ElectrodeReactionValues, \
DirichletBoundaryValues, EquationDataSteadyState.\>";\), "\n"}], "\n", 
    RowBox[{\(AnsysEquationSystemTrans3D::usage = \
"\<AnsysEquationSystemTrans3D[GeometryData3D, AnsysData, \
DiffusionCoefficient, ElectrodeReactionValues, DirichletBoundaryValues, \
InitialConcentrations, \[CapitalDelta]t] returns EquationDataTransient which \
contains the components of a linear transient matrix equation, the stiffness \
matrix, the right hand side vector, a vector with the initial concentrations \
and an additional vector with the volumes of the Voronoi cells. The matrix E \
has sparse form. Also see GeometryData3D, AnsysData, DiffusionCoefficient, \
InitialConcentrations, NeumannBoundaryValues, ElectrodeReactionValues, \
DirichletBoundaryValues, EquationDataTransient.\>";\), 
      "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(CurrentFunction3D::usage = "\<currentFunction3D[AnsysData, \
electrode, GeometryData3D, concDistribution] calculates the current on a \
boundary which is marked as 'electrode'. The arguments are:
\nAnsysData is the mesh data generated by Ansys,
\n'electrode' is an integer which relates to the boundary condition marker on \
the electrode-boundary,
\nGeometryData3D is an array of mesh geometry information (see \
GeometryData3D), 
\nconcDistribution is a two dimensional vector which contains of one or more \
vectors of concentration, one for each timestep and
\nDiffusionCoefficient is a list of diffusion coefficients, one for each \
species of the reaction.\>";\), 
      "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
    RowBox[{\(twoDEasymeshToThreeDFunction::usage = \
"\<twoDEasymeshToThreeDFunction[EasymeshData, thickness] takes as first \
argument EasymeshData, a 2D data array read from Easymesh output files and \
creates a 3D tetrahedron based mesh data object. Also see EasymeshData. Here \
'thickness' defines the dimension in the z-direction. The new mesh has two \
layers of nodes, one layer with the z-coordinate set to zero, and the second \
layer with the z-coordinate = 'thickness'.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(MakePoint::usage = "\<MakePoint[x, y] takes the x- and \
y-coordinate as arguments and returns a object with the Head 'Point'.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(MakeEasymeshVertex::usage = "\<MakeEasymeshVertex[point, \
meshSize, nodeMarker, boundaryMarker] takes an object with Head Point, a \
dimensionless number that determines the size of the mesh around the node, a \
tag which is associated with the node, and a tag which is associated with the \
side that starts with this node. It returns an object with Head \
EasymeshVertex.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(MakeEasymeshMaterialPoint::usage = \
"\<MakeEasymeshMaterialPoint[Point, meshSize, materialNodeMarker] takes an \
object with the Head Point, a dimensionless number that determines the size \
of the mesh around the node, and a tag which is associated with the node and \
a zone of the mesh. It returns an object with the Head \
'EasymeshMaterialPoint'.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(MakeEasymeshPolygon::usage = \
"\<MakeEasymeshPolygon[EasymeshVertex, EasymeshVertex, EasymeshVertex, \
\[Ellipsis]] takes three or more objects with Head 'EasymeshVertex' and \
returns an object with Head 'EasymeshPolygon'. The first and last \
EasymeshVertex are connected to form a closed polygon. Also see \
'MakeEasymeshPolyLine'.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(MakeEasymeshPolyLine::usage = \
"\<MakeEasymeshPolyLine[EasymeshVertex, EasymeshVertex, \[Ellipsis]]  takes \
two or more objects with Head 'EasymeshVertex' and returns an object with \
Head 'EasymeshPolyLine'. The nodes will not be connected to a polygon. Also \
see 'MakeEasymeshPolygon'.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(ReadAnsysNodes::usage = "\<ReadAnsysNodes[fileName] attempts to \
read an Ansys node output file and, if successful, returns an object of the \
type AnsysNodeData. The list contains an entry for each of the nodes of the \
mesh. Each entry is a list with the following structure: {nodeNumber, \
xCoordinate, yCoordinate, zCoordinate, nodeTag}.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(AnsysNodeData::usage = "\<AnsysNodeData is a list which \
contains an entry for each of the nodes of the mesh. Each entry is a list \
with the following structure: {nodeNumber, xCoordinate, yCoordinate, \
zCoordinate, nodeTag}.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(ReadAnsysElements::usage = "\<ReadAnsysElements[fileName] \
attempts to read an Ansys element output file and, if successful, returns an \
object of the type AnsysElementData. The list contains an entry for each of \
the elements of the mesh. Each entry is a list with the following structure: \
{elementNumber, node1, node2, node3, node4, elementTag}.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(AnsysElementData::usage = "\<AnsysElementData is a list which \
contains an entry for each of the elements of the mesh. Each entry is a list \
with the following structure: {elementNumber, node1, node2, node3, node4, \
elementTag}.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(EquationsystTransient2D\ ::usage = "\<EquationDataTransient2D \
has the following structure \
{stiffnessMatrix,rightHandSide,initialConcentration,voronoiVolumes};  the \
stiffnessMatrix is represented in the sparse format {{i,j}\[Rule]val_ij, \
\[Ellipsis]}, so that the matrix entry at position (i,j) has value val_ij and \
all unspecified elements are taken to be zero.\>";\), 
      "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(EquationsystSteadyState2D::usage = "\<EquationDataSteadyState2D \
contains of two lists {stiffnessMatrix,rightHandSide}; the stiffnessMatrix is \
represented in the sparse format {{i,j}\[Rule]val_ij,\[Ellipsis]}, so that \
the matrix entry at position (i,j) has value val_ij and all unspecified \
elements are taken to be zero.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(CurrentPerDepthFunction2D::usage = \
"\<CurrentPerDepthFunction2D[electrode, EasymeshData, \
concentrationDistribution] where 'electrode' is an integer which refers to \
the boundary condition marker on the electrode boundary, EasymeshData is the \
mesh data generated by Easymesh and concentrationDistribution is a two \
dimensional vector which contains of one or more vectors of concentration, \
one for each timestep. 'CurrentPerDepthFunction2D' returns a current per \
meter (this represents the depth of the simulation domain), and hence has to \
be multiplied with a length (the depth, of course) to get the right value and \
units.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(CVPlotData::usage = "\<CVPlotData[current] takes a list of \
currents, usually generated in a CV-calculation, and returns a list which can \
be displayed with 'MultipleListPlot'.\>";\), "\[IndentingNewLine]"}], "\n", 
    RowBox[{\(Feldplot::usage = "\<Feldplot[EasymeshData, \
concentrationDistribution, timeStepInterval] takes EasymeshData, \
concentrationDistribution, which is a result either of an axi-symmetric or a \
2D simulation, and 'timeStepInterval', which is an integer which indicates \
the selected time interval steps which will be plotted.\>";\), 
      "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(WireFrameMeshWithBCNodes::usage = \
"\<wireFrameMeshWithBCNodes[Ansysdata] plots a 3D mesh using the data read \
from an Ansys-generated file. Boundary nodes whose tag is not equal to zero \
(tag =!= 0) are highlighted.\>";\), "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(WireFrameMeshWitRotation::usage = \
"\<wireFrameMeshWithRotation[Ansysdata] plots a 3D mesh using the data read \
from an Ansys-generated file. The plot allows real time rotations.\>";\), 
      "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(NeumannBoundaryValues::usage = "\<NeumannBoundaryValues have \
the following structure:\n {{{boundaryTag1_Species1, NeumannValue1_Species1}, \
{boundaryTag2_Species_1, NeumannValue2_Species1}, \[Ellipsis]} , \
{{boundaryTag1_Species2, NeumannValue1_Species2}, {boundaryTag2_Species2, \
NeumannValue2_Species2}, \[Ellipsis]}, \[Ellipsis]} where \
boundaryTag1_Species1 means that this sublist refers to the boundary \
condition which is applied to species 1 on the boundary which is marked with \
boundaryTag1. On this boundary 1 the value 'NeumannValue1_Species1' will be \
applied to the first species.\>";\), "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(SpecificConstants::usage = "\<Some useful constants:
\n\nFaradayConst = 9.648456*10^7,
\nGasConst       = 8314,
\nStandardTemp   = 273.15,
\nButler_Volmer  = \
(Exp[\[Alpha]*1*9.648456*10^7(e-eo)/(8314*273.15)])-(Exp[(1-)\[Alpha]*1*9.\
648456*10^7(e-eo)/(8314*273.15)]).\>";\), "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(DirichletBoundaryValues::usage = "\<The DirichletBoundaryValues \
have the following structure:\n-{{boundaryTag1, \
{speciesNumber1,speciesNumber2, \[Ellipsis]}, {DirichletValueForSpecies1, \
DirichletValueForSpecies2, \[Ellipsis]}}, {boundaryTag2, \[Ellipsis]}, \
\[Ellipsis]} where boundaryTag1 means that this sublist refers to the \
boundary which is marked with boundaryTag1. On this boundary the species with \
'speciesNumber1' has the Dirichlet value 'DirichletValueForSpecies1'. In the \
next sublist the next part of the boundary is considered.\>";\), 
      "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(ElectrodeReactionValues::usage = "\<The ElectrodeReactionValues \
have the following structure:\n{{boundaryTag1, speciesNumber1, \
speciesNumber2, ElectrodeValueForSpecies1, ElectrodeValueForSpecies2} \
{boundaryTag2, \[Ellipsis]}, \[Ellipsis]} where boundaryTag1 means that this \
sublist refers to the boundary which is marked with boundaryTag1. On this \
boundary the species with 'speciesNumber1' has the electrode value \
'DirichletValueForSpecies1'. ElectrodeReactionValues are applied as mixed \
boundary condition.\>";\), "\n"}], "\[IndentingNewLine]", 
    RowBox[{\(InitialData::usage = "\<For the calculations the following \
initial data is needed:
\n initialConcentrations: {concentrationSpecies1, concentrationSpecies2, \
\[Ellipsis]}. The structure is a list of concentration values at the \
beginning of the calculation. The position in the list indicates the species \
to which it belongs.
\n \[CapitalDelta]t: the timestep for the transient (or CV) calculations is a \
real number.
\n tges: the whole simulation time for transient (or CV) simulations is a \
real number.
\n Dif: {DiffusionCoefficientSpecies1, DiffusionCoefficientSpecies2, \
\[Ellipsis]}. The diffusion coefficients are contained in a list of diffusion \
coefficient values, one for each species. The position in the list indicates \
the species to which it belongs.\>";\), 
      "\[IndentingNewLine]"}], "\[IndentingNewLine]", \
\(McDonaldGeometryFunction::usage = "\<\>";\), "\[IndentingNewLine]", \
\(AnsysMcDonaldEquationSystemSteadyState3D::usage = "\<\>";\), "\
\[IndentingNewLine]", \(CurrentFunctionMcDonald3D::usage = "\<\>";\), "\
\[IndentingNewLine]", \(AnsysMcDonaldEquationSystemTrans3D::usage = \
"\<\>";\), "\[IndentingNewLine]", \
\(CurrentbyMatrix2DAxyssymetricFunction::usage = "\<\>";\), "\
\[IndentingNewLine]", \(CurrentbyMatrix2DAxyssymetricFunctionCV::usage = \
"\<\>";\), "\[IndentingNewLine]", \
\(CurrentThroughBoxFunction2DAxissymetr::usage = "\<\>";\), "\
\[IndentingNewLine]", \(CurrentThroughBoxFunction3D::usage = "\<\>";\), "\
\[IndentingNewLine]", \(ReadAnsysNodefile::usage = "\<\>";\), "\
\[IndentingNewLine]", \(ReadAnsisElementFile::usage = "\<\>";\), "\
\[IndentingNewLine]", \(WireFrameMeshWithBCNodesold::usage = "\<\>";\), "\
\[IndentingNewLine]", 
    RowBox[{\(WireFrameMeshWitRotationold::usage = "\<\>";\), 
      "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
    RowBox[{\(NodeinFlatFunction::usage = \
"\<NodeinFlatFunction[meshData,minVal,maxVal,koord], returns a list with \
nodenumber and two koordinates for each node. The variables minVal and maxVal \
define the boundaries of the gape which includes the nodes. The variable \
koord defines the koordinate that is constant (in the range of minVal and \
maxVal). It can have the 'values': x, y, z, X, Y or Z. \>";\), 
      "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
    RowBox[{\(CvMultistepCalculation::usage = \
"\<CvMultistepCalculation[EquationDataTransientCV,{{Tges , \[CapitalDelta]t , \
\[CapitalDelta]Estart , \[CapitalDelta]Eend}..}, potentialVariable] solves a \
time-dependent sparse linear system. The timesteps are of size \
\[CapitalDelta]t (the value of \[CapitalDelta]t should be equal the value \
used for \[CapitalDelta]t in CvCalculation ) and the full simulation time of \
one step is specified by totalTime. potentialVariable is the name of the \
variable used for the ElectrodeReactionValues (see EquationDataTransientCV). \
Its value starts with the startValue and extends to endValue. The simulation \
is divided into totalTime/\[CapitalDelta]t equal steps. To simulate a full \
standart cv-loop you need two sublists, where \[CapitalDelta]Eend of sublist \
1 is equal \[CapitalDelta]Estart of sublist 2. Also see EquationDataTransient \
and EquationDataTransientCV.\>";\), 
      "\[IndentingNewLine]"}], "\[IndentingNewLine]", 
    RowBox[{\(BoundarynodesFunction3D::usage = \
"\<BoundarynodesFunction[boundaryMarker, meshdata] returns a multi \
dimensional list with node data belonging to nodes which has the boundary tag \
boundaryMarker. The first sublist contains the node numbers. The second \
sublist contains the Coordinates of the nodes. The third, fourth and fifth \
lists contain the sorted X-,Y- and Z- coordinates. \>";\), 
      "\[IndentingNewLine]"}], "\[IndentingNewLine]", \
\(CVPlotDataMultiList::usage = "\<CVPlotDataMultiList[current,NrLoops] takes \
a list of currents, usually generated in a CvMultistepCalculation, and the \
number of potential loops (= number of sublists in CvMultistepCalculation[... \
,{{Tges , \[CapitalDelta]t , \[CapitalDelta]Estart , \[CapitalDelta]Eend}..}, \
... ) and returns a list which can be displayed with \
'MultipleListPlot'.\>";\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Options Docu", "Subsection"],

Cell[BoxData[{
    \(\(Off[
        Developer`SparseLinearSolve::"\<luc\>"];\)\), "\[IndentingNewLine]", 
    \(\(Off[
        Developer`SparseLinearSolve::"\<deprec\>"];\)\), \
"\[IndentingNewLine]", 
    \(\(Off[General::"\<spell1\>"];\)\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Error Messages", "Subsection"],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      Error\ Messages\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\)\)], "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Constructor", "Section",
  InitializationCell->True],

Cell[BoxData[{
    \( (*\ *) \[IndentingNewLine]\[IndentingNewLine]\(\(MakePoint[\ x_, \ 
          y_\ ]\  := \ Point[1. *\ x, 1. *\ y\ ];\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(MakeEasymeshVertex[\ p_Point, \ size_\ , \ bcnode_Integer, \ 
          bcedge_Integer\ ] := 
        EasymeshVertex[\ p, \ 1. *size\ , \ bcnode, \ bcedge\ ];\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(MakeEasymeshMaterialPoint\ [\ p_Point, \ size_\ , \ 
          materialCondition_Integer] := 
        EasymeshMaterialPoint\ [\ p, \ 1. *size\ , \ 
          materialCondition];\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(MakeEasymeshPolygon[\ vertex__EasymeshVertex\ ] := 
        EasymeshPolygon[\ vertex\ ];\)\(\n\)
    \)\), "\[IndentingNewLine]", 
    \(\(MakeEasymeshPolyLine[\ vertex__EasymeshVertex\ ] := 
        EasymeshPolyLine[\ vertex\ ];\)\), "\[IndentingNewLine]", 
    \(\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Start Private", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(Begin["\<`Private`\>"];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Needs - Private Imports", "Section"],

Cell[BoxData[{
    \(\(Needs["\<Calculus`VectorAnalysis`\>"];\)\), "\[IndentingNewLine]", 
    \(\(Needs["\<Graphics`MultipleListPlot`\>"];\)\), "\[IndentingNewLine]", 
    \(\(Needs["\<DiscreteMath`ComputationalGeometry`\>"];\)\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Options", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(\( (*\ *) \)\(\[IndentingNewLine]\)\( (*\ 
      define\ your\ options\ *) \)\(\[IndentingNewLine]\)\( (*\ *) \)\(\
\[IndentingNewLine]\)\( (*\ 
      Options[\ myFunctio\ ]\  = \ {\ 
          myOptionName\  \[Rule] \ myValue\ }\ *) \)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Selector", "Section"],

Cell[BoxData[{
    \(\(GetVertexData[
          EasymeshVertex[Point[x_, y_], size_, bcNode_, \ bcEdge_]] := {x, y, 
          size, bcNode, bcEdge};\)\), "\[IndentingNewLine]", 
    \(\(GetMaterialPointData[
          EasymeshMaterialPoint\ [\ Point[\ x_, \ y_\ ]\ , \ size_\ , \ 
            materialCondition_\ \ ]] := {\ x, y, size, 
          materialCondition\ };\)\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Predicates", "Section"],

Cell[BoxData[
    \(\(\( (*\ predicates\ *) \)\(\[IndentingNewLine]\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Functions", "Section",
  InitializationCell->True],

Cell[CellGroupData[{

Cell["WriteEasymeshInputData (*specified *) ", "Subsection"],

Cell[BoxData[
    \(\(WriteEasymeshInputData[
          easymeshPolygonInput_, \[IndentingNewLine]easymeshLineInput : \
{___EasymeshVertex}, 
          easymeshMaterialPointInput : {___Point}] := \[IndentingNewLine]\
\[IndentingNewLine]Module[\[IndentingNewLine]{polygonVerticesFunction, 
            pointFunction, LineVerticesFunction, allPolygons, polygons, 
            allLines, lines, points, easymeshData, 
            allVerticesPerLineFunction, 
            allVerticesPerPolygonFunction}, \n\[IndentingNewLine]allPolygons \
= Cases[easymeshPolygonInput, _EasymeshPolygon]; \n
          allVerticesPerPolygonFunction[j_] := 
            Module[{onePolygon, 
                polygonVertices}, \[IndentingNewLine]onePolygon = 
                Cases[allPolygons[\([j]\)], _EasymeshVertex]; \
\[IndentingNewLine]\[IndentingNewLine]polygonVerticesFunction[i_] := 
                GetVertexData[
                  onePolygon[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]polygonVertices = 
                polygonVerticesFunction /@ 
                  Range[Length[
                      onePolygon]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                polygonVertices];\[IndentingNewLine]]; \n
          polygons = 
            allVerticesPerPolygonFunction /@ 
              Range[Length[
                  allPolygons]]; \[IndentingNewLine]\[IndentingNewLine]\n
          allLines = Cases[easymeshLineInput, _EasymeshPolyLine]; \n
          allVerticesPerLineFunction[j_] := 
            Module[{oneLine, lineVertices}, \[IndentingNewLine]oneLine = 
                Cases[allLines[\([j]\)], _EasymeshVertex]; \
\[IndentingNewLine]\[IndentingNewLine]LineVerticesFunction[i_] := 
                GetVertexData[
                  oneLine[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]lineVertices = 
                LineVerticesFunction /@ 
                  Range[Length[
                      oneLine]]; \[IndentingNewLine]\[IndentingNewLine]Return[
                lineVertices];\[IndentingNewLine]]; \n
          lines = allVerticesPerLineFunction /@ 
              Range[Length[
                  allLines]]; \[IndentingNewLine]\[IndentingNewLine]\n
          pointFunction[k_] := 
            GetMaterialPointData[easymeshMaterialPointInput[\([k]\)]]; \n
          points = 
            pointFunction /@ 
              Range[Length[
                  easymeshMaterialPointInput]]; \[IndentingNewLine]\
\[IndentingNewLine]easymeshData = 
            WriteEasymeshInput[polygons, lines, 
              points]; \[IndentingNewLine]\[IndentingNewLine]Return[
            easymeshData];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(WriteEasymeshInput[
          polygone : {{{_Real | _Integer, _Real | _Integer, _Real | _Integer, \
_Integer, _Integer} .. } .. }, 
          lines : {{{_Real | _Integer, _Real | _Integer, _Real | _Integer, \
_Integer, _Integer} .. } .. }, 
          singlePoints : {{_Real | _Integer, _Real | _Integer, _Real | \
_Integer, _Integer} .. }] := \[IndentingNewLine]\[IndentingNewLine]Module[{i, 
            j, convertToEasymeshFormatpointspolygone, pointslines, 
            pointssinglePoints, sidepolygone, sidelines, pointInformation, 
            sidePolygonInformationFunktion, sideListPolygon, 
            sideLinesInformationFunktion, sideListLines, 
            strukturFunktionPolygon, strukturPolygon, strukturFunktionLines, 
            strukturLines, givePartII, vari11, structuredpolygonList, 
            givePart22, vari22, structuredLineList, seitenline, 
            linesseitenlist, xx, seitenpolygon, polygonseitenlistFunction, 
            joinedSides, outSides, outputSides, sidepolygoneFunktion, 
            pointspolygone, 
            sidelinesFunktion}, \
\[IndentingNewLine]\[IndentingNewLine]sidepolygoneFunktion[i_] := 
            polygone[\([i, 
                Range[Length[polygone[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidelinesFunktion[i_] := 
            lines[\([i, 
                Range[Length[lines[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidePolygonInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidepolygone[\([i, j, {1, 2}]\)]] - 1)\), 
                sidepolygone[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]sideLinesInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidelines[\([i, j, {1, 2}]\)]] - 1)\), 
                sidelines[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]strukturFunktionPolygon[i_] := 
            Length[sidepolygone[\([i]\)]]; \[IndentingNewLine]\
\[IndentingNewLine]strukturFunktionLines[i_] := 
            Length[sidelines[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]givePartII[
              p_] := {Take[vari11, 
                p], \(vari11 = 
                  Drop[vari11, 
                    p];\)}; \[IndentingNewLine]\[IndentingNewLine]givePart22[
              p_] := {Take[vari22, 
                p], \(vari22 = 
                  Drop[vari22, 
                    p];\)}; \
\[IndentingNewLine]\[IndentingNewLine]linesseitenlist[j_] := 
            For[i = 1, i < strukturLines[\([j]\)], \(i++\), 
              xx = RotateLeft[
                  Flatten[{Reverse[structuredLineList[\([j, i]\)]], 
                      structuredLineList[\([j, i + 1, 1]\)]}]]; 
              seitenline = 
                Append[seitenline, 
                  xx]]; \[IndentingNewLine]\[IndentingNewLine]\
polygonseitenlistFunction[j_] := 
            For[i = 1, i \[LessEqual] strukturPolygon[\([j]\)], \(i++\), 
              Which[i < strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, i + 1, 1]\)]}]]; 
                seitenpolygon = Append[seitenpolygon, xx], 
                i \[Equal] strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, 1, 1]\)]}]]; 
                seitenpolygon = 
                  Append[seitenpolygon, 
                    xx];]]; \
\[IndentingNewLine]\[IndentingNewLine]pointspolygone = \(Flatten[polygone, 
                1]\)[\([Range[Length[Flatten[polygone, 1]]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]pointslines = \
\(Flatten[lines, 
                1]\)[\([Range[Length[Flatten[lines, 1]]], {1, 2, 3, 
                  4}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]pointssinglePoints = 
            singlePoints[\([Range[Length[singlePoints]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]sidepolygone \
= sidepolygoneFunktion /@ 
              Range[Length[
                  polygone]]; \[IndentingNewLine]\[IndentingNewLine]sidelines \
= sidelinesFunktion /@ 
              Range[Length[
                  lines]]; \
\[IndentingNewLine]\[IndentingNewLine]pointInformation = 
            Transpose[
              Flatten[{{Range[0, 
                      Length[Union[pointspolygone, pointslines, 
                            pointssinglePoints]] - 1]}, 
                  Transpose[
                    Union[pointspolygone, pointslines, pointssinglePoints]]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]sideListPolygon = \
\(Apply[sidePolygonInformationFunktion, #] &\) /@ 
              Flatten[
                Table[{i, j}, {i, Length[sidepolygone]}, {j, 
                    Length[sidepolygone[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]sideListLines = \
\(Apply[sideLinesInformationFunktion, #] &\) /@ 
              Flatten[Table[{i, j}, {i, Length[sidelines]}, {j, 
                    Length[sidelines[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]strukturPolygon = 
            strukturFunktionPolygon /@ 
              Range[Length[
                  sidepolygone]]; \
\[IndentingNewLine]\[IndentingNewLine]strukturLines = 
            strukturFunktionLines /@ 
              Range[Length[
                  sidelines]]; \[IndentingNewLine]\[IndentingNewLine]vari11 = 
            sideListPolygon; \
\[IndentingNewLine]\[IndentingNewLine]structuredpolygonList = 
            Cases[Flatten[givePartII /@ strukturPolygon, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]vari22 = 
            sideListLines; \
\[IndentingNewLine]\[IndentingNewLine]structuredLineList = 
            Cases[Flatten[givePart22 /@ strukturLines, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]seitenline \
= {}; \[IndentingNewLine]\[IndentingNewLine]linesseitenlist /@ 
            Range[Length[
                strukturLines]]; \
\[IndentingNewLine]\[IndentingNewLine]seitenpolygon = {}; \[IndentingNewLine]\
\[IndentingNewLine]polygonseitenlistFunction /@ 
            Range[Length[
                strukturPolygon]]; \
\[IndentingNewLine]\[IndentingNewLine]joinedSides = 
            Join[seitenpolygon, 
              seitenline]; \[IndentingNewLine]\[IndentingNewLine]outSides = \
{}; \[IndentingNewLine]\[IndentingNewLine]For[i = 1, 
            i \[LessEqual] Length[joinedSides], \(i++\), 
            If[MemberQ[outSides, joinedSides[\([i]\)]], Null, 
              outSides = 
                Append[outSides, 
                  joinedSides[\([i]\)]]]]; \[IndentingNewLine]\
\[IndentingNewLine]outputSides = 
            Transpose[
              Flatten[{{Range[0, Length[outSides] - 1]}, 
                  Transpose[outSides]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
pointInformation, outputSides}]];\)\)], "Input"],

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(WriteEasymeshInput[polygone_, lines_, 
          singlePoints_] := \[IndentingNewLine]\[IndentingNewLine]Module[{i, 
            j, convertToEasymeshFormatpointspolygone, pointslines, 
            pointssinglePoints, sidepolygone, sidelines, pointInformation, 
            sidePolygonInformationFunktion, sideListPolygon, 
            sideLinesInformationFunktion, sideListLines, 
            strukturFunktionPolygon, strukturPolygon, strukturFunktionLines, 
            strukturLines, givePartII, vari11, structuredpolygonList, 
            givePart22, vari22, structuredLineList, seitenline, 
            linesseitenlist, xx, seitenpolygon, polygonseitenlistFunction, 
            joinedSides, outSides, outputSides, sidepolygoneFunktion, 
            pointspolygone, 
            sidelinesFunktion}, \
\[IndentingNewLine]\[IndentingNewLine]sidepolygoneFunktion[i_] := 
            polygone[\([i, 
                Range[Length[polygone[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidelinesFunktion[i_] := 
            lines[\([i, 
                Range[Length[lines[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidePolygonInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidepolygone[\([i, j, {1, 2}]\)]] - 1)\), 
                sidepolygone[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]sideLinesInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidelines[\([i, j, {1, 2}]\)]] - 1)\), 
                sidelines[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]strukturFunktionPolygon[i_] := 
            Length[sidepolygone[\([i]\)]]; \[IndentingNewLine]\
\[IndentingNewLine]strukturFunktionLines[i_] := 
            Length[sidelines[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]givePartII[
              p_] := {Take[vari11, 
                p], \(vari11 = 
                  Drop[vari11, 
                    p];\)}; \[IndentingNewLine]\[IndentingNewLine]givePart22[
              p_] := {Take[vari22, 
                p], \(vari22 = 
                  Drop[vari22, 
                    p];\)}; \
\[IndentingNewLine]\[IndentingNewLine]linesseitenlist[j_] := 
            For[i = 1, i < strukturLines[\([j]\)], \(i++\), 
              xx = RotateLeft[
                  Flatten[{Reverse[structuredLineList[\([j, i]\)]], 
                      structuredLineList[\([j, i + 1, 1]\)]}]]; 
              seitenline = 
                Append[seitenline, 
                  xx]]; \[IndentingNewLine]\[IndentingNewLine]\
polygonseitenlistFunction[j_] := 
            For[i = 1, i \[LessEqual] strukturPolygon[\([j]\)], \(i++\), 
              Which[i < strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, i + 1, 1]\)]}]]; 
                seitenpolygon = Append[seitenpolygon, xx], 
                i \[Equal] strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, 1, 1]\)]}]]; 
                seitenpolygon = 
                  Append[seitenpolygon, 
                    xx];]]; \
\[IndentingNewLine]\[IndentingNewLine]pointspolygone = \(Flatten[polygone, 
                1]\)[\([Range[Length[Flatten[polygone, 1]]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]pointslines = \
\(Flatten[lines, 
                1]\)[\([Range[Length[Flatten[lines, 1]]], {1, 2, 3, 
                  4}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]pointssinglePoints = 
            singlePoints[\([Range[Length[singlePoints]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]sidepolygone \
= sidepolygoneFunktion /@ 
              Range[Length[
                  polygone]]; \[IndentingNewLine]\[IndentingNewLine]sidelines \
= sidelinesFunktion /@ 
              Range[Length[
                  lines]]; \
\[IndentingNewLine]\[IndentingNewLine]pointInformation = 
            Transpose[
              Flatten[{{Range[0, 
                      Length[Union[pointspolygone, pointslines, 
                            pointssinglePoints]] - 1]}, 
                  Transpose[
                    Union[pointspolygone, pointslines, pointssinglePoints]]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]sideListPolygon = \
\(Apply[sidePolygonInformationFunktion, #] &\) /@ 
              Flatten[Table[{i, j}, {i, Length[sidepolygone]}, {j, 
                    Length[sidepolygone[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]sideListLines = \
\(Apply[sideLinesInformationFunktion, #] &\) /@ 
              Flatten[Table[{i, j}, {i, Length[sidelines]}, {j, 
                    Length[sidelines[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]strukturPolygon = 
            strukturFunktionPolygon /@ 
              Range[Length[
                  sidepolygone]]; \
\[IndentingNewLine]\[IndentingNewLine]strukturLines = 
            strukturFunktionLines /@ 
              Range[Length[
                  sidelines]]; \[IndentingNewLine]\[IndentingNewLine]vari11 = 
            sideListPolygon; \
\[IndentingNewLine]\[IndentingNewLine]structuredpolygonList = 
            Cases[Flatten[givePartII /@ strukturPolygon, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]vari22 = 
            sideListLines; \
\[IndentingNewLine]\[IndentingNewLine]structuredLineList = 
            Cases[Flatten[givePart22 /@ strukturLines, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]seitenline \
= {}; \[IndentingNewLine]\[IndentingNewLine]linesseitenlist /@ 
            Range[Length[
                strukturLines]]; \
\[IndentingNewLine]\[IndentingNewLine]seitenpolygon = {}; \[IndentingNewLine]\
\[IndentingNewLine]polygonseitenlistFunction /@ 
            Range[Length[
                strukturPolygon]]; \
\[IndentingNewLine]\[IndentingNewLine]joinedSides = 
            Join[seitenpolygon, 
              seitenline]; \[IndentingNewLine]\[IndentingNewLine]outSides = \
{}; \[IndentingNewLine]\[IndentingNewLine]For[i = 1, 
            i \[LessEqual] Length[joinedSides], \(i++\), 
            If[MemberQ[outSides, joinedSides[\([i]\)]], Null, 
              outSides = 
                Append[outSides, 
                  joinedSides[\([i]\)]]]]; \[IndentingNewLine]\
\[IndentingNewLine]outputSides = 
            Transpose[
              Flatten[{{Range[0, Length[outSides] - 1]}, 
                  Transpose[outSides]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
pointInformation, outputSides}]];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["RunEasymesh (*specified *)", "Subsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{\(RunEasymesh[
          geometyData : {pointInformation : {{_Real | _Integer, _Real | \
_Integer, _Real | _Integer, _Real | _Integer, _Integer} .. }, 
              outputSides : {{_Real | _Integer, _Real | _Integer, _Real | \
_Integer, _Real | _Integer} .. } .. }]\), ":=", "\[IndentingNewLine]", 
        RowBox[{"Module", "[", "\[IndentingNewLine]", 
          
          RowBox[{\({easyMeshBaseName, BuildEasyMeshBaseName, easyMeshFile}\),
             ",", "\[IndentingNewLine]", 
            
            RowBox[{\(easyMeshBaseName = 
                StringJoin["\</tmp/\>", $UserName, 
                  PadRight[Characters[ToString[Random[Integer, 99999999]]], 
                    8]]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(BuildEasyMeshBaseName[] := 
                easyMeshBaseName /; $OperatingSystem \[Equal] "\<Unix\>"\), 
              ";", "\n", \(BuildEasyMeshBaseName[] := 
                Block[{}, Print["\<Not yet implemented\>"]; Abort[]]\), ";", 
              "\n", \(easyMeshFile = StringJoin[easyMeshBaseName, "\<.d\>"]\),
               ";", "\n", 
              RowBox[{
                StyleBox["Export",
                  Background->GrayLevel[1]], 
                StyleBox["[",
                  Background->GrayLevel[1]], 
                RowBox[{
                  StyleBox["easyMeshFile",
                    Background->GrayLevel[1]], 
                  StyleBox[",",
                    Background->GrayLevel[1]], 
                  RowBox[{
                    StyleBox["Join",
                      Background->GrayLevel[1]], 
                    StyleBox["[",
                      Background->GrayLevel[1]], 
                    RowBox[{
                      StyleBox[\({"\< \>"}\),
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      
                      StyleBox[\({Length[
                              geometyData[\([1]\)]] "\< \>" "\<#Points#\>"}\),
                        
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      StyleBox[\(geometyData[\([1]\)]\),
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      StyleBox[\({"\< \>"}\),
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      RowBox[{
                        StyleBox["{",
                          Background->GrayLevel[1]], 
                        RowBox[{
                          RowBox[{
                            StyleBox["Length",
                              Background->GrayLevel[1]], 
                            StyleBox["[",
                              Background->GrayLevel[
                              1]], \(geometyData[\([2]\)]\), 
                            StyleBox["]",
                              Background->GrayLevel[1]]}], 
                          StyleBox["\"\< \>\"",
                            Background->GrayLevel[1]], 
                          StyleBox["\"\<#Segments#\>\"",
                            Background->GrayLevel[1]]}], 
                        StyleBox["}",
                          Background->GrayLevel[1]]}], 
                      StyleBox[",",
                        Background->GrayLevel[1]], \(geometyData[\([2]\)]\)}],
                     
                    StyleBox["]",
                      Background->GrayLevel[1]]}], 
                  StyleBox[",",
                    Background->GrayLevel[1]], 
                  StyleBox["\"\<Table\>\"",
                    Background->GrayLevel[1]]}], 
                StyleBox["]",
                  Background->GrayLevel[1]]}], 
              StyleBox[";",
                Background->GrayLevel[1]], "\n", 
              RowBox[{
                StyleBox["Run",
                  Background->GrayLevel[1]], 
                StyleBox["[",
                  Background->GrayLevel[1]], 
                RowBox[{"StringJoin", "[", 
                  StyleBox[\("\<easymesh \>", \ easyMeshFile\),
                    Background->GrayLevel[1]], 
                  StyleBox["]",
                    Background->GrayLevel[1]]}], "]"}], 
              StyleBox[";",
                Background->GrayLevel[1]], "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[easyMeshBaseName]\)}]}], 
          "\[IndentingNewLine]", "]"}]}], ";"}]], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["ReadEasymesh (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(Off[Read::"\<readn\>"]\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(ReadEasymesh[
          fileName_String] \
:= \[IndentingNewLine]Module[\[IndentingNewLine]{readEasymeshFormat, 
            easymeshNode, nodefile, easymeshSide, sidefile, easymeshElement, 
            elementfile}, \[IndentingNewLine]easymeshNode = 
            OpenRead[StringJoin[fileName, "\<.n\>"]]; \[IndentingNewLine]\n
          Read[easymeshNode, {Number}]; \nnodefile = {}; \n
          nodefile = 
            ReadList[
              easymeshNode, {Number, Character, Real, Real, Number}]; \n
          Close[easymeshNode]; \n
          nodefile = Drop[Transpose[nodefile], {2, 2}]; \n
          nodefile[\([1]\)] = nodefile[\([1]\)] + 1; \n
          nodefile = 
            Transpose[
              nodefile]; \[IndentingNewLine]\[IndentingNewLine]easymeshSide = 
            OpenRead[StringJoin[fileName, "\<.s\>"]]; \n
          Read[easymeshSide, {Number}]; \nsidefile = {}; \n
          sidefile = 
            ReadList[
              easymeshSide, {Number, Character, Number, Number, Number, 
                Number, Number}]; \nClose[easymeshSide]; \n
          sidefile = Drop[Transpose[sidefile], {2}]; \n
          sidefile[\([1]\)] = sidefile[\([1]\)] + 1; \n
          sidefile[\([2]\)] = sidefile[\([2]\)] + 1; \n
          sidefile[\([3]\)] = sidefile[\([3]\)] + 1; \n
          sidefile[\([4]\)] = sidefile[\([4]\)] + 1; \n
          sidefile[\([5]\)] = sidefile[\([5]\)] + 1; \n
          sidefile = 
            Transpose[
              sidefile]; \
\[IndentingNewLine]\[IndentingNewLine]easymeshElement = 
            OpenRead[StringJoin[fileName, "\<.e\>"]]; \n
          Read[easymeshElement, {Number}]; \nelementfile = {}; \n
          elementfile = 
            ReadList[
              easymeshElement, {Number, Character, Number, Number, Number, 
                Number, Number, Number, Number, Number, Number, Real, Real, 
                Number}]; \nClose[easymeshElement]; \n
          elementfile = Drop[Transpose[elementfile], {2}]; \n
          elementfile[\([1]\)] = elementfile[\([1]\)] + 1; \n
          elementfile[\([2]\)] = elementfile[\([2]\)] + 1; \n
          elementfile[\([3]\)] = elementfile[\([3]\)] + 1; \n
          elementfile[\([4]\)] = elementfile[\([4]\)] + 1; \n
          elementfile[\([5]\)] = elementfile[\([5]\)] + 1; \n
          elementfile[\([6]\)] = elementfile[\([6]\)] + 1; \n
          elementfile[\([7]\)] = elementfile[\([7]\)] + 1; \n
          elementfile[\([8]\)] = elementfile[\([8]\)] + 1; \n
          elementfile[\([9]\)] = elementfile[\([9]\)] + 1; \n
          elementfile[\([10]\)] = elementfile[\([10]\)] + 1; \n
          elementfile = 
            Transpose[
              elementfile]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]Return[{nodefile, sidefile, 
              elementfile}]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation GeometryFunction2DAxisSymmetric  (*specified \
*)\
\>", "Subsection"],

Cell[BoxData[
    \(\(GeometryFunction2DAxisSymmetric[
          easymeshData : {nodeList : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementList : {\(({_Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, _Real, \
_Integer})\) .. }}] := \[IndentingNewLine]Module[{nodeNumbersPerElement, 
            coordinatesPerElementFunction, coordinatesPerElement, 
            lengthOfElementsidesFunction, lengthOfElementsides, 
            boxSideLengthFunction, boxSideLength, volumeOfVoronoiPart, 
            radiusOfCelFunction, radiusOfCel, radiusOfFluxFunction, 
            radiusOfFlux, 
            numberOfNodes}, \
\[IndentingNewLine]\[IndentingNewLine]nodeNumbersPerElement = \(easymeshData[\
\([3]\)]\)[\([All, {2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]numberOfNodes \
= easymeshData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine]\[IndentingNewLine]\
coordinatesPerElementFunction[
              i_] := \(\(easymeshData\[LeftDoubleBracket]1\
\[RightDoubleBracket]\)\[LeftDoubleBracket]
                All, {2, 3}\[RightDoubleBracket]\)\[LeftDoubleBracket]
              i\[RightDoubleBracket]; \n
          coordinatesPerElement = 
            coordinatesPerElementFunction /@ 
              nodeNumbersPerElement; \
\[IndentingNewLine]\[IndentingNewLine]lengthOfElementsides = 
            Transpose[{Apply[
                    Plus, \((coordinatesPerElement[\([All, 1]\)] - 
                          coordinatesPerElement[\([All, 2]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((coordinatesPerElement[\([All, 1]\)] - 
                          coordinatesPerElement[\([All, 3]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((coordinatesPerElement[\([All, 2]\)] - 
                          coordinatesPerElement[\([All, 
                              3]\)])\)^2, {1}]^0.5}]; \[IndentingNewLine]\
\[IndentingNewLine]boxSideLength = 
            Transpose[{Apply[
                    Plus, \((\((\((coordinatesPerElement[\([All, 1]\)] + 
                                  coordinatesPerElement[\([All, 2]\)])\)/
                              2)\) - \(easymeshData[\([3]\)]\)[\([All, {11, 
                                12}]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((\((\((coordinatesPerElement[\([All, 1]\)] + 
                                  coordinatesPerElement[\([All, 3]\)])\)/
                              2)\) - \(easymeshData[\([3]\)]\)[\([All, {11, 
                                12}]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((\((\((coordinatesPerElement[\([All, 2]\)] + 
                                  coordinatesPerElement[\([All, 3]\)])\)/
                              2)\) - \(easymeshData[\([3]\)]\)[\([All, {11, 
                                12}]\)])\)^2, {1}]^0.5}]; \[IndentingNewLine]\
\[IndentingNewLine]volumeOfVoronoiPart = 
            boxSideLength*
              lengthOfElementsides/
                4; \[IndentingNewLine]\[IndentingNewLine]radiusOfCel = 
            Transpose[{\((\((\((\((coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 1, 1]\)])\)/
                    3)\), \[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 1, 1]\)])\)/
                    3)\), \[IndentingNewLine]\[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 2, 1]\)])\)/
                    3)\), \[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 3, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 2, 1]\)])\)/
                    3)\), \[IndentingNewLine]\[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 3, 1]\)])\)/
                    3)\), \[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 2, 1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 3, 1]\)])\)/
                    3)\)}]; \
\[IndentingNewLine]\[IndentingNewLine]radiusOfFlux = 
            Transpose[{\((\((\((\((coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)])\)/
                    2)\), \((\((\((\((coordinatesPerElement[\([All, 1, 
                                    1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)])\)/
                    2)\), \((\((\((\((coordinatesPerElement[\([All, 2, 
                                    1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)])\)/
                    2)\)}]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]Return[{boxSideLength, lengthOfElementsides, 
              nodeNumbersPerElement, numberOfNodes, radiusOfCel, 
              radiusOfFlux, volumeOfVoronoiPart}]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation EquationsystemSteadyState2DAxisSymmetric  \
(*specified *)\
\>", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox["EquationsystemSteadyState2DAxisSymmetric",
            FontVariations->{"CompatibilityType"->0}], "[", 
          "\[IndentingNewLine]", \(geometry : {boxSideLengthvariable : \
{\(({_Real, _Real, _Real})\) .. }, \
\[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : \
{\((_Real | _Integer)\) .. }, \[IndentingNewLine]initialConcentrations : \
{\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \
\((_Real | _Integer)\)}, ___})\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, \
{_Integer, _Integer}, {_Real | _Integer, _Real | _Integer}})\) .. }\), 
          "\[IndentingNewLine]", "]"}], ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              concentrationFunction, elektrodenVariablen, 
              elektrodenVariablenFunktion, punktkombinationenFunktion}\), ",",
             "\[IndentingNewLine]", "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = geometry[\([5]\)]\),
               ";", "\[IndentingNewLine]", \(radiusOfFlux = 
                geometry[\([6]\)]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction}\), ",", 
                    "\[IndentingNewLine]", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"x", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 1]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 1]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"y", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 2]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 2]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"z", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 3]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 3]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(u = 
                        nodeNumbersPerElement[\([i, 1]\)]\), ";", 
                      "\[IndentingNewLine]", \(v = 
                        nodeNumbersPerElement[\([i, 2]\)]\), ";", 
                      "\[IndentingNewLine]", \(w = 
                        nodeNumbersPerElement[\([i, 3]\)]\), ";", 
                      "\[IndentingNewLine]", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj; \[IndentingNewLine]a[
                              j1v, j1v] += \((x + z)\)*
                              dj; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*
                              dj; \[IndentingNewLine]\[IndentingNewLine]a[
                              j1u, j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 
                  initialConcentrations[\([j]\)]\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", 
              "\n", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  vectorOfConcentrations}]\)}]}], "\[IndentingNewLine]", 
          "]"}]}], ";"}]], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation EquationsystTransient2DAxisSymmetric  (*specified *)\
\
\>", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox["EquationsystTransient2DAxisSymmetric",
            FontVariations->{"CompatibilityType"->0}], 
          "[", \(geometry : {boxSideLengthvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, \
_Real, _Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]Dif : {\((_Real | _Integer)\) \
.. }, \[IndentingNewLine]timeStep : \((_Real | _Integer)\), \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \((_Real | \
_Integer)\)}, ___})\) .. }, \[IndentingNewLine]electrodeReactionValues : \
{\(({\ \ \ _Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | \
_Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, 
          dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, {_Real | \
_Integer, _Real | _Integer}})\) .. }\), "]"}], ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, 
              vectorOfConcentrationsFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              vectorOfVolumes, concentrationFunction, 
              elektrodenVariablenFunktion, elektrodenVariablen, 
              punktkombinationenFunktion}\), ",", "\[IndentingNewLine]", 
            "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = geometry[\([5]\)]\),
               ";", "\[IndentingNewLine]", \(radiusOfFlux = 
                geometry[\([6]\)]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", 
              " ", \( (*\(\(**\)\(\ \)\(wenn\)\)\ volumeOfVoronoiPart = 
                  0\ gesetzt\ wird, \ 
                dann\ haben\ wir\ den\ steady\ state\ Fall\ ***) \), 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction, geom, r, 
                      s, t, transPart}\), ",", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"geom", "=", 
                        RowBox[{"boxSideLength", 
                          StyleBox["/",
                            FontColor->GrayLevel[0]], 
                          "lengthOfElementsides"}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ x = 
                          radiusOfFlux[\([i, 1]\)]*
                            geom[\([i, 1]\)]; \[IndentingNewLine]y = 
                          radiusOfFlux[\([i, 2]\)]*
                            geom[\([i, 2]\)]; \[IndentingNewLine]z = 
                          radiusOfFlux[\([i, 3]\)]*geom[\([i, 3]\)];\ \ *) \),
                       "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({x, y, z} = 
                        radiusOfFlux[\([i]\)]*geom[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(transPart = 
                        volumeOfVoronoiPart/timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(r = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 1]\)] + 
                          transPart[\([i, 2]\)] radiusOfCel[\([i, 2]\)]\), 
                      ";", "\[IndentingNewLine]", \(s = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 3]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 4]\)]\), 
                      ";", "\[IndentingNewLine]", \(t = 
                        transPart[\([i, 2]\)] radiusOfCel[\([i, 5]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 6]\)]\), 
                      ";", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ \ \ \ \ u = 
                          nodeNumbersPerElement[\([i, 
                              1]\)]; \[IndentingNewLine]v = 
                          nodeNumbersPerElement[\([i, 
                              2]\)]; \[IndentingNewLine]w = 
                          nodeNumbersPerElement[\([i, 3]\)];\ \ \ \ *) \), 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({u, v, w} = 
                        nodeNumbersPerElement[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction[j_] := 
                        Module[{}, \[IndentingNewLine]rightHandSideVector[\([\
\((j - 1)\)*numberOfNodes + u]\)] += 
                            r; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + v]\)] += 
                            s; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + w]\)] += t;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction /@ Range[Length[Dif]]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(vectorOfVolumes = 
                        rightHandSideVector*timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj + 
                              r; \[IndentingNewLine]a[j1v, 
                              j1v] += \((x + z)\)*dj + 
                              s; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*dj + 
                              t; \[IndentingNewLine]\[IndentingNewLine]a[j1u, 
                              j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrationsFunction[i_] := 
                Table[initialConcentrations[\([i]\)], {numberOfNodes}]\), ";",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Flatten[
                  vectorOfConcentrationsFunction /@ 
                    Range[Length[initialConcentrations]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 1\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  rightHandSideVector, vectorOfConcentrations, 
                  vectorOfVolumes}]\)}]}], "\[IndentingNewLine]", "]"}]}], 
      ";"}]], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentFunction2DAxisSymmetric (*specified *)", \
"Subsection",
  InitializationCell->True],

Cell["\<\
just the voronoi area is considered, not the area on the boundary. \
The current flows not just through the area between the nodes, but through \
the whole Voronoi box area (additional boundary part on the edge of a \
boundary side)\
\>", "Text",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(CurrentFunction2DAxisSymmetric[
        dieElektrode_Integer, \[IndentingNewLine]dritens : {nodeListvariable \
: {\(({_Integer, _Real, _Real, _Integer})\) .. }, \
\[IndentingNewLine]sideListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer})\) .. }, \[IndentingNewLine]elementListvariable \
: {\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Real, _Real, _Integer})\) .. }}, 
        concDistribution : {{\((_Real)\) .. } .. }] := 
      Module[{sideMarcs, sideposition, pointNumbersFunction, pointNumbers, i, 
          j, k, sidesToNeighboursFunction, sidesToNeighbours, 
          nodeAndNeighbourFunction, nodeAndNeighbour, allCoordinatesFunction, 
          allCoordinates, currentWithoutDifCoef, deltaTimesEveridgeFunktion, 
          deltaTimesEveridge, elementNumberFunction, elementNumber, 
          sortierenFunction, sortieren, startAndEndNodeFunktion, 
          startAndEndNode, stromFunction, totalCurrent, 
          voronoiLengthFunction, 
          voronoiLength}, \[IndentingNewLine]\  (*dieElektrode = 
            2; \ \ bestimmt\ die\ Elektrode, \ 
          an\ der\ der\ Strom\ berechnet\ wird\ *) \[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]sideMarcs = \(Transpose[
              dritens[\([2]\)]]\)[\([6]\)]\ ;  (*gibt\ die\ Randmarker\
*) \[IndentingNewLine]\[IndentingNewLine]sideposition = 
          Flatten[Position[sideMarcs, 
              dieElektrode]];  (*gibt\ die\ Positionen\ der\ \
elektrodenraender*) \[IndentingNewLine]\[IndentingNewLine]\
pointNumbersFunction[
            i_] := \(\(dritens[\([2]\)]\)[\([i]\)]\)[\([{2, 
                3}]\)];  (*gibt\ die\ Punktnummern\ der\ Electrode\
*) \[IndentingNewLine]pointNumbers = 
          Flatten[pointNumbersFunction /@ 
              sideposition]; \
\[IndentingNewLine]\[IndentingNewLine]sidesToNeighboursFunction[
            i_] := \(Transpose[
              Position[\(Transpose[dritens[\([2]\)]]\)[\([{2, 3}]\)], 
                i]]\)[\([2]\)];  (*gibt\ eine\ Liste\ der\ Seiten, \ 
          die\ den\ Electrodenpunkt\ \
enthalten*) \[IndentingNewLine]sidesToNeighbours = 
          sidesToNeighboursFunction /@ 
            pointNumbers; \
\[IndentingNewLine]\[IndentingNewLine]nodeAndNeighbourFunction[
            k_] := \(Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{2, 
                    3}]\)]]\)[\([k]\)];  (*gibt\ eine\ Liste\ mit\ dem\ \
Electrodenpunkt\ und\ seinen\ Nachbarn*) \[IndentingNewLine]nodeAndNeighbour \
= nodeAndNeighbourFunction /@ 
            sidesToNeighbours; \
\[IndentingNewLine]\[IndentingNewLine]allCoordinatesFunction[j_] := 
          Module[{coordinateFunction, 
              coordinate}, \[IndentingNewLine]coordinateFunction[
                i_] := \((Abs[\(\(Transpose[\(Transpose[
                                dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([1]\)] - \
\(\(Transpose[\(Transpose[dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([2]\)]])\) . {0, 
                  1};  (*gibt\ die\ Differenz\ der\ Koordinaten\ des\ Punktes\
\ und\ seines\ Nachbarn\ mal\ der\ Normalenrichtung*) \n
            coordinate = 
              coordinateFunction /@ 
                nodeAndNeighbour[\([j]\)]\[IndentingNewLine]]; \
\[IndentingNewLine]allCoordinates = 
          allCoordinatesFunction /@ 
            Range[Length[
                nodeAndNeighbour]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]sortierenFunction[i_] := Sort[i]; \n
        sortieren = 
          sortierenFunction /@ 
            Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{4, 
                    5}]\)]];  (*die\ Elementnummern\ an\ beiden\ Seiten\ \
aller\ Punktverbindungen\ im\ Gebiet; \ 
          die\ Elementnummern\ sind\ sortiert\ um\ Randelemente\ behandeln\ \
zu\ koennen*) \n\n
        elementNumberFunction[i_] := 
          sortieren[\([i]\)];  (*gibt\ die\ Elemente\ zu\ beiden\ Seiten\ der\
\ Verbindungsseite*) \n
        elementNumber = elementNumberFunction /@ sidesToNeighbours; \n\n
        startAndEndNodeFunktion[j_] := 
          Module[{startAndEndNodeFunktionII, 
              startAndEndNodeII}, \
\[IndentingNewLine]startAndEndNodeFunktionII[
                i_] := \(Transpose[\(Transpose[
                      dritens[\([2]\)]]\)[\([{2, 
                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                      i]\)]]\)];  (*das\ sind\ die\ Punkte\ zur\ Seite*) \n
            startAndEndNodeII = 
              startAndEndNodeFunktionII /@ 
                Range[Length[
                    sidesToNeighbours[\([j]\)]]]; \[IndentingNewLine]Return[
              startAndEndNodeII]\[IndentingNewLine]]; \n
        startAndEndNode = 
          startAndEndNodeFunktion /@ 
            Range[Length[
                sidesToNeighbours]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\n
        voronoiLengthFunction[j_] := 
          Module[{voronoiLengthFunctionII, 
              voronoiLengthII}, \[IndentingNewLine]voronoiLengthFunctionII[
                i_] := If[elementNumber[\([j, i, 1]\)] > 0.1, 
                Apply[Plus, \((\(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([1]\)]]\)] - \
\(Transpose[\(Transpose[dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5, 
                Apply[Plus, \((\((\(\(Transpose[\(Transpose[
                                        dritens[\([1]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([startAndEndNode[\([j, 
                                        i]\)]]\)]\)[\([1]\)] + \(\(Transpose[\
\(Transpose[dritens[\([1]\)]]\)[\([{2, 3}]\)]]\)[\([\(Transpose[\(Transpose[
                                        dritens[\([2]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                                        i]\)]]\)]]\)]\)[\([2]\)])\)/
                            2 - \(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5]; \
\[IndentingNewLine]voronoiLengthII = 
              voronoiLengthFunctionII /@ 
                Range[Length[
                    elementNumber[\([j]\)]]]; \[IndentingNewLine]Return[
              voronoiLengthII]\[IndentingNewLine]]; \n
        voronoiLength = 
          voronoiLengthFunction /@ 
            Range[Length[
                elementNumber]]; \
\[IndentingNewLine]\[IndentingNewLine]stromFunction[k_] := 
          Module[{conzDifferenceFunction, conzDifference, conzTimesSij, 
              gradientFunction, gradientsI, 
              strom}, \[IndentingNewLine]\[IndentingNewLine]\
conzDifferenceFunction[i_] := 
              Module[{conzDifferenceTwoFunction, 
                  conzDifferenceTwo}, \
\[IndentingNewLine]conzDifferenceTwoFunction[j_] := 
                  k[\([nodeAndNeighbour[\([i, j, 2]\)]]\)] - 
                    k[\([nodeAndNeighbour[\([i, j, 
                            1]\)]]\)];  (*gibt\ die\ \
Konzentrationsdifferenz\ \ i = Hauptpunkt, \ 
                  j = Hauptpunkt\ und\ ein\ Nachbar*) \n
                conzDifferenceTwo = 
                  conzDifferenceTwoFunction /@ 
                    Range[Length[
                        nodeAndNeighbour[\([i]\)]]]\[IndentingNewLine]]; \n
            conzDifference = 
              conzDifferenceFunction /@ 
                Range[Length[
                    nodeAndNeighbour]]; \
\[IndentingNewLine]\[IndentingNewLine]\n
            conzTimesSij = 
              conzDifference*voronoiLength*\[Pi]; \[IndentingNewLine]\n
            gradientFunction[i_] := 
              Module[{gradientToOneNode, 
                  gradientToOneNodeFunction}, \
\[IndentingNewLine]gradientToOneNodeFunction[j_] := \[IndentingNewLine]If[
                    allCoordinates[\([i, j]\)] =!= 0. , 
                    conzTimesSij[\([i, j]\)]/allCoordinates[\([i, j]\)], 
                    0. ]; \ngradientToOneNode = 
                  Apply[Plus, 
                    gradientToOneNodeFunction /@ 
                      Range[Length[
                          nodeAndNeighbour[\([i]\)]]]]\[IndentingNewLine]]; \n
            gradientsI = 
              gradientFunction /@ 
                Range[Length[
                    nodeAndNeighbour]];  (*gibt\ den\ Gradienten\ zum\ Punkt\ \
in\ der\ Normalenrichtung*) \[IndentingNewLine]\[IndentingNewLine]strom = 
              Apply[Plus, 
                gradientsI]; \[IndentingNewLine]\[IndentingNewLine]Return[
              strom]\[IndentingNewLine]]; \n\
\[IndentingNewLine]currentWithoutDifCoef = 
          stromFunction /@ 
            concDistribution; \[IndentingNewLine]\[IndentingNewLine]Return[
          currentWithoutDifCoef];\[IndentingNewLine]]\)\(\[IndentingNewLine]\)\
\(\[IndentingNewLine]\)
    \)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentbyMatrix2DAxyssymetricFunction", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(CurrentbyMatrix2DAxyssymetricFunction[equationSystemSteady_, 
          concDistribution_, electrode_, meshData_] := 
        Module[{CurrentbyMatrix2DAxyssymetricFunctionII, 
            current}, \
\[IndentingNewLine]\[IndentingNewLine]CurrentbyMatrix2DAxyssymetricFunctionVV[
              concDistributionSteady_] := 
            Module[{NodesOnElectrode, matrixElementFunction, matrixElements, 
                gradientFunction, 
                currentII}, \
\[IndentingNewLine]\[IndentingNewLine]NodesOnElectrode = 
                Flatten[
                  Position[meshData[\([1, All, 4]\)], electrode]]; \  (*\ 
                die\ Randpunkte\ *) \n\
\[IndentingNewLine]matrixElementFunction[i_] := 
                Module[{rowOfNodesOnElectrode, columnOfNodesOnElectrode, 
                    diagonalElement, nonDiagonalElements, 
                    nonDiagonalSparsMatrixEntrys}, \
\[IndentingNewLine]rowOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 1]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Zeileneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]columnOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 2]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Spalteneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]diagonalElement = 
                    Intersection[rowOfNodesOnElectrode, 
                      columnOfNodesOnElectrode];  (*\ das\ Element, \ 
                    das\ sowohl\ zur\ zeile\ wie\ auch\ zur\ Spalte\ gehoert \
. \ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalElements = 
                    DeleteCases[rowOfNodesOnElectrode, 
                      diagonalElement[\([1]\)]];  (*\ 
                    Alle\ Zeilenelemente\ ohne\ dem\ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalSparsMatrixEntrys = 
                    equationSystemSteady[\([1, 
                        nonDiagonalElements]\)]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                    nonDiagonalSparsMatrixEntrys];\[IndentingNewLine]]; \
\[IndentingNewLine]\n\n
              matrixElements = 
                Flatten[
                  matrixElementFunction /@ 
                    Range[Length[NodesOnElectrode]]]; \[IndentingNewLine]\n
              gradientFunction[
                  j_] := \((\((\(concDistributionSteady[\([matrixElements[\([\
j, 1]\)]]\)]\)[\([2]\)] - \(concDistributionSteady[\([matrixElements[\([j, 
                                  1]\)]]\)]\)[\([1]\)])\)*
                    matrixElements[\([j, 2]\)])\); \[IndentingNewLine]\n
              currentII = \((\((Apply[Plus, 
                          gradientFunction /@ 
                            Range[Length[
                                matrixElements]]])\)^2)\)*\[Pi]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                currentII]\[IndentingNewLine]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]current = 
            CurrentbyMatrix2DAxyssymetricFunctionVV /@ 
              concDistribution; \[IndentingNewLine]Return[
            current]\[IndentingNewLine]\[IndentingNewLine]];\)\(\
\[IndentingNewLine]\)
    \)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentbyMatrix2DAxyssymetricFunctionCV", "Subsection"],

Cell[BoxData[
    \(\(\(CurrentbyMatrix2DAxyssymetricFunctionCV[equationSystemSteady_, 
          concDistribution_, electrode_, meshData_, deltaE_\ ] := 
        Module[{CurrentbyMatrix2DAxyssymetricFunctionII, 
            current}, \
\[IndentingNewLine]\[IndentingNewLine]CurrentbyMatrix2DAxyssymetricFunctionVV[
              concDistributionSteady_] := 
            Module[{NodesOnElectrode, matrixElementFunction, matrixElements, 
                gradientFunction, 
                currentII}, \
\[IndentingNewLine]\[IndentingNewLine]NodesOnElectrode = 
                Flatten[
                  Position[meshData[\([1, All, 4]\)], electrode]]; \  (*\ 
                die\ Randpunkte\ *) \n\
\[IndentingNewLine]matrixElementFunction[i_] := 
                Module[{rowOfNodesOnElectrode, columnOfNodesOnElectrode, 
                    diagonalElement, nonDiagonalElements, 
                    nonDiagonalSparsMatrixEntrys}, \
\[IndentingNewLine]rowOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 1]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Zeileneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]columnOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 2]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Spalteneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]diagonalElement = 
                    Intersection[rowOfNodesOnElectrode, 
                      columnOfNodesOnElectrode];  (*\ das\ Element, \ 
                    das\ sowohl\ zur\ zeile\ wie\ auch\ zur\ Spalte\ gehoert \
. \ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalElements = 
                    DeleteCases[rowOfNodesOnElectrode, 
                      diagonalElement[\([1]\)]];  (*\ 
                    Alle\ Zeilenelemente\ ohne\ dem\ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalSparsMatrixEntrys = 
                    equationSystemSteady[\([1, nonDiagonalElements]\)] /. 
                      deltaE \[Rule] 
                        10; \[IndentingNewLine]\[IndentingNewLine]Return[
                    nonDiagonalSparsMatrixEntrys];\[IndentingNewLine]]; \
\[IndentingNewLine]\n\n
              matrixElements = 
                Flatten[
                  matrixElementFunction /@ 
                    Range[Length[NodesOnElectrode]]]; \[IndentingNewLine]\n
              gradientFunction[
                  j_] := \((\((\(concDistributionSteady[\([matrixElements[\([\
j, 1]\)]]\)]\)[\([2]\)] - \(concDistributionSteady[\([matrixElements[\([j, 
                                  1]\)]]\)]\)[\([1]\)])\)*
                    matrixElements[\([j, 2]\)])\); \[IndentingNewLine]\n
              currentII = \((\((Apply[Plus, 
                          gradientFunction /@ 
                            Range[Length[
                                matrixElements]]])\)^2)\)*\[Pi]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                currentII]\[IndentingNewLine]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]current = 
            CurrentbyMatrix2DAxyssymetricFunctionVV /@ 
              concDistribution; \[IndentingNewLine]Return[
            current]\[IndentingNewLine]\[IndentingNewLine]];\)\(\
\[IndentingNewLine]\)
    \)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation EquationsystTransient2D  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    RowBox[{
      RowBox[{\(EquationsystTransient2D[
          geometry : {boxSideLengthvariable : {\(({_Real, _Real, _Real})\) \
.. }, \[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]Dif : {\((_Real | _Integer)\) \
.. }, \[IndentingNewLine]timeStep : \((_Real | _Integer)\), \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \((_Real | \
_Integer)\)}, ___})\) .. }, \[IndentingNewLine]electrodeReactionValues : \
{\(({\ \ \ _Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | \
_Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, 
          dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, {_Real | \
_Integer, _Real | _Integer}})\) .. }]\), ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, 
              vectorOfConcentrationsFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              vectorOfVolumes, concentrationFunction, 
              elektrodenVariablenFunktion, elektrodenVariablen, 
              punktkombinationenFunktion}\), ",", "\[IndentingNewLine]", 
            "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = 
                Table[{1, 1, 1, 1, 1, 
                    1}, {Length[geometry[\([\)\(5\)\(]\)]]}]\), ";", 
              "     ", \( (*the\ radius\ of\ the\ axisymmetric\ Function\ has\
\ been\ set\ to\ 1\  \[Rule] \ the\ function\ became\ 2  D\ *) \), 
              "\n", \(radiusOfFlux = 
                Table[{1, 1, 1}, {Length[geometry[\([\)\(6\)\(]\)]]}]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", 
              " ", \( (*\(\(**\)\(\ \)\(wenn\)\)\ volumeOfVoronoiPart = 
                  0\ gesetzt\ wird, \ 
                dann\ haben\ wir\ den\ steady\ state\ Fall\ ***) \), 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction, geom, r, 
                      s, t, transPart}\), ",", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"geom", "=", 
                        RowBox[{"boxSideLength", 
                          StyleBox["/",
                            FontColor->GrayLevel[0]], 
                          "lengthOfElementsides"}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ x = 
                          radiusOfFlux[\([i, 1]\)]*
                            geom[\([i, 1]\)]; \[IndentingNewLine]y = 
                          radiusOfFlux[\([i, 2]\)]*
                            geom[\([i, 2]\)]; \[IndentingNewLine]z = 
                          radiusOfFlux[\([i, 3]\)]*geom[\([i, 3]\)];\ \ *) \),
                       "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({x, y, z} = 
                        radiusOfFlux[\([i]\)]*geom[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(transPart = 
                        volumeOfVoronoiPart/timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(r = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 1]\)] + 
                          transPart[\([i, 2]\)] radiusOfCel[\([i, 2]\)]\), 
                      ";", "\[IndentingNewLine]", \(s = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 3]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 4]\)]\), 
                      ";", "\[IndentingNewLine]", \(t = 
                        transPart[\([i, 2]\)] radiusOfCel[\([i, 5]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 6]\)]\), 
                      ";", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ \ \ \ \ u = 
                          nodeNumbersPerElement[\([i, 
                              1]\)]; \[IndentingNewLine]v = 
                          nodeNumbersPerElement[\([i, 
                              2]\)]; \[IndentingNewLine]w = 
                          nodeNumbersPerElement[\([i, 3]\)];\ \ \ \ *) \), 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({u, v, w} = 
                        nodeNumbersPerElement[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction[j_] := 
                        Module[{}, \[IndentingNewLine]rightHandSideVector[\([\
\((j - 1)\)*numberOfNodes + u]\)] += 
                            r; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + v]\)] += 
                            s; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + w]\)] += t;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction /@ Range[Length[Dif]]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(vectorOfVolumes = 
                        rightHandSideVector*timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj + 
                              r; \[IndentingNewLine]a[j1v, 
                              j1v] += \((x + z)\)*dj + 
                              s; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*dj + 
                              t; \[IndentingNewLine]\[IndentingNewLine]a[j1u, 
                              j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrationsFunction[i_] := 
                Table[initialConcentrations[\([i]\)], {numberOfNodes}]\), ";",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Flatten[
                  vectorOfConcentrationsFunction /@ 
                    Range[Length[initialConcentrations]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 1\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  rightHandSideVector, vectorOfConcentrations, 
                  vectorOfVolumes}]\)}]}], "\[IndentingNewLine]", "]"}]}], 
      ";"}]], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation EquationsystSteadyState2D  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox["EquationsystSteadyState2D",
            FontVariations->{"CompatibilityType"->0}], "[", 
          "\[IndentingNewLine]", \(geometry : {boxSideLengthvariable : \
{\(({_Real, _Real, _Real})\) .. }, \
\[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : \
{\((_Real | _Integer)\) .. }, \[IndentingNewLine]initialConcentrations : \
{\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \
\((_Real | _Integer)\)}, ___})\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, \
{_Integer, _Integer}, {_Real | _Integer, _Real | _Integer}})\) .. }\), 
          "\[IndentingNewLine]", "]"}], ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              concentrationFunction, elektrodenVariablen, 
              elektrodenVariablenFunktion, punktkombinationenFunktion}\), ",",
             "\[IndentingNewLine]", "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = 
                Table[{1, 1, 1, 1, 1, 1}, {Length[geometry[\([5]\)]]}]\), ";",
               "     ", \( (*the\ radius\ of\ the\ axisymmetric\ Function\ \
has\ been\ set\ to\ 1\  \[Rule] \ the\ function\ became\ 2  D\ *) \), 
              "\[IndentingNewLine]", \(radiusOfFlux = 
                Table[{1, 1, 1}, {Length[geometry[\([6]\)]]}]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction}\), ",", 
                    "\[IndentingNewLine]", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"x", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 1]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 1]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"y", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 2]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 2]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"z", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 3]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 3]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(u = 
                        nodeNumbersPerElement[\([i, 1]\)]\), ";", 
                      "\[IndentingNewLine]", \(v = 
                        nodeNumbersPerElement[\([i, 2]\)]\), ";", 
                      "\[IndentingNewLine]", \(w = 
                        nodeNumbersPerElement[\([i, 3]\)]\), ";", 
                      "\[IndentingNewLine]", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj; \[IndentingNewLine]a[
                              j1v, j1v] += \((x + z)\)*
                              dj; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*
                              dj; \[IndentingNewLine]\[IndentingNewLine]a[
                              j1u, j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 
                  initialConcentrations[\([j]\)]\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", 
              "\n", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  vectorOfConcentrations}]\)}]}], "\[IndentingNewLine]", 
          "]"}]}], ";"}]], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentPerDepthFunction2D (*specified *)", "Subsection",
  InitializationCell->True],

Cell["\<\
just the voronoi area is considered, not the area on the boundary. \
The current flows not just through the area between the nodes, but through \
the whole Voronoi box area (additional boundary part on the edge of a \
boundary side)\
\>", "Text",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(CurrentPerDepthFunction2D[
        dieElektrode_Integer, \[IndentingNewLine]dritens : {nodeListvariable \
: {\(({_Integer, _Real, _Real, _Integer})\) .. }, \
\[IndentingNewLine]sideListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer})\) .. }, \[IndentingNewLine]elementListvariable \
: {\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Real, _Real, _Integer})\) .. }}, 
        concDistribution : {{\((_Real)\) .. } .. }] := 
      Module[{sideMarcs, sideposition, pointNumbersFunction, pointNumbers, i, 
          j, k, sidesToNeighboursFunction, sidesToNeighbours, 
          nodeAndNeighbourFunction, nodeAndNeighbour, allCoordinatesFunction, 
          allCoordinates, currentWithoutDifCoef, deltaTimesEveridgeFunktion, 
          deltaTimesEveridge, elementNumberFunction, elementNumber, 
          sortierenFunction, sortieren, startAndEndNodeFunktion, 
          startAndEndNode, stromFunction, totalCurrent, 
          voronoiLengthFunction, 
          voronoiLength}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]sideMarcs = \(Transpose[
              dritens[\([2]\)]]\)[\([6]\)]\ ;  (*gibt\ die\ Randmarker\
*) \[IndentingNewLine]\[IndentingNewLine]sideposition = 
          Flatten[Position[sideMarcs, 
              dieElektrode]];  (*gibt\ die\ Positionen\ der\ \
elektrodenraender*) \[IndentingNewLine]\[IndentingNewLine]\
pointNumbersFunction[
            i_] := \(\(dritens[\([2]\)]\)[\([i]\)]\)[\([{2, 
                3}]\)];  (*gibt\ die\ Punktnummern\ der\ Electrode\
*) \[IndentingNewLine]pointNumbers = 
          Flatten[pointNumbersFunction /@ 
              sideposition]; \
\[IndentingNewLine]\[IndentingNewLine]sidesToNeighboursFunction[
            i_] := \(Transpose[
              Position[\(Transpose[dritens[\([2]\)]]\)[\([{2, 3}]\)], 
                i]]\)[\([2]\)];  (*gibt\ eine\ Liste\ der\ Seiten, \ 
          die\ den\ Electrodenpunkt\ \
enthalten*) \[IndentingNewLine]sidesToNeighbours = 
          sidesToNeighboursFunction /@ 
            pointNumbers; \
\[IndentingNewLine]\[IndentingNewLine]nodeAndNeighbourFunction[
            k_] := \(Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{2, 
                    3}]\)]]\)[\([k]\)];  (*gibt\ eine\ Liste\ mit\ dem\ \
Electrodenpunkt\ und\ seinen\ Nachbarn*) \[IndentingNewLine]nodeAndNeighbour \
= nodeAndNeighbourFunction /@ 
            sidesToNeighbours; \
\[IndentingNewLine]\[IndentingNewLine]allCoordinatesFunction[j_] := 
          Module[{coordinateFunction, 
              coordinate}, \[IndentingNewLine]coordinateFunction[
                i_] := \((Abs[\(\(Transpose[\(Transpose[
                                dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([1]\)] - \
\(\(Transpose[\(Transpose[dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([2]\)]])\) . {0, 
                  1};  (*gibt\ die\ Differenz\ der\ Koordinaten\ des\ Punktes\
\ und\ seines\ Nachbarn\ mal\ der\ Normalenrichtung*) \n
            coordinate = 
              coordinateFunction /@ 
                nodeAndNeighbour[\([j]\)]\[IndentingNewLine]]; \
\[IndentingNewLine]allCoordinates = 
          allCoordinatesFunction /@ 
            Range[Length[
                nodeAndNeighbour]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]sortierenFunction[i_] := Sort[i]; \n
        sortieren = 
          sortierenFunction /@ 
            Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{4, 
                    5}]\)]];  (*die\ Elementnummern\ an\ beiden\ Seiten\ \
aller\ Punktverbindungen\ im\ Gebiet; \ 
          die\ Elementnummern\ sind\ sortiert\ um\ Randelemente\ behandeln\ \
zu\ koennen*) \n\n
        elementNumberFunction[i_] := 
          sortieren[\([i]\)];  (*gibt\ die\ Elemente\ zu\ beiden\ Seiten\ der\
\ Verbindungsseite*) \n
        elementNumber = elementNumberFunction /@ sidesToNeighbours; \n\n
        startAndEndNodeFunktion[j_] := 
          Module[{startAndEndNodeFunktionII, 
              startAndEndNodeII}, \
\[IndentingNewLine]startAndEndNodeFunktionII[
                i_] := \(Transpose[\(Transpose[
                      dritens[\([2]\)]]\)[\([{2, 
                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                      i]\)]]\)];  (*das\ sind\ die\ Punkte\ zur\ Seite*) \n
            startAndEndNodeII = 
              startAndEndNodeFunktionII /@ 
                Range[Length[
                    sidesToNeighbours[\([j]\)]]]; \[IndentingNewLine]Return[
              startAndEndNodeII]\[IndentingNewLine]]; \n
        startAndEndNode = 
          startAndEndNodeFunktion /@ 
            Range[Length[
                sidesToNeighbours]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\n
        voronoiLengthFunction[j_] := 
          Module[{voronoiLengthFunctionII, 
              voronoiLengthII}, \[IndentingNewLine]voronoiLengthFunctionII[
                i_] := If[elementNumber[\([j, i, 1]\)] > 0.1, 
                Apply[Plus, \((\(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([1]\)]]\)] - \
\(Transpose[\(Transpose[dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5, 
                Apply[Plus, \((\((\(\(Transpose[\(Transpose[
                                        dritens[\([1]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([startAndEndNode[\([j, 
                                        i]\)]]\)]\)[\([1]\)] + \(\(Transpose[\
\(Transpose[dritens[\([1]\)]]\)[\([{2, 3}]\)]]\)[\([\(Transpose[\(Transpose[
                                        dritens[\([2]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                                        i]\)]]\)]]\)]\)[\([2]\)])\)/
                            2 - \(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5]; \
\[IndentingNewLine]voronoiLengthII = 
              voronoiLengthFunctionII /@ 
                Range[Length[
                    elementNumber[\([j]\)]]]; \[IndentingNewLine]Return[
              voronoiLengthII]\[IndentingNewLine]]; \n
        voronoiLength = 
          voronoiLengthFunction /@ 
            Range[Length[
                elementNumber]]; \
\[IndentingNewLine]\[IndentingNewLine]stromFunction[k_] := 
          Module[{conzDifferenceFunction, conzDifference, conzTimesSij, 
              gradientFunction, gradientsI, 
              strom}, \[IndentingNewLine]\[IndentingNewLine]\
conzDifferenceFunction[i_] := 
              Module[{conzDifferenceTwoFunction, 
                  conzDifferenceTwo}, \
\[IndentingNewLine]conzDifferenceTwoFunction[j_] := 
                  k[\([nodeAndNeighbour[\([i, j, 2]\)]]\)] - 
                    k[\([nodeAndNeighbour[\([i, j, 
                            1]\)]]\)];  (*gibt\ die\ \
Konzentrationsdifferenz\ \ i = Hauptpunkt, \ 
                  j = Hauptpunkt\ und\ ein\ Nachbar*) \n
                conzDifferenceTwo = 
                  conzDifferenceTwoFunction /@ 
                    Range[Length[
                        nodeAndNeighbour[\([i]\)]]]\[IndentingNewLine]]; \n
            conzDifference = 
              conzDifferenceFunction /@ 
                Range[Length[
                    nodeAndNeighbour]]; \
\[IndentingNewLine]\[IndentingNewLine]\n
            conzTimesSij = conzDifference*voronoiLength; \[IndentingNewLine]\n
            gradientFunction[i_] := 
              Module[{gradientToOneNode, 
                  gradientToOneNodeFunction}, \
\[IndentingNewLine]gradientToOneNodeFunction[j_] := \[IndentingNewLine]If[
                    allCoordinates[\([i, j]\)] =!= 0. , 
                    conzTimesSij[\([i, j]\)]/allCoordinates[\([i, j]\)], 
                    0. ]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                  geteilt\ durch\ allCoordinates\ beachtet\ die\ \
\(\(Normalenrichtung\ !!\)!\)\ *) \[IndentingNewLine]\n
                gradientToOneNode = 
                  Apply[Plus, 
                    gradientToOneNodeFunction /@ 
                      Range[Length[
                          nodeAndNeighbour[\([i]\)]]]]\[IndentingNewLine]]; \n
            gradientsI = 
              gradientFunction /@ 
                Range[Length[
                    nodeAndNeighbour]];  (*gibt\ den\ Gradienten\ zum\ Punkt\ \
in\ der\ Normalenrichtung*) \[IndentingNewLine]\[IndentingNewLine]strom = 
              Apply[Plus, 
                gradientsI]; \[IndentingNewLine]\[IndentingNewLine]Return[
              strom]\[IndentingNewLine]]; \[IndentingNewLine]\n
        currentWithoutDifCoef = 
          stromFunction /@ 
            concDistribution; \[IndentingNewLine]\[IndentingNewLine]Return[
          currentWithoutDifCoef];\[IndentingNewLine]]\)\(\[IndentingNewLine]\)\
\(\[IndentingNewLine]\)
    \)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisNodes", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\n\)\(ReadAnsysNodes[ansisNodesFilename_] := 
        Block[\[IndentingNewLine]{readTetgenFormat, tetgenNode, 
            nodefile}, \[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ nodefile\ generated\ by\ tetgen\ \
is\ read\ *************) \[IndentingNewLine]\[IndentingNewLine]anNodefile = 
            OpenRead[
              ansisNodesFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \)\(The\)\
\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\(\ \
\)\(variable\)\ **) \[IndentingNewLine]\[IndentingNewLine]nodefile = 
            ReadList[
              anNodefile, {Number, Real, Real, 
                Real}]; \[IndentingNewLine]\[IndentingNewLine]Close[
            anNodefile]; \[IndentingNewLine]\[IndentingNewLine]appendFunkt[
              x_] := Append[x, 0]; \[IndentingNewLine]nodefile = 
            appendFunkt /@ nodefile; \[IndentingNewLine]Return[
            nodefile]\[IndentingNewLine]];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisElements", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\n\)\(\(ReadAnsysElements[ansisElementFilename_] := 
        Block[\[IndentingNewLine]{anElementfile, 
            anelefile}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ elementfile\ \
generated\ by\ Ansis\ is\ read\ *************) \[IndentingNewLine]\
\[IndentingNewLine]anElementfile = 
            OpenRead[
              ansisElementFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \)\(The\
\)\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\(\ \
\)\(variable\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]anelefile = 
            ReadList[
              anElementfile, {Number, Number, Number, Number, Number, Number, 
                Number, Number, Number, Number, Number, Number, Number, 
                Number}]; \[IndentingNewLine] (*\(*\)\(\ \)\(the\)\(\ \
\)\(lines\)\(\ \)\(with\)\(\ \)\(the\)\(\ \)\(elementdata\)\(\ \)\(are\)\(\ \
\)\(red\)\(\ \)\((exclusive\ the\ last\ commentline)\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]Close[
            anElementfile]; \[IndentingNewLine]\[IndentingNewLine]anelefile = 
            anelefile[\([All, {1, 7, 8, 9, 11, 
                  2}]\)]; \[IndentingNewLine]\[IndentingNewLine]Return[
            anelefile]\[IndentingNewLine]];\)\(\n\)\(\[IndentingNewLine]\)\(\
\[IndentingNewLine]\)
    \)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisNodeFile (Sam)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\n\)\(ReadAnsysNodefile[ansisNodeFilename_] := 
        Block[\[IndentingNewLine]{readTetgenFormat, tetgenNode, 
            nodefile}, \[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ nodefile\ generated\ by\ tetgen\ \
is\ read\ *************) \[IndentingNewLine]\[IndentingNewLine]anNodefile = 
            OpenRead[
              ansisNodeFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \
\)\(The\)\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\
\(\ \)\(variable\)\ **) \[IndentingNewLine]\[IndentingNewLine]nodefile = 
            ReadList[
              anNodefile, {Real, Real, Real, Real, Real, Real, 
                Real}]; \[IndentingNewLine]\[IndentingNewLine]Close[
            anNodefile]; \[IndentingNewLine]\[IndentingNewLine]appendFunkt[
              x_] := Append[x, 0]; \[IndentingNewLine]nodefile = 
            appendFunkt /@ 
              nodefile; \[IndentingNewLine]nodefile[\([All, {1, 5}]\)] = 
            Round[nodefile[\([All, {1, 5}]\)]]; \[IndentingNewLine]Return[
            nodefile[\([All, {1, 2, 3, 4, 
                  5}]\)]]\[IndentingNewLine]];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisElementFile (Sam)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\n\)\(ReadAnsisElementFile[ansisElementFilename_] := 
        Block[\[IndentingNewLine]{anElementfile, 
            anelefile}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ elementfile\ \
generated\ by\ Ansis\ is\ read\ *************) \[IndentingNewLine]\
\[IndentingNewLine]anElementfile = 
            OpenRead[
              ansisElementFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \)\(The\
\)\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\(\ \
\)\(variable\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]anelefile = 
            ReadList[
              anElementfile, {Number, Number, Number, Number, Number, Number, 
                Number, Number, 
                Number}]; \[IndentingNewLine] (*\(*\)\(\ \)\(the\)\(\ \
\)\(lines\)\(\ \)\(with\)\(\ \)\(the\)\(\ \)\(elementdata\)\(\ \)\(are\)\(\ \
\)\(red\)\(\ \)\((exclusive\ the\ last\ commentline)\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]Close[
            anElementfile]; \[IndentingNewLine]\[IndentingNewLine]anelefile = 
            Round[anelefile[\([All, {1, 2, 3, 4, 6, 
                    2}]\)]]; \[IndentingNewLine]\[IndentingNewLine]Return[
            anelefile]\[IndentingNewLine]];\)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysElementGeometryFunction3D (*specified *)", \
"Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(AnsysElementGeometryFunction3D[
          ansisdata : {nodeList : {\(({_Integer, _Real, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]elementList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }}] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{nodeData, ElementGeometryFunction, 
            listOfGeometries}, \[IndentingNewLine]\[IndentingNewLine]\n
          nodeData = ansisdata[\([1]\)]; \n
          ElementGeometryFunction[l_] := 
            Module[{nodenumbers, elementCoordinates, lengthOfEdges, 
                edgeMidPoints, ElementVoronoiFunction, elementGeometryData, 
                ElementVoronoiNodes}, \
\[IndentingNewLine]\[IndentingNewLine]nodenumbers = 
                ansisdata[\([2, 
                    l, {2, 3, 4, 
                      5}]\)]; \[IndentingNewLine]elementCoordinates = 
                nodeData[\([\(ansisdata[\([2, l]\)]\)[\([{2, 3, 4, 
                          5}]\)], {2, 3, 
                      4}]\)]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]lengthOfEdges = \[IndentingNewLine]{Apply[
                      Plus, \((elementCoordinates[\([1]\)] - 
                            elementCoordinates[\([2]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([1]\)] - 
                            elementCoordinates[\([3]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([1]\)] - 
                            elementCoordinates[\([4]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([2]\)] - 
                            elementCoordinates[\([3]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([2]\)] - 
                            elementCoordinates[\([4]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([3]\)] - 
                            elementCoordinates[\([4]\)])\)^2]^ .5}; \
\[IndentingNewLine]\[IndentingNewLine]edgeMidPoints = \
\[IndentingNewLine]{\((elementCoordinates[\([1]\)] + 
                        elementCoordinates[\([2]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([1]\)] + 
                        elementCoordinates[\([3]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([1]\)] + 
                        elementCoordinates[\([4]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([2]\)] + 
                        elementCoordinates[\([3]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([2]\)] + 
                        elementCoordinates[\([4]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([3]\)] + 
                        elementCoordinates[\([4]\)])\)/
                    2}; \[IndentingNewLine]\[IndentingNewLine]\
ElementVoronoiFunction[elementCoordinates_] := 
                Module[{TriangleVoronoiPointFunction, 
                    TriangleVoronoiPointAndNormal, TriangleVoronoiPoint, 
                    crosspointElement, 
                    voronoiElementPoint}, \[IndentingNewLine]\
\[IndentingNewLine]TriangleVoronoiPointFunction[
                      i_]\  := \ \
\[IndentingNewLine]\[IndentingNewLine]Module[{triangleMatrix, planeNormal1, 
                        normVect1, normal1, normVect2, normal2, midpoint1, 
                        midpoint2, voronoiShort, 
                        t}, \[IndentingNewLine]\[IndentingNewLine]\
triangleMatrix = 
                        i; \[IndentingNewLine]\[IndentingNewLine] (*normal\ \
gives\ the\ normal\ vectors\ of\ two\ of\ the\ triangle\ sides\
*) \[IndentingNewLine]\[IndentingNewLine]planeNormal1 = 
                        CrossProduct[\((triangleMatrix[\([2]\)] - 
                              triangleMatrix[\([1]\)])\), \
\((triangleMatrix[\([3]\)] - 
                              triangleMatrix[\([1]\)])\)]; \
\[IndentingNewLine]\[IndentingNewLine]normVect1 = 
                        CrossProduct[
                          planeNormal1, \((triangleMatrix[\([2]\)] - 
                              triangleMatrix[\([1]\)])\)]; \
\[IndentingNewLine]normal1 = 
                        normVect1/\((Apply[Plus, 
                                normVect1^2]^ .5)\); \
\[IndentingNewLine]normVect2 = 
                        CrossProduct[
                          CrossProduct[\((triangleMatrix[\([2]\)] - 
                                triangleMatrix[\([1]\)])\), \
\((triangleMatrix[\([3]\)] - 
                                triangleMatrix[\([1]\)])\)], \
\((triangleMatrix[\([3]\)] - 
                              triangleMatrix[\([1]\)])\)]; \
\[IndentingNewLine]normal2 = 
                        normVect2/\((Apply[Plus, 
                                normVect2^2]^ .5)\); \[IndentingNewLine]\
\[IndentingNewLine]midpoint1 = \((triangleMatrix[\([1]\)] + 
                              triangleMatrix[\([2]\)])\)/
                          2; \[IndentingNewLine]midpoint2 = \
\((triangleMatrix[\([1]\)] + triangleMatrix[\([3]\)])\)/
                          2; \[IndentingNewLine]\[IndentingNewLine] (*\ \ It\ \
is\ impossible\ to\ solve\ the\ eqation\ to\ find\ the\ crosspoint\ between\ \
two\ lines\ which\ are\ build\ by\ the\ normals\ on\ two\ triangle\ sides\ \
through\ the\ midpoints\ of\ this\ sides\ because\ of\ the\ nummerical\ error\
\ the\ straits\ are\ often\ not\ in\ one\ plane . \ 
                            This\ function\ calculates\ the\ point, \ 
                        where\ the\ straits\ have\ the\ smalest\ distance . \ \
\((n11\ means\ the\ first\ element\ of\ the\ first\ normal\ vector, \ 
                              m11\ means\ the\ first\ element\ of\ the\ \
midpoint\ of\ the\ first\ triangle\ edge, \ \(\(etc\)\(.\)\)\ )\)\ The\ whole\
\ calculation\ is\ the\ \(following : \ 
                            D[Plus @@ \(({{m11 + n11*t - m21 - n21*k}, {m12 + 
                                        n12*t - m22 - n22*k}, {m13 + n13*t - 
                                        m23 - n23*k}}^2)\), 
                              k]\); \[IndentingNewLine]D[
                          Plus @@ \(({{m11 + n11*t - m21 - n21*k}, {m12 + 
                                      n12*t - m22 - n22*k}, {m13 + n13*t - 
                                      m23 - n23*k}}^2)\), 
                          t]; \[IndentingNewLine]FullSimplify[
                          Solve[{{\(-2\)\ n21\ \((m11 - m21 - k\ n21 + 
                                        n11\ t)\) - 
                                    2\ n22\ \((m12 - m22 - k\ n22 + 
                                        n12\ t)\) - 
                                    2\ n23\ \((m13 - m23 - k\ n23 + 
                                        n13\ t)\)} \[Equal] 
                                0, {2\ n11\ \((m11 - m21 - k\ n21 + 
                                        n11\ t)\) + 
                                    2\ n12\ \((m12 - m22 - k\ n22 + 
                                        n12\ t)\) + 
                                    2\ n13\ \((m13 - m23 - k\ n23 + 
                                        n13\ t)\)} \[Equal] 0}, {k, 
                              t}]];\ *) ; \ \[IndentingNewLine]\
\[IndentingNewLine]voronoiShort = 
                        normal1*
                              t + \((triangleMatrix[\([1]\)] + 
                                  triangleMatrix[\([2]\)])\)/2 /. 
                          t \[Rule] \(-\((4\ \((midpoint1[\([1]\)] 
                                        normal2[\([1]\)] - 
                                        midpoint2[\([1]\)]\ normal2[\([1]\)] \
+ midpoint1[\([2]\)]\ normal2[\([2]\)] - midpoint2[\([2\ ]\)] 
                                        normal2[\([2]\)] + 
                                        midpoint1[\([3]\)]\ normal2[\([3]\)] \
- midpoint2[\([3]\)]\ normal2[\([3]\)])\)\ \((normal1[\([1]\)]\ normal2[\([1]\
\)] + normal1[\([2]\)]\ normal2[\([2]\)] + 
                                        normal1[\([3]\)]\ normal2[\([3]\)])\) \
- 4\ \((midpoint1[\([1]\)]\ normal1[\([1]\)] - 
                                        midpoint2[\([1]\)]\ normal1[\([1]\)] \
+ midpoint1[\([2]\)]\ normal1[\([2]\)] - 
                                        midpoint2[\([2]\)]\ normal1[\([2]\)] \
+ midpoint1[\([3\ ]\)] normal1[\([3]\)] - 
                                        midpoint2[\([3]\)]\ normal1[\([3]\)])\
\)\ \((normal2[\([1]\)]^2 + normal2[\([2]\)]^2 + 
                                        normal2[\([3]\)]^2)\))\)\)/\((4\ \
\((normal1[\([1]\)]\ normal2[\([1]\)] + normal1[\([2]\)]\ normal2[\([2]\)] + 
                                        normal1[\([3]\)]\ \
normal2[\([3]\)])\)^2 - 4\ \((normal1[\([1]\)]^2 + normal1[\([2]\)]^2 + 
                                        normal1[\([3]\)]^2)\)\ \
\((normal2[\([1]\)]^2 + normal2[\([2]\)]^2 + 
                                        normal2[\([3]\)]^2)\))\); \
\[IndentingNewLine]\[IndentingNewLine]Return[{planeNormal1, 
                          voronoiShort}]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(\ \ \)\(The\)\)\ triangle\ \
Voronoi\ Function\ is\ called\ \  **  **  **  **  **  **  **  **  **  \
** **********) \[IndentingNewLine]TriangleVoronoiPointAndNormal = 
                    TriangleVoronoiPointFunction /@ \
{elementCoordinates[\([{1, 2, 3}]\)], elementCoordinates[\([{1, 2, 4}]\)], 
                        elementCoordinates[\([{1, 3, 4}]\)], 
                        elementCoordinates[\([{2, 3, 
                              4}]\)]}; \[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(\
**\)\(\ \ \ \ \)\(The\)\)\ Tetrahedron\ Voronoi\ node\ is\ calculeted\ \ \ \ \
\  **  **  **  **  **  **  **  **  **  **  **  ** ******) \[IndentingNewLine]\
\[IndentingNewLine]TriangleVoronoiPoint = 
                    TriangleVoronoiPointAndNormal[\([All, 
                        2]\)]; \
\[IndentingNewLine]\[IndentingNewLine]crosspointElement = 
                    t \[Rule] \(-\((4\ \
\((\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)])\)\ \
\((\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 1]\)]\)[\([3]\)])\) - 
                              4\ \((\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)])\)\ \
\((\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)]^2)\))\)\)/\((4\ \
\((\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 1]\)]\)[\([3]\)])\)^2 - 
                            4\ \((\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)]^2)\)\ \
\((\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)]^2)\))\); \
\[IndentingNewLine]voronoiElementPoint = 
                    TriangleVoronoiPointAndNormal[\([1, 1]\)]*t + 
                        TriangleVoronoiPointAndNormal[\([1, 2]\)] /. 
                      crosspointElement; \[IndentingNewLine]\
\[IndentingNewLine]Return[{voronoiElementPoint, 
                      TriangleVoronoiPoint}]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]ElementVoronoiNodes = 
                ElementVoronoiFunction[
                  elementCoordinates]; \[IndentingNewLine]\n (*\ 
                The\ node\ numbers\ of\ the\ edge, \ 
                the\ length\ of\ the\ edge\ and\ the\ voronoi\ edge\ areas\ \
in\ the\ \(order : \ {1, 2}\); {1, 3}; {1, 4}; {2, 3}; {2, 4}; {3, 
                  4};\ \ *) \[IndentingNewLine]elementGeometryData = \
{{nodenumbers[\([{1, 2}]\)], 
                    lengthOfEdges[\([1]\)], \((\((Apply[
                                  Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2]^ .5)\)*\((Apply[
                                  Plus, \((edgeMidPoints[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2]^ .5)\) + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2]^ .5)\)*\((Apply[
                                    Plus, \((edgeMidPoints[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{1, 3}]\)], 
                    lengthOfEdges[\([2]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([2]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5)\) + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([2]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{1, 4}]\)], 
                    lengthOfEdges[\([3]\)], \((\((Apply[
                                  Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2]^ .5)\)*\((Apply[
                                  Plus, \((edgeMidPoints[\([3]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2]^ .5)\) + \((Apply[
                                  Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2]^ .5)\)*\((Apply[
                                  Plus, \((edgeMidPoints[\([3]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2]^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{2, 3}]\)], 
                    lengthOfEdges[\([4]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([4]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5)\)\n + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([4]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{2, 4}]\)], 
                    lengthOfEdges[\([5]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([5]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5)\)\n + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([5]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{3, 4}]\)], 
                    lengthOfEdges[\([6]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([6]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5)\)\n + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([6]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5)\))\)/2}, 
                  ElementVoronoiNodes[\([1]\)]}; \[IndentingNewLine]\
\[IndentingNewLine] (*\ \ returns\ for\ each\ edge\ of\ a\ tetrahedron\ the\ \
node\ numbers, \ the\ length\ of\ the\ edge, \ 
                the\ area\ of\ the\ voronoi\ box\ \ and\ the\ element - 
                  voronoi - 
                  node\ *) \[IndentingNewLine]\[IndentingNewLine]Return[
                
                elementGeometryData];\[IndentingNewLine]\[IndentingNewLine]]; \
\nlistOfGeometries = 
            ElementGeometryFunction /@ 
              Range[Length[
                  ansisdata[\([2]\)]]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
            listOfGeometries]\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation GeometryTestForVoronoi3D  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(GeometryTestForVoronoi3D[
        meshdata : {{{_Integer, _Real, _Real, _Real, _Integer} .. }, \
{{_Integer, _Integer, _Integer, _Integer, _Integer, _Integer} .. }}, 
        geometryData : {\(({\(({{_Integer, _Integer}, _Real, _Real})\) .. , \
{_Real, _Real, _Real}})\) .. }] := 
      Module[{PointInTetrahedronFunction, isOrNotList, 
          isOrnotFunction}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]PointInTetrahedronFunction[{V1 : {x1_, y1_, z1_}, 
              V2 : {x2_, y2_, z2_}, V3 : {x3_, y3_, z3_}, 
              V4 : {x4_, y4_, z4_}, 
              P : {x_, y_, 
                  z_}}] := \[IndentingNewLine]\[IndentingNewLine]Module[{D0, 
              D1, D2, D3, D4, s1, s2, s3, s4, isDelaunay, vergleich, 
              punktLiegtAufSeite, 
              volumeOfTetrahedron}, \[IndentingNewLine]\[IndentingNewLine]D0 \
= Det[{{x1, y1, z1, 1}, {x2, y2, z2, 1}, {x3, y3, z3, 1}, {x4, y4, z4, 
                    1}}]; \[IndentingNewLine]D1 = 
              Det[{{x, y, z, 1}, {x2, y2, z2, 1}, {x3, y3, z3, 1}, {x4, y4, 
                    z4, 1}}]; \[IndentingNewLine]D2 = 
              Det[{{x1, y1, z1, 1}, {x, y, z, 1}, {x3, y3, z3, 1}, {x4, y4, 
                    z4, 1}}]; \[IndentingNewLine]D3 = 
              Det[{{x1, y1, z1, 1}, {x2, y2, z2, 1}, {x, y, z, 1}, {x4, y4, 
                    z4, 1}}]; \[IndentingNewLine]D4 = 
              Det[{{x1, y1, z1, 1}, {x2, y2, z2, 1}, {x3, y3, z3, 1}, {x, y, 
                    z, 1}}]; \[IndentingNewLine]\[IndentingNewLine]vergleich[
                a_, b_] := 
              0 /; \((\(-10^\(-14\)\) < \ b < \ 
                    10^\(-14\))\); \[IndentingNewLine]vergleich[a_, b_] := 
              1 /; \((a*b)\) > 0; \[IndentingNewLine]vergleich[a_, 
                b_] := \(-1\) /; \((a*b)\) < 
                  0; \[IndentingNewLine]\[IndentingNewLine]s1 = 
              vergleich[D0, D1]; \[IndentingNewLine]s2 = 
              vergleich[D0, D2]; \[IndentingNewLine]s3 = 
              vergleich[D0, D3]; \[IndentingNewLine]s4 = 
              vergleich[D0, 
                D4]; \[IndentingNewLine]\[IndentingNewLine]isDelaunay = 
              FreeQ[{s1, s2, s3, 
                  s4}, \(-1\)]; \
\[IndentingNewLine]\[IndentingNewLine]volumeOfTetrahedron = 
              D0/6; \[IndentingNewLine]\[IndentingNewLine]punktLiegtAufSeite \
= Flatten[Position[{s1, s2, s3, s4}, 
                  0]]; \[IndentingNewLine] (*wenn\ zwei\ Seiten\ ausgegeben\ \
werden, \ 
              dann\ liegt\ der\ Punkt\ auf\ der\ Kante\[IndentingNewLine]\
*) \[IndentingNewLine]Return[{volumeOfTetrahedron, isDelaunay, 
                punktLiegtAufSeite}]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]isOrnotFunction[elementNr_] := 
          Module[{elementNodes, isOrNot}, \[IndentingNewLine]elementNodes = 
              Append[\(meshdata[\([1, 
                      meshdata[\([2, 
                          elementNr, {2, 3, 4, 5}]\)]]\)]\)[\([All, {2, 3, 
                      4}]\)], 
                geometryData[\([elementNr, \(-1\)]\)]]; \
\[IndentingNewLine]isOrNot = \(PointInTetrahedronFunction[
                  elementNodes]\)[\([2]\)]; \ \[IndentingNewLine]Return[
              isOrNot]\[IndentingNewLine]]; \[IndentingNewLine]isOrNotList = 
          isOrnotFunction /@ 
            Range[Length[
                geometryData]]; \[IndentingNewLine]numberOfNotVoronoiEle = 
          Count[isOrNotList, False]; \[IndentingNewLine]NumberOfElements = 
          Length[geometryData]; \[IndentingNewLine]Return[{ToString[
                numberOfNotVoronoiEle] <> "\< of \>" <> 
              ToString[\ 
                NumberOfElements] <> \ "\< elements, are not Voronoi elements\
\>"}]\[IndentingNewLine]]\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation AnsysEquationSystemSteadyState3D  (*specified \
*)\
\>", "Subsection"],

Cell[BoxData[
    \(\(AnsysEquationSystemSteadyState3D[\[IndentingNewLine]listOfGeometries \
: {\(({\(({{_Integer, _Integer}, _Real, _Real})\) .. , {_Real, _Real, \
_Real}})\) .. }, \[IndentingNewLine]tetgenData : {{{_Integer, _Real, _Real, \
_Real, _Integer} .. }, {{_Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer} .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : {\((_Real | \
_Integer)\) .. }, \[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }\
\[IndentingNewLine]] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{elementAssembleFunction, 
            numberOfNodes, rightHandSideVector, nodeMarcs, 
            electrodeReactionsFunktion, elektrodenVariablenFunktion, 
            elektrodenVariablen, electrodeReaction, aIndices, 
            dirichletBcNodesFunktion, dirichletBcNodes, 
            allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, a, allNodePairs, nodesPerElement, 
            nodepairsForEverySpezies, sparseInitialisation, 
            sparseDiagonalInitialisation, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]nodesPerElement = \
\(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[{assembleFunction, i, voro1, voro2, voro3, voro4, voro5, 
                voro6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, j]\ *) \[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/i[\([6, 2]\)]; \n
              assembleFunction[spezNumber_] := 
                Module[{diffcoefOfSpez, multiSpez, voroDif1, voroDif2, 
                    voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1; \[IndentingNewLine]\[IndentingNewLine]voroDif2 \
= diffcoefOfSpez*voro2; \[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3; \[IndentingNewLine]\[IndentingNewLine]voroDif4 \
= diffcoefOfSpez*voro4; \[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4; \[IndentingNewLine]\[IndentingNewLine]voroDif5 \
= diffcoefOfSpez*voro5; \[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5; \[IndentingNewLine]\[IndentingNewLine]voroDif6 \
= diffcoefOfSpez*voro6; \[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    
                    voroDif6;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\) ** \
\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\
\[IndentingNewLine]vectorOfConcentrations = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine]\n (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n (*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 
              initialConcentrations[\([j]\)]\); \n\(Apply[
                dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\n\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, 
              vectorOfConcentrations}]\[IndentingNewLine]\[IndentingNewLine]];\
\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysEquationSystemTrans3D  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(AnsysEquationSystemTrans3D[
          listOfGeometries : {\(({\(({{_Integer, _Integer}, _Real, _Real})\) \
.. , {_Real, _Real, _Real}})\) .. }, \[IndentingNewLine]tetgenData : \
{{{_Integer, _Real, _Real, _Real, _Integer} .. }, {{_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer} .. }}, \[IndentingNewLine]Dif : \
{\((_Real | _Integer)\) .. }, \[IndentingNewLine]electrodeReactionValues : \
{\(({\ \ \ _Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | \
_Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]timeStep : \((_Real | _Integer)\)] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{elementAssembleFunction, numberOfNodes, 
            rightHandSideVector, nodeMarcs, electrodeReactionsFunktion, 
            elektrodenVariablenFunktion, elektrodenVariablen, 
            electrodeReaction, aIndices, dirichletBcNodesFunktion, 
            dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, vectorOfConcentrationsFunction, 
            vectorOfConcentrations, 
            a}, \[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine]\[IndentingNewLine]\
vectorOfConcentrationsFunction[i_] := 
            Table[initialConcentrations[\([i]\)], {numberOfNodes}]; \n
          vectorOfConcentrations = 
            Flatten[vectorOfConcentrationsFunction /@ 
                Range[Length[
                    initialConcentrations]]]; \[IndentingNewLine]\
\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]nodesPerElement \
= \(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[\[IndentingNewLine]{assembleFunction, i, voro1, voro2, 
                voro3, voro4, voro5, voro6, volume1, volume2, volume3, 
                volume4, volume5, 
                volume6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, 
                      j]\ *) \[IndentingNewLine]\[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/
                  i[\([6, 
                      2]\)]; \[IndentingNewLine]\[IndentingNewLine] (*this\ \
lines\ calculate\ the\ volume\ of\ the\ voronoi\ box\ of\ one\ element, \ 
                between\ each\ node\ pair\ ij*) \n
              volume1 = i[\([1, 3]\)]*i[\([1, 2]\)]/6; \n
              volume2 = i[\([2, 3]\)]*i[\([2, 2]\)]/6; \n
              volume3 = i[\([3, 3]\)]*i[\([3, 2]\)]/6; \n
              volume4 = i[\([4, 3]\)]*i[\([4, 2]\)]/6; \n
              volume5 = i[\([5, 3]\)]*i[\([5, 2]\)]/6; \n
              volume6 = i[\([6, 3]\)]*i[\([6, 2]\)]/6; \[IndentingNewLine]\n
              assembleFunction[spezNumber_] := 
                Module[\[IndentingNewLine]{diffcoefOfSpez, multiSpez, 
                    voroDif1, voroDif2, voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1 + volume1/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1 + volume1/timeStep; 
                  rightHandSideVector[\([multiSpez + i[\([1, 1, 1]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([1, 1, 2]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif2 = 
                    diffcoefOfSpez*voro2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2 + volume2/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2 + 
                      volume2/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 1]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 2]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3 + volume3/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3 + 
                      volume3/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 1]\)]]\)] += 
                    volume3/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 2]\)]]\)] += 
                    volume3/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif4 = 
                    diffcoefOfSpez*voro4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4 + volume4/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4 + 
                      volume4/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 1]\)]]\)] += 
                    volume4/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 2]\)]]\)] += 
                    volume4/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif5 = 
                    diffcoefOfSpez*voro5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5 + volume5/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5 + 
                      volume5/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 1]\)]]\)] += 
                    volume5/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 2]\)]]\)] += 
                    volume5/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif6 = 
                    diffcoefOfSpez*voro6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6 + volume6/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    voroDif6 + 
                      volume6/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 1]\)]]\)] += 
                    volume6/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 2]\)]]\)] += 
                    volume6/
                      timeStep;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \n\[IndentingNewLine]vectorOfVolumes = 
            rightHandSideVector*
              timeStep;  (*vectorOfVolumes\ is\ needed\ for\ model\ order\ \
reduction\ \((C - 
                  vector)\)*) \[IndentingNewLine]\[IndentingNewLine] (*\(\(\
**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]\n
          nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n (*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 1\); \n\(Apply[dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \n\
\[IndentingNewLine]\[IndentingNewLine]concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, rightHandSideVector, vectorOfConcentrations, 
              vectorOfVolumes}]\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["twoDEasymeshToThreeDFunction  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(twoDEasymeshToThreeDFunction[
          easymeshData : {\[IndentingNewLine]nodeListvariable : \
{\(({_Integer, _Real, _Real, _Integer})\) .. }, \
\[IndentingNewLine]sideListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer})\) .. }, \[IndentingNewLine]elementListvariable \
: {\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Real, _Real, _Integer})\) .. }}, 
          delta : \((_Real | _Integer)\)\[IndentingNewLine]] := 
        Module[{ansisdata, elements3Doutput, element2DTo3D, nodes3Doutput, 
            node2DTo3D}, \[IndentingNewLine]\[IndentingNewLine]\n
          node2DTo3D[theNodes_List] := 
            Module[{m}, 
              m = Length[
                  theNodes]; \[IndentingNewLine]Join[\((\(Join[
                        Drop[#, \(-1\)], {delta}, Take[#, \(-1\)]] &\) /@ 
                    theNodes)\), \((\(Join[Take[#, 1] + m, 
                        Drop[Drop[#, \(-1\)], 1], {0.0}, 
                        Take[#, \(-1\)]] &\) /@ 
                    theNodes)\)]]; \[IndentingNewLine]\n
          nodes3Doutput = node2DTo3D[nodeListvariable]; \[IndentingNewLine]\n
          element2DTo3D[theNodes_List, theElements_List] := 
            Module[{m, mm}, 
              m = Length[theNodes]; \[IndentingNewLine]mm = 
                Length[theElements]; \[IndentingNewLine]Join[\((\({#\
\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]3\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket], #\[LeftDoubleBracket]3\
\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]\(-1\)\[RightDoubleBracket]}\
 &\) /@ theElements)\), \[IndentingNewLine]\((\({#\[LeftDoubleBracket]1\
\[RightDoubleBracket] + 
                          mm, #\[LeftDoubleBracket]2\[RightDoubleBracket], #\
\[LeftDoubleBracket]3\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]2\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]\(-1\)\[RightDoubleBracket]}\
 &\) /@ theElements)\), \[IndentingNewLine]\((\({#\[LeftDoubleBracket]1\
\[RightDoubleBracket] + 2  mm, #\[LeftDoubleBracket]2\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]3\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]\(-1\)\[RightDoubleBracket]}\
 &\) /@ theElements)\)]]; \[IndentingNewLine]\n
          elements3Doutput = 
            element2DTo3D[nodeListvariable, 
              elementListvariable]; \[IndentingNewLine]\n
          ansisdata = {nodes3Doutput, 
              elements3Doutput}; \[IndentingNewLine]\[IndentingNewLine]Return[
            ansisdata]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentFunction3D (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(CurrentFunction3D[\[IndentingNewLine]\
meshdata : {{{_Integer, _Real, _Real, _Real, _Integer} .. }, {{_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer} .. }}, \
\[IndentingNewLine]electrode_Integer, \[IndentingNewLine]listOfGeometries : {\
\(({\(({{_Integer, _Integer}, _Real, _Real})\) .. , {_Real, _Real, _Real}})\) \
.. }, \[IndentingNewLine]concList : {{\((_Real)\) .. } .. }] := 
        Module[{geometryofBoundaryNodesFunction, boundaryNodes, 
            geometryofBoundaryNodes, geometryofBCNodes, assembleFunction, 
            cutrrentPerTimestep}, \
\[IndentingNewLine]\[IndentingNewLine]geometryofBoundaryNodesFunction[k_] := 
            Module[{positionofBCNodesFunction, positionofBCNodes, 
                sortNodesFunction, nodePairsWithGeometryFunction, 
                nodePairsWithGeometry, 
                sortNodes}, \
\[IndentingNewLine]\[IndentingNewLine]positionofBCNodesFunction[
                  i_] := \(Position[listOfGeometries[\([All, All, 1]\)], 
                    i]\)[\([All, {1, 
                      2}]\)]; \[IndentingNewLine]positionofBCNodes = 
                positionofBCNodesFunction[k]; \[IndentingNewLine]\n
              nodePairsWithGeometryFunction[{i_, j_}] := 
                listOfGeometries[\([i, j]\)]; \n
              nodePairsWithGeometry = 
                nodePairsWithGeometryFunction /@ 
                  positionofBCNodes; \
\[IndentingNewLine]\[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_}] := {{y, x}, m, l} /; 
                  x =!= k; \[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_}] := {{x, y}, m, l} /; 
                  x == k; \[IndentingNewLine]\[IndentingNewLine]sortNodes = 
                sortNodesFunction /@ 
                  nodePairsWithGeometry; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                sortNodes]\[IndentingNewLine]]; \[IndentingNewLine]\n
          boundaryNodes = 
            Flatten[Position[meshdata[\([1, All, 5]\)], 
                electrode]]; \[IndentingNewLine]\n
          geometryofBoundaryNodes = 
            Partition[
              Flatten[geometryofBoundaryNodesFunction /@ boundaryNodes], 
              4]; \[IndentingNewLine]\[IndentingNewLine]geometryofBCNodes = 
            geometryofBoundaryNodes; \n\[IndentingNewLine]assembleFunction[
              concentrations_] := 
            Module[{gradientTimesAreaFunction, 
                gradientTimesArea}, \
\[IndentingNewLine]gradientTimesAreaFunction[
                  i_] := \[IndentingNewLine]\((concentrations[\([\
geometryofBCNodes[\([i, 2]\)]]\)] - 
                      concentrations[\([geometryofBCNodes[\([i, 1]\)]]\)])\)*
                  geometryofBCNodes[\([i, 4]\)]/
                    geometryofBCNodes[\([i, 
                        3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]gradientTimesArea = 
                gradientTimesAreaFunction /@ 
                  Range[Length[
                      geometryofBCNodes]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                Apply[Plus, gradientTimesArea]]\[IndentingNewLine]]; \n
          cutrrentPerTimestep = 
            assembleFunction /@ concList; \[IndentingNewLine]Return[
            cutrrentPerTimestep]\[IndentingNewLine]];\)\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["McDonaldGeometryFunction", "Subsection"],

Cell[BoxData[
    \(\(McDonaldGeometryFunction[
          ansysdataMc : {nodeList : {\(({_Integer, _Real, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]elementList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }}] := 
        Module[{elementMcDonaldGeometryFunction, 
            elementMcDonaldGeometry}, \[IndentingNewLine]\[IndentingNewLine]\n
          elementMcDonaldGeometryFunction[element_] := 
            Module[{outPut, outPutFunction, volumeOfMcDonaldSubzells, 
                volumeOfMcDonaldSubzellsFunction, normalVectors, 
                mcDonaldSubareas, edgeVector, edgeVectorFunction, edgeLength, 
                edgeLengthFunction, edgeCenters, edgeCentersFunction, 
                massPointTriangle, massPointTriangleFunction, trianglesNodes, 
                massPointTet, nodePairs, nodeNumbers, edgeNormalVectors, 
                areaDotEdgeFunction, areaDotEdge, reducedAreas}, \n\n
              nodeNumbers = 
                ansysdataMc[\([2, 
                    element, {2, 3, 4, 5}]\)]; \[IndentingNewLine]\n
              nodePairs = {{nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTet = 
                Apply[Plus, ansysdataMc[\([1, nodeNumbers, {2, 3, 4}]\)]]/
                  4; \[IndentingNewLine]\n
              trianglesNodes = {{nodeNumbers[\([1]\)], nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTriangleFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/3; \n
              massPointTriangle = 
                massPointTriangleFunction /@ 
                  trianglesNodes; \[IndentingNewLine]\n
              edgeCentersFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/2; \n
              edgeCenters = 
                edgeCentersFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeLengthFunction[nNumbers_] := 
                Apply[Plus, \((ansysdataMc[\([1, 
                              nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                          ansysdataMc[\([1, 
                              nNumbers[\([2]\)], {2, 3, 4}]\)])\)^2]^ .5; \n
              edgeLength = 
                edgeLengthFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeVectorFunction[
                  nNumbers_] := \((ansysdataMc[\([1, 
                        nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                    ansysdataMc[\([1, nNumbers[\([2]\)], {2, 3, 4}]\)])\); \n
              edgeVector = 
                edgeVectorFunction /@ 
                  nodePairs; \n (*vector\ von\ massPointTet\ zu\ edgeCenters\ \
zwei\ mal\ benutzen\ x\ vector\ non\ edgeCenters\ zu\ massPointTriangle . \ 
                    Das\ Kreuzprodukt\ des\ einen\ Paares\ muss\ orthogonal\ \
\((dotproduct)\)\ zum\ dritten\ vector\ sein, \ 
                dann\ sind\ beide\ Flaechen\ in\ einer\ Ebene\ \((Beweis\ \
wurde\ in\ Mathematica\ symbolisch\ durchgefuehrt)\)*) \[IndentingNewLine]\
\[IndentingNewLine]mcDonaldSubareas = {\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2}; \[IndentingNewLine]\[IndentingNewLine]\n
              areaNormalVectors = {\((CrossProduct[\((edgeCenters[\([1]\)] - 
                            massPointTet)\), \((edgeCenters[\([1]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\n\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([1]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([2]\)] - 
                            massPointTet)\), \((edgeCenters[\([2]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([2]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([3]\)] - 
                            massPointTet)\), \((edgeCenters[\([3]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                      
                                      massPointTet)\), \
\((edgeCenters[\([3]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([4]\)] - 
                            massPointTet)\), \((edgeCenters[\([4]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([4]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([5]\)] - 
                            massPointTet)\), \((edgeCenters[\([5]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([5]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([6]\)] - 
                            massPointTet)\), \((edgeCenters[\([6]\)] - 
                            massPointTriangle[\([3]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([6]\)] - 
                                      massPointTriangle[\([3]\)])\)])\)^2])\)^\
 .5)\)}; \[IndentingNewLine]\[IndentingNewLine]edgeNormalVectors = 
                edgeVector/
                  edgeLength; \
\[IndentingNewLine]\[IndentingNewLine]areaDotEdgeFunction[j_] := 
                Abs[DotProduct[areaNormalVectors[\([j]\)], 
                    edgeNormalVectors[\([j]\)]]]; \
\[IndentingNewLine]areaDotEdge = 
                areaDotEdgeFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\n
              reducedAreas = 
                mcDonaldSubareas*
                  areaDotEdge; \
\[IndentingNewLine]\[IndentingNewLine]volumeOfMcDonaldSubzellsFunction[{{{x1_,\
 y1_, z1_}, {x2_, y2_, z2_}}, {x3_, y3_, z3_}, {x4_, y4_, 
                      z4_}, {{x5_, y5_, z5_}, {x6_, y6_, 
                        z6_}}}] := {\((Abs[
                          Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, z4, 
                                1}, {x6, y6, z6, 1}}]] + 
                        Abs[Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, 
                                z4, 1}, {x5, y5, z5, 1}}]])\)/
                    6}; \n (*\(\(**\)\(\(*\)\(volumeVariable\)\)\) = \
{{ansysdataMc[\([1, nodePairs[\([1]\)], {2, 3, 4}]\)], edgeCenters[\([1]\)], 
                      massPointTet, 
                      massPointTriangle[\([{1, 2}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([2]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([2]\)], massPointTet, 
                      massPointTriangle[\([{1, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([3]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([3]\)], massPointTet, 
                      massPointTriangle[\([{2, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([4]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([4]\)], massPointTet, 
                      massPointTriangle[\([{1, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([5]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([5]\)], massPointTet, 
                      massPointTriangle[\([{2, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([6]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([6]\)], massPointTet, 
                      massPointTriangle[\([{3, 4}]\)]}}****) \n
              volumeOfMcDonaldSubzells = 
                volumeOfMcDonaldSubzellsFunction[{ansysdataMc[\([1, 
                        nodePairs[\([1]\)], {2, 3, 4}]\)], 
                    edgeCenters[\([1]\)], massPointTet, 
                    massPointTriangle[\([{1, 
                          2}]\)]}]; \  (*all\ 12\ McDonald\ subvolumes\ in\ a\
\ tetrahedron\ have\ the\ same\ value*) \n\[IndentingNewLine]outPutFunction[
                  i_] := {nodePairs[\([i]\)], lengthEdge[\([i]\)], 
                  reducedAreas[\([i]\)], 
                  volumeOfMcDonaldSubzells[\([1]\)]}; \n
              outPut = 
                outPutFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\[IndentingNewLine]Return[
                outPut]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]elementMcDonaldGeometry = 
            elementMcDonaldGeometryFunction /@ 
              Range[Length[
                  elementList]]; \[IndentingNewLine]\[IndentingNewLine]Return[
            elementMcDonaldGeometry]\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["McDonaldGeometryFunction", "Subsection"],

Cell[BoxData[
    \(\(McDonaldGeometryFunction[
          ansysdataMc : {nodeList : {\(({_Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]elementList : {\(({_Real, _Real, _Real, \
_Real, _Real, _Real})\) .. }}] := 
        Module[{elementMcDonaldGeometryFunction, 
            elementMcDonaldGeometry}, \[IndentingNewLine]\[IndentingNewLine]\n
          elementMcDonaldGeometryFunction[element_] := 
            Module[{outPut, outPutFunction, volumeOfMcDonaldSubzells, 
                volumeOfMcDonaldSubzellsFunction, normalVectors, 
                mcDonaldSubareas, edgeVector, edgeVectorFunction, edgeLength, 
                edgeLengthFunction, edgeCenters, edgeCentersFunction, 
                massPointTriangle, massPointTriangleFunction, trianglesNodes, 
                massPointTet, nodePairs, nodeNumbers, edgeNormalVectors, 
                areaDotEdgeFunction, areaDotEdge, reducedAreas}, \n\n
              nodeNumbers = 
                ansysdataMc[\([2, 
                    element, {2, 3, 4, 5}]\)]; \[IndentingNewLine]\n
              nodePairs = {{nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTet = 
                Apply[Plus, ansysdataMc[\([1, nodeNumbers, {2, 3, 4}]\)]]/
                  4; \[IndentingNewLine]\n
              trianglesNodes = {{nodeNumbers[\([1]\)], nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTriangleFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/3; \n
              massPointTriangle = 
                massPointTriangleFunction /@ 
                  trianglesNodes; \[IndentingNewLine]\n
              edgeCentersFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/2; \n
              edgeCenters = 
                edgeCentersFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeLengthFunction[nNumbers_] := 
                Apply[Plus, \((ansysdataMc[\([1, 
                              nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                          ansysdataMc[\([1, 
                              nNumbers[\([2]\)], {2, 3, 4}]\)])\)^2]^ .5; \n
              edgeLength = 
                edgeLengthFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeVectorFunction[
                  nNumbers_] := \((ansysdataMc[\([1, 
                        nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                    ansysdataMc[\([1, nNumbers[\([2]\)], {2, 3, 4}]\)])\); \n
              edgeVector = 
                edgeVectorFunction /@ 
                  nodePairs; \n (*vector\ von\ massPointTet\ zu\ edgeCenters\ \
zwei\ mal\ benutzen\ x\ vector\ non\ edgeCenters\ zu\ massPointTriangle . \ 
                    Das\ Kreuzprodukt\ des\ einen\ Paares\ muss\ orthogonal\ \
\((dotproduct)\)\ zum\ dritten\ vector\ sein, \ 
                dann\ sind\ beide\ Flaechen\ in\ einer\ Ebene\ \((Beweis\ \
wurde\ in\ Mathematica\ symbolisch\ durchgefuehrt)\)*) \[IndentingNewLine]\
\[IndentingNewLine]mcDonaldSubareas = {\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2}; \[IndentingNewLine]\[IndentingNewLine]\n
              areaNormalVectors = {\((CrossProduct[\((edgeCenters[\([1]\)] - 
                            massPointTet)\), \((edgeCenters[\([1]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\n\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([1]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([2]\)] - 
                            massPointTet)\), \((edgeCenters[\([2]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([2]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([3]\)] - 
                            massPointTet)\), \((edgeCenters[\([3]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([3]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([4]\)] - 
                            massPointTet)\), \((edgeCenters[\([4]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([4]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([5]\)] - 
                            massPointTet)\), \((edgeCenters[\([5]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([5]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([6]\)] - 
                            massPointTet)\), \((edgeCenters[\([6]\)] - 
                            massPointTriangle[\([3]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([6]\)] - 
                                      massPointTriangle[\([3]\)])\)])\)^2])\)^\
 .5)\)}; \[IndentingNewLine]\[IndentingNewLine]edgeNormalVectors = 
                edgeVector/
                  edgeLength; \
\[IndentingNewLine]\[IndentingNewLine]areaDotEdgeFunction[j_] := 
                Abs[DotProduct[areaNormalVectors[\([j]\)], 
                    edgeNormalVectors[\([j]\)]]]; \
\[IndentingNewLine]areaDotEdge = 
                areaDotEdgeFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\n
              reducedAreas = 
                mcDonaldSubareas*
                  areaDotEdge; \
\[IndentingNewLine]\[IndentingNewLine]volumeOfMcDonaldSubzellsFunction[{{{x1_,\
 y1_, z1_}, {x2_, y2_, z2_}}, {x3_, y3_, z3_}, {x4_, y4_, 
                      z4_}, {{x5_, y5_, z5_}, {x6_, y6_, 
                        z6_}}}] := {\((Abs[
                          Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, z4, 
                                1}, {x6, y6, z6, 1}}]] + 
                        Abs[Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, 
                                z4, 1}, {x5, y5, z5, 1}}]])\)/
                    6}; \n (*\(\(**\)\(\(*\)\(volumeVariable\)\)\) = \
{{ansysdataMc[\([1, nodePairs[\([1]\)], {2, 3, 4}]\)], edgeCenters[\([1]\)], 
                      massPointTet, 
                      massPointTriangle[\([{1, 2}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([2]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([2]\)], massPointTet, 
                      massPointTriangle[\([{1, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([3]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([3]\)], massPointTet, 
                      massPointTriangle[\([{2, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([4]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([4]\)], massPointTet, 
                      massPointTriangle[\([{1, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([5]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([5]\)], massPointTet, 
                      massPointTriangle[\([{2, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([6]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([6]\)], massPointTet, 
                      massPointTriangle[\([{3, 4}]\)]}}****) \n
              volumeOfMcDonaldSubzells = 
                volumeOfMcDonaldSubzellsFunction[{ansysdataMc[\([1, 
                        nodePairs[\([1]\)], {2, 3, 4}]\)], 
                    edgeCenters[\([1]\)], massPointTet, 
                    massPointTriangle[\([{1, 
                          2}]\)]}]; \  (*all\ 12\ McDonald\ subvolumes\ in\ a\
\ tetrahedron\ have\ the\ same\ value*) \n\[IndentingNewLine]outPutFunction[
                  i_] := {nodePairs[\([i]\)], edgeLength[\([i]\)], 
                  reducedAreas[\([i]\)], 
                  volumeOfMcDonaldSubzells[\([1]\)]}; \n
              outPut = 
                outPutFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\[IndentingNewLine]Return[
                outPut]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]elementMcDonaldGeometry = 
            elementMcDonaldGeometryFunction /@ 
              Range[Length[
                  elementList]]; \[IndentingNewLine]\[IndentingNewLine]Return[
            elementMcDonaldGeometry]\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["McDonaldGeometryFunction", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(McDonaldGeometryFunction[
          ansysdataMc : {nodeList : {\(({_Integer, _Real, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]elementList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }}] := 
        Module[{elementMcDonaldGeometryFunction, 
            elementMcDonaldGeometry}, \[IndentingNewLine]\[IndentingNewLine]\n
          elementMcDonaldGeometryFunction[element_] := 
            Module[{outPut, outPutFunction, volumeOfMcDonaldSubzells, 
                volumeOfMcDonaldSubzellsFunction, normalVectors, 
                mcDonaldSubareas, edgeVector, edgeVectorFunction, edgeLength, 
                edgeLengthFunction, edgeCenters, edgeCentersFunction, 
                massPointTriangle, massPointTriangleFunction, trianglesNodes, 
                massPointTet, nodePairs, nodeNumbers, edgeNormalVectors, 
                areaDotEdgeFunction, areaDotEdge, reducedAreas}, \n\n
              nodeNumbers = 
                ansysdataMc[\([2, 
                    element, {2, 3, 4, 5}]\)]; \[IndentingNewLine]\n
              nodePairs = {{nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTet = 
                Apply[Plus, ansysdataMc[\([1, nodeNumbers, {2, 3, 4}]\)]]/
                  4; \[IndentingNewLine]\n
              trianglesNodes = {{nodeNumbers[\([1]\)], nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTriangleFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/3; \n
              massPointTriangle = 
                massPointTriangleFunction /@ 
                  trianglesNodes; \[IndentingNewLine]\n
              edgeCentersFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/2; \n
              edgeCenters = 
                edgeCentersFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeLengthFunction[nNumbers_] := 
                Apply[Plus, \((ansysdataMc[\([1, 
                              nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                          ansysdataMc[\([1, 
                              nNumbers[\([2]\)], {2, 3, 4}]\)])\)^2]^ .5; \n
              edgeLength = 
                edgeLengthFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeVectorFunction[
                  nNumbers_] := \((ansysdataMc[\([1, 
                        nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                    ansysdataMc[\([1, nNumbers[\([2]\)], {2, 3, 4}]\)])\); \n
              edgeVector = 
                edgeVectorFunction /@ 
                  nodePairs; \n (*vector\ von\ massPointTet\ zu\ edgeCenters\ \
zwei\ mal\ benutzen\ x\ vector\ non\ edgeCenters\ zu\ massPointTriangle . \ 
                    Das\ Kreuzprodukt\ des\ einen\ Paares\ muss\ orthogonal\ \
\((dotproduct)\)\ zum\ dritten\ vector\ sein, \ 
                dann\ sind\ beide\ Flaechen\ in\ einer\ Ebene\ \((Beweis\ \
wurde\ in\ Mathematica\ symbolisch\ durchgefuehrt)\)*) \[IndentingNewLine]\
\[IndentingNewLine]mcDonaldSubareas = {\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2}; \[IndentingNewLine]\[IndentingNewLine]\n
              areaNormalVectors = {\((CrossProduct[\((edgeCenters[\([1]\)] - 
                            massPointTet)\), \((edgeCenters[\([1]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\n\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([1]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([2]\)] - 
                            massPointTet)\), \((edgeCenters[\([2]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([2]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([3]\)] - 
                            massPointTet)\), \((edgeCenters[\([3]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                      
                                      massPointTet)\), \
\((edgeCenters[\([3]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([4]\)] - 
                            massPointTet)\), \((edgeCenters[\([4]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([4]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([5]\)] - 
                            massPointTet)\), \((edgeCenters[\([5]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([5]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([6]\)] - 
                            massPointTet)\), \((edgeCenters[\([6]\)] - 
                            massPointTriangle[\([3]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([6]\)] - 
                                      massPointTriangle[\([3]\)])\)])\)^2])\)^\
 .5)\)}; \[IndentingNewLine]\[IndentingNewLine]edgeNormalVectors = 
                edgeVector/
                  edgeLength; \
\[IndentingNewLine]\[IndentingNewLine]areaDotEdgeFunction[j_] := 
                Abs[DotProduct[areaNormalVectors[\([j]\)], 
                    edgeNormalVectors[\([j]\)]]]; \
\[IndentingNewLine]areaDotEdge = 
                areaDotEdgeFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\n
              reducedAreas = 
                mcDonaldSubareas*
                  areaDotEdge; \
\[IndentingNewLine]\[IndentingNewLine]volumeOfMcDonaldSubzellsFunction[{{{x1_,\
 y1_, z1_}, {x2_, y2_, z2_}}, {x3_, y3_, z3_}, {x4_, y4_, 
                      z4_}, {{x5_, y5_, z5_}, {x6_, y6_, 
                        z6_}}}] := {\((Abs[
                          Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, z4, 
                                1}, {x6, y6, z6, 1}}]] + 
                        Abs[Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, 
                                z4, 1}, {x5, y5, z5, 1}}]])\)/
                    6}; \n (*\(\(**\)\(\(*\)\(volumeVariable\)\)\) = \
{{ansysdataMc[\([1, nodePairs[\([1]\)], {2, 3, 4}]\)], edgeCenters[\([1]\)], 
                      massPointTet, 
                      massPointTriangle[\([{1, 2}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([2]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([2]\)], massPointTet, 
                      massPointTriangle[\([{1, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([3]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([3]\)], massPointTet, 
                      massPointTriangle[\([{2, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([4]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([4]\)], massPointTet, 
                      massPointTriangle[\([{1, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([5]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([5]\)], massPointTet, 
                      massPointTriangle[\([{2, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([6]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([6]\)], massPointTet, 
                      massPointTriangle[\([{3, 4}]\)]}}****) \n
              volumeOfMcDonaldSubzells = 
                volumeOfMcDonaldSubzellsFunction[{ansysdataMc[\([1, 
                        nodePairs[\([1]\)], {2, 3, 4}]\)], 
                    edgeCenters[\([1]\)], massPointTet, 
                    massPointTriangle[\([{1, 
                          2}]\)]}]; \  (*all\ 12\ McDonald\ subvolumes\ in\ a\
\ tetrahedron\ have\ the\ same\ value*) \n\[IndentingNewLine]outPutFunction[
                  i_] := {nodePairs[\([i]\)], edgeLength[\([i]\)], 
                  reducedAreas[\([i]\)], 
                  volumeOfMcDonaldSubzells[\([1]\)]}; \n
              outPut = 
                outPutFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\[IndentingNewLine]Return[
                outPut]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]elementMcDonaldGeometry = 
            elementMcDonaldGeometryFunction /@ 
              Range[Length[
                  elementList]]; \[IndentingNewLine]\[IndentingNewLine]Return[
            elementMcDonaldGeometry]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation AnsysMcDonaldEquationSystemSteadyState3D  (*not \
specified *)\
\>", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(AnsysMcDonaldEquationSystemSteadyState3D[listOfGeometries_, 
          tetgenData_, Dif_, electrodeReactionValues_, dirichletBoundaries_, 
          initialConcentrations_] := 
        Module[{elementAssembleFunction, numberOfNodes, rightHandSideVector, 
            nodeMarcs, electrodeReactionsFunktion, 
            elektrodenVariablenFunktion, elektrodenVariablen, 
            electrodeReaction, aIndices, dirichletBcNodesFunktion, 
            dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, a, allNodePairs, nodesPerElement, 
            nodepairsForEverySpezies, sparseInitialisation, 
            sparseDiagonalInitialisation, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*
              Start\ sparse\ matrix\ initialization*********************)  \
(*\(\(*\)\(this\)\(\ \)\(part\)\(\ \)\(produces\)\(\ \)\(all\)\(\ \)\(a[i, 
                  j]\)\) = 0\ which\ apeares\ in\ the\ final\ sparse\ matrix**) 
            nodesPerElement = \(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 
                  5}]\)]; \[IndentingNewLine]nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, nodePairs}, 
              nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];]; \[IndentingNewLine]allNodePairs = 
            nodepairsForEverySpezies /@ 
              Range[Length[
                  diffcoef]]; \[IndentingNewLine]sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]sparseDiagonalInitialisation[
              i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              end\ sparse\ matrix\ initialization\
*********************) \[IndentingNewLine]\n
          elementAssembleFunction[listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[{assembleFunction, i, voro1, voro2, voro3, voro4, voro5, 
                voro6},  (*this\ rows\ calculate\ the\ area\ of\ the\ voronoi\
\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : A[i, j]/\[CapitalDelta][i, j]*) i = 
                listOfGeom; \[IndentingNewLine]voro1 = 
                i[\([1, 3]\)]/i[\([1, 2]\)]; \[IndentingNewLine]voro2 = 
                i[\([2, 3]\)]/i[\([2, 2]\)]; \[IndentingNewLine]voro3 = 
                i[\([3, 3]\)]/i[\([3, 2]\)]; \[IndentingNewLine]voro4 = 
                i[\([4, 3]\)]/i[\([4, 2]\)]; \[IndentingNewLine]voro5 = 
                i[\([5, 3]\)]/i[\([5, 2]\)]; \[IndentingNewLine]voro6 = 
                i[\([6, 3]\)]/
                  i[\([6, 2]\)]; \[IndentingNewLine]assembleFunction[
                  spezNumber_] := 
                Module[{diffcoefOfSpez, multiSpez, voroDif1, voroDif2, 
                    voroDif3, voroDif4, voroDif5, voroDif6}, 
                  diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*numberOfNodes; \[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1; \[IndentingNewLine]voroDif2 = 
                    diffcoefOfSpez*voro2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2; \[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3; \[IndentingNewLine]voroDif4 = 
                    diffcoefOfSpez*voro4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4; \[IndentingNewLine]voroDif5 = 
                    diffcoefOfSpez*voro5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5; \[IndentingNewLine]voroDif6 = 
                    diffcoefOfSpez*voro6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    voroDif6;]; \[IndentingNewLine]assembleFunction /@ 
                Range[Length[diffcoef]];]; \[IndentingNewLine]Outer[
            elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              End\ AssembleFunction*********************) 
            Print[{stelle2, 
              MemoryInUse[]}]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              Start\ rightHandSideVector\
*********************) \[IndentingNewLine]rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine]vectorOfConcentrations \
= Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              End\ rightHandSideVector\
*********************) \[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*
              Start\ of\ electrode\ reactions\
*********************) \[IndentingNewLine]electrodeReactionsFunktion[i_, j_] := 
            If[nodeMarcs[\([i]\)] \[Equal] 
                electrodeReactionValues[\([j, 1]\)], 
              a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]a[\((electrodeReactionValues[\
\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);]; \
\[IndentingNewLine]elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 
                    1]\)]], {i}]; \[IndentingNewLine]elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 
              3]; \[IndentingNewLine] (*Durch\ die\ Elektrodevariablen\ \
werden\ nur\ noch\ die\ Elektrodenpunkte\\\nabgefragt\ dadurch\ werden\ viele\
\ Loops\ gespart*) 
            electrodeReaction = \(Apply[electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              End\ of\ electrode\ reactions\
*********************) \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              Start\ Dirichlet**************************) \[IndentingNewLine]\
aIndices = \(Level[#1, {2}] &\) @@@ 
              DownValues[a]; \[IndentingNewLine]dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, 
                dirichletBoundaries[\([i, 
                    1]\)]]]; \[IndentingNewLine]dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[
                  dirichletBoundaries]]; \
\[IndentingNewLine]allDirichletNodesFunction[
              j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \[IndentingNewLine]allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ 
                Range[Length[
                    Dif]]]; \[IndentingNewLine]dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 
              1]; \[IndentingNewLine]dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                1]]; \[IndentingNewLine]dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \[IndentingNewLine]\(Apply[
                dirichletEliminationFunktion, #] &\) /@ 
            dirichletLines; \[IndentingNewLine]diagonDirichl[
              i_] := \(a[i, i] = 
              1\); \[IndentingNewLine]diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \
\[IndentingNewLine]dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[
                      Flatten[
                        dirichletBcNodes]]}]}]; \
\[IndentingNewLine]dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 
              1]; \[IndentingNewLine]dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 
              initialConcentrations[\([j]\)]\); \[IndentingNewLine]\(Apply[
                dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]concentrationFunction[
              k_] := Module[{diricFunction}, 
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, 
                      j]\)]\); \[IndentingNewLine]\(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ \
die\\\nNodenumbers*) , 
                    Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \[IndentingNewLine]concentrationFunction /@ 
            Range[
              Length[dirichletBoundaries]]; \[IndentingNewLine] (*\(\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*
              End\ of\ \
Dirichlet*********************) \[IndentingNewLine]sparseStiffnessMatrix = \
\(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]Return[{sparseStiffnessMatrix, 
              vectorOfConcentrations}]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysMcDonaldEquationSystemSteadyState3D", "Subsection"],

Cell[BoxData[
    \(\(AnsysMcDonaldEquationSystemSteadyState3D[\[IndentingNewLine]\
listOfGeometries : {\(({\(({{_Integer, _Integer}, _Real, _Real, _Real})\) \
.. })\) .. }, \[IndentingNewLine]\[IndentingNewLine]tetgenData : {{{_Integer, \
_Real, _Real, _Real, _Integer} .. }, {{_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer} .. }}, \
\[IndentingNewLine]\[IndentingNewLine]Dif : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, \
{_Integer, _Integer}, {_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]initialConcentrations : {\((_Real | \
_Integer)\) .. }\[IndentingNewLine]] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{elementAssembleFunction, 
            numberOfNodes, rightHandSideVector, nodeMarcs, 
            electrodeReactionsFunktion, elektrodenVariablenFunktion, 
            elektrodenVariablen, electrodeReaction, aIndices, 
            dirichletBcNodesFunktion, dirichletBcNodes, 
            allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, a, allNodePairs, nodesPerElement, 
            nodepairsForEverySpezies, sparseInitialisation, 
            sparseDiagonalInitialisation, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]Print[{stelle0, 
              MemoryInUse[]}]; \[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]nodesPerElement = \
\(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  
                ** *****) \[IndentingNewLine]Print[{stelle1, 
              MemoryInUse[]}]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \n\[IndentingNewLine]elementAssembleFunction[listOfGeom_, 
              diffcoef_, numberOfNodes_] := 
            Module[{assembleFunction, i, voro1, voro2, voro3, voro4, voro5, 
                voro6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, j]\ *) \[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/i[\([6, 2]\)]; \n
              assembleFunction[spezNumber_] := 
                Module[{diffcoefOfSpez, multiSpez, voroDif1, voroDif2, 
                    voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1; \[IndentingNewLine]\[IndentingNewLine]voroDif2 \
= diffcoefOfSpez*voro2; \[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3; \[IndentingNewLine]\[IndentingNewLine]voroDif4 \
= diffcoefOfSpez*voro4; \[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4; \[IndentingNewLine]\[IndentingNewLine]voroDif5 \
= diffcoefOfSpez*voro5; \[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5; \[IndentingNewLine]\[IndentingNewLine]voroDif6 \
= diffcoefOfSpez*voro6; \[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    voroDif6;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \n\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          Print[{stelle2, 
              MemoryInUse[]}]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]rightHandSideVector = 
            Table[0, {Length[diffcoef]*numberOfNodes}]; \[IndentingNewLine]\n
          vectorOfConcentrations = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine]\n (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 
              3]; \[IndentingNewLine] (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \n
          electrodeReaction = \(Apply[electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          Print[{stelle3, 
              MemoryInUse[]}]; \[IndentingNewLine]\[IndentingNewLine] (*\(\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  ** **************) \n
          aIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 
              initialConcentrations[\([j]\)]\); \n\(Apply[
                dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\n\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \nPrint[{stelle4, MemoryInUse[]}]; \n
          sparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, 
              vectorOfConcentrations}]\[IndentingNewLine]\[IndentingNewLine]];\
\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysMcDonaldEquationSystemSteadyState3D", "Subsection"],

Cell[BoxData[
    \(\(AnsysMcDonaldEquationSystemSteadyState3D[\[IndentingNewLine]\
listOfGeometries : {\(({\(({{_Real, _Real}, _Real, _Real, _Real})\) .. })\) \
.. }, \[IndentingNewLine]tetgenData : {{{_Real, _Real, _Real, _Real, _Real} \
.. }, {{_Real, _Real, _Real, _Real, _Real, _Real} .. }}, \[IndentingNewLine]\
\[IndentingNewLine]Dif : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ _Integer, \ _Integer, \
\ _Integer, \ \ \ butvolmHin : _Real | _Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }\
\[IndentingNewLine]] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{elementAssembleFunction, 
            numberOfNodes, rightHandSideVector, nodeMarcs, 
            electrodeReactionsFunktion, elektrodenVariablenFunktion, 
            elektrodenVariablen, electrodeReaction, aIndices, 
            dirichletBcNodesFunktion, dirichletBcNodes, 
            allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, a, allNodePairs, nodesPerElement, 
            nodepairsForEverySpezies, sparseInitialisation, 
            sparseDiagonalInitialisation, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]nodesPerElement = \
\(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[{assembleFunction, i, voro1, voro2, voro3, voro4, voro5, 
                voro6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, j]\ *) \[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/i[\([6, 2]\)]; \n
              assembleFunction[spezNumber_] := 
                Module[{diffcoefOfSpez, multiSpez, voroDif1, voroDif2, 
                    voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1; \[IndentingNewLine]\[IndentingNewLine]voroDif2 \
= diffcoefOfSpez*voro2; \[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3; \[IndentingNewLine]\[IndentingNewLine]voroDif4 \
= diffcoefOfSpez*voro4; \[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4; \[IndentingNewLine]\[IndentingNewLine]voroDif5 \
= diffcoefOfSpez*voro5; \[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5; \[IndentingNewLine]\[IndentingNewLine]voroDif6 \
= diffcoefOfSpez*voro6; \[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    voroDif6;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\) ** \
\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\
\[IndentingNewLine]vectorOfConcentrations = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine]\n (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n (*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 
              initialConcentrations[\([j]\)]\); \n\(Apply[
                dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\n\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, 
              vectorOfConcentrations}]\[IndentingNewLine]\[IndentingNewLine]];\
\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation AnsysMcDonaldEquationSystemTrans3D  (*specified *)\
\
\>", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(AnsysMcDonaldEquationSystemTrans3D[
          listOfGeometries : {\(({\(({{_Integer, _Integer}, _Real, _Real, \
_Real})\) .. })\) .. }, \[IndentingNewLine]tetgenData : {{{_Integer, _Real, \
_Real, _Real, _Integer} .. }, {{_Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer} .. }}, \[IndentingNewLine]Dif : {\((_Real | _Integer)\) \
.. }, \[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ _Integer, \ \
_Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]timeStep : \((_Real | _Integer)\)] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{elementAssembleFunction, numberOfNodes, 
            rightHandSideVector, nodeMarcs, electrodeReactionsFunktion, 
            elektrodenVariablenFunktion, elektrodenVariablen, 
            electrodeReaction, aIndices, dirichletBcNodesFunktion, 
            dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, vectorOfConcentrationsFunction, 
            vectorOfConcentrations, 
            a}, \[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine]\[IndentingNewLine]\
vectorOfConcentrationsFunction[i_] := 
            Table[initialConcentrations[\([i]\)], {numberOfNodes}]; \n
          vectorOfConcentrations = 
            Flatten[vectorOfConcentrationsFunction /@ 
                Range[Length[
                    initialConcentrations]]]; \[IndentingNewLine]\
\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  
                **  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \
\)\(part\)\(\ \)\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]nodesPerElement \
= \(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[\[IndentingNewLine]{assembleFunction, i, voro1, voro2, 
                voro3, voro4, voro5, voro6, volume1, volume2, volume3, 
                volume4, volume5, 
                volume6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, 
                      j]\ *) \[IndentingNewLine]\[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/
                  i[\([6, 
                      2]\)]; \[IndentingNewLine]\[IndentingNewLine] (*this\ \
lines\ calculate\ the\ volume\ of\ the\ voronoi\ box\ of\ one\ element, \ 
                between\ each\ node\ pair\ ij*) \n
              volume1 = \(volume2 = \(volume3 = \(volume4 = \(volume5 = \
\(volume6 = i[\([1, 4]\)]\)\)\)\)\); \[IndentingNewLine]\n
              assembleFunction[spezNumber_] := 
                Module[\[IndentingNewLine]{diffcoefOfSpez, multiSpez, 
                    voroDif1, voroDif2, voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += \((voroDif1 + 
                        volume1/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += \((voroDif1 + 
                        volume1/timeStep)\); 
                  rightHandSideVector[\([multiSpez + i[\([1, 1, 1]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([1, 1, 2]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif2 = 
                    diffcoefOfSpez*voro2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += \((voroDif2 + 
                        volume2/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += \((voroDif2 + 
                        volume2/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 1]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 2]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += \((voroDif3 + 
                        volume3/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += \((voroDif3 + 
                        volume3/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 1]\)]]\)] += 
                    volume3/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 2]\)]]\)] += 
                    volume3/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif4 = 
                    diffcoefOfSpez*voro4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += \((voroDif4 + 
                        volume4/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += \((voroDif4 + 
                        volume4/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 1]\)]]\)] += 
                    volume4/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 2]\)]]\)] += 
                    volume4/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif5 = 
                    diffcoefOfSpez*voro5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += \((voroDif5 + 
                        volume5/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += \((voroDif5 + 
                        volume5/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 1]\)]]\)] += 
                    volume5/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 2]\)]]\)] += 
                    volume5/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif6 = 
                    diffcoefOfSpez*voro6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += \((voroDif6 + 
                        volume6/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += \((voroDif6 + 
                        volume6/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 1]\)]]\)] += 
                    volume6/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 2]\)]]\)] += 
                    volume6/
                      timeStep;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \n\[IndentingNewLine]vectorOfVolumes = 
            rightHandSideVector*
              timeStep;  (*vectorOfVolumes\ is\ needed\ for\ model\ order\ \
reduction\ \((C - 
                  vector)\)*) \[IndentingNewLine]\[IndentingNewLine] (*\(\(\
**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  ** *****) \n\
\[IndentingNewLine]\[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \ \ \[IndentingNewLine] (*\(\(**\)\(**\)\) \
** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(\
**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 1\); \n\(Apply[dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\[IndentingNewLine]\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, rightHandSideVector, vectorOfConcentrations, 
              vectorOfVolumes}]\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentFunctionMcDonald3D (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(CurrentFunctionMcDonald3D[\[IndentingNewLine]\
meshdata : {{{_Integer, _Real, _Real, _Real, _Integer} .. }, {{_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer} .. }}, \
\[IndentingNewLine]electrode_Integer, \[IndentingNewLine]listOfGeometries : {\
\(({\(({{_Integer, _Integer}, _Real, _Real, _Real})\) .. })\) .. }, \
\[IndentingNewLine]concList : {{\((_Real)\) .. } .. }] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{geometryofBoundaryNodesFunction, boundaryNodes, 
            geometryofBoundaryNodes, geometryofBCNodes, assembleFunction, 
            cutrrentPerTimestep}, \
\[IndentingNewLine]\[IndentingNewLine]geometryofBoundaryNodesFunction[k_] := 
            Module[{positionofBCNodesFunction, positionofBCNodes, 
                sortNodesFunction, nodePairsWithGeometryFunction, 
                nodePairsWithGeometry, 
                sortNodes}, \
\[IndentingNewLine]\[IndentingNewLine]positionofBCNodesFunction[
                  i_] := \(Position[listOfGeometries[\([All, All, 1]\)], 
                    i]\)[\([All, {1, 
                      2}]\)]; \[IndentingNewLine]positionofBCNodes = 
                positionofBCNodesFunction[k]; \[IndentingNewLine]\n
              nodePairsWithGeometryFunction[{i_, j_}] := 
                listOfGeometries[\([i, j]\)]; \n
              nodePairsWithGeometry = 
                nodePairsWithGeometryFunction /@ 
                  positionofBCNodes; \
\[IndentingNewLine]\[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_, n_}] := {{y, x}, m, l, n} /; 
                  x =!= k; \[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_, n_}] := {{x, y}, m, l, n} /; 
                  x == k; \[IndentingNewLine]\[IndentingNewLine]sortNodes = 
                sortNodesFunction /@ 
                  nodePairsWithGeometry; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                sortNodes]\[IndentingNewLine]]; \[IndentingNewLine]\n
          boundaryNodes = 
            Flatten[Position[meshdata[\([1, All, 5]\)], 
                electrode]]; \[IndentingNewLine]\n
          geometryofBoundaryNodes = 
            Partition[
              Flatten[geometryofBoundaryNodesFunction /@ boundaryNodes], 
              5]; \[IndentingNewLine]\[IndentingNewLine]geometryofBCNodes = 
            geometryofBoundaryNodes; \n\[IndentingNewLine]assembleFunction[
              concentrations_] := 
            Module[{gradientTimesAreaFunction, 
                gradientTimesArea}, \
\[IndentingNewLine]gradientTimesAreaFunction[
                  i_] := \[IndentingNewLine]\((concentrations[\([\
geometryofBCNodes[\([i, 2]\)]]\)] - 
                      concentrations[\([geometryofBCNodes[\([i, 1]\)]]\)])\)*
                  geometryofBCNodes[\([i, 4]\)]/
                    geometryofBCNodes[\([i, 
                        3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]gradientTimesArea = 
                gradientTimesAreaFunction /@ 
                  Range[Length[
                      geometryofBCNodes]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                Apply[Plus, gradientTimesArea]]\[IndentingNewLine]]; \n
          cutrrentPerTimestep = 
            assembleFunction /@ concList; \[IndentingNewLine]Return[
            cutrrentPerTimestep]\[IndentingNewLine]];\)\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation Calculation SteadyState  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(SteadyStateCalculation[
          equationElements : {sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }}] := 
        Module[{concentrationsVerteilung, matrixA, 
            vectorE}, \[IndentingNewLine]\[IndentingNewLine]matrixA = 
            equationElements[\([1]\)]; \[IndentingNewLine]vectorE = 
            equationElements[\([2]\)]; \
\[IndentingNewLine]\[IndentingNewLine]concentrationsVerteilung = 
            Developer`SparseLinearSolve[matrixA, 
              vectorE]; \
\[IndentingNewLine]\[IndentingNewLine]Return[{concentrationsVerteilung}];\
\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation Calculation Timedep.  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(TransientCalculation[{sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }, 
            initialConcentrations : {\((_Real | _Integer)\) .. }, 
            elementVolumes : {\((_Real | _Integer)\) .. }}, 
          tges : \((_Real | _Integer)\), 
          timeStep : \((_Real | _Integer)\)] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{concentrationsVerteilung, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]vectorOfConcentrations = 
            initialConcentrations; \
\[IndentingNewLine]concentrationsVerteilung = 
            Table[vectorOfConcentrations = 
                Developer`SparseLinearSolve[
                  sparseMatrix, \((rightHandVector*
                      vectorOfConcentrations)\)], {tges/
                  timeStep}]; \[IndentingNewLine]Return[
            concentrationsVerteilung];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CvCalculation  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(CvCalculation[\ 
          equationElements : {sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }, 
              initialConcentrations : {\((_Real | _Integer)\) .. }, 
              elementVolumes : {\((_Real | _Integer)\) .. }}, Tges_\ , \ 
          deltaT_\ , \ deltaEstart_\ , \ deltaEend_\ , deltaE_\ ] := 
        Module[{concentrationsVerteilung, vectorOfConcentrations, 
            potentialSteps, potentialList, 
            i}, \[IndentingNewLine]\[IndentingNewLine]potentialSteps = \
\((deltaEend - deltaEstart)\)/\((Tges/\ 
                  deltaT)\)\ ; \[IndentingNewLine]potentialList = 
            Join[Table[i, {i, deltaEstart, deltaEend, potentialSteps}], 
              Reverse[Table[
                  i, {i, deltaEstart, deltaEend, 
                    potentialSteps}]]]; \
\[IndentingNewLine]\[IndentingNewLine]vectorOfConcentrations = 
            equationElements[\([3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]concentrationsVerteilung = 
            Table[vectorOfConcentrations = 
                Developer`SparseLinearSolve[
                  equationElements[\([1]\)] /. 
                    deltaE \[Rule] 
                      potentialList[\([i]\)], \((equationElements[\([2]\)]*
                      vectorOfConcentrations)\)\ ], {i, 
                Length[potentialList]}]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
            concentrationsVerteilung];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CvMultistepCalculation  (*specified *)", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(CvMultistepCalculation[\ 
          equationElements : {sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }, 
              initialConcentrations : {\((_Real | _Integer)\) .. }, 
              elementVolumes : {\((_Real | _Integer)\) .. }}, 
          timePotentialList : {{\((_Real | _Integer)\)\ , \ \((_Real | \
_Integer)\)\ , \ \((_Real | _Integer)\)\ , \ \((_Real | _Integer)\)} .. }, 
          deltaE_\ ] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{concentrationsVerteilung, 
            vectorOfConcentrations, potentialSteps, potentialList, 
            i}, \[IndentingNewLine]\[IndentingNewLine]PotentialListFunction[
              cv1_] := Module[{potentialSteps, 
                potentialList}, \
\[IndentingNewLine]\[IndentingNewLine]potentialSteps = \((cv1[\([4]\)] - 
                      cv1[\([3]\)])\)/\((cv1[\([1]\)]/\ 
                      cv1[\([2]\)])\)\ ; \[IndentingNewLine]potentialList1 = 
                Table[i, {i, cv1[\([3]\)], cv1[\([4]\)], 
                    potentialSteps}]; \[IndentingNewLine]\ \ \ Return[
                potentialList1]\[IndentingNewLine]]; \
\[IndentingNewLine]potentialList = 
            Flatten[PotentialListFunction /@ 
                timePotentialList]; \
\[IndentingNewLine]\[IndentingNewLine]vectorOfConcentrations = 
            equationElements[\([3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]concentrationsVerteilung = 
            Table[vectorOfConcentrations = 
                Developer`SparseLinearSolve[
                  equationElements[\([1]\)] /. 
                    deltaE \[Rule] 
                      potentialList[\([i]\)], \((equationElements[\([2]\)]*
                      vectorOfConcentrations)\)\ ], {i, 
                Length[potentialList]}]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
            concentrationsVerteilung];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["PointInBox      (****eigenstaendig****)  2+3D", "Subsection",
  InitializationCell->True],

Cell[BoxData[{
    \(\(\(PointInBox[box_, point_] := 
        Module[{testFunction3, 
              testresult}, \
\[IndentingNewLine]\[IndentingNewLine]testFunction3[{x0_, y0_, deltaX_, 
                  deltaY_}, {a_, x_, y_, b_}] := {a, \(-1\)} /; 
                x0 > x || x > \((x0 + deltaX)\) || y0 > y || 
                  y > \((y0 + deltaY)\); \n\n
            testFunction3[{x0_, y0_, deltaX_, deltaY_}, {a_, x_, y_, 
                  b_}] := {a, 0} /; 
                x \[Equal] x0 || 
                  x \[Equal] \((x0 + deltaX)\) && 
                    y0 \[LessEqual] y \[LessEqual] \((y0 + deltaY)\); \n\n
            testFunction3[{x0_, y0_, deltaX_, deltaY_}, {a_, x_, y_, 
                  b_}] := {a, 0} /; 
                y \[Equal] y0 || 
                  y \[Equal] \((y0 + deltaY)\) && 
                    x0 \[LessEqual] x \[LessEqual] \((x0 + deltaX)\); \n\n
            testFunction3[{x0_, y0_, deltaX_, deltaY_}, {a_, x_, y_, 
                  b_}] := {a, 1} /; 
                x > x0 && x < \((x0 + deltaX)\) && y0 < y && 
                  y < \((y0 + 
                        deltaY)\); \
\[IndentingNewLine]\[IndentingNewLine]testFunction3[{x0_, y0_, z0_, deltaX_, 
                  deltaY_, deltaZ_}, {a_, x_, y_, z_, b_}] := {a, \(-1\)} /; 
                x0 > x || x > \((x0 + deltaX)\) || y0 > y || 
                  y > \((y0 + deltaY)\) || z0 > z || 
                  z > \((z0 + deltaZ)\); \n\n
            testFunction3[{x0_, y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, 
                  x_, y_, z_, b_}] := {a, 0} /; 
                x \[Equal] x0 || 
                  x \[Equal] \((x0 + deltaX)\) && 
                    y0 \[LessEqual] y \[LessEqual] \((y0 + deltaY)\) && 
                    z0 \[LessEqual] z \[LessEqual] \((z0 + deltaZ)\); \n\n
            testFunction3[{x0_, y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, 
                  x_, y_, z_, b_}] := {a, 0} /; 
                y \[Equal] y0 || 
                  y \[Equal] \((y0 + deltaY)\) && 
                    x0 \[LessEqual] x \[LessEqual] \((x0 + deltaX)\) && 
                    z0 \[LessEqual] 
                      z \[LessEqual] \((z0 + 
                          deltaZ)\); \n\[IndentingNewLine]testFunction3[{x0_, 
                  y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, x_, y_, z_, 
                  b_}] := {a, 0} /; 
                z \[Equal] z0 || 
                  z \[Equal] \((z0 + deltaZ)\) && 
                    x0 \[LessEqual] x \[LessEqual] \((x0 + deltaX)\) && 
                    y0 \[LessEqual] 
                      y \[LessEqual] \((y0 + deltaY)\); \[IndentingNewLine]\n
            testFunction3[{x0_, y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, 
                  x_, y_, z_, b_}] := {a, 1} /; 
                x > x0 && x < \((x0 + deltaX)\) && y0 < y || 
                  y < \((y0 + deltaY)\) && z0 < z || 
                  z < \((z0 + 
                        deltaZ)\); \
\[IndentingNewLine]\[IndentingNewLine]testresult = 
              testFunction3[box, 
                point]; \[IndentingNewLine]\[IndentingNewLine]Return[
              testresult];\[IndentingNewLine]\[IndentingNewLine]] /; \
\((Length[box] \[Equal] 4 && 
                Length[point] \[Equal] 4)\) || \((Length[box] \[Equal] 6 && 
                Length[point] \[Equal] 5)\);\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(PointInBox::"\<inputData\>" = "\<argument badly conditioned\>";\)\), \
"\[IndentingNewLine]", 
    \(\(PointInBox[___] := 
        Message[PointInBox::"\<inputData\>"];\)\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
BoundaryElementTest  Function for one element  \
(****eigenstaendig****)  2+3D\
\>", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(BoundaryElementTest[nodeNumbers_, 
        testedNodes_] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{boundaryElementTestFunction, 
          boundaryElement}, \
\[IndentingNewLine]\[IndentingNewLine]testedNodesList = \(testedNodes[\([All, 
                2]\)]\)[\([nodeNumbers]\)]; \[IndentingNewLine]\
\[IndentingNewLine]boundaryElementTestFunction[{nodes : {a_, b_, c_, d_}, 
              tags : {e_, f_, g_, h_}}] := 
          raus /; \((Count[tags, 1] \[Equal] 0 && Count[tags, 0] =!= 4)\) || 
              Count[tags, 1] \[Equal] 4; \n
        boundaryElementTestFunction[{nodes : {a_, b_, c_, d_}, 
              tags : {e_, f_, g_, h_}}] := {nodes, tags}; \n
        boundaryElementTestFunction[{nodes : {a_, b_, c_}, 
              tags : {e_, f_, g_}}] := 
          raus /; \((Count[tags, 1] \[Equal] 0 && Count[tags, 0] =!= 3)\) || 
              Count[tags, 1] \[Equal] 3; \n
        boundaryElementTestFunction[{nodes : {a_, b_, c_}, 
              tags : {e_, f_, g_}}] := {nodes, 
            tags}; \n\[IndentingNewLine]boundaryElement = 
          boundaryElementTestFunction[{nodeNumbers, 
              testedNodesList}]; \[IndentingNewLine]\[IndentingNewLine]Return[
          boundaryElement]\[IndentingNewLine]\[IndentingNewLine]]\)], "Input",\

  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentThroughBoxFunction2DAxissymetr", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    RowBox[{"\[IndentingNewLine]", 
      RowBox[{\(CurrentThroughBoxFunction2DAxissymetr[fixedNode_, meshData_, 
          geometrys2D_, concDistributionSteady_]\), ":=", 
        "\[IndentingNewLine]", "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{
              "TestElementOnBoundary", ",", "elementsOnBoundary", ",", 
                StyleBox["ElementMatrixAssembleFunction2D",
                  FontVariations->{"CompatibilityType"->0}], 
                StyleBox[",",
                  FontVariations->{"CompatibilityType"->0}], 
                "elementMatrixAssemble", ",", "ElementCurrentFunction", ",", 
                "elementCurrentList", ",", "positionsOfInnerNodes", ",", 
                "CurrentPerElementandNodeFunction", ",", 
                "currentThroughBox"}], "}"}], ",", "\[IndentingNewLine]", 
            "\[IndentingNewLine]", "\[IndentingNewLine]", 
            
            RowBox[{\(testFunction[i_] := 
                PointInBox[fixedNode, meshData[\([1, i]\)]]\), ";", 
              "\[IndentingNewLine]", \(testedNodes2D = 
                testFunction /@ Range[Length[meshData[\([1]\)]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(ElementsOnBox = 
                BoundaryElementTest[meshData[\([3, 1, {2, 3, 4}]\)], 
                  testedNodes2D]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(TestElementOnBoundary[meshData2D_, 
                  testedNodes2D_] := 
                Module[{testedElementFunction, 
                    testedElement}, \[IndentingNewLine]\n
                  testedElementFunction[i_] := 
                    BoundaryElementTest[meshData2D[\([3, 1, {2, 3, 4}]\)], 
                      testedNodes2D]; \[IndentingNewLine]testedElement = 
                    testedElementFunction /@ 
                      Range[Length[
                          meshData2D[\([3, 
                              1, {2, 3, 
                                4}]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[testedElement]\[IndentingNewLine]]\), ";", "\n", 
              "\[IndentingNewLine]", \(elementsOnBoundary = 
                DeleteCases[
                  TestElementOnBoundary[meshData, testedNodes2D], _Symbol]\), 
              ";", "\[IndentingNewLine]", "\n", 
              RowBox[{
                RowBox[{
                  StyleBox["ElementMatrixAssembleFunction2D",
                    FontVariations->{"CompatibilityType"->0}], "[", 
                  "\[IndentingNewLine]", \(geometry : {boxSideLengthvariable \
: {\(({_Real, _Real, _Real})\) .. }, \
\[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
                      radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, \
_Real, _Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, \
_Real, _Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : \
{\(({_Real, _Real, _Real})\) .. }}\), "\[IndentingNewLine]", 
                  "\[IndentingNewLine]", "]"}], ":=", "\[IndentingNewLine]", 
                "\[IndentingNewLine]", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
                      nodeNumbersPerElement, radiusOfCel, radiusOfFlux, 
                      boxSideLength, lengthOfElementsides, 
                      sparseMatrixAValues}\), ",", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    
                    RowBox[{\(boxSideLength = geometry[\([\)\(1\)\(]\)]\), 
                      ";", "\[IndentingNewLine]", \(lengthOfElementsides = 
                        geometry[\([\)\(2\)\(]\)]\), ";", 
                      "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                        geometry[\([\)\(3\)\(]\)]\), ";", 
                      "\[IndentingNewLine]", \(numberOfNodes = 
                        geometry[\([\)\(4\)\(]\)]\), ";", 
                      "\[IndentingNewLine]", \(radiusOfCel = 
                        geometry[\([\)\(5\)\(]\)]\), ";", 
                      "\[IndentingNewLine]", \(radiusOfFlux = 
                        geometry[\([\)\(6\)\(]\)]\), ";", 
                      "\[IndentingNewLine]", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", 
                      RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                        RowBox[{"Module", "[", 
                          
                          RowBox[{\({x, y, z, u, v, w, 
                              numberOfSpezFunction}\), ",", 
                            "\[IndentingNewLine]", "\[IndentingNewLine]", 
                            "\[IndentingNewLine]", 
                            RowBox[{
                              RowBox[{"x", "=", 
                                RowBox[{\(radiusOfFlux[\([\)\(i, 1\)\(]\)]\), 
                                  "*", 
                                  RowBox[{
                                    RowBox[{
                                      StyleBox["(",
                                        FontColor->GrayLevel[0]], 
                                      RowBox[{"boxSideLength", 
                                        StyleBox["/",
                                        FontColor->GrayLevel[0]], 
                                        "lengthOfElementsides"}], ")"}], 
                                    "[", \(\([\)\(i, 1\)\(]\)\), "]"}]}]}], 
                              ";", "\[IndentingNewLine]", 
                              RowBox[{"y", "=", 
                                
                                RowBox[{\(radiusOfFlux[\([\)\(i, 2\)\(]\)]\), 
                                  "*", 
                                  RowBox[{
                                    RowBox[{
                                      StyleBox["(",
                                        FontColor->GrayLevel[0]], 
                                      RowBox[{"boxSideLength", 
                                        StyleBox["/",
                                        FontColor->GrayLevel[0]], 
                                        "lengthOfElementsides"}], ")"}], 
                                    "[", \(\([\)\(i, 2\)\(]\)\), "]"}]}]}], 
                              ";", "\[IndentingNewLine]", 
                              RowBox[{"z", "=", 
                                
                                RowBox[{\(radiusOfFlux[\([\)\(i, 3\)\(]\)]\), 
                                  "*", 
                                  RowBox[{
                                    RowBox[{
                                      StyleBox["(",
                                        FontColor->GrayLevel[0]], 
                                      RowBox[{"boxSideLength", 
                                        StyleBox["/",
                                        FontColor->GrayLevel[0]], 
                                        "lengthOfElementsides"}], ")"}], 
                                    "[", \(\([\)\(i, 3\)\(]\)\), "]"}]}]}], 
                              ";", "\[IndentingNewLine]", 
                              "\[IndentingNewLine]", \(u = 
                                nodeNumbersPerElement[\([\)\(i, 1\)\(]\)]\), 
                              ";", 
                              "\[IndentingNewLine]", \(v = 
                                nodeNumbersPerElement[\([\)\(i, 2\)\(]\)]\), 
                              ";", "\[IndentingNewLine]", \(w = 
                                nodeNumbersPerElement[\([\)\(i, 3\)\(]\)]\), 
                              ";", "\[IndentingNewLine]", 
                              "\[IndentingNewLine]", \(Return[{i, {u, v, 
                                    w}, {{\((x + 
                                        y)\), \(-\((x)\)\), \(-\((y)\)\)}, \
{\(-\((x)\)\), \((x + 
                                        z)\), \(-\((z)\)\)}, {\(-\((y)\)\), \
\(-\((z)\)\), \((y + z)\)}}}]\)}]}], "\[IndentingNewLine]", 
                          "\[IndentingNewLine]", "]"}]}], " ", ";", 
                      "\n", \(sparseMatrixAValues = 
                        sparseMatrixAValuesFunction /@ 
                          Range[Length[nodeNumbersPerElement]]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(Return[
                        sparseMatrixAValues]\)}]}], "\[IndentingNewLine]", 
                  "]"}]}], ";", "\n", "\n", 
              RowBox[{"elementMatrixAssemble", "=", 
                StyleBox[\(ElementMatrixAssembleFunction2D[geometrys2D]\),
                  FontVariations->{"CompatibilityType"->0}]}], 
              StyleBox[";",
                FontVariations->{"CompatibilityType"->0}], 
              "\[IndentingNewLine]", 
              "\n", \(ElementCurrentFunction[concDistribution_, 
                  elementMatrix_] := 
                Module[{EachTimestepFunction, 
                    EachTimestepCurrents}, \[IndentingNewLine]\
\[IndentingNewLine]EachTimestepFunction[timestep_] := 
                    Module[{concDistributionOfTimestep, 
                        ElementCurrentPerTimestepFunction, 
                        elementCurrentPerTimestep}, \[IndentingNewLine]\n
                      concDistributionOfTimestep = 
                        concDistribution[\([\)\(timestep\)\(]\)]; \
\[IndentingNewLine]\nElementCurrentPerTimestepFunction[elementNumber_] := 
                        Module[{nodeNumbersPerElement, 
                            elementCurrentInner}, \[IndentingNewLine]\n
                          nodeNumbersPerElement = \
\(elementMatrix[\([\)\(elementNumber\)\(]\)]\)[\([\)\(2\)\(]\)]; \
\[IndentingNewLine]\n
                          elementCurrentInner = \
\((\(elementMatrix[\([\)\(elementNumber\)\(]\)]\)[\([\)\(3\)\(]\)])\) . \
\((concDistributionOfTimestep[\([\)\(nodeNumbersPerElement\)\(]\)])\); \
\[IndentingNewLine]\[IndentingNewLine]Return[{nodeNumbersPerElement, 
                              
                              elementCurrentInner}]; \[IndentingNewLine]]; \
\[IndentingNewLine]\nelementCurrentPerTimestep = 
                        ElementCurrentPerTimestepFunction /@ 
                          Range[Length[
                              elementMatrix]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                        elementCurrentPerTimestep]; \[IndentingNewLine]\
\[IndentingNewLine]]; \[IndentingNewLine]EachTimestepCurrents = 
                    EachTimestepFunction /@ 
                      Range[Length[
                          concDistribution]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[EachTimestepCurrents]\[IndentingNewLine]\n]\), ";", 
              "\n", \(elementCurrentList = 
                ElementCurrentFunction[concDistributionSteady, 
                  elementMatrixAssemble]\), ";", "\[IndentingNewLine]", 
              "\n", \(positionsOfInnerNodes = 
                Position[elementsOnBoundary[\([\)\(All, 2\)\(]\)], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\n", \(CurrentPerElementandNodeFunction[i_] := 
                elementCurrentList[\([\)\(1, 
                  positionsOfInnerNodes[\([\)\(i, 1\)\(]\)], 2, 
                  positionsOfInnerNodes[\([\)\(i, 2\)\(]\)]\)\(]\)]\), ";", 
              "\n", \(currentThroughBox = 
                Apply[Plus, 
                  CurrentPerElementandNodeFunction /@ 
                    Range[Length[positionsOfInnerNodes]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[currentThroughBox]\)}]}], 
          "\[IndentingNewLine]", "\[IndentingNewLine]", "]"}]}]}]], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["BoundarynodesFunction3D", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(BoundarynodesFunction3D[boundaryMarker_, 
          ansysdata_] \
:= \[IndentingNewLine]{\(\(ansysdata[\([1]\)]\)[\([Flatten[
                  Position[\(ansysdata[\([1]\)]\)[\([All, \(-1\)]\)], 
                    boundaryMarker]]]\)]\)[\([All, 
              1]\)], \(\(ansysdata[\([1]\)]\)[\([Flatten[
                  Position[\(ansysdata[\([1]\)]\)[\([All, \(-1\)]\)], 
                    boundaryMarker]]]\)]\)[\([All, {2, 3, 4}]\)], 
          Sort[\(\(ansysdata[\([1]\)]\)[\([Flatten[
                    Position[\(ansysdata[\([1]\)]\)[\([All, \(-1\)]\)], 
                      boundaryMarker]]]\)]\)[\([All, 2]\)]], 
          Sort[\(\(ansysdata[\([1]\)]\)[\([Flatten[
                    Position[\(ansysdata[\([1]\)]\)[\([All, \(-1\)]\)], 
                      boundaryMarker]]]\)]\)[\([All, 3]\)]], 
          Sort[\(\(ansysdata[\([1]\)]\)[\([Flatten[
                    Position[\(ansysdata[\([1]\)]\)[\([All, \(-1\)]\)], 
                      boundaryMarker]]]\)]\)[\([All, 4]\)]]};\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentThroughBoxFunction3D", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(CurrentThroughBoxFunction3D[fixedNode3D_, ansisdata2to3_, 
          listOfGeometriesMcDonald_, concDistributionSteady3DMcDonald_] := 
        Module[{testFunction, testedNodes3D, TestElementOnBoundary, 
            elementsOnBoundary, ReducedListOfGeometries3DFunction, 
            reducedListOfGeometries3D, ElementMatrixAssembleFunction, 
            elementMatrixAssemble, ElementCurrentFunction, 
            ElementCurrentList, positionsOfInnerNodes, 
            CurrentPerElementandNodeFunction, 
            wholeCurrent}, \[IndentingNewLine]\[IndentingNewLine]\n
          testFunction[i_] := 
            PointInBox[fixedNode3D, ansisdata2to3[\([1, i]\)]]; \n
          testedNodes3D = 
            testFunction /@ 
              Range[Length[
                  ansisdata2to3[\([1]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]\n
          TestElementOnBoundary[ansisdata3D_, testedNodes_] := 
            Module[{testedElementFunction, 
                testedElement}, \[IndentingNewLine]\n
              testedElementFunction[i_] := 
                BoundaryElementTest[\(ansisdata3D[\([2, 
                        All, {2, 3, 4, 5}]\)]\)[\([i]\)], 
                  testedNodes3D]; \[IndentingNewLine]testedElement = 
                testedElementFunction /@ 
                  Range[Length[
                      ansisdata3D[\([2, 
                          All, {2, 3, 4, 
                            5}]\)]]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                testedElement]\[IndentingNewLine]]; \n
          elementsOnBoundary = 
            DeleteCases[
              TestElementOnBoundary[ansisdata2to3, 
                testedNodes3D], _Symbol]; \n\[IndentingNewLine]\
\[IndentingNewLine]ReducedListOfGeometries3DFunction[listOfGeometries3D_, 
              ansisdata3D_, elementsOnBoundary_] := 
            Module[{BoundaryElementNumberFunction, 
                reducedListOfGeometriesMcDonald}, \[IndentingNewLine]\
\[IndentingNewLine]BoundaryElementNumberFunction[ansisdata_] := 
                Module[{positionNumbers, 
                    eachBoundaryElementNumberFunction}, \[IndentingNewLine]\n
                  eachBoundaryElementNumberFunction[i_] := 
                    Position[ansisdata[\([2, All, {2, 3, 4, 5}]\)], 
                      elementsOnBoundary[\([i, 
                          1]\)]]; \[IndentingNewLine]positionNumbers = 
                    eachBoundaryElementNumberFunction /@ 
                      Range[Length[
                          elementsOnBoundary]]; \[IndentingNewLine]Return[
                    positionNumbers]\[IndentingNewLine]]; \n
              reducedListOfGeometriesMcDonald = 
                listOfGeometries3D[\([Flatten[
                      BoundaryElementNumberFunction[
                        ansisdata3D]]]\)]; \[IndentingNewLine]Return[
                reducedListOfGeometriesMcDonald]\[IndentingNewLine]]; \
\[IndentingNewLine]reducedListOfGeometries3D = 
            ReducedListOfGeometries3DFunction[listOfGeometriesMcDonald, 
              ansisdata2to3, 
              elementsOnBoundary]; \n\
\[IndentingNewLine]\[IndentingNewLine]ElementMatrixAssembleFunction[
              listOfGeometries3D_] := 
            Module[{ElementMatrixFunction, 
                ElementMatrix}, \[IndentingNewLine]\n
              ElementMatrixFunction[
                  i_] := \[IndentingNewLine]Module[{elementData, nodeNumbers, 
                    voro1, voro2, voro3, voro4, voro5, voro6, 
                    elementMatrixInner}, \[IndentingNewLine]\
\[IndentingNewLine]elementData = 
                    listOfGeometries3D[\([i]\)]; \
\[IndentingNewLine]nodeNumbers = {elementData[\([1, 1, 1]\)], 
                      elementData[\([1, 1, 2]\)], elementData[\([2, 1, 2]\)], 
                      elementData[\([3, 1, 2]\)]}; \[IndentingNewLine]voro1 = 
                    elementData[\([1, 3]\)]/elementData[\([1, 2]\)]; \n
                  voro2 = elementData[\([2, 3]\)]/elementData[\([2, 2]\)]; \n
                  voro3 = elementData[\([3, 3]\)]/elementData[\([3, 2]\)]; \n
                  voro4 = elementData[\([4, 3]\)]/elementData[\([4, 2]\)]; \n
                  voro5 = elementData[\([5, 3]\)]/elementData[\([5, 2]\)]; \n
                  voro6 = 
                    elementData[\([6, 3]\)]/
                      elementData[\([6, 
                          2]\)]; \n\[IndentingNewLine]elementMatrixInner = {{\
\(-\((voro1 + voro2 + voro3)\)\), voro1, voro2, 
                        voro3}, {voro1, \(-\((voro1 + voro4 + voro5)\)\), 
                        voro4, voro5}, {voro2, 
                        voro4, \(-\((voro2 + voro4 + voro6)\)\), 
                        voro6}, {voro3, voro5, 
                        voro6, \(-\((voro3 + voro5 + 
                              voro6)\)\)}}; \[IndentingNewLine]Return[{i, 
                      nodeNumbers, 
                      elementMatrixInner}]\[IndentingNewLine]]; \
\[IndentingNewLine]ElementMatrix = 
                ElementMatrixFunction /@ 
                  Range[Length[
                      listOfGeometries3D]]; \[IndentingNewLine]Return[
                ElementMatrix]\[IndentingNewLine]]; \
\[IndentingNewLine]elementMatrixAssemble = 
            ElementMatrixAssembleFunction[
              reducedListOfGeometries3D]; \[IndentingNewLine]\
\[IndentingNewLine]\n
          ElementCurrentFunction[concDistribution_, elementMatrix_] := 
            Module[{EachTimestepFunction, 
                EachTimestepCurrents}, \
\[IndentingNewLine]\[IndentingNewLine]EachTimestepFunction[timestep_] := 
                Module[{concDistributionOfTimestep, 
                    ElementCurrentPerTimestepFunction, 
                    elementCurrentPerTimestep}, \[IndentingNewLine]\n
                  concDistributionOfTimestep = 
                    concDistribution[\([timestep]\)]; \n
                  ElementCurrentPerTimestepFunction[elementNumber_] := 
                    Module[{nodeNumbersPerElement, 
                        elementCurrentInner}, \[IndentingNewLine]\n
                      nodeNumbersPerElement = \
\(elementMatrix[\([elementNumber]\)]\)[\([2]\)]; \n
                      elementCurrentInner = \
\((\(elementMatrix[\([elementNumber]\)]\)[\([3]\)])\) . \
\((concDistributionOfTimestep[\([nodeNumbersPerElement]\)])\); \
\[IndentingNewLine]Return[{nodeNumbersPerElement, 
                          elementCurrentInner}];\[IndentingNewLine]]; \n
                  elementCurrentPerTimestep = 
                    ElementCurrentPerTimestepFunction /@ 
                      Range[Length[elementMatrix]]; \[IndentingNewLine]Return[
                    elementCurrentPerTimestep];\[IndentingNewLine]]; \
\[IndentingNewLine]EachTimestepCurrents = 
                EachTimestepFunction /@ 
                  Range[Length[concDistribution]]; \[IndentingNewLine]Return[
                EachTimestepCurrents]\n]; \n
          ElementCurrentList = 
            ElementCurrentFunction[concDistributionSteady3DMcDonald, 
              elementMatrixAssemble]; \[IndentingNewLine]\n
          positionsOfInnerNodes = 
            Position[elementsOnBoundary[\([All, 2]\)], 
              1]; \[IndentingNewLine]\n
          CurrentPerElementandNodeFunction[i_] := 
            ElementCurrentList[\([1, positionsOfInnerNodes[\([i, 1]\)], 2, 
                positionsOfInnerNodes[\([i, 2]\)]]\)]; \n
          wholeCurrent = 
            Apply[Plus, 
              CurrentPerElementandNodeFunction /@ 
                Range[Length[positionsOfInnerNodes]]]; \[IndentingNewLine]\n
          Return[wholeCurrent]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["NodeinFlatFunction", "Subsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(NodeinFlatFunction[ansysdata_, a_, b_, koord_] := 
        Module[{NodeinFlatFunctionInner, NodeinFlat, kordinate}, 
          kordinate[h_] := 
            Module[{}, \(k = 1;\)] /; 
              koord \[Equal] x || 
                koord \[Equal] X; \[IndentingNewLine]kordinate[h_] := 
            Module[{}, \(k = 2;\)] /; 
              koord \[Equal] y || 
                koord \[Equal] Y; \[IndentingNewLine]kordinate[h_] := 
            Module[{}, \(k = 3;\)] /; 
              koord \[Equal] z || 
                koord \[Equal] Z; \[IndentingNewLine]kordinate[h_] := 
            Module[{}, \(k = 0;\)]; \[IndentingNewLine]kordinate[
            h]; \[IndentingNewLine]flaechenNodes[x_] := 
            ansysdata[\([1, x, {1, 2, 3}]\)] /; 
              k \[Equal] 3 && ansysdata[\([1, x, k + 1]\)] \[GreaterEqual] a && 
                b \[GreaterEqual] 
                  ansysdata[\([1, x, 
                      k + 1]\)]; \[IndentingNewLine]flaechenNodes[x_] := 
            ansysdata[\([1, x, {1, 2, 4}]\)] /; 
              k \[Equal] 2 && ansysdata[\([1, x, k + 1]\)] \[GreaterEqual] a && 
                b \[GreaterEqual] 
                  ansysdata[\([1, x, 
                      k + 1]\)]; \[IndentingNewLine]flaechenNodes[x_] := 
            ansysdata[\([1, x, {1, 3, 4}]\)] /; 
              k \[Equal] 1 && ansysdata[\([1, x, k + 1]\)] \[GreaterEqual] a && 
                b \[GreaterEqual] 
                  ansysdata[\([1, x, 
                      k + 1]\)]; \[IndentingNewLine]flaechenNodes[x_] := 
            p; \[IndentingNewLine]NodeinFlat = 
            flaechenNodes /@ 
              Range[Length[ansysdata[\([1]\)]]]; \[IndentingNewLine]Return[
            DeleteCases[NodeinFlat, _Symbol]]];\)\)], "Input",
  InitializationCell->True],

Cell[BoxData[
    \(\(NodeinFlatFunction2[ansysdata_, a_, b_, k_] := 
        Module[{NodeinFlatFunctionInner, NodeinFlat}, 
          flaechenNodes[x_] := 
            ansysdata[\([1, x, {1, 2, 3}]\)] /; 
              k \[Equal] 3 && ansysdata[\([1, x, k + 1]\)] \[GreaterEqual] a && 
                b \[GreaterEqual] 
                  ansysdata[\([1, x, 
                      k + 1]\)]; \[IndentingNewLine]flaechenNodes[x_] := 
            ansysdata[\([1, x, {1, 2, 4}]\)] /; 
              k \[Equal] 2 && ansysdata[\([1, x, k + 1]\)] \[GreaterEqual] a && 
                b \[GreaterEqual] 
                  ansysdata[\([1, x, 
                      k + 1]\)]; \[IndentingNewLine]flaechenNodes[x_] := 
            ansysdata[\([1, x, {1, 3, 4}]\)] /; 
              k \[Equal] 1 && ansysdata[\([1, x, k + 1]\)] \[GreaterEqual] a && 
                b \[GreaterEqual] 
                  ansysdata[\([1, x, 
                      k + 1]\)]; \[IndentingNewLine]flaechenNodes[x_] := 
            p; \[IndentingNewLine]NodeinFlat = 
            flaechenNodes /@ 
              Range[Length[ansysdata[\([1]\)]]]; \[IndentingNewLine]Return[
            DeleteCases[NodeinFlat, _Symbol]]];\)\)], "Input"],

Cell[CellGroupData[{

Cell["PlotMesh (*specified *)", "Subsubsection"],

Cell[BoxData[
    \(\(PlotMesh[
          easymeshData : {nodeList : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementList : {\(({_Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, _Real, \
_Integer})\) .. }}] := \[IndentingNewLine]\[IndentingNewLine]Module[\
\[IndentingNewLine]{easymeshMeshGraphics, linienPlotFunkt, liste333, 
            voronoilinienPlotFunkt, liste222, voronoiBoundaryNodesFunction, 
            voronoiBoundaryNodes, voronoiNeighbours, 
            voronoiBoundaryPlotFunkt, voronoiBoundaryPlot, 
            delaunayBoundaryNodesFunction, 
            delaunayBoundaryNodes}, \
\[IndentingNewLine]\[IndentingNewLine]linienPlotFunkt[i_] := 
            Line[{easymeshData[\([1, easymeshData[\([2, i, 2]\)], {2, 3}]\)], 
                easymeshData[\([1, 
                    easymeshData[\([2, i, 3]\)], {2, 3}]\)]}]; \n
          liste333 = 
            linienPlotFunkt /@ 
              Range[Length[
                  easymeshData[\([2]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]Off[Part::"\<partd\>"]; \n
          voronoilinienPlotFunkt[i_] := 
            Line[{easymeshData[\([3, 
                    easymeshData[\([2, i, 4]\)], {11, 12}]\)], 
                easymeshData[\([3, 
                    easymeshData[\([2, i, 5]\)], {11, 12}]\)]}]; \n
          liste222 = 
            voronoilinienPlotFunkt /@ 
              Range[Length[
                  easymeshData[\([2]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]voronoiBoundaryNodesFunction[i_] := 
            Apply[Plus, easymeshData[\([1, i, {2, 3}]\)]]/2; \n
          voronoiBoundaryNodes = 
            voronoiBoundaryNodesFunction /@ 
              easymeshData[\([2, 
                  Flatten[
                    Position[\(Transpose[easymeshData[\([2]\)]]\)[\([5]\)], 
                      0]], {2, 3}]\)] (*randpunkte\ Voronoi*) ; \n
          voronoiNeighbours = 
            easymeshData[\([3, 
                easymeshData[\([2, 
                    Flatten[
                      Position[\(Transpose[easymeshData[\([2]\)]]\)[\([5]\)], 
                        0]], 4]\)], {11, 12}]\)]; \n
          voronoiBoundaryPlotFunkt[i_] := 
            Line[{voronoiBoundaryNodes[\([i]\)], 
                voronoiNeighbours[\([i]\)]}]; \n
          voronoiBoundaryPlot = 
            voronoiBoundaryPlotFunkt /@ 
              Range[Length[voronoiNeighbours]];  (*\ 
            Liste\ mit\ den\ zwei\ Punkten\ einer\ VoronoiRandSeite\ \
*) \[IndentingNewLine]\[IndentingNewLine]delaunayBoundaryNodesFunction[i_] := 
            Line[easymeshData[\([1, i, {2, 3}]\)]]; \n
          delaunayBoundaryNodes = 
            delaunayBoundaryNodesFunction /@ 
              Append[easymeshData[\([2, 
                    Flatten[
                      Position[\(Transpose[easymeshData[\([2]\)]]\)[\([5]\)], 
                        0]], {2, 3}]\)], 
                Flatten[
                  easymeshData[\([2, 
                      Flatten[
                        Position[\(Transpose[
                              easymeshData[\([2]\)]]\)[\([4]\)], 0]], {2, 
                        3}]\)], 
                  1]]; \[IndentingNewLine]\[IndentingNewLine]Off[
            Graphics::"\<gpt\>"]; \
\[IndentingNewLine]\[IndentingNewLine]StylePrint[
            Length[easymeshData[\([1]\)]] "\<Nodes\>", "\<Title\>"]; \
\[IndentingNewLine]\[IndentingNewLine]Show[
            Graphics[{RGBColor[0, 0, 0], liste333}, 
              PlotLabel \[Rule] "\< Delaunay mesh\>", 
              TextStyle \[Rule] {FontSize \[Rule] 16}, 
              AspectRatio \[Rule] Automatic]]; \[IndentingNewLine]\n
          Show[Graphics[{RGBColor[1, 0, 0], liste222, RGBColor[1, 0, 0], 
                voronoiBoundaryPlot, RGBColor[1, 0, 0], 
                delaunayBoundaryNodes}, PlotLabel \[Rule] "\<Voronoi mesh\>", 
              TextStyle \[Rule] {FontSize \[Rule] 16}, 
              AspectRatio \[Rule] Automatic]]; \n
          Show[Graphics[{\[IndentingNewLine]RGBColor[0, 0, 0], liste333, 
                RGBColor[1, 0, 0], liste222, RGBColor[1, 0, 0], 
                voronoiBoundaryPlot}, PlotLabel \[Rule] "\<both meshes\>", 
              TextStyle \[Rule] {FontSize \[Rule] 16}, 
              AspectRatio \[Rule] 
                Automatic]];\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["CVPlotData   (*specified *)", "Subsubsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(CVPlotData[\ cvStrom : {\((_Real | _Integer)\) .. }\ ] := 
        Module[{geteilt}, \[IndentingNewLine]\[IndentingNewLine]geteilt = 
            Partition[cvStrom, 
              Length[cvStrom]/
                2]; \n\[IndentingNewLine]Return[{geteilt[\([1]\)], 
              Reverse[geteilt[\([2]\)]]}];\[IndentingNewLine]\
\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["CVPlotDataMultiList   (*specified *)", "Subsubsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(CVPlotDataMultiList[\ cvStrom : {\((_Real | _Integer)\) .. }\ , 
          n_Integer] := 
        Module[{geteilt}, \[IndentingNewLine]\[IndentingNewLine]geteilt = 
            Partition[cvStrom, 
              Length[cvStrom]/n]; \n\[IndentingNewLine]Return[
            Join[Reverse /@ Take[geteilt, {2, Length[geteilt], 2}], 
              Take[geteilt, {1, Length[geteilt], 
                  2}]]]\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["SurfacePlot   (*specified *)", "Subsubsection",
  InitializationCell->True],

Cell[BoxData[
    \( (*\(Needs["\<DiscreteMath`ComputationalGeometry`\>"];\)*) \)], "Input"],

Cell[BoxData[
    \(\(SurfacePlotData[
          meshData : {\[IndentingNewLine]nodeListvariable : {\(({_Integer, \
_Real, _Real, _Integer})\) .. }, \[IndentingNewLine]sideListvariable : \
{\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]concDistribution : \
{{\((_Real)\) .. } .. }, 
          timestep_Integer\ ] := \[IndentingNewLine]Module[{coord, 
            data11}, \[IndentingNewLine]coord = 
            Transpose[\(Transpose[meshData[\([1]\)]]\)[\([{2, 3}]\)]]; \n
          data11 = 
            Partition[
              Flatten[Transpose[{coord, \((\(Partition[
                          100*concDistribution[\([timestep]\)], 
                          Length[coord]]\)[\([2]\)])\)}]], 
              3]; \[IndentingNewLine]Return[
            data11];\[IndentingNewLine]];\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["3Dplots   (*specified *)", "Subsubsection",
  InitializationCell->True],

Cell[BoxData[{
    \(\(wireFrameMeshold[pointOfView_, 
          ansisdata : {n : {{_Real, _Real, _Real, _Real, _Real} .. }, 
              e : {{_Real, _Real, _Real, _Real, _Real, _Real} .. }}] := 
        Module[{nodeCoordRules, 
            BCNodes}, \[IndentingNewLine]nodeCoordRules = \((\(\((Rule[#\
\[LeftDoubleBracket]1\[RightDoubleBracket], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]3\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket]}])\) &\) /@ 
                n)\); \[IndentingNewLine]BCNodes = \(Point[#] &\) /@ \
\((\(Drop[#, 1] &\) /@ \((\(Drop[#, \(-1\)] &\) /@ 
                      Select[n, \((#\[LeftDoubleBracket]\(-1\)\
\[RightDoubleBracket] > 
                              0)\) &])\))\); \
\[IndentingNewLine]Graphics3D[{PointSize[ .02], \((\(Line[
                        Join[Drop[#, {1, 6, 
                              5}], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]3\[RightDoubleBracket], #\[LeftDoubleBracket]5\
\[RightDoubleBracket]}]] &\) /@ e)\) /. nodeCoordRules, RGBColor[1, 0, 0], 
              BCNodes}, pointOfView, Boxed \[Rule] False, Axes \[Rule] True, 
            PlotRange \[Rule] 
              All]\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(WireFrameMeshWithBCNodesold[pointOfView_, tetgenData_] := 
        Module[{}, << Default3D`; 
          wireFrameMeshold[pointOfView, tetgenData] // 
            Show;];\)\[IndentingNewLine]\), "\[IndentingNewLine]", 
    \(\(WireFrameMeshWitRotationold[pointOfView_, tetgenData_] := 
        Module[{}, << RealTime3D`; 
          wireFrameMeshold[pointOfView, tetgenData] // 
            Show;];\)\), "\[IndentingNewLine]", 
    \(\)}], "Input",
  InitializationCell->True],

Cell["\<\
\"wireFrameMeshold\" to be used for the Ansys datastructure as used \
befor.\
\>", "Text"],

Cell[BoxData[{
    \(\(wireFrameMesh[pointOfView_, 
          ansisdata : {n : {{_Integer, _Real, _Real, _Real, _Integer} .. }, 
              e : {{_Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer} .. }}] := 
        Module[{nodeCoordRules, 
            BCNodes}, \[IndentingNewLine]nodeCoordRules = \((\(\((Rule[#\
\[LeftDoubleBracket]1\[RightDoubleBracket], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]3\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket]}])\) &\) /@ 
                n)\); \[IndentingNewLine]BCNodes = \(Point[#] &\) /@ \
\((\(Drop[#, 1] &\) /@ \((\(Drop[#, \(-1\)] &\) /@ 
                      Select[n, \((#\[LeftDoubleBracket]\(-1\)\
\[RightDoubleBracket] > 
                              0)\) &])\))\); \
\[IndentingNewLine]Graphics3D[{PointSize[ .02], \((\(Line[
                        Join[Drop[#, {1, 6, 
                              5}], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]3\[RightDoubleBracket], #\[LeftDoubleBracket]5\
\[RightDoubleBracket]}]] &\) /@ e)\) /. nodeCoordRules, RGBColor[1, 0, 0], 
              BCNodes}, pointOfView, Boxed \[Rule] False, Axes \[Rule] True, 
            PlotRange \[Rule] 
              All]\[IndentingNewLine]];\)\[IndentingNewLine]\), "\
\[IndentingNewLine]", 
    \(\(WireFrameMeshWithBCNodes[pointOfView_, tetgenData_] := 
        Module[{}, << Default3D`; 
          wireFrameMesh[pointOfView, tetgenData] // 
            Show;];\)\[IndentingNewLine]\), "\[IndentingNewLine]", 
    \(\(WireFrameMeshWitRotation[pointOfView_, tetgenData_] := 
        Module[{}, << RealTime3D`; 
          wireFrameMesh[pointOfView, tetgenData] // Show;];\)\)}], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Feldplot    (*specified *)", "Subsubsection",
  InitializationCell->True],

Cell[BoxData[
    \(\(Feldplot[
          meshData : {\[IndentingNewLine]nodeListvariable : {\(({_Integer, \
_Real, _Real, _Integer})\) .. }, \[IndentingNewLine]sideListvariable : \
{\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, concDistribution : {{\((_Real)\) .. } .. }, 
          plotFrequency_Integer] := 
        Module[{coord, ele, v, vals}, \[IndentingNewLine]coord = 
            Transpose[\(Transpose[meshData[\([1]\)]]\)[\([{2, 3}]\)]]; \n
          ele = Transpose[\(Transpose[
                  meshData[\([3]\)]]\)[\([{2, 3, 4}]\)]]; \n
          For[v = 1, v \[LessEqual] Length[concDistribution], 
            v += plotFrequency, \[IndentingNewLine]vals = \(Partition[
                    concDistribution[\([v]\)], 
                    Length[coord]]\)[\([1 (*gibt\ die\ Nummer\ der\ \
Spezie*) ]\)]* .87; \[IndentingNewLine]Show[
              Graphics[
                Transpose[{Map[GrayLevel, 
                      Map[\((vals[\([#[\([1]\)]]\)] + 
                                vals[\([#[\([2]\)]]\)] + 
                                vals[\([#[\([3]\)]]\)])\)/3.  &, ele]], \n
                    Map[Polygon, 
                      Map[{coord[\([#[\([1]\)]]\)], coord[\([#[\([2]\)]]\)], 
                            coord[\([#[\([3]\)]]\)]} &, ele]]}], 
                AspectRatio \[Rule] 
                  Automatic]]\[IndentingNewLine]];\[IndentingNewLine]];\)\)], \
"Input",
  InitializationCell->True]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["all Functions for old Datastructures", "Section"],

Cell[CellGroupData[{

Cell["WriteEasymeshInputData (*specified *) ", "Subsection"],

Cell[BoxData[
    \(\(WriteEasymeshInputData[
          easymeshPolygonInput_, \[IndentingNewLine]easymeshLineInput : \
{___EasymeshVertex}, 
          easymeshMaterialPointInput : {___Point}] := \[IndentingNewLine]\
\[IndentingNewLine]Module[\[IndentingNewLine]{polygonVerticesFunction, 
            pointFunction, LineVerticesFunction, allPolygons, polygons, 
            allLines, lines, points, easymeshData, 
            allVerticesPerLineFunction, 
            allVerticesPerPolygonFunction}, \n\[IndentingNewLine]allPolygons \
= Cases[easymeshPolygonInput, _EasymeshPolygon]; \n
          allVerticesPerPolygonFunction[j_] := 
            Module[{onePolygon, 
                polygonVertices}, \[IndentingNewLine]onePolygon = 
                Cases[allPolygons[\([j]\)], _EasymeshVertex]; \
\[IndentingNewLine]\[IndentingNewLine]polygonVerticesFunction[i_] := 
                GetVertexData[
                  onePolygon[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]polygonVertices = 
                polygonVerticesFunction /@ 
                  Range[Length[
                      onePolygon]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                polygonVertices];\[IndentingNewLine]]; \n
          polygons = 
            allVerticesPerPolygonFunction /@ 
              Range[Length[
                  allPolygons]]; \[IndentingNewLine]\[IndentingNewLine]\n
          allLines = Cases[easymeshLineInput, _EasymeshPolyLine]; \n
          allVerticesPerLineFunction[j_] := 
            Module[{oneLine, lineVertices}, \[IndentingNewLine]oneLine = 
                Cases[allLines[\([j]\)], _EasymeshVertex]; \
\[IndentingNewLine]\[IndentingNewLine]LineVerticesFunction[i_] := 
                GetVertexData[
                  oneLine[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]lineVertices = 
                LineVerticesFunction /@ 
                  Range[Length[
                      oneLine]]; \[IndentingNewLine]\[IndentingNewLine]Return[
                lineVertices];\[IndentingNewLine]]; \n
          lines = allVerticesPerLineFunction /@ 
              Range[Length[
                  allLines]]; \[IndentingNewLine]\[IndentingNewLine]\n
          pointFunction[k_] := 
            GetMaterialPointData[easymeshMaterialPointInput[\([k]\)]]; \n
          points = 
            pointFunction /@ 
              Range[Length[
                  easymeshMaterialPointInput]]; \[IndentingNewLine]\
\[IndentingNewLine]easymeshData = 
            WriteEasymeshInput[polygons, lines, 
              points]; \[IndentingNewLine]\[IndentingNewLine]Return[
            easymeshData];\[IndentingNewLine]];\)\)], "Input"],

Cell[BoxData[
    \(\(WriteEasymeshInput[
          polygone : {{{_Real | _Integer, _Real | _Integer, _Real | _Integer, \
_Integer, _Integer} .. } .. }, 
          lines : {{{_Real | _Integer, _Real | _Integer, _Real | _Integer, \
_Integer, _Integer} .. } .. }, 
          singlePoints : {{_Real | _Integer, _Real | _Integer, _Real | \
_Integer, _Integer} .. }] := \[IndentingNewLine]\[IndentingNewLine]Module[{i, 
            j, convertToEasymeshFormatpointspolygone, pointslines, 
            pointssinglePoints, sidepolygone, sidelines, pointInformation, 
            sidePolygonInformationFunktion, sideListPolygon, 
            sideLinesInformationFunktion, sideListLines, 
            strukturFunktionPolygon, strukturPolygon, strukturFunktionLines, 
            strukturLines, givePartII, vari11, structuredpolygonList, 
            givePart22, vari22, structuredLineList, seitenline, 
            linesseitenlist, xx, seitenpolygon, polygonseitenlistFunction, 
            joinedSides, outSides, outputSides, sidepolygoneFunktion, 
            pointspolygone, 
            sidelinesFunktion}, \
\[IndentingNewLine]\[IndentingNewLine]sidepolygoneFunktion[i_] := 
            polygone[\([i, 
                Range[Length[polygone[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidelinesFunktion[i_] := 
            lines[\([i, 
                Range[Length[lines[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidePolygonInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidepolygone[\([i, j, {1, 2}]\)]] - 1)\), 
                sidepolygone[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]sideLinesInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidelines[\([i, j, {1, 2}]\)]] - 1)\), 
                sidelines[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]strukturFunktionPolygon[i_] := 
            Length[sidepolygone[\([i]\)]]; \[IndentingNewLine]\
\[IndentingNewLine]strukturFunktionLines[i_] := 
            Length[sidelines[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]givePartII[
              p_] := {Take[vari11, 
                p], \(vari11 = 
                  Drop[vari11, 
                    p];\)}; \[IndentingNewLine]\[IndentingNewLine]givePart22[
              p_] := {Take[vari22, 
                p], \(vari22 = 
                  Drop[vari22, 
                    p];\)}; \
\[IndentingNewLine]\[IndentingNewLine]linesseitenlist[j_] := 
            For[i = 1, i < strukturLines[\([j]\)], \(i++\), 
              xx = RotateLeft[
                  Flatten[{Reverse[structuredLineList[\([j, i]\)]], 
                      structuredLineList[\([j, i + 1, 1]\)]}]]; 
              seitenline = 
                Append[seitenline, 
                  xx]]; \[IndentingNewLine]\[IndentingNewLine]\
polygonseitenlistFunction[j_] := 
            For[i = 1, i \[LessEqual] strukturPolygon[\([j]\)], \(i++\), 
              Which[i < strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, i + 1, 1]\)]}]]; 
                seitenpolygon = Append[seitenpolygon, xx], 
                i \[Equal] strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, 1, 1]\)]}]]; 
                seitenpolygon = 
                  Append[seitenpolygon, 
                    xx];]]; \
\[IndentingNewLine]\[IndentingNewLine]pointspolygone = \(Flatten[polygone, 
                1]\)[\([Range[Length[Flatten[polygone, 1]]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]pointslines = \
\(Flatten[lines, 
                1]\)[\([Range[Length[Flatten[lines, 1]]], {1, 2, 3, 
                  4}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]pointssinglePoints = 
            singlePoints[\([Range[Length[singlePoints]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]sidepolygone \
= sidepolygoneFunktion /@ 
              Range[Length[
                  polygone]]; \[IndentingNewLine]\[IndentingNewLine]sidelines \
= sidelinesFunktion /@ 
              Range[Length[
                  lines]]; \
\[IndentingNewLine]\[IndentingNewLine]pointInformation = 
            Transpose[
              Flatten[{{Range[0, 
                      Length[Union[pointspolygone, pointslines, 
                            pointssinglePoints]] - 1]}, 
                  Transpose[
                    Union[pointspolygone, pointslines, pointssinglePoints]]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]sideListPolygon = \
\(Apply[sidePolygonInformationFunktion, #] &\) /@ 
              Flatten[
                Table[{i, j}, {i, Length[sidepolygone]}, {j, 
                    Length[sidepolygone[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]sideListLines = \
\(Apply[sideLinesInformationFunktion, #] &\) /@ 
              Flatten[Table[{i, j}, {i, Length[sidelines]}, {j, 
                    Length[sidelines[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]strukturPolygon = 
            strukturFunktionPolygon /@ 
              Range[Length[
                  sidepolygone]]; \
\[IndentingNewLine]\[IndentingNewLine]strukturLines = 
            strukturFunktionLines /@ 
              Range[Length[
                  sidelines]]; \[IndentingNewLine]\[IndentingNewLine]vari11 = 
            sideListPolygon; \
\[IndentingNewLine]\[IndentingNewLine]structuredpolygonList = 
            Cases[Flatten[givePartII /@ strukturPolygon, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]vari22 = 
            sideListLines; \
\[IndentingNewLine]\[IndentingNewLine]structuredLineList = 
            Cases[Flatten[givePart22 /@ strukturLines, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]seitenline \
= {}; \[IndentingNewLine]\[IndentingNewLine]linesseitenlist /@ 
            Range[Length[
                strukturLines]]; \
\[IndentingNewLine]\[IndentingNewLine]seitenpolygon = {}; \[IndentingNewLine]\
\[IndentingNewLine]polygonseitenlistFunction /@ 
            Range[Length[
                strukturPolygon]]; \
\[IndentingNewLine]\[IndentingNewLine]joinedSides = 
            Join[seitenpolygon, 
              seitenline]; \[IndentingNewLine]\[IndentingNewLine]outSides = \
{}; \[IndentingNewLine]\[IndentingNewLine]For[i = 1, 
            i \[LessEqual] Length[joinedSides], \(i++\), 
            If[MemberQ[outSides, joinedSides[\([i]\)]], Null, 
              outSides = 
                Append[outSides, 
                  joinedSides[\([i]\)]]]]; \[IndentingNewLine]\
\[IndentingNewLine]outputSides = 
            Transpose[
              Flatten[{{Range[0, Length[outSides] - 1]}, 
                  Transpose[outSides]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
pointInformation, outputSides}]];\)\)], "Input"],

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(WriteEasymeshInput[polygone_, lines_, 
          singlePoints_] := \[IndentingNewLine]\[IndentingNewLine]Module[{i, 
            j, convertToEasymeshFormatpointspolygone, pointslines, 
            pointssinglePoints, sidepolygone, sidelines, pointInformation, 
            sidePolygonInformationFunktion, sideListPolygon, 
            sideLinesInformationFunktion, sideListLines, 
            strukturFunktionPolygon, strukturPolygon, strukturFunktionLines, 
            strukturLines, givePartII, vari11, structuredpolygonList, 
            givePart22, vari22, structuredLineList, seitenline, 
            linesseitenlist, xx, seitenpolygon, polygonseitenlistFunction, 
            joinedSides, outSides, outputSides, sidepolygoneFunktion, 
            pointspolygone, 
            sidelinesFunktion}, \
\[IndentingNewLine]\[IndentingNewLine]sidepolygoneFunktion[i_] := 
            polygone[\([i, 
                Range[Length[polygone[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidelinesFunktion[i_] := 
            lines[\([i, 
                Range[Length[lines[\([i]\)]]], {1, 2, 
                  5}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]sidePolygonInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidepolygone[\([i, j, {1, 2}]\)]] - 1)\), 
                sidepolygone[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]sideLinesInformationFunktion[i_, j_] := 
            Flatten[{\((Position[
                      pointInformation[\([Range[
                            Length[pointInformation]], {2, 3}]\)], 
                      sidelines[\([i, j, {1, 2}]\)]] - 1)\), 
                sidelines[\([i, j, 
                    3]\)]}]; \
\[IndentingNewLine]\[IndentingNewLine]strukturFunktionPolygon[i_] := 
            Length[sidepolygone[\([i]\)]]; \[IndentingNewLine]\
\[IndentingNewLine]strukturFunktionLines[i_] := 
            Length[sidelines[\([i]\)]]; \
\[IndentingNewLine]\[IndentingNewLine]givePartII[
              p_] := {Take[vari11, 
                p], \(vari11 = 
                  Drop[vari11, 
                    p];\)}; \[IndentingNewLine]\[IndentingNewLine]givePart22[
              p_] := {Take[vari22, 
                p], \(vari22 = 
                  Drop[vari22, 
                    p];\)}; \
\[IndentingNewLine]\[IndentingNewLine]linesseitenlist[j_] := 
            For[i = 1, i < strukturLines[\([j]\)], \(i++\), 
              xx = RotateLeft[
                  Flatten[{Reverse[structuredLineList[\([j, i]\)]], 
                      structuredLineList[\([j, i + 1, 1]\)]}]]; 
              seitenline = 
                Append[seitenline, 
                  xx]]; \[IndentingNewLine]\[IndentingNewLine]\
polygonseitenlistFunction[j_] := 
            For[i = 1, i \[LessEqual] strukturPolygon[\([j]\)], \(i++\), 
              Which[i < strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, i + 1, 1]\)]}]]; 
                seitenpolygon = Append[seitenpolygon, xx], 
                i \[Equal] strukturPolygon[\([j]\)], 
                xx = RotateLeft[
                    Flatten[{Reverse[structuredpolygonList[\([j, i]\)]], 
                        structuredpolygonList[\([j, 1, 1]\)]}]]; 
                seitenpolygon = 
                  Append[seitenpolygon, 
                    xx];]]; \
\[IndentingNewLine]\[IndentingNewLine]pointspolygone = \(Flatten[polygone, 
                1]\)[\([Range[Length[Flatten[polygone, 1]]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]pointslines = \
\(Flatten[lines, 
                1]\)[\([Range[Length[Flatten[lines, 1]]], {1, 2, 3, 
                  4}]\)]; \
\[IndentingNewLine]\[IndentingNewLine]pointssinglePoints = 
            singlePoints[\([Range[Length[singlePoints]], {1, 2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]sidepolygone \
= sidepolygoneFunktion /@ 
              Range[Length[
                  polygone]]; \[IndentingNewLine]\[IndentingNewLine]sidelines \
= sidelinesFunktion /@ 
              Range[Length[
                  lines]]; \
\[IndentingNewLine]\[IndentingNewLine]pointInformation = 
            Transpose[
              Flatten[{{Range[0, 
                      Length[Union[pointspolygone, pointslines, 
                            pointssinglePoints]] - 1]}, 
                  Transpose[
                    Union[pointspolygone, pointslines, pointssinglePoints]]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]sideListPolygon = \
\(Apply[sidePolygonInformationFunktion, #] &\) /@ 
              Flatten[Table[{i, j}, {i, Length[sidepolygone]}, {j, 
                    Length[sidepolygone[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]sideListLines = \
\(Apply[sideLinesInformationFunktion, #] &\) /@ 
              Flatten[Table[{i, j}, {i, Length[sidelines]}, {j, 
                    Length[sidelines[\([i]\)]]}], 
                1]; \[IndentingNewLine]\[IndentingNewLine]strukturPolygon = 
            strukturFunktionPolygon /@ 
              Range[Length[
                  sidepolygone]]; \
\[IndentingNewLine]\[IndentingNewLine]strukturLines = 
            strukturFunktionLines /@ 
              Range[Length[
                  sidelines]]; \[IndentingNewLine]\[IndentingNewLine]vari11 = 
            sideListPolygon; \
\[IndentingNewLine]\[IndentingNewLine]structuredpolygonList = 
            Cases[Flatten[givePartII /@ strukturPolygon, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]vari22 = 
            sideListLines; \
\[IndentingNewLine]\[IndentingNewLine]structuredLineList = 
            Cases[Flatten[givePart22 /@ strukturLines, 
                1], _List]; \[IndentingNewLine]\[IndentingNewLine]seitenline \
= {}; \[IndentingNewLine]\[IndentingNewLine]linesseitenlist /@ 
            Range[Length[
                strukturLines]]; \
\[IndentingNewLine]\[IndentingNewLine]seitenpolygon = {}; \[IndentingNewLine]\
\[IndentingNewLine]polygonseitenlistFunction /@ 
            Range[Length[
                strukturPolygon]]; \
\[IndentingNewLine]\[IndentingNewLine]joinedSides = 
            Join[seitenpolygon, 
              seitenline]; \[IndentingNewLine]\[IndentingNewLine]outSides = \
{}; \[IndentingNewLine]\[IndentingNewLine]For[i = 1, 
            i \[LessEqual] Length[joinedSides], \(i++\), 
            If[MemberQ[outSides, joinedSides[\([i]\)]], Null, 
              outSides = 
                Append[outSides, 
                  joinedSides[\([i]\)]]]]; \[IndentingNewLine]\
\[IndentingNewLine]outputSides = 
            Transpose[
              Flatten[{{Range[0, Length[outSides] - 1]}, 
                  Transpose[outSides]}, 
                1]]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
pointInformation, outputSides}]];\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["RunEasymesh (*specified *)", "Subsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{\(RunEasymesh[
          geometyData : {pointInformation : {{_Real | _Integer, _Real | \
_Integer, _Real | _Integer, _Real | _Integer, _Integer} .. }, 
              outputSides : {{_Real | _Integer, _Real | _Integer, _Real | \
_Integer, _Real | _Integer} .. } .. }]\), ":=", "\[IndentingNewLine]", 
        RowBox[{"Module", "[", "\[IndentingNewLine]", 
          
          RowBox[{\({easyMeshBaseName, BuildEasyMeshBaseName, easyMeshFile}\),
             ",", "\[IndentingNewLine]", 
            
            RowBox[{\(easyMeshBaseName = 
                StringJoin["\</tmp/\>", $UserName, 
                  PadRight[Characters[ToString[Random[Integer, 99999999]]], 
                    8]]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(BuildEasyMeshBaseName[] := 
                easyMeshBaseName /; $OperatingSystem \[Equal] "\<Unix\>"\), 
              ";", "\n", \(BuildEasyMeshBaseName[] := 
                Block[{}, Print["\<Not yet implemented\>"]; Abort[]]\), ";", 
              "\n", \(easyMeshFile = StringJoin[easyMeshBaseName, "\<.d\>"]\),
               ";", "\n", 
              RowBox[{
                StyleBox["Export",
                  Background->GrayLevel[1]], 
                StyleBox["[",
                  Background->GrayLevel[1]], 
                RowBox[{
                  StyleBox["easyMeshFile",
                    Background->GrayLevel[1]], 
                  StyleBox[",",
                    Background->GrayLevel[1]], 
                  RowBox[{
                    StyleBox["Join",
                      Background->GrayLevel[1]], 
                    StyleBox["[",
                      Background->GrayLevel[1]], 
                    RowBox[{
                      StyleBox[\({"\< \>"}\),
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      
                      StyleBox[\({Length[
                              geometyData[\([1]\)]] "\< \>" "\<#Points#\>"}\),
                        
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      StyleBox[\(geometyData[\([1]\)]\),
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      StyleBox[\({"\< \>"}\),
                        Background->GrayLevel[1]], 
                      StyleBox[",",
                        Background->GrayLevel[1]], 
                      RowBox[{
                        StyleBox["{",
                          Background->GrayLevel[1]], 
                        RowBox[{
                          RowBox[{
                            StyleBox["Length",
                              Background->GrayLevel[1]], 
                            StyleBox["[",
                              Background->GrayLevel[
                              1]], \(geometyData[\([2]\)]\), 
                            StyleBox["]",
                              Background->GrayLevel[1]]}], 
                          StyleBox["\"\< \>\"",
                            Background->GrayLevel[1]], 
                          StyleBox["\"\<#Segments#\>\"",
                            Background->GrayLevel[1]]}], 
                        StyleBox["}",
                          Background->GrayLevel[1]]}], 
                      StyleBox[",",
                        Background->GrayLevel[1]], \(geometyData[\([2]\)]\)}],
                     
                    StyleBox["]",
                      Background->GrayLevel[1]]}], 
                  StyleBox[",",
                    Background->GrayLevel[1]], 
                  StyleBox["\"\<Table\>\"",
                    Background->GrayLevel[1]]}], 
                StyleBox["]",
                  Background->GrayLevel[1]]}], 
              StyleBox[";",
                Background->GrayLevel[1]], "\n", 
              RowBox[{
                StyleBox["Run",
                  Background->GrayLevel[1]], 
                StyleBox["[",
                  Background->GrayLevel[1]], 
                RowBox[{"StringJoin", "[", 
                  StyleBox[\("\<easymesh10T \>", \ easyMeshFile\),
                    Background->GrayLevel[1]], 
                  StyleBox["]",
                    Background->GrayLevel[1]]}], "]"}], 
              StyleBox[";",
                Background->GrayLevel[1]], "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[easyMeshBaseName]\)}]}], 
          "\[IndentingNewLine]", "]"}]}], ";"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["ReadEasymesh (*specified *)", "Subsection"],

Cell[BoxData[
    \(Off[Read::"\<readn\>"]\)], "Input"],

Cell[BoxData[
    \(\(ReadEasymesh[
          fileName_String] \
:= \[IndentingNewLine]Module[\[IndentingNewLine]{readEasymeshFormat, 
            easymeshNode, nodefile, easymeshSide, sidefile, easymeshElement, 
            elementfile}, \[IndentingNewLine]easymeshNode = 
            OpenRead[StringJoin[fileName, "\<.n\>"]]; \[IndentingNewLine]\n
          Read[easymeshNode, {Number}]; \nnodefile = {}; \n
          nodefile = 
            ReadList[
              easymeshNode, {Number, Character, Real, Real, Number}]; \n
          Close[easymeshNode]; \n
          nodefile = Drop[Transpose[nodefile], {2, 2}]; \n
          nodefile[\([1]\)] = nodefile[\([1]\)] + 1; \n
          nodefile = 
            Transpose[
              nodefile]; \[IndentingNewLine]\[IndentingNewLine]easymeshSide = 
            OpenRead[StringJoin[fileName, "\<.s\>"]]; \n
          Read[easymeshSide, {Number}]; \nsidefile = {}; \n
          sidefile = 
            ReadList[
              easymeshSide, {Number, Character, Number, Number, Number, 
                Number, Number}]; \nClose[easymeshSide]; \n
          sidefile = Drop[Transpose[sidefile], {2}]; \n
          sidefile[\([1]\)] = sidefile[\([1]\)] + 1; \n
          sidefile[\([2]\)] = sidefile[\([2]\)] + 1; \n
          sidefile[\([3]\)] = sidefile[\([3]\)] + 1; \n
          sidefile[\([4]\)] = sidefile[\([4]\)] + 1; \n
          sidefile[\([5]\)] = sidefile[\([5]\)] + 1; \n
          sidefile = 
            Transpose[
              sidefile]; \
\[IndentingNewLine]\[IndentingNewLine]easymeshElement = 
            OpenRead[StringJoin[fileName, "\<.e\>"]]; \n
          Read[easymeshElement, {Number}]; \nelementfile = {}; \n
          elementfile = 
            ReadList[
              easymeshElement, {Number, Character, Number, Number, Number, 
                Number, Number, Number, Number, Number, Number, Real, Real, 
                Number}]; \nClose[easymeshElement]; \n
          elementfile = Drop[Transpose[elementfile], {2}]; \n
          elementfile[\([1]\)] = elementfile[\([1]\)] + 1; \n
          elementfile[\([2]\)] = elementfile[\([2]\)] + 1; \n
          elementfile[\([3]\)] = elementfile[\([3]\)] + 1; \n
          elementfile[\([4]\)] = elementfile[\([4]\)] + 1; \n
          elementfile[\([5]\)] = elementfile[\([5]\)] + 1; \n
          elementfile[\([6]\)] = elementfile[\([6]\)] + 1; \n
          elementfile[\([7]\)] = elementfile[\([7]\)] + 1; \n
          elementfile[\([8]\)] = elementfile[\([8]\)] + 1; \n
          elementfile[\([9]\)] = elementfile[\([9]\)] + 1; \n
          elementfile[\([10]\)] = elementfile[\([10]\)] + 1; \n
          elementfile = 
            Transpose[
              elementfile]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]Return[{nodefile, sidefile, 
              elementfile}]\[IndentingNewLine]];\)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation GeometryFunction2DAxisSymmetric  (*specified \
*)\
\>", "Subsection"],

Cell[BoxData[
    \(\(GeometryFunction2DAxisSymmetric[
          easymeshData : {nodeList : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementList : {\(({_Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, _Real, \
_Integer})\) .. }}] := \[IndentingNewLine]Module[{nodeNumbersPerElement, 
            coordinatesPerElementFunction, coordinatesPerElement, 
            lengthOfElementsidesFunction, lengthOfElementsides, 
            boxSideLengthFunction, boxSideLength, volumeOfVoronoiPart, 
            radiusOfCelFunction, radiusOfCel, radiusOfFluxFunction, 
            radiusOfFlux, 
            numberOfNodes}, \
\[IndentingNewLine]\[IndentingNewLine]nodeNumbersPerElement = \(easymeshData[\
\([3]\)]\)[\([All, {2, 3, 
                  4}]\)]; \[IndentingNewLine]\[IndentingNewLine]numberOfNodes \
= easymeshData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine]\[IndentingNewLine]\
coordinatesPerElementFunction[
              i_] := \(\(easymeshData\[LeftDoubleBracket]1\
\[RightDoubleBracket]\)\[LeftDoubleBracket]
                All, {2, 3}\[RightDoubleBracket]\)\[LeftDoubleBracket]
              i\[RightDoubleBracket]; \n
          coordinatesPerElement = 
            coordinatesPerElementFunction /@ 
              nodeNumbersPerElement; \
\[IndentingNewLine]\[IndentingNewLine]lengthOfElementsides = 
            Transpose[{Apply[
                    Plus, \((coordinatesPerElement[\([All, 1]\)] - 
                          coordinatesPerElement[\([All, 2]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((coordinatesPerElement[\([All, 1]\)] - 
                          coordinatesPerElement[\([All, 3]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((coordinatesPerElement[\([All, 2]\)] - 
                          coordinatesPerElement[\([All, 
                              3]\)])\)^2, {1}]^0.5}]; \[IndentingNewLine]\
\[IndentingNewLine]boxSideLength = 
            Transpose[{Apply[
                    Plus, \((\((\((coordinatesPerElement[\([All, 1]\)] + 
                                  coordinatesPerElement[\([All, 2]\)])\)/
                              2)\) - \(easymeshData[\([3]\)]\)[\([All, {11, 
                                12}]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((\((\((coordinatesPerElement[\([All, 1]\)] + 
                                  coordinatesPerElement[\([All, 3]\)])\)/
                              2)\) - \(easymeshData[\([3]\)]\)[\([All, {11, 
                                12}]\)])\)^2, {1}]^0.5, 
                Apply[Plus, \((\((\((coordinatesPerElement[\([All, 2]\)] + 
                                  coordinatesPerElement[\([All, 3]\)])\)/
                              2)\) - \(easymeshData[\([3]\)]\)[\([All, {11, 
                                12}]\)])\)^2, {1}]^0.5}]; \[IndentingNewLine]\
\[IndentingNewLine]volumeOfVoronoiPart = 
            boxSideLength*
              lengthOfElementsides/
                4; \[IndentingNewLine]\[IndentingNewLine]radiusOfCel = 
            Transpose[{\((\((\((\((coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 1, 1]\)])\)/
                    3)\), \[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 1, 1]\)])\)/
                    3)\), \[IndentingNewLine]\[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 2, 1]\)])\)/
                    3)\), \[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 3, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 2, 1]\)])\)/
                    3)\), \[IndentingNewLine]\[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 3, 1]\)])\)/
                    3)\), \[IndentingNewLine]\((\((\((\((\
coordinatesPerElement[\([All, 2, 1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)] + 
                        coordinatesPerElement[\([All, 3, 1]\)])\)/
                    3)\)}]; \
\[IndentingNewLine]\[IndentingNewLine]radiusOfFlux = 
            Transpose[{\((\((\((\((coordinatesPerElement[\([All, 1, 1]\)] + 
                                coordinatesPerElement[\([All, 2, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)])\)/
                    2)\), \((\((\((\((coordinatesPerElement[\([All, 1, 
                                    1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)])\)/
                    2)\), \((\((\((\((coordinatesPerElement[\([All, 2, 
                                    1]\)] + 
                                coordinatesPerElement[\([All, 3, 1]\)])\)/
                            2)\) + easymeshData[\([3, All, 11]\)])\)/
                    2)\)}]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]Return[{boxSideLength, lengthOfElementsides, 
              nodeNumbersPerElement, numberOfNodes, radiusOfCel, 
              radiusOfFlux, volumeOfVoronoiPart}]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation EquationsystemSteadyState2DAxisSymmetric  \
(*specified *)\
\>", "Subsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox["EquationsystemSteadyState2DAxisSymmetric",
            FontVariations->{"CompatibilityType"->0}], "[", 
          "\[IndentingNewLine]", \(geometry : {boxSideLengthvariable : \
{\(({_Real, _Real, _Real})\) .. }, \
\[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : \
{\((_Real | _Integer)\) .. }, \[IndentingNewLine]initialConcentrations : \
{\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \
\((_Real | _Integer)\)}, ___})\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, \
{_Integer, _Integer}, {_Real | _Integer, _Real | _Integer}})\) .. }\), 
          "\[IndentingNewLine]", "]"}], ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              concentrationFunction, elektrodenVariablen, 
              elektrodenVariablenFunktion, punktkombinationenFunktion}\), ",",
             "\[IndentingNewLine]", "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = geometry[\([5]\)]\),
               ";", "\[IndentingNewLine]", \(radiusOfFlux = 
                geometry[\([6]\)]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction}\), ",", 
                    "\[IndentingNewLine]", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"x", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 1]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 1]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"y", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 2]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 2]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"z", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 3]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 3]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(u = 
                        nodeNumbersPerElement[\([i, 1]\)]\), ";", 
                      "\[IndentingNewLine]", \(v = 
                        nodeNumbersPerElement[\([i, 2]\)]\), ";", 
                      "\[IndentingNewLine]", \(w = 
                        nodeNumbersPerElement[\([i, 3]\)]\), ";", 
                      "\[IndentingNewLine]", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj; \[IndentingNewLine]a[
                              j1v, j1v] += \((x + z)\)*
                              dj; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*
                              dj; \[IndentingNewLine]\[IndentingNewLine]a[
                              j1u, j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 
                  initialConcentrations[\([j]\)]\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", 
              "\n", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  vectorOfConcentrations}]\)}]}], "\[IndentingNewLine]", 
          "]"}]}], ";"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation EquationsystTransient2DAxisSymmetric  (*specified *)\
\
\>", "Subsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox["EquationsystTransient2DAxisSymmetric",
            FontVariations->{"CompatibilityType"->0}], 
          "[", \(geometry : {boxSideLengthvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, \
_Real, _Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]Dif : {\((_Real | _Integer)\) \
.. }, \[IndentingNewLine]timeStep : \((_Real | _Integer)\), \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \((_Real | \
_Integer)\)}, ___})\) .. }, \[IndentingNewLine]electrodeReactionValues : \
{\(({\ \ \ _Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | \
_Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, 
          dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, {_Real | \
_Integer, _Real | _Integer}})\) .. }\), "]"}], ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, 
              vectorOfConcentrationsFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              vectorOfVolumes, concentrationFunction, 
              elektrodenVariablenFunktion, elektrodenVariablen, 
              punktkombinationenFunktion}\), ",", "\[IndentingNewLine]", 
            "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = geometry[\([5]\)]\),
               ";", "\[IndentingNewLine]", \(radiusOfFlux = 
                geometry[\([6]\)]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", 
              " ", \( (*\(\(**\)\(\ \)\(wenn\)\)\ volumeOfVoronoiPart = 
                  0\ gesetzt\ wird, \ 
                dann\ haben\ wir\ den\ steady\ state\ Fall\ ***) \), 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction, geom, r, 
                      s, t, transPart}\), ",", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"geom", "=", 
                        RowBox[{"boxSideLength", 
                          StyleBox["/",
                            FontColor->GrayLevel[0]], 
                          "lengthOfElementsides"}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ x = 
                          radiusOfFlux[\([i, 1]\)]*
                            geom[\([i, 1]\)]; \[IndentingNewLine]y = 
                          radiusOfFlux[\([i, 2]\)]*
                            geom[\([i, 2]\)]; \[IndentingNewLine]z = 
                          radiusOfFlux[\([i, 3]\)]*geom[\([i, 3]\)];\ \ *) \),
                       "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({x, y, z} = 
                        radiusOfFlux[\([i]\)]*geom[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(transPart = 
                        volumeOfVoronoiPart/timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(r = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 1]\)] + 
                          transPart[\([i, 2]\)] radiusOfCel[\([i, 2]\)]\), 
                      ";", "\[IndentingNewLine]", \(s = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 3]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 4]\)]\), 
                      ";", "\[IndentingNewLine]", \(t = 
                        transPart[\([i, 2]\)] radiusOfCel[\([i, 5]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 6]\)]\), 
                      ";", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ \ \ \ \ u = 
                          nodeNumbersPerElement[\([i, 
                              1]\)]; \[IndentingNewLine]v = 
                          nodeNumbersPerElement[\([i, 
                              2]\)]; \[IndentingNewLine]w = 
                          nodeNumbersPerElement[\([i, 3]\)];\ \ \ \ *) \), 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({u, v, w} = 
                        nodeNumbersPerElement[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction[j_] := 
                        Module[{}, \[IndentingNewLine]rightHandSideVector[\([\
\((j - 1)\)*numberOfNodes + u]\)] += 
                            r; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + v]\)] += 
                            s; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + w]\)] += t;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction /@ Range[Length[Dif]]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(vectorOfVolumes = 
                        rightHandSideVector*timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj + 
                              r; \[IndentingNewLine]a[j1v, 
                              j1v] += \((x + z)\)*dj + 
                              s; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*dj + 
                              t; \[IndentingNewLine]\[IndentingNewLine]a[j1u, 
                              j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrationsFunction[i_] := 
                Table[initialConcentrations[\([i]\)], {numberOfNodes}]\), ";",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Flatten[
                  vectorOfConcentrationsFunction /@ 
                    Range[Length[initialConcentrations]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 1\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  rightHandSideVector, vectorOfConcentrations, 
                  vectorOfVolumes}]\)}]}], "\[IndentingNewLine]", "]"}]}], 
      ";"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentFunction2DAxisSymmetric (*specified *)", \
"Subsection"],

Cell["\<\
just the voronoi area is considered, not the area on the boundary. \
The current flows not just through the area between the nodes, but through \
the whole Voronoi box area (additional boundary part on the edge of a \
boundary side)\
\>", "Text"],

Cell[BoxData[
    \(\(\(CurrentFunction2DAxisSymmetric[
        dieElektrode_Integer, \[IndentingNewLine]dritens : {nodeListvariable \
: {\(({_Integer, _Real, _Real, _Integer})\) .. }, \
\[IndentingNewLine]sideListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer})\) .. }, \[IndentingNewLine]elementListvariable \
: {\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Real, _Real, _Integer})\) .. }}, 
        concDistribution : {{\((_Real)\) .. } .. }] := 
      Module[{sideMarcs, sideposition, pointNumbersFunction, pointNumbers, i, 
          j, k, sidesToNeighboursFunction, sidesToNeighbours, 
          nodeAndNeighbourFunction, nodeAndNeighbour, allCoordinatesFunction, 
          allCoordinates, currentWithoutDifCoef, deltaTimesEveridgeFunktion, 
          deltaTimesEveridge, elementNumberFunction, elementNumber, 
          sortierenFunction, sortieren, startAndEndNodeFunktion, 
          startAndEndNode, stromFunction, totalCurrent, 
          voronoiLengthFunction, 
          voronoiLength}, \[IndentingNewLine]\  (*dieElektrode = 
            2; \ \ bestimmt\ die\ Elektrode, \ 
          an\ der\ der\ Strom\ berechnet\ wird\ *) \[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]sideMarcs = \(Transpose[
              dritens[\([2]\)]]\)[\([6]\)]\ ;  (*gibt\ die\ Randmarker\
*) \[IndentingNewLine]\[IndentingNewLine]sideposition = 
          Flatten[Position[sideMarcs, 
              dieElektrode]];  (*gibt\ die\ Positionen\ der\ \
elektrodenraender*) \[IndentingNewLine]\[IndentingNewLine]\
pointNumbersFunction[
            i_] := \(\(dritens[\([2]\)]\)[\([i]\)]\)[\([{2, 
                3}]\)];  (*gibt\ die\ Punktnummern\ der\ Electrode\
*) \[IndentingNewLine]pointNumbers = 
          Flatten[pointNumbersFunction /@ 
              sideposition]; \
\[IndentingNewLine]\[IndentingNewLine]sidesToNeighboursFunction[
            i_] := \(Transpose[
              Position[\(Transpose[dritens[\([2]\)]]\)[\([{2, 3}]\)], 
                i]]\)[\([2]\)];  (*gibt\ eine\ Liste\ der\ Seiten, \ 
          die\ den\ Electrodenpunkt\ \
enthalten*) \[IndentingNewLine]sidesToNeighbours = 
          sidesToNeighboursFunction /@ 
            pointNumbers; \
\[IndentingNewLine]\[IndentingNewLine]nodeAndNeighbourFunction[
            k_] := \(Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{2, 
                    3}]\)]]\)[\([k]\)];  (*gibt\ eine\ Liste\ mit\ dem\ \
Electrodenpunkt\ und\ seinen\ Nachbarn*) \[IndentingNewLine]nodeAndNeighbour \
= nodeAndNeighbourFunction /@ 
            sidesToNeighbours; \
\[IndentingNewLine]\[IndentingNewLine]allCoordinatesFunction[j_] := 
          Module[{coordinateFunction, 
              coordinate}, \[IndentingNewLine]coordinateFunction[
                i_] := \((Abs[\(\(Transpose[\(Transpose[
                                dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([1]\)] - \
\(\(Transpose[\(Transpose[dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([2]\)]])\) . {0, 
                  1};  (*gibt\ die\ Differenz\ der\ Koordinaten\ des\ Punktes\
\ und\ seines\ Nachbarn\ mal\ der\ Normalenrichtung*) \n
            coordinate = 
              coordinateFunction /@ 
                nodeAndNeighbour[\([j]\)]\[IndentingNewLine]]; \
\[IndentingNewLine]allCoordinates = 
          allCoordinatesFunction /@ 
            Range[Length[
                nodeAndNeighbour]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]sortierenFunction[i_] := Sort[i]; \n
        sortieren = 
          sortierenFunction /@ 
            Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{4, 
                    5}]\)]];  (*die\ Elementnummern\ an\ beiden\ Seiten\ \
aller\ Punktverbindungen\ im\ Gebiet; \ 
          die\ Elementnummern\ sind\ sortiert\ um\ Randelemente\ behandeln\ \
zu\ koennen*) \n\n
        elementNumberFunction[i_] := 
          sortieren[\([i]\)];  (*gibt\ die\ Elemente\ zu\ beiden\ Seiten\ der\
\ Verbindungsseite*) \n
        elementNumber = elementNumberFunction /@ sidesToNeighbours; \n\n
        startAndEndNodeFunktion[j_] := 
          Module[{startAndEndNodeFunktionII, 
              startAndEndNodeII}, \
\[IndentingNewLine]startAndEndNodeFunktionII[
                i_] := \(Transpose[\(Transpose[
                      dritens[\([2]\)]]\)[\([{2, 
                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                      i]\)]]\)];  (*das\ sind\ die\ Punkte\ zur\ Seite*) \n
            startAndEndNodeII = 
              startAndEndNodeFunktionII /@ 
                Range[Length[
                    sidesToNeighbours[\([j]\)]]]; \[IndentingNewLine]Return[
              startAndEndNodeII]\[IndentingNewLine]]; \n
        startAndEndNode = 
          startAndEndNodeFunktion /@ 
            Range[Length[
                sidesToNeighbours]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\n
        voronoiLengthFunction[j_] := 
          Module[{voronoiLengthFunctionII, 
              voronoiLengthII}, \[IndentingNewLine]voronoiLengthFunctionII[
                i_] := If[elementNumber[\([j, i, 1]\)] > 0.1, 
                Apply[Plus, \((\(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([1]\)]]\)] - \
\(Transpose[\(Transpose[dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5, 
                Apply[Plus, \((\((\(\(Transpose[\(Transpose[
                                        dritens[\([1]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([startAndEndNode[\([j, 
                                        i]\)]]\)]\)[\([1]\)] + \(\(Transpose[\
\(Transpose[dritens[\([1]\)]]\)[\([{2, 3}]\)]]\)[\([\(Transpose[\(Transpose[
                                        dritens[\([2]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                                        i]\)]]\)]]\)]\)[\([2]\)])\)/
                            2 - \(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5]; \
\[IndentingNewLine]voronoiLengthII = 
              voronoiLengthFunctionII /@ 
                Range[Length[
                    elementNumber[\([j]\)]]]; \[IndentingNewLine]Return[
              voronoiLengthII]\[IndentingNewLine]]; \n
        voronoiLength = 
          voronoiLengthFunction /@ 
            Range[Length[
                elementNumber]]; \
\[IndentingNewLine]\[IndentingNewLine]stromFunction[k_] := 
          Module[{conzDifferenceFunction, conzDifference, conzTimesSij, 
              gradientFunction, gradientsI, 
              strom}, \[IndentingNewLine]\[IndentingNewLine]\
conzDifferenceFunction[i_] := 
              Module[{conzDifferenceTwoFunction, 
                  conzDifferenceTwo}, \
\[IndentingNewLine]conzDifferenceTwoFunction[j_] := 
                  k[\([nodeAndNeighbour[\([i, j, 2]\)]]\)] - 
                    k[\([nodeAndNeighbour[\([i, j, 
                            1]\)]]\)];  (*gibt\ die\ \
Konzentrationsdifferenz\ \ i = Hauptpunkt, \ 
                  j = Hauptpunkt\ und\ ein\ Nachbar*) \n
                conzDifferenceTwo = 
                  conzDifferenceTwoFunction /@ 
                    Range[Length[
                        nodeAndNeighbour[\([i]\)]]]\[IndentingNewLine]]; \n
            conzDifference = 
              conzDifferenceFunction /@ 
                Range[Length[
                    nodeAndNeighbour]]; \
\[IndentingNewLine]\[IndentingNewLine]\n
            conzTimesSij = 
              conzDifference*voronoiLength*\[Pi]; \[IndentingNewLine]\n
            gradientFunction[i_] := 
              Module[{gradientToOneNode, 
                  gradientToOneNodeFunction}, \
\[IndentingNewLine]gradientToOneNodeFunction[j_] := \[IndentingNewLine]If[
                    allCoordinates[\([i, j]\)] =!= 0. , 
                    conzTimesSij[\([i, j]\)]/allCoordinates[\([i, j]\)], 
                    0. ]; \ngradientToOneNode = 
                  Apply[Plus, 
                    gradientToOneNodeFunction /@ 
                      Range[Length[
                          nodeAndNeighbour[\([i]\)]]]]\[IndentingNewLine]]; \n
            gradientsI = 
              gradientFunction /@ 
                Range[Length[
                    nodeAndNeighbour]];  (*gibt\ den\ Gradienten\ zum\ Punkt\ \
in\ der\ Normalenrichtung*) \[IndentingNewLine]\[IndentingNewLine]strom = 
              Apply[Plus, 
                gradientsI]; \[IndentingNewLine]\[IndentingNewLine]Return[
              strom]\[IndentingNewLine]]; \n\
\[IndentingNewLine]currentWithoutDifCoef = 
          stromFunction /@ 
            concDistribution; \[IndentingNewLine]\[IndentingNewLine]Return[
          currentWithoutDifCoef];\[IndentingNewLine]]\)\(\[IndentingNewLine]\)\
\(\[IndentingNewLine]\)
    \)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentbyMatrix2DAxyssymetricFunction", "Subsection"],

Cell[BoxData[
    \(\(\(CurrentbyMatrix2DAxyssymetricFunction[equationSystemSteady_, 
          concDistribution_, electrode_, meshData_] := 
        Module[{CurrentbyMatrix2DAxyssymetricFunctionII, 
            current}, \
\[IndentingNewLine]\[IndentingNewLine]CurrentbyMatrix2DAxyssymetricFunctionVV[
              concDistributionSteady_] := 
            Module[{NodesOnElectrode, matrixElementFunction, matrixElements, 
                gradientFunction, 
                currentII}, \
\[IndentingNewLine]\[IndentingNewLine]NodesOnElectrode = 
                Flatten[
                  Position[meshData[\([1, All, 4]\)], electrode]]; \  (*\ 
                die\ Randpunkte\ *) \n\
\[IndentingNewLine]matrixElementFunction[i_] := 
                Module[{rowOfNodesOnElectrode, columnOfNodesOnElectrode, 
                    diagonalElement, nonDiagonalElements, 
                    nonDiagonalSparsMatrixEntrys}, \
\[IndentingNewLine]rowOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 1]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Zeileneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]columnOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 2]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Spalteneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]diagonalElement = 
                    Intersection[rowOfNodesOnElectrode, 
                      columnOfNodesOnElectrode];  (*\ das\ Element, \ 
                    das\ sowohl\ zur\ zeile\ wie\ auch\ zur\ Spalte\ gehoert \
. \ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalElements = 
                    DeleteCases[rowOfNodesOnElectrode, 
                      diagonalElement[\([1]\)]];  (*\ 
                    Alle\ Zeilenelemente\ ohne\ dem\ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalSparsMatrixEntrys = 
                    equationSystemSteady[\([1, 
                        nonDiagonalElements]\)]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                    nonDiagonalSparsMatrixEntrys];\[IndentingNewLine]]; \
\[IndentingNewLine]\n\n
              matrixElements = 
                Flatten[
                  matrixElementFunction /@ 
                    Range[Length[NodesOnElectrode]]]; \[IndentingNewLine]\n
              gradientFunction[
                  j_] := \((\((\(concDistributionSteady[\([matrixElements[\([\
j, 1]\)]]\)]\)[\([2]\)] - \(concDistributionSteady[\([matrixElements[\([j, 
                                  1]\)]]\)]\)[\([1]\)])\)*
                    matrixElements[\([j, 2]\)])\); \[IndentingNewLine]\n
              currentII = \((\((Apply[Plus, 
                          gradientFunction /@ 
                            Range[Length[
                                matrixElements]]])\)^2)\)*\[Pi]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                currentII]\[IndentingNewLine]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]current = 
            CurrentbyMatrix2DAxyssymetricFunctionVV /@ 
              concDistribution; \[IndentingNewLine]Return[
            current]\[IndentingNewLine]\[IndentingNewLine]];\)\(\
\[IndentingNewLine]\)
    \)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentbyMatrix2DAxyssymetricFunctionCV", "Subsection"],

Cell[BoxData[
    \(\(\(CurrentbyMatrix2DAxyssymetricFunctionCV[equationSystemSteady_, 
          concDistribution_, electrode_, meshData_, deltaE_\ ] := 
        Module[{CurrentbyMatrix2DAxyssymetricFunctionII, 
            current}, \
\[IndentingNewLine]\[IndentingNewLine]CurrentbyMatrix2DAxyssymetricFunctionVV[
              concDistributionSteady_] := 
            Module[{NodesOnElectrode, matrixElementFunction, matrixElements, 
                gradientFunction, 
                currentII}, \
\[IndentingNewLine]\[IndentingNewLine]NodesOnElectrode = 
                Flatten[
                  Position[meshData[\([1, All, 4]\)], electrode]]; \  (*\ 
                die\ Randpunkte\ *) \n\
\[IndentingNewLine]matrixElementFunction[i_] := 
                Module[{rowOfNodesOnElectrode, columnOfNodesOnElectrode, 
                    diagonalElement, nonDiagonalElements, 
                    nonDiagonalSparsMatrixEntrys}, \
\[IndentingNewLine]rowOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 1]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Zeileneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]columnOfNodesOnElectrode = 
                    Flatten[
                      Position[equationSystemSteady[\([1, All, 1, 2]\)], 
                        NodesOnElectrode[\([i]\)]]];  (*\ 
                    die\ Spalteneintraege\ der\ Randpunkte\ incl . \ 
                        Diagonalelement\ *) \[IndentingNewLine]\
\[IndentingNewLine]diagonalElement = 
                    Intersection[rowOfNodesOnElectrode, 
                      columnOfNodesOnElectrode];  (*\ das\ Element, \ 
                    das\ sowohl\ zur\ zeile\ wie\ auch\ zur\ Spalte\ gehoert \
. \ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalElements = 
                    DeleteCases[rowOfNodesOnElectrode, 
                      diagonalElement[\([1]\)]];  (*\ 
                    Alle\ Zeilenelemente\ ohne\ dem\ Diagonalelement\ \
*) \[IndentingNewLine]\[IndentingNewLine]nonDiagonalSparsMatrixEntrys = 
                    equationSystemSteady[\([1, nonDiagonalElements]\)] /. 
                      deltaE \[Rule] 
                        10; \[IndentingNewLine]\[IndentingNewLine]Return[
                    nonDiagonalSparsMatrixEntrys];\[IndentingNewLine]]; \
\[IndentingNewLine]\n\n
              matrixElements = 
                Flatten[
                  matrixElementFunction /@ 
                    Range[Length[NodesOnElectrode]]]; \[IndentingNewLine]\n
              gradientFunction[
                  j_] := \((\((\(concDistributionSteady[\([matrixElements[\([\
j, 1]\)]]\)]\)[\([2]\)] - \(concDistributionSteady[\([matrixElements[\([j, 
                                  1]\)]]\)]\)[\([1]\)])\)*
                    matrixElements[\([j, 2]\)])\); \[IndentingNewLine]\n
              currentII = \((\((Apply[Plus, 
                          gradientFunction /@ 
                            Range[Length[
                                matrixElements]]])\)^2)\)*\[Pi]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                currentII]\[IndentingNewLine]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]current = 
            CurrentbyMatrix2DAxyssymetricFunctionVV /@ 
              concDistribution; \[IndentingNewLine]Return[
            current]\[IndentingNewLine]\[IndentingNewLine]];\)\(\
\[IndentingNewLine]\)
    \)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation EquationsystTransient2D  (*specified *)", "Subsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{\(EquationsystTransient2D[
          geometry : {boxSideLengthvariable : {\(({_Real, _Real, _Real})\) \
.. }, \[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]Dif : {\((_Real | _Integer)\) \
.. }, \[IndentingNewLine]timeStep : \((_Real | _Integer)\), \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \((_Real | \
_Integer)\)}, ___})\) .. }, \[IndentingNewLine]electrodeReactionValues : \
{\(({\ \ \ _Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | \
_Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, 
          dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, {_Real | \
_Integer, _Real | _Integer}})\) .. }]\), ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, 
              vectorOfConcentrationsFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              vectorOfVolumes, concentrationFunction, 
              elektrodenVariablenFunktion, elektrodenVariablen, 
              punktkombinationenFunktion}\), ",", "\[IndentingNewLine]", 
            "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = 
                Table[{1, 1, 1, 1, 1, 1}, {Length[geometry[\([5]\)]]}]\), ";",
               "     ", \( (*the\ radius\ of\ the\ axisymmetric\ Function\ \
has\ been\ set\ to\ 1\  \[Rule] \ the\ function\ became\ 2  D\ *) \), 
              "\n", \(radiusOfFlux = 
                Table[{1, 1, 1}, {Length[geometry[\([6]\)]]}]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", 
              " ", \( (*\(\(**\)\(\ \)\(wenn\)\)\ volumeOfVoronoiPart = 
                  0\ gesetzt\ wird, \ 
                dann\ haben\ wir\ den\ steady\ state\ Fall\ ***) \), 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", 
              "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction, geom, r, 
                      s, t, transPart}\), ",", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"geom", "=", 
                        RowBox[{"boxSideLength", 
                          StyleBox["/",
                            FontColor->GrayLevel[0]], 
                          "lengthOfElementsides"}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ x = 
                          radiusOfFlux[\([i, 1]\)]*
                            geom[\([i, 1]\)]; \[IndentingNewLine]y = 
                          radiusOfFlux[\([i, 2]\)]*
                            geom[\([i, 2]\)]; \[IndentingNewLine]z = 
                          radiusOfFlux[\([i, 3]\)]*geom[\([i, 3]\)];\ \ *) \),
                       "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({x, y, z} = 
                        radiusOfFlux[\([i]\)]*geom[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(transPart = 
                        volumeOfVoronoiPart/timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(r = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 1]\)] + 
                          transPart[\([i, 2]\)] radiusOfCel[\([i, 2]\)]\), 
                      ";", "\[IndentingNewLine]", \(s = 
                        transPart[\([i, 1]\)] radiusOfCel[\([i, 3]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 4]\)]\), 
                      ";", 
                      "\[IndentingNewLine]", \(t = 
                        transPart[\([i, 2]\)] radiusOfCel[\([i, 5]\)] + 
                          transPart[\([i, 3]\)] radiusOfCel[\([i, 6]\)]\), 
                      ";", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \( (*\ \ \ \ \ \ u = 
                          nodeNumbersPerElement[\([i, 
                              1]\)]; \[IndentingNewLine]v = 
                          nodeNumbersPerElement[\([i, 
                              2]\)]; \[IndentingNewLine]w = 
                          nodeNumbersPerElement[\([i, 3]\)];\ \ \ \ *) \), 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \({u, v, w} = 
                        nodeNumbersPerElement[\([i]\)]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction[j_] := 
                        Module[{}, \[IndentingNewLine]rightHandSideVector[\([\
\((j - 1)\)*numberOfNodes + u]\)] += 
                            r; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + v]\)] += 
                            s; \[IndentingNewLine]rightHandSideVector[\([\((j \
- 1)\)*numberOfNodes + w]\)] += t;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \
\(rightHandSideVectorBuildingFunction /@ Range[Length[Dif]]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(vectorOfVolumes = 
                        rightHandSideVector*timeStep\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj + 
                              r; \[IndentingNewLine]a[j1v, 
                              j1v] += \((x + z)\)*dj + 
                              s; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*dj + 
                              t; \[IndentingNewLine]\[IndentingNewLine]a[j1u, 
                              j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrationsFunction[i_] := 
                Table[initialConcentrations[\([i]\)], {numberOfNodes}]\), ";",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Flatten[
                  vectorOfConcentrationsFunction /@ 
                    Range[Length[initialConcentrations]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 1\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  rightHandSideVector, vectorOfConcentrations, 
                  vectorOfVolumes}]\)}]}], "\[IndentingNewLine]", "]"}]}], 
      ";"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation EquationsystSteadyState2D  (*specified *)", "Subsection"],

Cell[BoxData[
    RowBox[{
      RowBox[{
        RowBox[{
          StyleBox["EquationsystSteadyState2D",
            FontVariations->{"CompatibilityType"->0}], "[", 
          "\[IndentingNewLine]", \(geometry : {boxSideLengthvariable : \
{\(({_Real, _Real, _Real})\) .. }, \
\[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
              radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : {\(({_Real, \
_Real, _Real})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]easymeshData : \
{\[IndentingNewLine]nodeListvariable : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideListvariable : {\(({_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : \
{\((_Real | _Integer)\) .. }, \[IndentingNewLine]initialConcentrations : \
{\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]neumannBoundaryValues : {\(({{_Integer, \
\((_Real | _Integer)\)}, ___})\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, \
{_Integer, _Integer}, {_Real | _Integer, _Real | _Integer}})\) .. }\), 
          "\[IndentingNewLine]", "]"}], ":=", "\[IndentingNewLine]", 
        "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          
          RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
              nodeNumbersPerElement, radiusOfCel, volumeOfVoronoiPart, 
              radiusOfFlux, boxSideLength, lengthOfElementsides, a, 
              sparseMatrixAValues, rightHandSideVector, 
              rightHandSideVectorBuildingFunction, vectorOfConcentrations, 
              nodeMarcs, neumannBCFunction, electrodeReactionsFunktion, 
              electrodeReaction, aIndices, dirichletBcNodesFunktion, 
              dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
              dirichletLinesFunktion, dirichletLines, 
              dirichletEliminationFunktion, diagonDirichl, 
              dirichletRHSVariableFunction, dirichletRHSFunction, 
              dirichletRHSVariable, sparseStiffnessMatrix, 
              punktkombinationen, startMatrixFunction, startMatrix, 
              concentrationFunction, elektrodenVariablen, 
              elektrodenVariablenFunktion, punktkombinationenFunktion}\), ",",
             "\[IndentingNewLine]", "\[IndentingNewLine]", 
            
            RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
              "\[IndentingNewLine]", \(lengthOfElementsides = 
                geometry[\([2]\)]\), ";", 
              "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                geometry[\([3]\)]\), ";", 
              "\[IndentingNewLine]", \(numberOfNodes = geometry[\([4]\)]\), 
              ";", "\[IndentingNewLine]", \(radiusOfCel = 
                Table[{1, 1, 1, 1, 1, 1}, {Length[geometry[\([5]\)]]}]\), ";",
               "     ", \( (*the\ radius\ of\ the\ axisymmetric\ Function\ \
has\ been\ set\ to\ 1\  \[Rule] \ the\ function\ became\ 2  D\ *) \), 
              "\[IndentingNewLine]", \(radiusOfFlux = 
                Table[{1, 1, 1}, {Length[geometry[\([6]\)]]}]\), ";", 
              "\[IndentingNewLine]", \(volumeOfVoronoiPart = 
                geometry[\([7]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(punktkombinationenFunktion[
                  i_] := {\((i - 1)\) 
                      easymeshData[\([1, \(-1\), 
                          1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                          3}]\)], 
                  Map[RotateLeft, \((i - 1)\) 
                        easymeshData[\([1, \(-1\), 
                            1]\)] + \(easymeshData[\([2]\)]\)[\([All, {2, 
                            3}]\)]], \((i - 1)\) 
                      easymeshData[\([1, \(-1\), 1]\)] + 
                    Table[{k, k}, {k, easymeshData[\([1, \(-1\), 1]\)]}]}\), 
              ";", "\n", \(punktkombinationen = 
                Flatten[punktkombinationenFunktion /@ Range[Length[Dif]], 
                  2]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(startMatrixFunction[
                  i_] := \(a[i\[LeftDoubleBracket]1\[RightDoubleBracket], 
                    i\[LeftDoubleBracket]2\[RightDoubleBracket]] = 0\)\), ";",
               "\n", \(startMatrix = 
                startMatrixFunction /@ punktkombinationen\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                durch\ die\ Startmatrix\ entfallen\ die\ If - 
                  Abfragen\ fuer\ den\ Matrixaufbau\ *) \), 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({x, y, z, u, v, w, numberOfSpezFunction}\), ",", 
                    "\[IndentingNewLine]", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    RowBox[{
                      RowBox[{"x", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 1]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 1]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"y", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 2]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 2]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      RowBox[{"z", "=", 
                        RowBox[{\(radiusOfFlux[\([i, 3]\)]\), "*", 
                          RowBox[{
                            RowBox[{
                              StyleBox["(",
                                FontColor->GrayLevel[0]], 
                              RowBox[{"boxSideLength", 
                                StyleBox["/",
                                  FontColor->GrayLevel[0]], 
                                "lengthOfElementsides"}], ")"}], 
                            "[", \([i, 3]\), "]"}]}]}], ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(u = 
                        nodeNumbersPerElement[\([i, 1]\)]\), ";", 
                      "\[IndentingNewLine]", \(v = 
                        nodeNumbersPerElement[\([i, 2]\)]\), ";", 
                      "\[IndentingNewLine]", \(w = 
                        nodeNumbersPerElement[\([i, 3]\)]\), ";", 
                      "\[IndentingNewLine]", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction[j_] := 
                        Module[{j1u = \((j - 1)\)*numberOfNodes + u, 
                            j1v = \((j - 1)\)*numberOfNodes + v, 
                            j1w = \((j - 1)\)*numberOfNodes + w, 
                            dj = Dif[\([j]\)]}, \[IndentingNewLine]a[j1u, 
                              j1u] += \((x + y)\)*dj; \[IndentingNewLine]a[
                              j1v, j1v] += \((x + z)\)*
                              dj; \[IndentingNewLine]a[j1w, 
                              j1w] += \((y + z)\)*
                              dj; \[IndentingNewLine]\[IndentingNewLine]a[
                              j1u, j1v] = 
                            a[j1v, j1u] += \(-\((x)\)\)*
                                dj; \[IndentingNewLine]a[j1v, j1w] = 
                            a[j1w, j1v] += \(-\((z)\)\)*
                                dj; \[IndentingNewLine]a[j1u, j1w] = 
                            a[j1w, j1u] += \(-\((y)\)\)*
                                dj;\[IndentingNewLine]]\), ";", 
                      "\[IndentingNewLine]", \(numberOfSpezFunction /@ 
                        Range[Length[Dif]]\), ";"}]}], "\[IndentingNewLine]", 
                  "]"}]}], " ", ";", 
              "\n", \(sparseMatrixAValues = 
                sparseMatrixAValuesFunction /@ 
                  Range[Length[nodeNumbersPerElement]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(rightHandSideVector = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(vectorOfConcentrations = 
                Table[0, {Length[Dif]*numberOfNodes}]\), ";", 
              "\[IndentingNewLine]", \(nodeMarcs = \(easymeshData[\([1]\)]\)[\
\([All, 4]\)]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(neumannBCFunction[i_, j_, k_] := 
                If[nodeMarcs[\([i]\)] == 
                    neumannBoundaryValues[\([j, k, 
                        1]\)], \[IndentingNewLine]a[\((j - 1)\)*
                          numberOfNodes + i, \((j - 1)\)*numberOfNodes + i] += 
                    neumannBoundaryValues[\([j, k, 
                        2]\)]\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(If[
                Length[neumannBoundaryValues[\([1]\)]] > 
                  0, \[IndentingNewLine]\(\(Apply[neumannBCFunction, #] &\) /@ 
                    Flatten[
                      Table[{i, j, k}, {j, Length[Dif]}, {i, 
                          Length[nodeMarcs]}, {k, 
                          Length[neumannBoundaryValues[\([1]\)]]}], 
                      2];\)\[IndentingNewLine]]\), ";", "\[IndentingNewLine]",
               "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(electrodeReactionsFunktion[i_, 
                  j_] := \[IndentingNewLine]If[
                  nodeMarcs[\([i]\)] == 
                    electrodeReactionValues[\([j, 
                        1]\)], \
\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + i] += 
                    electrodeReactionValues[\([j, 
                        4]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  2]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \(-\((electrodeReactionValues[\([j, 
                            5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                          numberOfNodes + 
                        i] += \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                      electrodeReactionValues[\([j, 
                          5]\)]; \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                                  3]\)] - 1)\)*numberOfNodes + 
                        i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                          numberOfNodes + 
                        i] = \((Dif[\([electrodeReactionValues[\([j, 
                                  2]\)]]\)]/
                          Dif[\([electrodeReactionValues[\([j, 
                                  3]\)]]\)])\)*\(-electrodeReactionValues[\([\
j, 4]\)]\);\[IndentingNewLine]]\), ";", 
              "\[IndentingNewLine]", \(elektrodenVariablenFunktion[i_] := 
                Outer[List, 
                  Position[nodeMarcs, 
                    electrodeReactionValues[\([i, 1]\)]], {i}]\), ";", 
              "\n", \(elektrodenVariablen = 
                Flatten[
                  elektrodenVariablenFunktion /@ 
                    Range[Length[electrodeReactionValues]], 3]\), ";", 
              "\[IndentingNewLine]", \( (*\ 
                Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ *) \), 
              "\[IndentingNewLine]", \(electrodeReaction = \(Apply[
                      electrodeReactionsFunktion, #] &\) /@ 
                  elektrodenVariablen\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(aIndices = \(Level[#1, {2}] &\) @@@ 
                  DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletBcNodesFunktion[i_] := 
                Flatten[
                  Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]\), 
              ";", "\n", \(dirichletBcNodes = 
                dirichletBcNodesFunktion /@ 
                  Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(allDirichletNodesFunction[
                  j_] := \((j - 1)\)*Length[nodeMarcs] + dirichletBcNodes\), 
              ";", "\[IndentingNewLine]", \(allDirichletNodes = 
                Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]\), 
              ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletLinesFunktion[i_] := 
                Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]\), 
              ";", "\n", \(dirichletLines = 
                Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 
                    1]]\), ";", 
              "\n", \(dirichletEliminationFunktion[i_, 
                  j_] := \(a[i, j] =. \)\), ";", 
              "\n", \(\(Apply[dirichletEliminationFunktion, #] &\) /@ 
                dirichletLines\), ";", 
              "\n", \(diagonDirichl[i_] := \(a[i, i] = 1\)\), ";", 
              "\n", \(diagonDirichl /@ \(Transpose[
                    dirichletLines]\)[\([1]\)]\), ";", "           ", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSVariableFunction[i_] := 
                Transpose[{Flatten[dirichletBcNodes], 
                    Table[i, {Length[Flatten[dirichletBcNodes]]}]}]\), ";", 
              "\n", \(dirichletRHSVariable = 
                Flatten[
                  dirichletRHSVariableFunction /@ 
                    Range[Length[initialConcentrations]], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(dirichletRHSFunction[i_, 
                  j_] := \(rightHandSideVector[\([\((j - 1)\)*
                          Length[nodeMarcs] + i]\)] = 
                  initialConcentrations[\([j]\)]\)\), ";", 
              "\n", \(\(Apply[dirichletRHSFunction, #] &\) /@ 
                dirichletRHSVariable\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(concentrationFunction[k_] := 
                Module[{diricFunction}, \n
                  diricFunction[i_, 
                      j_] := \(vectorOfConcentrations[\([\((\
dirichletBoundaries[\([k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                      dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                        diricFunction, #] &\) /@ 
                    Transpose[{Flatten[
                          Transpose[
                            Table[Flatten[
                                Position[nodeMarcs, 
                                  dirichletBoundaries[\([k, 1]\)]]], {Length[
                                  Flatten[
                                    dirichletBoundaries[\([k, 2, 
                                        Range[
                                        Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[Table[
                            dirichletBoundaries[\([k, 2, 
                                Range[
                                  Length[
                                    dirichletBoundaries[\([k, 
                                        2]\)]]]]\)], {Length[
                                Flatten[
                                  Position[nodeMarcs, 
                                    dirichletBoundaries[\([k, 
                                        1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]\), ";", 
              "\n", \(concentrationFunction /@ 
                Range[Length[dirichletBoundaries]]\), ";", 
              "\[IndentingNewLine]", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(sparseStiffnessMatrix = \ \(Level[#1, \
{2}] \[Rule] #2 &\) @@@ DownValues[a]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[{sparseStiffnessMatrix, 
                  vectorOfConcentrations}]\)}]}], "\[IndentingNewLine]", 
          "]"}]}], ";"}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CurrentPerDepthFunction2D (*specified *)", "Subsection"],

Cell["\<\
just the voronoi area is considered, not the area on the boundary. \
The current flows not just through the area between the nodes, but through \
the whole Voronoi box area (additional boundary part on the edge of a \
boundary side)\
\>", "Text"],

Cell[BoxData[
    \(\(\(CurrentPerDepthFunction2D[
        dieElektrode_Integer, \[IndentingNewLine]dritens : {nodeListvariable \
: {\(({_Integer, _Real, _Real, _Integer})\) .. }, \
\[IndentingNewLine]sideListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer})\) .. }, \[IndentingNewLine]elementListvariable \
: {\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Real, _Real, _Integer})\) .. }}, 
        concDistribution : {{\((_Real)\) .. } .. }] := 
      Module[{sideMarcs, sideposition, pointNumbersFunction, pointNumbers, i, 
          j, k, sidesToNeighboursFunction, sidesToNeighbours, 
          nodeAndNeighbourFunction, nodeAndNeighbour, allCoordinatesFunction, 
          allCoordinates, currentWithoutDifCoef, deltaTimesEveridgeFunktion, 
          deltaTimesEveridge, elementNumberFunction, elementNumber, 
          sortierenFunction, sortieren, startAndEndNodeFunktion, 
          startAndEndNode, stromFunction, totalCurrent, 
          voronoiLengthFunction, 
          voronoiLength}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]sideMarcs = \(Transpose[
              dritens[\([2]\)]]\)[\([6]\)]\ ;  (*gibt\ die\ Randmarker\
*) \[IndentingNewLine]\[IndentingNewLine]sideposition = 
          Flatten[Position[sideMarcs, 
              dieElektrode]];  (*gibt\ die\ Positionen\ der\ \
elektrodenraender*) \[IndentingNewLine]\[IndentingNewLine]\
pointNumbersFunction[
            i_] := \(\(dritens[\([2]\)]\)[\([i]\)]\)[\([{2, 
                3}]\)];  (*gibt\ die\ Punktnummern\ der\ Electrode\
*) \[IndentingNewLine]pointNumbers = 
          Flatten[pointNumbersFunction /@ 
              sideposition]; \
\[IndentingNewLine]\[IndentingNewLine]sidesToNeighboursFunction[
            i_] := \(Transpose[
              Position[\(Transpose[dritens[\([2]\)]]\)[\([{2, 3}]\)], 
                i]]\)[\([2]\)];  (*gibt\ eine\ Liste\ der\ Seiten, \ 
          die\ den\ Electrodenpunkt\ \
enthalten*) \[IndentingNewLine]sidesToNeighbours = 
          sidesToNeighboursFunction /@ 
            pointNumbers; \
\[IndentingNewLine]\[IndentingNewLine]nodeAndNeighbourFunction[
            k_] := \(Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{2, 
                    3}]\)]]\)[\([k]\)];  (*gibt\ eine\ Liste\ mit\ dem\ \
Electrodenpunkt\ und\ seinen\ Nachbarn*) \[IndentingNewLine]nodeAndNeighbour \
= nodeAndNeighbourFunction /@ 
            sidesToNeighbours; \
\[IndentingNewLine]\[IndentingNewLine]allCoordinatesFunction[j_] := 
          Module[{coordinateFunction, 
              coordinate}, \[IndentingNewLine]coordinateFunction[
                i_] := \((Abs[\(\(Transpose[\(Transpose[
                                dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([1]\)] - \
\(\(Transpose[\(Transpose[dritens[\([1]\)]]\)[\([{2, 
                                  3}]\)]]\)[\([i]\)]\)[\([2]\)]])\) . {0, 
                  1};  (*gibt\ die\ Differenz\ der\ Koordinaten\ des\ Punktes\
\ und\ seines\ Nachbarn\ mal\ der\ Normalenrichtung*) \n
            coordinate = 
              coordinateFunction /@ 
                nodeAndNeighbour[\([j]\)]\[IndentingNewLine]]; \
\[IndentingNewLine]allCoordinates = 
          allCoordinatesFunction /@ 
            Range[Length[
                nodeAndNeighbour]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]sortierenFunction[i_] := Sort[i]; \n
        sortieren = 
          sortierenFunction /@ 
            Transpose[\(Transpose[
                  dritens[\([2]\)]]\)[\([{4, 
                    5}]\)]];  (*die\ Elementnummern\ an\ beiden\ Seiten\ \
aller\ Punktverbindungen\ im\ Gebiet; \ 
          die\ Elementnummern\ sind\ sortiert\ um\ Randelemente\ behandeln\ \
zu\ koennen*) \n\n
        elementNumberFunction[i_] := 
          sortieren[\([i]\)];  (*gibt\ die\ Elemente\ zu\ beiden\ Seiten\ der\
\ Verbindungsseite*) \n
        elementNumber = elementNumberFunction /@ sidesToNeighbours; \n\n
        startAndEndNodeFunktion[j_] := 
          Module[{startAndEndNodeFunktionII, 
              startAndEndNodeII}, \
\[IndentingNewLine]startAndEndNodeFunktionII[
                i_] := \(Transpose[\(Transpose[
                      dritens[\([2]\)]]\)[\([{2, 
                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                      i]\)]]\)];  (*das\ sind\ die\ Punkte\ zur\ Seite*) \n
            startAndEndNodeII = 
              startAndEndNodeFunktionII /@ 
                Range[Length[
                    sidesToNeighbours[\([j]\)]]]; \[IndentingNewLine]Return[
              startAndEndNodeII]\[IndentingNewLine]]; \n
        startAndEndNode = 
          startAndEndNodeFunktion /@ 
            Range[Length[
                sidesToNeighbours]]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\n
        voronoiLengthFunction[j_] := 
          Module[{voronoiLengthFunctionII, 
              voronoiLengthII}, \[IndentingNewLine]voronoiLengthFunctionII[
                i_] := If[elementNumber[\([j, i, 1]\)] > 0.1, 
                Apply[Plus, \((\(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([1]\)]]\)] - \
\(Transpose[\(Transpose[dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5, 
                Apply[Plus, \((\((\(\(Transpose[\(Transpose[
                                        dritens[\([1]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([startAndEndNode[\([j, 
                                        i]\)]]\)]\)[\([1]\)] + \(\(Transpose[\
\(Transpose[dritens[\([1]\)]]\)[\([{2, 3}]\)]]\)[\([\(Transpose[\(Transpose[
                                        dritens[\([2]\)]]\)[\([{2, 
                                        3}]\)]]\)[\([sidesToNeighbours[\([j, 
                                        i]\)]]\)]]\)]\)[\([2]\)])\)/
                            2 - \(Transpose[\(Transpose[
                                  dritens[\([3]\)]]\)[\([{11, 
                                    12}]\)]]\)[\([\(elementNumber[\([j, 
                                    i]\)]\)[\([2]\)]]\)])\)^2]^ .5]; \
\[IndentingNewLine]voronoiLengthII = 
              voronoiLengthFunctionII /@ 
                Range[Length[
                    elementNumber[\([j]\)]]]; \[IndentingNewLine]Return[
              voronoiLengthII]\[IndentingNewLine]]; \n
        voronoiLength = 
          voronoiLengthFunction /@ 
            Range[Length[
                elementNumber]]; \
\[IndentingNewLine]\[IndentingNewLine]stromFunction[k_] := 
          Module[{conzDifferenceFunction, conzDifference, conzTimesSij, 
              gradientFunction, gradientsI, 
              strom}, \[IndentingNewLine]\[IndentingNewLine]\
conzDifferenceFunction[i_] := 
              Module[{conzDifferenceTwoFunction, 
                  conzDifferenceTwo}, \
\[IndentingNewLine]conzDifferenceTwoFunction[j_] := 
                  k[\([nodeAndNeighbour[\([i, j, 2]\)]]\)] - 
                    k[\([nodeAndNeighbour[\([i, j, 
                            1]\)]]\)];  (*gibt\ die\ \
Konzentrationsdifferenz\ \ i = Hauptpunkt, \ 
                  j = Hauptpunkt\ und\ ein\ Nachbar*) \n
                conzDifferenceTwo = 
                  conzDifferenceTwoFunction /@ 
                    Range[Length[
                        nodeAndNeighbour[\([i]\)]]]\[IndentingNewLine]]; \n
            conzDifference = 
              conzDifferenceFunction /@ 
                Range[Length[
                    nodeAndNeighbour]]; \
\[IndentingNewLine]\[IndentingNewLine]\n
            conzTimesSij = conzDifference*voronoiLength; \[IndentingNewLine]\n
            gradientFunction[i_] := 
              Module[{gradientToOneNode, 
                  gradientToOneNodeFunction}, \
\[IndentingNewLine]gradientToOneNodeFunction[j_] := \[IndentingNewLine]If[
                    allCoordinates[\([i, j]\)] =!= 0. , 
                    conzTimesSij[\([i, j]\)]/allCoordinates[\([i, j]\)], 
                    0. ]; \[IndentingNewLine]\[IndentingNewLine] (*\ 
                  geteilt\ durch\ allCoordinates\ beachtet\ die\ \
\(\(Normalenrichtung\ !!\)!\)\ *) \[IndentingNewLine]\n
                gradientToOneNode = 
                  Apply[Plus, 
                    gradientToOneNodeFunction /@ 
                      Range[Length[
                          nodeAndNeighbour[\([i]\)]]]]\[IndentingNewLine]]; \n
            gradientsI = 
              gradientFunction /@ 
                Range[Length[
                    nodeAndNeighbour]];  (*gibt\ den\ Gradienten\ zum\ Punkt\ \
in\ der\ Normalenrichtung*) \[IndentingNewLine]\[IndentingNewLine]strom = 
              Apply[Plus, 
                gradientsI]; \[IndentingNewLine]\[IndentingNewLine]Return[
              strom]\[IndentingNewLine]]; \[IndentingNewLine]\n
        currentWithoutDifCoef = 
          stromFunction /@ 
            concDistribution; \[IndentingNewLine]\[IndentingNewLine]Return[
          currentWithoutDifCoef];\[IndentingNewLine]]\)\(\[IndentingNewLine]\)\
\(\[IndentingNewLine]\)
    \)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisNodes", "Subsection"],

Cell[BoxData[
    \(\(\(\n\)\(ReadAnsysNodes[ansisNodesFilename_] := 
        Block[\[IndentingNewLine]{readTetgenFormat, tetgenNode, 
            nodefile}, \[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ nodefile\ generated\ by\ tetgen\ \
is\ read\ *************) \[IndentingNewLine]\[IndentingNewLine]anNodefile = 
            OpenRead[
              ansisNodesFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \)\(The\)\
\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\(\ \
\)\(variable\)\ **) \[IndentingNewLine]\[IndentingNewLine]nodefile = 
            ReadList[
              anNodefile, {Number, Real, Real, 
                Real}]; \[IndentingNewLine]\[IndentingNewLine]Close[
            anNodefile]; \[IndentingNewLine]\[IndentingNewLine]appendFunkt[
              x_] := Append[x, 0]; \[IndentingNewLine]nodefile = 
            appendFunkt /@ nodefile; \[IndentingNewLine]Return[
            nodefile]\[IndentingNewLine]];\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisElements", "Subsection"],

Cell[BoxData[
    \(\(\(\n\)\(\(ReadAnsysElements[ansisElementFilename_] := 
        Block[\[IndentingNewLine]{anElementfile, 
            anelefile}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ elementfile\ \
generated\ by\ Ansis\ is\ read\ *************) \[IndentingNewLine]\
\[IndentingNewLine]anElementfile = 
            OpenRead[
              ansisElementFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \)\(The\
\)\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\(\ \
\)\(variable\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]anelefile = 
            ReadList[
              anElementfile, {Number, Number, Number, Number, Number, Number, 
                Number, Number, Number, Number, Number, Number, Number, 
                Number}]; \[IndentingNewLine] (*\(*\)\(\ \)\(the\)\(\ \
\)\(lines\)\(\ \)\(with\)\(\ \)\(the\)\(\ \)\(elementdata\)\(\ \)\(are\)\(\ \
\)\(red\)\(\ \)\((exclusive\ the\ last\ commentline)\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]Close[
            anElementfile]; \[IndentingNewLine]\[IndentingNewLine]anelefile = 
            anelefile[\([All, {1, 7, 8, 9, 11, 
                  2}]\)]; \[IndentingNewLine]\[IndentingNewLine]Return[
            anelefile]\[IndentingNewLine]];\)\(\[IndentingNewLine]\)\(\
\[IndentingNewLine]\)\(\n\)
    \)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisNodeFile (Sam)", "Subsection"],

Cell[BoxData[
    \(\(\(\n\)\(ReadAnsysNodefile[ansisNodeFilename_] := 
        Block[\[IndentingNewLine]{readTetgenFormat, tetgenNode, 
            nodefile}, \[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ nodefile\ generated\ by\ tetgen\ \
is\ read\ *************) \[IndentingNewLine]\[IndentingNewLine]anNodefile = 
            OpenRead[
              ansisNodeFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \
\)\(The\)\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\
\(\ \)\(variable\)\ **) \[IndentingNewLine]\[IndentingNewLine]nodefile = 
            ReadList[
              anNodefile, {Real, Real, Real, Real, Real, Real, 
                Real}]; \[IndentingNewLine]\[IndentingNewLine]Close[
            anNodefile]; \[IndentingNewLine]\[IndentingNewLine]appendFunkt[
              x_] := Append[x, 0]; \[IndentingNewLine]nodefile = 
            appendFunkt /@ nodefile; \[IndentingNewLine]Return[
            nodefile[\([All, {1, 2, 3, 4, 
                  5}]\)]]\[IndentingNewLine]];\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation ReadAnsisElementFile (Sam)", "Subsection"],

Cell[BoxData[
    \(\(\(\n\)\(ReadAnsisElementFile[ansisElementFilename_] := 
        Block[\[IndentingNewLine]{anElementfile, 
            anelefile}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(\ \)\(the\)\)\ elementfile\ \
generated\ by\ Ansis\ is\ read\ *************) \[IndentingNewLine]\
\[IndentingNewLine]anElementfile = 
            OpenRead[
              ansisElementFilename]; \[IndentingNewLine] (*\(*\)\(\ \ \)\(The\
\)\(\ \)\(filename\)\(\ \)\(is\)\(\ \)\(given\)\(\ \)\(as\)\(\ \)\(a\)\(\ \
\)\(variable\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]anelefile = 
            ReadList[
              anElementfile, {Number, Number, Number, Number, Number, Number, 
                Number, Number, 
                Number}]; \[IndentingNewLine] (*\(*\)\(\ \)\(the\)\(\ \
\)\(lines\)\(\ \)\(with\)\(\ \)\(the\)\(\ \)\(elementdata\)\(\ \)\(are\)\(\ \
\)\(red\)\(\ \)\((exclusive\ the\ last\ commentline)\)\ \
**) \[IndentingNewLine]\[IndentingNewLine]Close[
            anElementfile]; \[IndentingNewLine]\[IndentingNewLine]anelefile = 
            anelefile[\([All, {1, 2, 3, 4, 6, 
                  2}]\)]; \[IndentingNewLine]\[IndentingNewLine]Return[
            anelefile]\[IndentingNewLine]];\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysElementGeometryFunction3D (*specified *)", \
"Subsection"],

Cell[BoxData[
    \(\(AnsysElementGeometryFunction3D[
          ansisdata : {nodeList : {\(({_Integer, _Real, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]elementList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }}] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{nodeData, ElementGeometryFunction, 
            listOfGeometries}, \[IndentingNewLine]\[IndentingNewLine]\n
          nodeData = ansisdata[\([1]\)]; \n
          ElementGeometryFunction[l_] := 
            Module[{nodenumbers, elementCoordinates, lengthOfEdges, 
                edgeMidPoints, ElementVoronoiFunction, elementGeometryData, 
                ElementVoronoiNodes}, \
\[IndentingNewLine]\[IndentingNewLine]nodenumbers = 
                ansisdata[\([2, 
                    l, {2, 3, 4, 
                      5}]\)]; \[IndentingNewLine]elementCoordinates = 
                nodeData[\([\(ansisdata[\([2, l]\)]\)[\([{2, 3, 4, 
                          5}]\)], {2, 3, 
                      4}]\)]; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]lengthOfEdges = \[IndentingNewLine]{Apply[
                      Plus, \((elementCoordinates[\([1]\)] - 
                            elementCoordinates[\([2]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([1]\)] - 
                            elementCoordinates[\([3]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([1]\)] - 
                            elementCoordinates[\([4]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([2]\)] - 
                            elementCoordinates[\([3]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([2]\)] - 
                            elementCoordinates[\([4]\)])\)^2]^ .5, \
\[IndentingNewLine]Apply[
                      Plus, \((elementCoordinates[\([3]\)] - 
                            elementCoordinates[\([4]\)])\)^2]^ .5}; \
\[IndentingNewLine]\[IndentingNewLine]edgeMidPoints = \
\[IndentingNewLine]{\((elementCoordinates[\([1]\)] + 
                        elementCoordinates[\([2]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([1]\)] + 
                        elementCoordinates[\([3]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([1]\)] + 
                        elementCoordinates[\([4]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([2]\)] + 
                        elementCoordinates[\([3]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([2]\)] + 
                        elementCoordinates[\([4]\)])\)/
                    2, \[IndentingNewLine]\((elementCoordinates[\([3]\)] + 
                        elementCoordinates[\([4]\)])\)/
                    2}; \[IndentingNewLine]\[IndentingNewLine]\
ElementVoronoiFunction[elementCoordinates_] := 
                Module[{TriangleVoronoiPointFunction, 
                    TriangleVoronoiPointAndNormal, TriangleVoronoiPoint, 
                    crosspointElement, 
                    voronoiElementPoint}, \[IndentingNewLine]\
\[IndentingNewLine]TriangleVoronoiPointFunction[
                      i_]\  := \ \
\[IndentingNewLine]\[IndentingNewLine]Module[{triangleMatrix, planeNormal1, 
                        normVect1, normal1, normVect2, normal2, midpoint1, 
                        midpoint2, voronoiShort, 
                        t}, \[IndentingNewLine]\[IndentingNewLine]\
triangleMatrix = 
                        i; \[IndentingNewLine]\[IndentingNewLine] (*normal\ \
gives\ the\ normal\ vectors\ of\ two\ of\ the\ triangle\ sides\
*) \[IndentingNewLine]\[IndentingNewLine]planeNormal1 = 
                        CrossProduct[\((triangleMatrix[\([2]\)] - 
                              triangleMatrix[\([1]\)])\), \
\((triangleMatrix[\([3]\)] - 
                              triangleMatrix[\([1]\)])\)]; \
\[IndentingNewLine]\[IndentingNewLine]normVect1 = 
                        CrossProduct[
                          planeNormal1, \((triangleMatrix[\([2]\)] - 
                              triangleMatrix[\([1]\)])\)]; \
\[IndentingNewLine]normal1 = 
                        normVect1/\((Apply[Plus, 
                                normVect1^2]^ .5)\); \
\[IndentingNewLine]normVect2 = 
                        CrossProduct[
                          CrossProduct[\((triangleMatrix[\([2]\)] - 
                                triangleMatrix[\([1]\)])\), \
\((triangleMatrix[\([3]\)] - 
                                triangleMatrix[\([1]\)])\)], \
\((triangleMatrix[\([3]\)] - 
                              triangleMatrix[\([1]\)])\)]; \
\[IndentingNewLine]normal2 = 
                        normVect2/\((Apply[Plus, 
                                normVect2^2]^ .5)\); \[IndentingNewLine]\
\[IndentingNewLine]midpoint1 = \((triangleMatrix[\([1]\)] + 
                              triangleMatrix[\([2]\)])\)/
                          2; \[IndentingNewLine]midpoint2 = \
\((triangleMatrix[\([1]\)] + triangleMatrix[\([3]\)])\)/
                          2; \[IndentingNewLine]\[IndentingNewLine] (*\ \ It\ \
is\ impossible\ to\ solve\ the\ eqation\ to\ find\ the\ crosspoint\ between\ \
two\ lines\ which\ are\ build\ by\ the\ normals\ on\ two\ triangle\ sides\ \
through\ the\ midpoints\ of\ this\ sides\ because\ of\ the\ nummerical\ error\
\ the\ straits\ are\ often\ not\ in\ one\ plane . \ 
                            This\ function\ calculates\ the\ point, \ 
                        where\ the\ straits\ have\ the\ smalest\ distance . \ \
\((n11\ means\ the\ first\ element\ of\ the\ first\ normal\ vector, \ 
                              m11\ means\ the\ first\ element\ of\ the\ \
midpoint\ of\ the\ first\ triangle\ edge, \ \(\(etc\)\(.\)\)\ )\)\ The\ whole\
\ calculation\ is\ the\ \(following : \ 
                            D[Plus @@ \(({{m11 + n11*t - m21 - n21*k}, {m12 + 
                                        n12*t - m22 - n22*k}, {m13 + n13*t - 
                                        m23 - n23*k}}^2)\), 
                              k]\); \[IndentingNewLine]D[
                          Plus @@ \(({{m11 + n11*t - m21 - n21*k}, {m12 + 
                                      n12*t - m22 - n22*k}, {m13 + n13*t - 
                                      m23 - n23*k}}^2)\), 
                          t]; \[IndentingNewLine]FullSimplify[
                          Solve[{{\(-2\)\ n21\ \((m11 - m21 - k\ n21 + 
                                        n11\ t)\) - 
                                    2\ n22\ \((m12 - m22 - k\ n22 + 
                                        n12\ t)\) - 
                                    2\ n23\ \((m13 - m23 - k\ n23 + 
                                        n13\ t)\)} \[Equal] 
                                0, {2\ n11\ \((m11 - m21 - k\ n21 + 
                                        n11\ t)\) + 
                                    2\ n12\ \((m12 - m22 - k\ n22 + 
                                        n12\ t)\) + 
                                    2\ n13\ \((m13 - m23 - k\ n23 + 
                                        n13\ t)\)} \[Equal] 0}, {k, 
                              t}]];\ *) ; \ \[IndentingNewLine]\
\[IndentingNewLine]voronoiShort = 
                        normal1*
                              t + \((triangleMatrix[\([1]\)] + 
                                  triangleMatrix[\([2]\)])\)/2 /. 
                          t \[Rule] \(-\((4\ \((midpoint1[\([1]\)] 
                                        normal2[\([1]\)] - 
                                        midpoint2[\([1]\)]\ normal2[\([1]\)] \
+ midpoint1[\([2]\)]\ normal2[\([2]\)] - midpoint2[\([2\ ]\)] 
                                        normal2[\([2]\)] + 
                                        midpoint1[\([3]\)]\ normal2[\([3]\)] \
- midpoint2[\([3]\)]\ normal2[\([3]\)])\)\ \((normal1[\([1]\)]\ normal2[\([1]\
\)] + normal1[\([2]\)]\ normal2[\([2]\)] + 
                                        normal1[\([3]\)]\ normal2[\([3]\)])\) \
- 4\ \((midpoint1[\([1]\)]\ normal1[\([1]\)] - 
                                        midpoint2[\([1]\)]\ normal1[\([1]\)] \
+ midpoint1[\([2]\)]\ normal1[\([2]\)] - 
                                        midpoint2[\([2]\)]\ normal1[\([2]\)] \
+ midpoint1[\([3\ ]\)] normal1[\([3]\)] - 
                                        midpoint2[\([3]\)]\ normal1[\([3]\)])\
\)\ \((normal2[\([1]\)]^2 + normal2[\([2]\)]^2 + 
                                        normal2[\([3]\)]^2)\))\)\)/\((4\ \
\((normal1[\([1]\)]\ normal2[\([1]\)] + normal1[\([2]\)]\ normal2[\([2]\)] + 
                                        normal1[\([3]\)]\ \
normal2[\([3]\)])\)^2 - 4\ \((normal1[\([1]\)]^2 + normal1[\([2]\)]^2 + 
                                        normal1[\([3]\)]^2)\)\ \
\((normal2[\([1]\)]^2 + normal2[\([2]\)]^2 + 
                                        normal2[\([3]\)]^2)\))\); \
\[IndentingNewLine]\[IndentingNewLine]Return[{planeNormal1, 
                          voronoiShort}]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(\ \ \)\(The\)\)\ triangle\ \
Voronoi\ Function\ is\ called\ \  **  **  **  **  **  **  **  **  **  \
** **********) \[IndentingNewLine]TriangleVoronoiPointAndNormal = 
                    TriangleVoronoiPointFunction /@ \
{elementCoordinates[\([{1, 2, 3}]\)], elementCoordinates[\([{1, 2, 4}]\)], 
                        elementCoordinates[\([{1, 3, 4}]\)], 
                        elementCoordinates[\([{2, 3, 
                              4}]\)]}; \[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(\
**\)\(\ \ \ \ \)\(The\)\)\ Tetrahedron\ Voronoi\ node\ is\ calculeted\ \ \ \ \
\  **  **  **  **  **  **  **  **  **  **  **  ** ******) \[IndentingNewLine]\
\[IndentingNewLine]TriangleVoronoiPoint = 
                    TriangleVoronoiPointAndNormal[\([All, 
                        2]\)]; \
\[IndentingNewLine]\[IndentingNewLine]crosspointElement = 
                    t \[Rule] \(-\((4\ \
\((\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)])\)\ \
\((\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 1]\)]\)[\([3]\)])\) - 
                              4\ \((\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)] - \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        2]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)])\)\ \
\((\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)]^2)\))\)\)/\((4\ \
\((\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)] + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)]\ \
\(TriangleVoronoiPointAndNormal[\([2, 1]\)]\)[\([3]\)])\)^2 - 
                            4\ \((\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([1]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([2]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([1, 
                                        1]\)]\)[\([3]\)]^2)\)\ \
\((\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([1]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([2]\)]^2 + \
\(TriangleVoronoiPointAndNormal[\([2, 
                                        1]\)]\)[\([3]\)]^2)\))\); \
\[IndentingNewLine]voronoiElementPoint = 
                    TriangleVoronoiPointAndNormal[\([1, 1]\)]*t + 
                        TriangleVoronoiPointAndNormal[\([1, 2]\)] /. 
                      crosspointElement; \[IndentingNewLine]\
\[IndentingNewLine]Return[{voronoiElementPoint, 
                      TriangleVoronoiPoint}]\[IndentingNewLine]]; \
\[IndentingNewLine]\[IndentingNewLine]ElementVoronoiNodes = 
                ElementVoronoiFunction[
                  elementCoordinates]; \[IndentingNewLine]\n (*\ 
                The\ node\ numbers\ of\ the\ edge, \ 
                the\ length\ of\ the\ edge\ and\ the\ voronoi\ edge\ areas\ \
in\ the\ \(order : \ {1, 2}\); {1, 3}; {1, 4}; {2, 3}; {2, 4}; {3, 
                  4};\ \ *) \[IndentingNewLine]elementGeometryData = \
{{nodenumbers[\([{1, 2}]\)], 
                    lengthOfEdges[\([1]\)], \((\((Apply[
                                  Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2]^ .5)\)*\((Apply[
                                  Plus, \((edgeMidPoints[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2]^ .5)\) + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2]^ .5)\)*\((Apply[
                                    Plus, \((edgeMidPoints[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{1, 3}]\)], 
                    lengthOfEdges[\([2]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([2]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5)\) + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([2]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{1, 4}]\)], 
                    lengthOfEdges[\([3]\)], \((\((Apply[
                                  Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2]^ .5)\)*\((Apply[
                                  Plus, \((edgeMidPoints[\([3]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2]^ .5)\) + \((Apply[
                                  Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2]^ .5)\)*\((Apply[
                                  Plus, \((edgeMidPoints[\([3]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2]^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{2, 3}]\)], 
                    lengthOfEdges[\([4]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([4]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        1]\)])\)^2])\)^ .5)\)\n + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([4]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{2, 4}]\)], 
                    lengthOfEdges[\([5]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([5]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5)\)\n + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([5]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        2]\)])\)^2])\)^ .5)\))\)/
                      2}, \[IndentingNewLine]{nodenumbers[\([{3, 4}]\)], 
                    lengthOfEdges[\([6]\)], \((\((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([6]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        3]\)])\)^2])\)^ .5)\)\n + \((\((Apply[
                                    Plus, \((ElementVoronoiNodes[\([1]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5*\((Apply[
                                    Plus, \((edgeMidPoints[\([6]\)] - 
                                        ElementVoronoiNodes[\([2, 
                                        4]\)])\)^2])\)^ .5)\))\)/2}, 
                  ElementVoronoiNodes[\([1]\)]}; \[IndentingNewLine]\
\[IndentingNewLine] (*\ \ returns\ for\ each\ edge\ of\ a\ tetrahedron\ the\ \
node\ numbers, \ the\ length\ of\ the\ edge, \ 
                the\ area\ of\ the\ voronoi\ box\ \ and\ the\ element - 
                  voronoi - 
                  node\ *) \[IndentingNewLine]\[IndentingNewLine]Return[
                
                elementGeometryData];\[IndentingNewLine]\[IndentingNewLine]]; \
\nlistOfGeometries = 
            ElementGeometryFunction /@ 
              Range[Length[
                  ansisdata[\([2]\)]]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
            listOfGeometries]\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation GeometryTestForVoronoi3D  (*specified *)", "Subsection"],

Cell[BoxData[
    \(GeometryTestForVoronoi3D[
        meshdata : {{{_Integer, _Real, _Real, _Real, _Integer} .. }, \
{{_Integer, _Integer, _Integer, _Integer, _Integer, _Integer} .. }}, 
        geometryData : {\(({\(({{_Integer, _Integer}, _Real, _Real})\) .. , \
{_Real, _Real, _Real}})\) .. }] := 
      Module[{PointInTetrahedronFunction, isOrNotList, 
          isOrnotFunction}, \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]PointInTetrahedronFunction[{V1 : {x1_, y1_, z1_}, 
              V2 : {x2_, y2_, z2_}, V3 : {x3_, y3_, z3_}, 
              V4 : {x4_, y4_, z4_}, 
              P : {x_, y_, 
                  z_}}] := \[IndentingNewLine]\[IndentingNewLine]Module[{D0, 
              D1, D2, D3, D4, s1, s2, s3, s4, isDelaunay, vergleich, 
              punktLiegtAufSeite, 
              volumeOfTetrahedron}, \[IndentingNewLine]\[IndentingNewLine]D0 \
= Det[{{x1, y1, z1, 1}, {x2, y2, z2, 1}, {x3, y3, z3, 1}, {x4, y4, z4, 
                    1}}]; \[IndentingNewLine]D1 = 
              Det[{{x, y, z, 1}, {x2, y2, z2, 1}, {x3, y3, z3, 1}, {x4, y4, 
                    z4, 1}}]; \[IndentingNewLine]D2 = 
              Det[{{x1, y1, z1, 1}, {x, y, z, 1}, {x3, y3, z3, 1}, {x4, y4, 
                    z4, 1}}]; \[IndentingNewLine]D3 = 
              Det[{{x1, y1, z1, 1}, {x2, y2, z2, 1}, {x, y, z, 1}, {x4, y4, 
                    z4, 1}}]; \[IndentingNewLine]D4 = 
              Det[{{x1, y1, z1, 1}, {x2, y2, z2, 1}, {x3, y3, z3, 1}, {x, y, 
                    z, 1}}]; \[IndentingNewLine]\[IndentingNewLine]vergleich[
                a_, b_] := 
              0 /; \((\(-10^\(-14\)\) < \ b < \ 
                    10^\(-14\))\); \[IndentingNewLine]vergleich[a_, b_] := 
              1 /; \((a*b)\) > 0; \[IndentingNewLine]vergleich[a_, 
                b_] := \(-1\) /; \((a*b)\) < 
                  0; \[IndentingNewLine]\[IndentingNewLine]s1 = 
              vergleich[D0, D1]; \[IndentingNewLine]s2 = 
              vergleich[D0, D2]; \[IndentingNewLine]s3 = 
              vergleich[D0, D3]; \[IndentingNewLine]s4 = 
              vergleich[D0, 
                D4]; \[IndentingNewLine]\[IndentingNewLine]isDelaunay = 
              FreeQ[{s1, s2, s3, 
                  s4}, \(-1\)]; \
\[IndentingNewLine]\[IndentingNewLine]volumeOfTetrahedron = 
              D0/6; \[IndentingNewLine]\[IndentingNewLine]punktLiegtAufSeite \
= Flatten[Position[{s1, s2, s3, s4}, 
                  0]]; \[IndentingNewLine] (*wenn\ zwei\ Seiten\ ausgegeben\ \
werden, \ 
              dann\ liegt\ der\ Punkt\ auf\ der\ Kante\[IndentingNewLine]\
*) \[IndentingNewLine]Return[{volumeOfTetrahedron, isDelaunay, 
                punktLiegtAufSeite}]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]isOrnotFunction[elementNr_] := 
          Module[{elementNodes, isOrNot}, \[IndentingNewLine]elementNodes = 
              Append[\(meshdata[\([1, 
                      meshdata[\([2, 
                          elementNr, {2, 3, 4, 5}]\)]]\)]\)[\([All, {2, 3, 
                      4}]\)], 
                geometryData[\([elementNr, \(-1\)]\)]]; \
\[IndentingNewLine]isOrNot = \(PointInTetrahedronFunction[
                  elementNodes]\)[\([2]\)]; \ \[IndentingNewLine]Return[
              isOrNot]\[IndentingNewLine]]; \[IndentingNewLine]isOrNotList = 
          isOrnotFunction /@ 
            Range[Length[
                geometryData]]; \[IndentingNewLine]numberOfNotVoronoiEle = 
          Count[isOrNotList, False]; \[IndentingNewLine]NumberOfElements = 
          Length[geometryData]; \[IndentingNewLine]Return[{ToString[
                numberOfNotVoronoiEle] <> "\< of \>" <> 
              ToString[\ 
                NumberOfElements] <> \ "\< elements, are not Voronoi elements\
\>"}]\[IndentingNewLine]]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation AnsysEquationSystemSteadyState3D  (*specified \
*)\
\>", "Subsection"],

Cell[BoxData[
    \(\(AnsysEquationSystemSteadyState3D[\[IndentingNewLine]listOfGeometries \
: {\(({\(({{_Integer, _Integer}, _Real, _Real})\) .. , {_Real, _Real, \
_Real}})\) .. }, \[IndentingNewLine]tetgenData : {{{_Integer, _Real, _Real, \
_Real, _Integer} .. }, {{_Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer} .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : {\((_Real | \
_Integer)\) .. }, \[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }\
\[IndentingNewLine]] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{elementAssembleFunction, 
            numberOfNodes, rightHandSideVector, nodeMarcs, 
            electrodeReactionsFunktion, elektrodenVariablenFunktion, 
            elektrodenVariablen, electrodeReaction, aIndices, 
            dirichletBcNodesFunktion, dirichletBcNodes, 
            allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, a, allNodePairs, nodesPerElement, 
            nodepairsForEverySpezies, sparseInitialisation, 
            sparseDiagonalInitialisation, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]nodesPerElement = \
\(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[{assembleFunction, i, voro1, voro2, voro3, voro4, voro5, 
                voro6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, j]\ *) \[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/i[\([6, 2]\)]; \n
              assembleFunction[spezNumber_] := 
                Module[{diffcoefOfSpez, multiSpez, voroDif1, voroDif2, 
                    voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1; \[IndentingNewLine]\[IndentingNewLine]voroDif2 \
= diffcoefOfSpez*voro2; \[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3; \[IndentingNewLine]\[IndentingNewLine]voroDif4 \
= diffcoefOfSpez*voro4; \[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4; \[IndentingNewLine]\[IndentingNewLine]voroDif5 \
= diffcoefOfSpez*voro5; \[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5; \[IndentingNewLine]\[IndentingNewLine]voroDif6 \
= diffcoefOfSpez*voro6; \[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    
                    voroDif6;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\) ** \
\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\
\[IndentingNewLine]vectorOfConcentrations = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine]\n (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n (*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 
              initialConcentrations[\([j]\)]\); \n\(Apply[
                dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\n\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, 
              vectorOfConcentrations}]\[IndentingNewLine]\[IndentingNewLine]];\
\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysEquationSystemTrans3D  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(AnsysEquationSystemTrans3D[
          listOfGeometries : {\(({\(({{_Integer, _Integer}, _Real, _Real})\) \
.. , {_Real, _Real, _Real}})\) .. }, \[IndentingNewLine]tetgenData : \
{{{_Integer, _Real, _Real, _Real, _Integer} .. }, {{_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer} .. }}, \[IndentingNewLine]Dif : \
{\((_Real | _Integer)\) .. }, \[IndentingNewLine]electrodeReactionValues : \
{\(({\ \ \ _Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | \
_Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]timeStep : \((_Real | _Integer)\)] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{elementAssembleFunction, numberOfNodes, 
            rightHandSideVector, nodeMarcs, electrodeReactionsFunktion, 
            elektrodenVariablenFunktion, elektrodenVariablen, 
            electrodeReaction, aIndices, dirichletBcNodesFunktion, 
            dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, vectorOfConcentrationsFunction, 
            vectorOfConcentrations, 
            a}, \[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine]\[IndentingNewLine]\
vectorOfConcentrationsFunction[i_] := 
            Table[initialConcentrations[\([i]\)], {numberOfNodes}]; \n
          vectorOfConcentrations = 
            Flatten[vectorOfConcentrationsFunction /@ 
                Range[Length[
                    initialConcentrations]]]; \[IndentingNewLine]\
\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]nodesPerElement \
= \(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[\[IndentingNewLine]{assembleFunction, i, voro1, voro2, 
                voro3, voro4, voro5, voro6, volume1, volume2, volume3, 
                volume4, volume5, 
                volume6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, 
                      j]\ *) \[IndentingNewLine]\[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/
                  i[\([6, 
                      2]\)]; \[IndentingNewLine]\[IndentingNewLine] (*this\ \
lines\ calculate\ the\ volume\ of\ the\ voronoi\ box\ of\ one\ element, \ 
                between\ each\ node\ pair\ ij*) \n
              volume1 = i[\([1, 3]\)]*i[\([1, 2]\)]/6; \n
              volume2 = i[\([2, 3]\)]*i[\([2, 2]\)]/6; \n
              volume3 = i[\([3, 3]\)]*i[\([3, 2]\)]/6; \n
              volume4 = i[\([4, 3]\)]*i[\([4, 2]\)]/6; \n
              volume5 = i[\([5, 3]\)]*i[\([5, 2]\)]/6; \n
              volume6 = i[\([6, 3]\)]*i[\([6, 2]\)]/6; \[IndentingNewLine]\n
              assembleFunction[spezNumber_] := 
                Module[\[IndentingNewLine]{diffcoefOfSpez, multiSpez, 
                    voroDif1, voroDif2, voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1 + volume1/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1 + volume1/timeStep; 
                  rightHandSideVector[\([multiSpez + i[\([1, 1, 1]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([1, 1, 2]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif2 = 
                    diffcoefOfSpez*voro2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2 + volume2/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2 + 
                      volume2/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 1]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 2]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3 + volume3/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3 + 
                      volume3/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 1]\)]]\)] += 
                    volume3/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 2]\)]]\)] += 
                    volume3/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif4 = 
                    diffcoefOfSpez*voro4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4 + volume4/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4 + 
                      volume4/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 1]\)]]\)] += 
                    volume4/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 2]\)]]\)] += 
                    volume4/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif5 = 
                    diffcoefOfSpez*voro5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5 + volume5/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5 + 
                      volume5/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 1]\)]]\)] += 
                    volume5/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 2]\)]]\)] += 
                    volume5/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif6 = 
                    diffcoefOfSpez*voro6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6 + volume6/timeStep; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    voroDif6 + 
                      volume6/
                        timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 1]\)]]\)] += 
                    volume6/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 2]\)]]\)] += 
                    volume6/
                      timeStep;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \n\[IndentingNewLine]vectorOfVolumes = 
            rightHandSideVector*
              timeStep;  (*vectorOfVolumes\ is\ needed\ for\ model\ order\ \
reduction\ \((C - 
                  vector)\)*) \[IndentingNewLine]\[IndentingNewLine] (*\(\(\
**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]\n
          nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n (*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 1\); \n\(Apply[dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \n\
\[IndentingNewLine]\[IndentingNewLine]concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, rightHandSideVector, vectorOfConcentrations, 
              vectorOfVolumes}]\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["twoDEasymeshToThreeDFunction  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(twoDEasymeshToThreeDFunction[
          easymeshData : {\[IndentingNewLine]nodeListvariable : \
{\(({_Integer, _Real, _Real, _Integer})\) .. }, \
\[IndentingNewLine]sideListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer})\) .. }, \[IndentingNewLine]elementListvariable \
: {\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Real, _Real, _Integer})\) .. }}, 
          delta : \((_Real | _Integer)\)\[IndentingNewLine]] := 
        Module[{ansisdata, elements3Doutput, element2DTo3D, nodes3Doutput, 
            node2DTo3D}, \[IndentingNewLine]\[IndentingNewLine]\n
          node2DTo3D[theNodes_List] := 
            Module[{m}, 
              m = Length[
                  theNodes]; \[IndentingNewLine]Join[\((\(Join[
                        Drop[#, \(-1\)], {delta}, Take[#, \(-1\)]] &\) /@ 
                    theNodes)\), \((\(Join[Take[#, 1] + m, 
                        Drop[Drop[#, \(-1\)], 1], {0.0}, 
                        Take[#, \(-1\)]] &\) /@ 
                    theNodes)\)]]; \[IndentingNewLine]\n
          nodes3Doutput = node2DTo3D[nodeListvariable]; \[IndentingNewLine]\n
          element2DTo3D[theNodes_List, theElements_List] := 
            Module[{m, mm}, 
              m = Length[theNodes]; \[IndentingNewLine]mm = 
                Length[theElements]; \[IndentingNewLine]Join[\((\({#\
\[LeftDoubleBracket]1\[RightDoubleBracket], #\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]3\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket], #\[LeftDoubleBracket]3\
\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]\(-1\)\[RightDoubleBracket]}\
 &\) /@ theElements)\), \[IndentingNewLine]\((\({#\[LeftDoubleBracket]1\
\[RightDoubleBracket] + 
                          mm, #\[LeftDoubleBracket]2\[RightDoubleBracket], #\
\[LeftDoubleBracket]3\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]2\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]\(-1\)\[RightDoubleBracket]}\
 &\) /@ theElements)\), \[IndentingNewLine]\((\({#\[LeftDoubleBracket]1\
\[RightDoubleBracket] + 2  mm, #\[LeftDoubleBracket]2\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]3\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket] + 
                          m, #\[LeftDoubleBracket]\(-1\)\[RightDoubleBracket]}\
 &\) /@ theElements)\)]]; \[IndentingNewLine]\n
          elements3Doutput = 
            element2DTo3D[nodeListvariable, 
              elementListvariable]; \[IndentingNewLine]\n
          ansisdata = {nodes3Doutput, 
              elements3Doutput}; \[IndentingNewLine]\[IndentingNewLine]Return[
            ansisdata]\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentFunction3D (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(CurrentFunction3D[\[IndentingNewLine]\
meshdata : {{{_Integer, _Real, _Real, _Real, _Integer} .. }, {{_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer} .. }}, \
\[IndentingNewLine]electrode_Integer, \[IndentingNewLine]listOfGeometries : {\
\(({\(({{_Integer, _Integer}, _Real, _Real})\) .. , {_Real, _Real, _Real}})\) \
.. }, \[IndentingNewLine]concList : {{\((_Real)\) .. } .. }] := 
        Module[{geometryofBoundaryNodesFunction, boundaryNodes, 
            geometryofBoundaryNodes, geometryofBCNodes, assembleFunction, 
            cutrrentPerTimestep}, \
\[IndentingNewLine]\[IndentingNewLine]geometryofBoundaryNodesFunction[k_] := 
            Module[{positionofBCNodesFunction, positionofBCNodes, 
                sortNodesFunction, nodePairsWithGeometryFunction, 
                nodePairsWithGeometry, 
                sortNodes}, \
\[IndentingNewLine]\[IndentingNewLine]positionofBCNodesFunction[
                  i_] := \(Position[listOfGeometries[\([All, All, 1]\)], 
                    i]\)[\([All, {1, 
                      2}]\)]; \[IndentingNewLine]positionofBCNodes = 
                positionofBCNodesFunction[k]; \[IndentingNewLine]\n
              nodePairsWithGeometryFunction[{i_, j_}] := 
                listOfGeometries[\([i, j]\)]; \n
              nodePairsWithGeometry = 
                nodePairsWithGeometryFunction /@ 
                  positionofBCNodes; \
\[IndentingNewLine]\[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_}] := {{y, x}, m, l} /; 
                  x =!= k; \[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_}] := {{x, y}, m, l} /; 
                  x == k; \[IndentingNewLine]\[IndentingNewLine]sortNodes = 
                sortNodesFunction /@ 
                  nodePairsWithGeometry; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                sortNodes]\[IndentingNewLine]]; \[IndentingNewLine]\n
          boundaryNodes = 
            Flatten[Position[meshdata[\([1, All, 5]\)], 
                electrode]]; \[IndentingNewLine]\n
          geometryofBoundaryNodes = 
            Partition[
              Flatten[geometryofBoundaryNodesFunction /@ boundaryNodes], 
              4]; \[IndentingNewLine]\[IndentingNewLine]geometryofBCNodes = 
            geometryofBoundaryNodes; \n\[IndentingNewLine]assembleFunction[
              concentrations_] := 
            Module[{gradientTimesAreaFunction, 
                gradientTimesArea}, \
\[IndentingNewLine]gradientTimesAreaFunction[
                  i_] := \[IndentingNewLine]\((concentrations[\([\
geometryofBCNodes[\([i, 2]\)]]\)] - 
                      concentrations[\([geometryofBCNodes[\([i, 1]\)]]\)])\)*
                  geometryofBCNodes[\([i, 4]\)]/
                    geometryofBCNodes[\([i, 
                        3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]gradientTimesArea = 
                gradientTimesAreaFunction /@ 
                  Range[Length[
                      geometryofBCNodes]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                Apply[Plus, gradientTimesArea]]\[IndentingNewLine]]; \n
          cutrrentPerTimestep = 
            assembleFunction /@ concList; \[IndentingNewLine]Return[
            cutrrentPerTimestep]\[IndentingNewLine]];\)\)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["McDonaldGeometryFunction", "Subsection"],

Cell[BoxData[
    \(\(McDonaldGeometryFunction[
          ansysdataMc : {nodeList : {\(({_Integer, _Real, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]elementList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }}] := 
        Module[{elementMcDonaldGeometryFunction, 
            elementMcDonaldGeometry}, \[IndentingNewLine]\[IndentingNewLine]\n
          elementMcDonaldGeometryFunction[element_] := 
            Module[{outPut, outPutFunction, volumeOfMcDonaldSubzells, 
                volumeOfMcDonaldSubzellsFunction, normalVectors, 
                mcDonaldSubareas, edgeVector, edgeVectorFunction, edgeLength, 
                edgeLengthFunction, edgeCenters, edgeCentersFunction, 
                massPointTriangle, massPointTriangleFunction, trianglesNodes, 
                massPointTet, nodePairs, nodeNumbers, edgeNormalVectors, 
                areaDotEdgeFunction, areaDotEdge, reducedAreas}, \n\n
              nodeNumbers = 
                ansysdataMc[\([2, 
                    element, {2, 3, 4, 5}]\)]; \[IndentingNewLine]\n
              nodePairs = {{nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTet = 
                Apply[Plus, ansysdataMc[\([1, nodeNumbers, {2, 3, 4}]\)]]/
                  4; \[IndentingNewLine]\n
              trianglesNodes = {{nodeNumbers[\([1]\)], nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([2]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([1]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}, {nodeNumbers[\([2]\)], 
                    nodeNumbers[\([3]\)], 
                    nodeNumbers[\([4]\)]}}; \[IndentingNewLine]\n
              massPointTriangleFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/3; \n
              massPointTriangle = 
                massPointTriangleFunction /@ 
                  trianglesNodes; \[IndentingNewLine]\n
              edgeCentersFunction[nNumbers_] := 
                Apply[Plus, ansysdataMc[\([1, nNumbers, {2, 3, 4}]\)]]/2; \n
              edgeCenters = 
                edgeCentersFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeLengthFunction[nNumbers_] := 
                Apply[Plus, \((ansysdataMc[\([1, 
                              nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                          ansysdataMc[\([1, 
                              nNumbers[\([2]\)], {2, 3, 4}]\)])\)^2]^ .5; \n
              edgeLength = 
                edgeLengthFunction /@ nodePairs; \[IndentingNewLine]\n
              edgeVectorFunction[
                  nNumbers_] := \((ansysdataMc[\([1, 
                        nNumbers[\([1]\)], {2, 3, 4}]\)] - 
                    ansysdataMc[\([1, nNumbers[\([2]\)], {2, 3, 4}]\)])\); \n
              edgeVector = 
                edgeVectorFunction /@ 
                  nodePairs; \n (*vector\ von\ massPointTet\ zu\ edgeCenters\ \
zwei\ mal\ benutzen\ x\ vector\ non\ edgeCenters\ zu\ massPointTriangle . \ 
                    Das\ Kreuzprodukt\ des\ einen\ Paares\ muss\ orthogonal\ \
\((dotproduct)\)\ zum\ dritten\ vector\ sein, \ 
                dann\ sind\ beide\ Flaechen\ in\ einer\ Ebene\ \((Beweis\ \
wurde\ in\ Mathematica\ symbolisch\ durchgefuehrt)\)*) \[IndentingNewLine]\
\[IndentingNewLine]mcDonaldSubareas = {\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                        massPointTet)\), \((edgeCenters[\([1]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                        massPointTet)\), \((edgeCenters[\([2]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                        massPointTet)\), \((edgeCenters[\([3]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([1]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                        massPointTet)\), \((edgeCenters[\([4]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([2]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                        massPointTet)\), \((edgeCenters[\([5]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2, \[IndentingNewLine]\n\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([3]\)])\)])\)^2])\)^ .5)\)/
                      2 + \[IndentingNewLine]\((\((Apply[
                              Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                        massPointTet)\), \((edgeCenters[\([6]\
\)] - massPointTriangle[\([4]\)])\)])\)^2])\)^ .5)\)/
                      2}; \[IndentingNewLine]\[IndentingNewLine]\n
              areaNormalVectors = {\((CrossProduct[\((edgeCenters[\([1]\)] - 
                            massPointTet)\), \((edgeCenters[\([1]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\n\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([1]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([1]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([2]\)] - 
                            massPointTet)\), \((edgeCenters[\([2]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([2]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([2]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([3]\)] - 
                            massPointTet)\), \((edgeCenters[\([3]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([3]\)] - 
                                      
                                      massPointTet)\), \
\((edgeCenters[\([3]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([4]\)] - 
                            massPointTet)\), \((edgeCenters[\([4]\)] - 
                            massPointTriangle[\([1]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([4]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([4]\)] - 
                                      massPointTriangle[\([1]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([5]\)] - 
                            massPointTet)\), \((edgeCenters[\([5]\)] - 
                            massPointTriangle[\([2]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([5]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([5]\)] - 
                                      massPointTriangle[\([2]\)])\)])\)^2])\)^\
 .5)\), \[IndentingNewLine]\n\((CrossProduct[\((edgeCenters[\([6]\)] - 
                            massPointTet)\), \((edgeCenters[\([6]\)] - 
                            massPointTriangle[\([3]\)])\)])\)/\((\((Apply[
                            Plus, \((CrossProduct[\((edgeCenters[\([6]\)] - 
                                      massPointTet)\), \
\((edgeCenters[\([6]\)] - 
                                      massPointTriangle[\([3]\)])\)])\)^2])\)^\
 .5)\)}; \[IndentingNewLine]\[IndentingNewLine]edgeNormalVectors = 
                edgeVector/
                  edgeLength; \
\[IndentingNewLine]\[IndentingNewLine]areaDotEdgeFunction[j_] := 
                Abs[DotProduct[areaNormalVectors[\([j]\)], 
                    edgeNormalVectors[\([j]\)]]]; \
\[IndentingNewLine]areaDotEdge = 
                areaDotEdgeFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\n
              reducedAreas = 
                mcDonaldSubareas*
                  areaDotEdge; \
\[IndentingNewLine]\[IndentingNewLine]volumeOfMcDonaldSubzellsFunction[{{{x1_,\
 y1_, z1_}, {x2_, y2_, z2_}}, {x3_, y3_, z3_}, {x4_, y4_, 
                      z4_}, {{x5_, y5_, z5_}, {x6_, y6_, 
                        z6_}}}] := {\((Abs[
                          Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, z4, 
                                1}, {x6, y6, z6, 1}}]] + 
                        Abs[Det[{{x1, y1, z1, 1}, {x3, y3, z3, 1}, {x4, y4, 
                                z4, 1}, {x5, y5, z5, 1}}]])\)/
                    6}; \n (*\(\(**\)\(\(*\)\(volumeVariable\)\)\) = \
{{ansysdataMc[\([1, nodePairs[\([1]\)], {2, 3, 4}]\)], edgeCenters[\([1]\)], 
                      massPointTet, 
                      massPointTriangle[\([{1, 2}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([2]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([2]\)], massPointTet, 
                      massPointTriangle[\([{1, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([3]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([3]\)], massPointTet, 
                      massPointTriangle[\([{2, 3}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([4]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([4]\)], massPointTet, 
                      massPointTriangle[\([{1, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([5]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([5]\)], massPointTet, 
                      massPointTriangle[\([{2, 4}]\)]}, \n{ansysdataMc[\([1, 
                          nodePairs[\([6]\)], {2, 3, 4}]\)], 
                      edgeCenters[\([6]\)], massPointTet, 
                      massPointTriangle[\([{3, 4}]\)]}}****) \n
              volumeOfMcDonaldSubzells = 
                volumeOfMcDonaldSubzellsFunction[{ansysdataMc[\([1, 
                        nodePairs[\([1]\)], {2, 3, 4}]\)], 
                    edgeCenters[\([1]\)], massPointTet, 
                    massPointTriangle[\([{1, 
                          2}]\)]}]; \  (*all\ 12\ McDonald\ subvolumes\ in\ a\
\ tetrahedron\ have\ the\ same\ value*) \n\[IndentingNewLine]outPutFunction[
                  i_] := {nodePairs[\([i]\)], edgeLength[\([i]\)], 
                  reducedAreas[\([i]\)], 
                  volumeOfMcDonaldSubzells[\([1]\)]}; \n
              outPut = 
                outPutFunction /@ {1, 2, 3, 4, 5, 
                    6}; \[IndentingNewLine]\[IndentingNewLine]Return[
                outPut]\[IndentingNewLine]]; \[IndentingNewLine]\
\[IndentingNewLine]elementMcDonaldGeometry = 
            elementMcDonaldGeometryFunction /@ 
              Range[Length[
                  elementList]]; \[IndentingNewLine]\[IndentingNewLine]Return[
            elementMcDonaldGeometry]\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation AnsysMcDonaldEquationSystemSteadyState3D", "Subsection"],

Cell[BoxData[
    \(\(AnsysMcDonaldEquationSystemSteadyState3D[\[IndentingNewLine]\
listOfGeometries : {\(({\(({{_Integer, _Integer}, _Real, _Real, _Real})\) \
.. })\) .. }, \[IndentingNewLine]tetgenData : {{{_Integer, _Real, _Real, \
_Real, _Integer} .. }, {{_Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer} .. }}, \[IndentingNewLine]\[IndentingNewLine]Dif : {\((_Real | \
_Integer)\) .. }, \[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ \
_Integer, \ _Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | \
_Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }\
\[IndentingNewLine]] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{elementAssembleFunction, 
            numberOfNodes, rightHandSideVector, nodeMarcs, 
            electrodeReactionsFunktion, elektrodenVariablenFunktion, 
            elektrodenVariablen, electrodeReaction, aIndices, 
            dirichletBcNodesFunktion, dirichletBcNodes, 
            allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, a, allNodePairs, nodesPerElement, 
            nodepairsForEverySpezies, sparseInitialisation, 
            sparseDiagonalInitialisation, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  \
**  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \)\(part\)\(\ \)\
\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]nodesPerElement = \
\(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[{assembleFunction, i, voro1, voro2, voro3, voro4, voro5, 
                voro6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, j]\ *) \[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/i[\([6, 2]\)]; \n
              assembleFunction[spezNumber_] := 
                Module[{diffcoefOfSpez, multiSpez, voroDif1, voroDif2, 
                    voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += 
                    voroDif1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += 
                    voroDif1; \[IndentingNewLine]\[IndentingNewLine]voroDif2 \
= diffcoefOfSpez*voro2; \[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += 
                    voroDif2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += 
                    voroDif2; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += 
                    voroDif3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += 
                    voroDif3; \[IndentingNewLine]\[IndentingNewLine]voroDif4 \
= diffcoefOfSpez*voro4; \[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += 
                    voroDif4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += 
                    voroDif4; \[IndentingNewLine]\[IndentingNewLine]voroDif5 \
= diffcoefOfSpez*voro5; \[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += 
                    voroDif5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += 
                    voroDif5; \[IndentingNewLine]\[IndentingNewLine]voroDif6 \
= diffcoefOfSpez*voro6; \[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += 
                    voroDif6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += 
                    
                    voroDif6;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\) ** \
\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\
\[IndentingNewLine]vectorOfConcentrations = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \[IndentingNewLine]\n (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \n (*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 
              initialConcentrations[\([j]\)]\); \n\(Apply[
                dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\n\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, 
              vectorOfConcentrations}]\[IndentingNewLine]\[IndentingNewLine]];\
\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
Implementation AnsysMcDonaldEquationSystemTrans3D  (*specified *)\
\
\>", "Subsection"],

Cell[BoxData[
    \(\(AnsysMcDonaldEquationSystemTrans3D[
          listOfGeometries : {\(({\(({{_Integer, _Integer}, _Real, _Real, \
_Real})\) .. })\) .. }, \[IndentingNewLine]tetgenData : {{{_Integer, _Real, \
_Real, _Real, _Integer} .. }, {{_Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer} .. }}, \[IndentingNewLine]Dif : {\((_Real | _Integer)\) \
.. }, \[IndentingNewLine]electrodeReactionValues : {\(({\ \ \ _Integer, \ \
_Integer, \ _Integer, \ \ \ butvolmHin : _Real | _Power\  | _Symbol, \ 
                    butvolmRueck\  : _Real | _Power\  | _Symbol\ \ })\) .. }, \
\[IndentingNewLine]dirichletBoundaries : {\(({_Integer, {_Integer, _Integer}, \
{_Real | _Integer, _Real | _Integer}})\) .. }, \
\[IndentingNewLine]initialConcentrations : {\((_Real | _Integer)\) .. }, \
\[IndentingNewLine]timeStep : \((_Real | _Integer)\)] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{elementAssembleFunction, numberOfNodes, 
            rightHandSideVector, nodeMarcs, electrodeReactionsFunktion, 
            elektrodenVariablenFunktion, elektrodenVariablen, 
            electrodeReaction, aIndices, dirichletBcNodesFunktion, 
            dirichletBcNodes, allDirichletNodesFunction, allDirichletNodes, 
            dirichletLinesFunktion, dirichletLines, 
            dirichletEliminationFunktion, diagonDirichl, 
            dirichletRHSVariableFunction, dirichletRHSVariable, 
            dirichletRHSFunction, concentrationFunction, diricFunction, 
            sparseStiffnessMatrix, vectorOfConcentrationsFunction, 
            vectorOfConcentrations, 
            a}, \[IndentingNewLine]\[IndentingNewLine]diffcoef = 
            Dif; \[IndentingNewLine]numberOfNodes = 
            tetgenData[\([1, \(-1\), 
                1]\)]; \[IndentingNewLine]\[IndentingNewLine]\
vectorOfConcentrationsFunction[i_] := 
            Table[initialConcentrations[\([i]\)], {numberOfNodes}]; \n
          vectorOfConcentrations = 
            Flatten[vectorOfConcentrationsFunction /@ 
                Range[Length[
                    initialConcentrations]]]; \[IndentingNewLine]\
\[IndentingNewLine] \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ sparse\ matrix\ initialization\  **  **  **  **  **  **  
                **  ** *****) \[IndentingNewLine] (*\(\(*\)\(\ \)\(this\)\(\ \
\)\(part\)\(\ \)\(produces\)\(\ \)\(all\)\(\ \)\(a[i, j]\)\) = 
              0\ which\ apeares\ in\ the\ final\ sparse\ matrix\ \
**) \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]nodesPerElement \
= \(tetgenData[\([2]\)]\)[\([All, {2, 3, 4, 5}]\)]; \n
          nodepairsForEverySpezies[spez_] := 
            Module[{nodePairsPerElement, 
                nodePairs}, \[IndentingNewLine]nodePairsPerElement[
                  i_] := {{\((spez - 1)\)*numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 1]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 2]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 4]\)]}, {\((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 3]\)], \((spez - 1)\)*
                        numberOfNodes + 
                      nodesPerElement[\([i, 
                          4]\)]}}; \
\[IndentingNewLine]\[IndentingNewLine]nodePairs = 
                nodePairsPerElement /@ 
                  Range[Length[nodesPerElement]]; \[IndentingNewLine]Return[
                nodePairs];\[IndentingNewLine]]; \n
          allNodePairs = 
            nodepairsForEverySpezies /@ Range[Length[diffcoef]]; \n
          sparseInitialisation[
              i_] := \(a[i[\([1]\)], 
                i[\([2]\)]] = \(a[i[\([2]\)], i[\([1]\)]] = 
                0\)\); \n\[IndentingNewLine]sparseInitialisation /@ 
            Union[Flatten[allNodePairs, 
                2]]; \[IndentingNewLine]\[IndentingNewLine]\
sparseDiagonalInitialisation[i_] := \(a[i, i] = 
              0\); \[IndentingNewLine]sparseDiagonalInitialisation /@ 
            Range[Length[tetgenData[\([1]\)]]*
                Length[diffcoef]]; \n\[IndentingNewLine]\[IndentingNewLine] \
(*\(\(**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              
              end\ sparse\ matrix\ initialization\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(**\)\
\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ AssembleFunction\  **  **  **  **  **  **  **  \
** *****) \n\[IndentingNewLine] (*\ \ the\ input\ for\ \
elementAssembleFunction\ is\ the\ list\ of\ geometries\ for\ one\ element, \ 
            the\ list\ of\ all\ diffusion\ coeficients\ and\ the\ number\ of\ \
nodes\ \ *) \[IndentingNewLine]\[IndentingNewLine] (*\(\(**\)\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\n
          rightHandSideVector = 
            Table[0, {Length[diffcoef]*
                  numberOfNodes}]; \n\[IndentingNewLine] (*\(\(**\)\(**\)\(\
**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ rightHandSideVector\  **  **  **  **  **  **  **  \
** *****) \[IndentingNewLine]\[IndentingNewLine]elementAssembleFunction[
              listOfGeom_, diffcoef_, numberOfNodes_] := 
            Module[\[IndentingNewLine]{assembleFunction, i, voro1, voro2, 
                voro3, voro4, voro5, voro6, volume1, volume2, volume3, 
                volume4, volume5, 
                volume6}, \n (*this\ rows\ calculate\ the\ area\ of\ the\ \
voronoi\ box\ edge\ A[i, 
                      j]\ over\ the\ distance\ between\ two\ points\ \
\[CapitalDelta][i, j] : \ 
                  A[i, j]/\[CapitalDelta][i, 
                      j]\ *) \[IndentingNewLine]\[IndentingNewLine]i = 
                listOfGeom; \nvoro1 = i[\([1, 3]\)]/i[\([1, 2]\)]; \n
              voro2 = i[\([2, 3]\)]/i[\([2, 2]\)]; \n
              voro3 = i[\([3, 3]\)]/i[\([3, 2]\)]; \n
              voro4 = i[\([4, 3]\)]/i[\([4, 2]\)]; \n
              voro5 = i[\([5, 3]\)]/i[\([5, 2]\)]; \n
              voro6 = i[\([6, 3]\)]/
                  i[\([6, 
                      2]\)]; \[IndentingNewLine]\[IndentingNewLine] (*this\ \
lines\ calculate\ the\ volume\ of\ the\ voronoi\ box\ of\ one\ element, \ 
                between\ each\ node\ pair\ ij*) \n
              volume1 = \(volume2 = \(volume3 = \(volume4 = \(volume5 = \
\(volume6 = i[\([1, 4]\)]\)\)\)\)\); \[IndentingNewLine]\n
              assembleFunction[spezNumber_] := 
                Module[\[IndentingNewLine]{diffcoefOfSpez, multiSpez, 
                    voroDif1, voroDif2, voroDif3, voroDif4, voroDif5, 
                    voroDif6}, \
\[IndentingNewLine]\[IndentingNewLine]diffcoefOfSpez = 
                    diffcoef[\([spezNumber]\)]; \[IndentingNewLine]multiSpez \
= \((spezNumber - 1)\)*
                      numberOfNodes; \
\[IndentingNewLine]\[IndentingNewLine]voroDif1 = 
                    diffcoefOfSpez*voro1; \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] = 
                    a[multiSpez + i[\([1, 1, 2]\)], 
                        multiSpez + 
                          i[\([1, 1, 
                              1]\)]] += \((\(-voroDif1\))\); \
\[IndentingNewLine]a[multiSpez + i[\([1, 1, 1]\)], 
                      multiSpez + i[\([1, 1, 1]\)]] += \((voroDif1 + 
                        volume1/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([1, 1, 2]\)], 
                      multiSpez + i[\([1, 1, 2]\)]] += \((voroDif1 + 
                        volume1/timeStep)\); 
                  rightHandSideVector[\([multiSpez + i[\([1, 1, 1]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([1, 1, 2]\)]]\)] += 
                    volume1/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif2 = 
                    diffcoefOfSpez*voro2; \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] = 
                    a[multiSpez + i[\([2, 1, 2]\)], 
                        multiSpez + 
                          i[\([2, 1, 
                              1]\)]] += \((\(-voroDif2\))\); \
\[IndentingNewLine]a[multiSpez + i[\([2, 1, 1]\)], 
                      multiSpez + i[\([2, 1, 1]\)]] += \((voroDif2 + 
                        volume2/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([2, 1, 2]\)], 
                      multiSpez + i[\([2, 1, 2]\)]] += \((voroDif2 + 
                        volume2/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 1]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([2, 1, 2]\)]]\)] += 
                    volume2/
                      timeStep; \
\[IndentingNewLine]\[IndentingNewLine]voroDif3 = 
                    diffcoefOfSpez*voro3; \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] = 
                    a[multiSpez + i[\([3, 1, 2]\)], 
                        multiSpez + 
                          i[\([3, 1, 
                              1]\)]] += \((\(-voroDif3\))\); \
\[IndentingNewLine]a[multiSpez + i[\([3, 1, 1]\)], 
                      multiSpez + i[\([3, 1, 1]\)]] += \((voroDif3 + 
                        volume3/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([3, 1, 2]\)], 
                      multiSpez + i[\([3, 1, 2]\)]] += \((voroDif3 + 
                        volume3/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 1]\)]]\)] += 
                    volume3/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([3, 1, 2]\)]]\)] += 
                    volume3/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif4 = 
                    diffcoefOfSpez*voro4; \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] = 
                    a[multiSpez + i[\([4, 1, 2]\)], 
                        multiSpez + 
                          i[\([4, 1, 
                              1]\)]] += \((\(-voroDif4\))\); \
\[IndentingNewLine]a[multiSpez + i[\([4, 1, 1]\)], 
                      multiSpez + i[\([4, 1, 1]\)]] += \((voroDif4 + 
                        volume4/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([4, 1, 2]\)], 
                      multiSpez + i[\([4, 1, 2]\)]] += \((voroDif4 + 
                        volume4/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 1]\)]]\)] += 
                    volume4/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([4, 1, 2]\)]]\)] += 
                    volume4/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif5 = 
                    diffcoefOfSpez*voro5; \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] = 
                    a[multiSpez + i[\([5, 1, 2]\)], 
                        multiSpez + 
                          i[\([5, 1, 
                              1]\)]] += \((\(-voroDif5\))\); \
\[IndentingNewLine]a[multiSpez + i[\([5, 1, 1]\)], 
                      multiSpez + i[\([5, 1, 1]\)]] += \((voroDif5 + 
                        volume5/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([5, 1, 2]\)], 
                      multiSpez + i[\([5, 1, 2]\)]] += \((voroDif5 + 
                        volume5/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 1]\)]]\)] += 
                    volume5/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([5, 1, 2]\)]]\)] += 
                    volume5/
                      timeStep; \[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]voroDif6 = 
                    diffcoefOfSpez*voro6; \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] = 
                    a[multiSpez + i[\([6, 1, 2]\)], 
                        multiSpez + 
                          i[\([6, 1, 
                              1]\)]] += \((\(-voroDif6\))\); \
\[IndentingNewLine]a[multiSpez + i[\([6, 1, 1]\)], 
                      multiSpez + i[\([6, 1, 1]\)]] += \((voroDif6 + 
                        volume6/timeStep)\); \[IndentingNewLine]a[
                      multiSpez + i[\([6, 1, 2]\)], 
                      multiSpez + i[\([6, 1, 2]\)]] += \((voroDif6 + 
                        volume6/
                          timeStep)\); \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 1]\)]]\)] += 
                    volume6/
                      timeStep; \
\[IndentingNewLine]rightHandSideVector[\([multiSpez + i[\([6, 1, 2]\)]]\)] += 
                    volume6/
                      timeStep;\[IndentingNewLine]\[IndentingNewLine]\
\[IndentingNewLine]\[IndentingNewLine]]; \n
              assembleFunction /@ Range[Length[diffcoef]];\n]; \n\n\n
          Outer[elementAssembleFunction, 
            listOfGeometries, {diffcoef}, {numberOfNodes}, 1, 1, 
            1]; \n\[IndentingNewLine]vectorOfVolumes = 
            rightHandSideVector*
              timeStep;  (*vectorOfVolumes\ is\ needed\ for\ model\ order\ \
reduction\ \((C - 
                  vector)\)*) \[IndentingNewLine]\[IndentingNewLine] (*\(\(\
**\)\(**\)\) ** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ AssembleFunction\  **  **  **  **  **  **  **  ** *****) \n\
\[IndentingNewLine]\[IndentingNewLine]nodeMarcs = 
            tetgenData[\([1, All, 
                5]\)]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              Start\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n\n
          electrodeReactionsFunktion[i_, j_] := \[IndentingNewLine]If[
              nodeMarcs[\([i]\)] == 
                electrodeReactionValues[\([j, 
                    1]\)], \[IndentingNewLine]a[\((electrodeReactionValues[\([\
j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + i] += 
                electrodeReactionValues[\([j, 
                    4]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 2]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \(-\((electrodeReactionValues[\([j, 
                        
                        5]\)])\)\); \
\[IndentingNewLine]\[IndentingNewLine]a[\((electrodeReactionValues[\([j, 
                              3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 3]\)] - 1)\)*
                      numberOfNodes + 
                    i] += \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([1, 3]\)]]\)])\)*
                  electrodeReactionValues[\([j, 
                      5]\)]; \[IndentingNewLine]\[IndentingNewLine]a[\((\
electrodeReactionValues[\([j, 3]\)] - 1)\)*numberOfNodes + 
                    i, \((electrodeReactionValues[\([j, 2]\)] - 1)\)*
                      numberOfNodes + 
                    i] = \((Dif[\([electrodeReactionValues[\([j, 2]\)]]\)]/
                      Dif[\([electrodeReactionValues[\([j, 
                              3]\)]]\)])\)*\(-electrodeReactionValues[\([j, 
                        4]\)]\);\[IndentingNewLine]]; \n
          elektrodenVariablenFunktion[i_] := 
            Outer[List, 
              Position[nodeMarcs, 
                electrodeReactionValues[\([i, 1]\)]], {i}]; \n
          elektrodenVariablen = 
            Flatten[elektrodenVariablenFunktion /@ 
                Range[Length[electrodeReactionValues]], 3]; \n (*\ 
            Durch\ die\ Elektrodevariablen\ werden\ nur\ noch\ die\ \
Elektrodenpunkte\ abgefragt\ dadurch\ werden\ viele\ Loops\ gespart\ \
*) \[IndentingNewLine]electrodeReaction = \(Apply[
                  electrodeReactionsFunktion, #] &\) /@ 
              elektrodenVariablen; \ \ \[IndentingNewLine] (*\(\(**\)\(**\)\) \
** \(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ electrode\ reactions\  **  **  **  **  **  **  **  \
** *****) \n\n (*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(\
**\)\(**\)\)*\ 
              Start\ Dirichlet\  **  **  **  **  **  **  **  **  **  \
** ******) \naIndices = \(Level[#1, {2}] &\) @@@ DownValues[a]; \n\n
          dirichletBcNodesFunktion[i_] := 
            Flatten[Position[nodeMarcs, dirichletBoundaries[\([i, 1]\)]]]; \n
          dirichletBcNodes = 
            dirichletBcNodesFunktion /@ 
              Range[Length[dirichletBoundaries]]; \n\n\n
          allDirichletNodesFunction[j_] := \((j - 1)\)*Length[nodeMarcs] + 
              dirichletBcNodes; \n
          allDirichletNodes = 
            Flatten[allDirichletNodesFunction /@ Range[Length[Dif]]]; \n\n
          dirichletLinesFunktion[i_] := 
            Flatten[{Select[aIndices, #[\([1]\)] \[Equal] i &]}, 1]; \n
          dirichletLines = 
            Union[Flatten[dirichletLinesFunktion /@ allDirichletNodes, 1]]; \n
          dirichletEliminationFunktion[i_, 
              j_] := \(a[i, j] =. \); \n\(Apply[
                dirichletEliminationFunktion, #] &\) /@ dirichletLines; \n
          diagonDirichl[i_] := \(a[i, i] = 1\); \n
          diagonDirichl /@ \(Transpose[
                dirichletLines]\)[\([1]\)]; \ \ \ \ \ \ \ \ \ \ \ \n\n\n
          dirichletRHSVariableFunction[i_] := 
            Transpose[{Flatten[dirichletBcNodes], 
                Table[i, {Length[Flatten[dirichletBcNodes]]}]}]; \n
          dirichletRHSVariable = 
            Flatten[dirichletRHSVariableFunction /@ 
                Range[Length[initialConcentrations]], 1]; \n\n
          dirichletRHSFunction[i_, 
              j_] := \(rightHandSideVector[\([\((j - 1)\)*Length[nodeMarcs] + 
                    i]\)] = 1\); \n\(Apply[dirichletRHSFunction, #] &\) /@ 
            dirichletRHSVariable; \[IndentingNewLine]\[IndentingNewLine]\n
          concentrationFunction[k_] := 
            Module[{diricFunction}, \n
              diricFunction[i_, 
                  j_] := \(vectorOfConcentrations[\([\((dirichletBoundaries[\(\
[k, 2, j]\)] - 1)\)*Length[nodeMarcs] + i]\)] = 
                  dirichletBoundaries[\([k, 3, j]\)]\); \(Apply[
                    diricFunction, #] &\) /@ 
                Transpose[{Flatten[
                      Transpose[
                        Table[Flatten[
                            Position[nodeMarcs, 
                              dirichletBoundaries[\([k, 1]\)]]], {Length[
                              Flatten[
                                dirichletBoundaries[\([k, 2, 
                                    Range[
                                      Length[
                                        dirichletBoundaries[\([k, 
                                        2]\)]]]]\)]]]}]]] (*das\ gibt\ die\ \
Nodenumbers*) , Flatten[
                      Table[dirichletBoundaries[\([k, 2, 
                            Range[Length[
                                dirichletBoundaries[\([k, 
                                    2]\)]]]]\)], {Length[
                            Flatten[
                              Position[nodeMarcs, 
                                dirichletBoundaries[\([k, 
                                    1]\)]]]]}]] (*das\ gibt\ die\ \
Spezies*) }];]; \n\n
          concentrationFunction /@ 
            Range[Length[
                dirichletBoundaries]]; \n \
(*\(\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\(**\)\)*\ 
              End\ of\ Dirichlet\  **  **  **  **  **  **  **  ** *****) \ \ \
\ \ \ \n\nsparseStiffnessMatrix = \ \(Level[#1, {2}] \[Rule] #2 &\) @@@ 
              DownValues[
                a]; \[IndentingNewLine]\[IndentingNewLine]Return[{\
sparseStiffnessMatrix, rightHandSideVector, vectorOfConcentrations, 
              vectorOfVolumes}]\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentFunctionMcDonald3D (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(\(\[IndentingNewLine]\)\(CurrentFunctionMcDonald3D[\[IndentingNewLine]\
meshdata : {{{_Integer, _Real, _Real, _Real, _Integer} .. }, {{_Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer} .. }}, \
\[IndentingNewLine]electrode_Integer, \[IndentingNewLine]listOfGeometries : {\
\(({\(({{_Integer, _Integer}, _Real, _Real, _Real})\) .. })\) .. }, \
\[IndentingNewLine]concList : {{\((_Real)\) .. } .. }] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{geometryofBoundaryNodesFunction, boundaryNodes, 
            geometryofBoundaryNodes, geometryofBCNodes, assembleFunction, 
            cutrrentPerTimestep}, \
\[IndentingNewLine]\[IndentingNewLine]geometryofBoundaryNodesFunction[k_] := 
            Module[{positionofBCNodesFunction, positionofBCNodes, 
                sortNodesFunction, nodePairsWithGeometryFunction, 
                nodePairsWithGeometry, 
                sortNodes}, \
\[IndentingNewLine]\[IndentingNewLine]positionofBCNodesFunction[
                  i_] := \(Position[listOfGeometries[\([All, All, 1]\)], 
                    i]\)[\([All, {1, 
                      2}]\)]; \[IndentingNewLine]positionofBCNodes = 
                positionofBCNodesFunction[k]; \[IndentingNewLine]\n
              nodePairsWithGeometryFunction[{i_, j_}] := 
                listOfGeometries[\([i, j]\)]; \n
              nodePairsWithGeometry = 
                nodePairsWithGeometryFunction /@ 
                  positionofBCNodes; \
\[IndentingNewLine]\[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_, n_}] := {{y, x}, m, l, n} /; 
                  x =!= k; \[IndentingNewLine]sortNodesFunction[{{x_Integer, 
                      y_Integer}, m_, l_, n_}] := {{x, y}, m, l, n} /; 
                  x == k; \[IndentingNewLine]\[IndentingNewLine]sortNodes = 
                sortNodesFunction /@ 
                  nodePairsWithGeometry; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                sortNodes]\[IndentingNewLine]]; \[IndentingNewLine]\n
          boundaryNodes = 
            Flatten[Position[meshdata[\([1, All, 5]\)], 
                electrode]]; \[IndentingNewLine]\n
          geometryofBoundaryNodes = 
            Partition[
              Flatten[geometryofBoundaryNodesFunction /@ boundaryNodes], 
              5]; \[IndentingNewLine]\[IndentingNewLine]geometryofBCNodes = 
            geometryofBoundaryNodes; \n\[IndentingNewLine]assembleFunction[
              concentrations_] := 
            Module[{gradientTimesAreaFunction, 
                gradientTimesArea}, \
\[IndentingNewLine]gradientTimesAreaFunction[
                  i_] := \[IndentingNewLine]\((concentrations[\([\
geometryofBCNodes[\([i, 2]\)]]\)] - 
                      concentrations[\([geometryofBCNodes[\([i, 1]\)]]\)])\)*
                  geometryofBCNodes[\([i, 4]\)]/
                    geometryofBCNodes[\([i, 
                        3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]gradientTimesArea = 
                gradientTimesAreaFunction /@ 
                  Range[Length[
                      geometryofBCNodes]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                Apply[Plus, gradientTimesArea]]\[IndentingNewLine]]; \n
          cutrrentPerTimestep = 
            assembleFunction /@ concList; \[IndentingNewLine]Return[
            cutrrentPerTimestep]\[IndentingNewLine]];\)\)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation Calculation SteadyState  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(SteadyStateCalculation[
          equationElements : {sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }}] := 
        Module[{concentrationsVerteilung, matrixA, 
            vectorE}, \[IndentingNewLine]\[IndentingNewLine]matrixA = 
            equationElements[\([1]\)]; \[IndentingNewLine]vectorE = 
            equationElements[\([2]\)]; \
\[IndentingNewLine]\[IndentingNewLine]concentrationsVerteilung = 
            Developer`SparseLinearSolve[matrixA, 
              vectorE]; \
\[IndentingNewLine]\[IndentingNewLine]Return[{concentrationsVerteilung}];\
\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation Calculation Timedep.  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(TransientCalculation[{sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }, 
            initialConcentrations : {\((_Real | _Integer)\) .. }, 
            elementVolumes : {\((_Real | _Integer)\) .. }}, 
          tges : \((_Real | _Integer)\), 
          timeStep : \((_Real | _Integer)\)] := \[IndentingNewLine]\
\[IndentingNewLine]Module[{concentrationsVerteilung, 
            vectorOfConcentrations}, \
\[IndentingNewLine]\[IndentingNewLine]vectorOfConcentrations = 
            initialConcentrations; \
\[IndentingNewLine]concentrationsVerteilung = 
            Table[vectorOfConcentrations = 
                Developer`SparseLinearSolve[
                  sparseMatrix, \((rightHandVector*
                      vectorOfConcentrations)\)], {tges/
                  timeStep}]; \[IndentingNewLine]Return[
            concentrationsVerteilung];\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Implementation CvCalculation  (*specified *)", "Subsection"],

Cell[BoxData[
    \(\(CvCalculation[\ 
          equationElements : {sparseMatrix : {\(({_Integer, _Integer} \[Rule] \
_)\) .. }, rightHandVector : {\((_Real | _Integer)\) .. }, 
              initialConcentrations : {\((_Real | _Integer)\) .. }, 
              elementVolumes : {\((_Real | _Integer)\) .. }}, Tges_\ , \ 
          deltaT_\ , \ deltaEstart_\ , \ deltaEend_\ , deltaE_\ ] := 
        Module[{concentrationsVerteilung, vectorOfConcentrations, 
            potentialSteps, potentialList, 
            i}, \[IndentingNewLine]\[IndentingNewLine]potentialSteps = \
\((deltaEend - deltaEstart)\)/\((Tges/\ 
                  deltaT)\)\ ; \[IndentingNewLine]potentialList = 
            Join[Table[i, {i, deltaEstart, deltaEend, potentialSteps}], 
              Reverse[Table[
                  i, {i, deltaEstart, deltaEend, 
                    potentialSteps}]]]; \
\[IndentingNewLine]\[IndentingNewLine]vectorOfConcentrations = 
            equationElements[\([3]\)]; \
\[IndentingNewLine]\[IndentingNewLine]concentrationsVerteilung = 
            Table[vectorOfConcentrations = 
                Developer`SparseLinearSolve[
                  equationElements[\([1]\)] /. 
                    deltaE \[Rule] 
                      potentialList[\([i]\)], \((equationElements[\([2]\)]*
                      vectorOfConcentrations)\)\ ], {i, 
                Length[potentialList]}]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
            concentrationsVerteilung];\[IndentingNewLine]];\)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["PointInBox      (****eigenstaendig****)  2+3D", "Subsection"],

Cell[BoxData[{
    \(\(\(PointInBox[box_, point_] := 
        Module[{testFunction3, 
              testresult}, \
\[IndentingNewLine]\[IndentingNewLine]testFunction3[{x0_, y0_, deltaX_, 
                  deltaY_}, {a_, x_, y_, b_}] := {a, \(-1\)} /; 
                x0 > x || x > \((x0 + deltaX)\) || y0 > y || 
                  y > \((y0 + deltaY)\); \n\n
            testFunction3[{x0_, y0_, deltaX_, deltaY_}, {a_, x_, y_, 
                  b_}] := {a, 0} /; 
                x \[Equal] x0 || 
                  x \[Equal] \((x0 + deltaX)\) && 
                    y0 \[LessEqual] y \[LessEqual] \((y0 + deltaY)\); \n\n
            testFunction3[{x0_, y0_, deltaX_, deltaY_}, {a_, x_, y_, 
                  b_}] := {a, 0} /; 
                y \[Equal] y0 || 
                  y \[Equal] \((y0 + deltaY)\) && 
                    x0 \[LessEqual] x \[LessEqual] \((x0 + deltaX)\); \n\n
            testFunction3[{x0_, y0_, deltaX_, deltaY_}, {a_, x_, y_, 
                  b_}] := {a, 1} /; 
                x > x0 && x < \((x0 + deltaX)\) && y0 < y && 
                  y < \((y0 + 
                        deltaY)\); \
\[IndentingNewLine]\[IndentingNewLine]testFunction3[{x0_, y0_, z0_, deltaX_, 
                  deltaY_, deltaZ_}, {a_, x_, y_, z_, b_}] := {a, \(-1\)} /; 
                x0 > x || x > \((x0 + deltaX)\) || y0 > y || 
                  y > \((y0 + deltaY)\) || z0 > z || 
                  z > \((z0 + deltaZ)\); \n\n
            testFunction3[{x0_, y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, 
                  x_, y_, z_, b_}] := {a, 0} /; 
                x \[Equal] x0 || 
                  x \[Equal] \((x0 + deltaX)\) && 
                    y0 \[LessEqual] y \[LessEqual] \((y0 + deltaY)\) && 
                    z0 \[LessEqual] z \[LessEqual] \((z0 + deltaZ)\); \n\n
            testFunction3[{x0_, y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, 
                  x_, y_, z_, b_}] := {a, 0} /; 
                y \[Equal] y0 || 
                  y \[Equal] \((y0 + deltaY)\) && 
                    x0 \[LessEqual] x \[LessEqual] \((x0 + deltaX)\) && 
                    z0 \[LessEqual] 
                      z \[LessEqual] \((z0 + 
                          deltaZ)\); \n\[IndentingNewLine]testFunction3[{x0_, 
                  y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, x_, y_, z_, 
                  b_}] := {a, 0} /; 
                z \[Equal] z0 || 
                  z \[Equal] \((z0 + deltaZ)\) && 
                    x0 \[LessEqual] x \[LessEqual] \((x0 + deltaX)\) && 
                    y0 \[LessEqual] 
                      y \[LessEqual] \((y0 + deltaY)\); \[IndentingNewLine]\n
            testFunction3[{x0_, y0_, z0_, deltaX_, deltaY_, deltaZ_}, {a_, 
                  x_, y_, z_, b_}] := {a, 1} /; 
                x > x0 && x < \((x0 + deltaX)\) && y0 < y || 
                  y < \((y0 + deltaY)\) && z0 < z || 
                  z < \((z0 + 
                        deltaZ)\); \
\[IndentingNewLine]\[IndentingNewLine]testresult = 
              testFunction3[box, 
                point]; \[IndentingNewLine]\[IndentingNewLine]Return[
              testresult];\[IndentingNewLine]\[IndentingNewLine]] /; \
\((Length[box] \[Equal] 4 && 
                Length[point] \[Equal] 4)\) || \((Length[box] \[Equal] 6 && 
                Length[point] \[Equal] 5)\);\)\(\[IndentingNewLine]\)
    \)\), "\n", 
    \(\(PointInBox::"\<inputData\>" = "\<argument badly conditioned\>";\)\), \
"\[IndentingNewLine]", 
    \(\(PointInBox[___] := 
        Message[PointInBox::"\<inputData\>"];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["\<\
BoundaryElementTest  Function for one element  \
(****eigenstaendig****)  2+3D\
\>", "Subsection"],

Cell[BoxData[
    \(BoundaryElementTest[nodeNumbers_, 
        testedNodes_] \
:= \[IndentingNewLine]\[IndentingNewLine]Module[{boundaryElementTestFunction, 
          boundaryElement}, \
\[IndentingNewLine]\[IndentingNewLine]testedNodesList = \(testedNodes[\([All, 
                2]\)]\)[\([nodeNumbers]\)]; \[IndentingNewLine]\
\[IndentingNewLine]boundaryElementTestFunction[{nodes : {a_, b_, c_, d_}, 
              tags : {e_, f_, g_, h_}}] := 
          raus /; \((Count[tags, 1] \[Equal] 0 && Count[tags, 0] =!= 4)\) || 
              Count[tags, 1] \[Equal] 4; \n
        boundaryElementTestFunction[{nodes : {a_, b_, c_, d_}, 
              tags : {e_, f_, g_, h_}}] := {nodes, tags}; \n
        boundaryElementTestFunction[{nodes : {a_, b_, c_}, 
              tags : {e_, f_, g_}}] := 
          raus /; \((Count[tags, 1] \[Equal] 0 && Count[tags, 0] =!= 3)\) || 
              Count[tags, 1] \[Equal] 3; \n
        boundaryElementTestFunction[{nodes : {a_, b_, c_}, 
              tags : {e_, f_, g_}}] := {nodes, 
            tags}; \n\[IndentingNewLine]boundaryElement = 
          boundaryElementTestFunction[{nodeNumbers, 
              testedNodesList}]; \[IndentingNewLine]\[IndentingNewLine]Return[
          boundaryElement]\[IndentingNewLine]\[IndentingNewLine]]\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentThroughBoxFunction2DAxissymetr", "Subsection"],

Cell[BoxData[
    RowBox[{"\[IndentingNewLine]", 
      RowBox[{\(CurrentThroughBoxFunction2DAxissymetr[fixedNode_, meshData_, 
          geometrys2D_, concDistributionSteady_]\), ":=", 
        "\[IndentingNewLine]", "\[IndentingNewLine]", 
        RowBox[{"Module", "[", 
          RowBox[{
            RowBox[{"{", 
              RowBox[{
              "TestElementOnBoundary", ",", "elementsOnBoundary", ",", 
                StyleBox["ElementMatrixAssembleFunction2D",
                  FontVariations->{"CompatibilityType"->0}], 
                StyleBox[",",
                  FontVariations->{"CompatibilityType"->0}], 
                "elementMatrixAssemble", ",", "ElementCurrentFunction", ",", 
                "elementCurrentList", ",", "positionsOfInnerNodes", ",", 
                "CurrentPerElementandNodeFunction", ",", 
                "currentThroughBox"}], "}"}], ",", "\[IndentingNewLine]", 
            "\[IndentingNewLine]", "\[IndentingNewLine]", 
            
            RowBox[{\(testFunction[i_] := 
                PointInBox[fixedNode, meshData[\([1, i]\)]]\), ";", 
              "\[IndentingNewLine]", \(testedNodes2D = 
                testFunction /@ Range[Length[meshData[\([1]\)]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(ElementsOnBox = 
                BoundaryElementTest[meshData[\([3, 1, {2, 3, 4}]\)], 
                  testedNodes2D]\), ";", "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(TestElementOnBoundary[meshData2D_, 
                  testedNodes2D_] := 
                Module[{testedElementFunction, 
                    testedElement}, \[IndentingNewLine]\n
                  testedElementFunction[i_] := 
                    BoundaryElementTest[meshData2D[\([3, 1, {2, 3, 4}]\)], 
                      testedNodes2D]; \[IndentingNewLine]testedElement = 
                    testedElementFunction /@ 
                      Range[Length[
                          meshData2D[\([3, 
                              1, {2, 3, 
                                4}]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[testedElement]\[IndentingNewLine]]\), ";", "\n", 
              "\[IndentingNewLine]", \(elementsOnBoundary = 
                DeleteCases[
                  TestElementOnBoundary[meshData, testedNodes2D], _Symbol]\), 
              ";", "\[IndentingNewLine]", "\n", 
              RowBox[{
                RowBox[{
                  StyleBox["ElementMatrixAssembleFunction2D",
                    FontVariations->{"CompatibilityType"->0}], "[", 
                  "\[IndentingNewLine]", \(geometry : {boxSideLengthvariable \
: {\(({_Real, _Real, _Real})\) .. }, \
\[IndentingNewLine]lengthOfElementsidesvariable : {\(({_Real, _Real, \
_Real})\) .. }, \[IndentingNewLine]nodeNumbersPerElementvariable : \
{\(({_Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]numberOfNodesvariable_Integer, 
                      radiusOfCelvariable : {\(({_Real, _Real, _Real, _Real, \
_Real, _Real})\) .. }, \[IndentingNewLine]radiusOfFluxvariable : {\(({_Real, \
_Real, _Real})\) .. }, \[IndentingNewLine]volumeOfVoronoiPartvariable : \
{\(({_Real, _Real, _Real})\) .. }}\), "\[IndentingNewLine]", 
                  "\[IndentingNewLine]", "]"}], ":=", "\[IndentingNewLine]", 
                "\[IndentingNewLine]", 
                RowBox[{"Module", "[", 
                  
                  RowBox[{\({sparseMatrixAValuesFunction, numberOfNodes, 
                      nodeNumbersPerElement, radiusOfCel, radiusOfFlux, 
                      boxSideLength, lengthOfElementsides, 
                      sparseMatrixAValues}\), ",", "\[IndentingNewLine]", 
                    "\[IndentingNewLine]", 
                    
                    RowBox[{\(boxSideLength = geometry[\([1]\)]\), ";", 
                      "\[IndentingNewLine]", \(lengthOfElementsides = 
                        geometry[\([2]\)]\), ";", 
                      "\[IndentingNewLine]", \(nodeNumbersPerElement = 
                        geometry[\([3]\)]\), ";", 
                      "\[IndentingNewLine]", \(numberOfNodes = 
                        geometry[\([4]\)]\), ";", 
                      "\[IndentingNewLine]", \(radiusOfCel = 
                        geometry[\([5]\)]\), ";", 
                      "\[IndentingNewLine]", \(radiusOfFlux = 
                        geometry[\([6]\)]\), ";", "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", "\[IndentingNewLine]", 
                      RowBox[{\(sparseMatrixAValuesFunction[i_]\), ":=", 
                        RowBox[{"Module", "[", 
                          
                          RowBox[{\({x, y, z, u, v, w, 
                              numberOfSpezFunction}\), ",", 
                            "\[IndentingNewLine]", "\[IndentingNewLine]", 
                            "\[IndentingNewLine]", 
                            RowBox[{
                              RowBox[{"x", "=", 
                                RowBox[{\(radiusOfFlux[\([i, 1]\)]\), "*", 
                                  RowBox[{
                                    RowBox[{
                                      StyleBox["(",
                                        FontColor->GrayLevel[0]], 
                                      RowBox[{"boxSideLength", 
                                        StyleBox["/",
                                        FontColor->GrayLevel[0]], 
                                        "lengthOfElementsides"}], ")"}], 
                                    "[", \([i, 1]\), "]"}]}]}], ";", 
                              "\[IndentingNewLine]", 
                              RowBox[{"y", "=", 
                                RowBox[{\(radiusOfFlux[\([i, 2]\)]\), "*", 
                                  RowBox[{
                                    RowBox[{
                                      StyleBox["(",
                                        FontColor->GrayLevel[0]], 
                                      RowBox[{"boxSideLength", 
                                        StyleBox["/",
                                        FontColor->GrayLevel[0]], 
                                        "lengthOfElementsides"}], ")"}], 
                                    "[", \([i, 2]\), "]"}]}]}], ";", 
                              "\[IndentingNewLine]", 
                              RowBox[{"z", "=", 
                                RowBox[{\(radiusOfFlux[\([i, 3]\)]\), "*", 
                                  RowBox[{
                                    RowBox[{
                                      StyleBox["(",
                                        FontColor->GrayLevel[0]], 
                                      RowBox[{"boxSideLength", 
                                        StyleBox["/",
                                        FontColor->GrayLevel[0]], 
                                        "lengthOfElementsides"}], ")"}], 
                                    "[", \([i, 3]\), "]"}]}]}], ";", 
                              "\[IndentingNewLine]", 
                              "\[IndentingNewLine]", \(u = 
                                nodeNumbersPerElement[\([i, 1]\)]\), ";", 
                              "\[IndentingNewLine]", \(v = 
                                nodeNumbersPerElement[\([i, 2]\)]\), ";", 
                              "\[IndentingNewLine]", \(w = 
                                nodeNumbersPerElement[\([i, 3]\)]\), ";", 
                              "\[IndentingNewLine]", 
                              "\[IndentingNewLine]", \(Return[{i, {u, v, 
                                    w}, {{\((x + 
                                        y)\), \(-\((x)\)\), \(-\((y)\)\)}, \
{\(-\((x)\)\), \((x + 
                                        z)\), \(-\((z)\)\)}, {\(-\((y)\)\), \
\(-\((z)\)\), \((y + z)\)}}}]\)}]}], "\[IndentingNewLine]", 
                          "\[IndentingNewLine]", "]"}]}], " ", ";", 
                      "\n", \(sparseMatrixAValues = 
                        sparseMatrixAValuesFunction /@ 
                          Range[Length[nodeNumbersPerElement]]\), ";", 
                      "\[IndentingNewLine]", 
                      "\[IndentingNewLine]", \(Return[
                        sparseMatrixAValues]\)}]}], "\[IndentingNewLine]", 
                  "]"}]}], ";", "\n", "\n", 
              RowBox[{"elementMatrixAssemble", "=", 
                StyleBox[\(ElementMatrixAssembleFunction2D[geometrys2D]\),
                  FontVariations->{"CompatibilityType"->0}]}], 
              StyleBox[";",
                FontVariations->{"CompatibilityType"->0}], 
              "\[IndentingNewLine]", 
              "\n", \(ElementCurrentFunction[concDistribution_, 
                  elementMatrix_] := 
                Module[{EachTimestepFunction, 
                    EachTimestepCurrents}, \[IndentingNewLine]\
\[IndentingNewLine]EachTimestepFunction[timestep_] := 
                    Module[{concDistributionOfTimestep, 
                        ElementCurrentPerTimestepFunction, 
                        elementCurrentPerTimestep}, \[IndentingNewLine]\n
                      concDistributionOfTimestep = 
                        concDistribution[\([timestep]\)]; \[IndentingNewLine]\
\nElementCurrentPerTimestepFunction[elementNumber_] := 
                        Module[{nodeNumbersPerElement, 
                            elementCurrentInner}, \[IndentingNewLine]\n
                          nodeNumbersPerElement = \
\(elementMatrix[\([elementNumber]\)]\)[\([2]\)]; \[IndentingNewLine]\n
                          elementCurrentInner = \
\((\(elementMatrix[\([elementNumber]\)]\)[\([3]\)])\) . \
\((concDistributionOfTimestep[\([nodeNumbersPerElement]\)])\); \
\[IndentingNewLine]\[IndentingNewLine]Return[{nodeNumbersPerElement, 
                              elementCurrentInner}];\[IndentingNewLine]]; \
\[IndentingNewLine]\nelementCurrentPerTimestep = 
                        ElementCurrentPerTimestepFunction /@ 
                          Range[Length[
                              elementMatrix]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[
                        elementCurrentPerTimestep];\[IndentingNewLine]\
\[IndentingNewLine]]; \[IndentingNewLine]EachTimestepCurrents = 
                    EachTimestepFunction /@ 
                      Range[Length[
                          concDistribution]]; \[IndentingNewLine]\
\[IndentingNewLine]Return[EachTimestepCurrents]\[IndentingNewLine]\n]\), ";", 
              "\n", \(elementCurrentList = 
                ElementCurrentFunction[concDistributionSteady, 
                  elementMatrixAssemble]\), ";", "\[IndentingNewLine]", 
              "\n", \(positionsOfInnerNodes = 
                Position[elementsOnBoundary[\([All, 2]\)], 1]\), ";", 
              "\[IndentingNewLine]", 
              "\n", \(CurrentPerElementandNodeFunction[i_] := 
                elementCurrentList[\([1, positionsOfInnerNodes[\([i, 1]\)], 
                    2, positionsOfInnerNodes[\([i, 2]\)]]\)]\), ";", 
              "\n", \(currentThroughBox = 
                Apply[Plus, 
                  CurrentPerElementandNodeFunction /@ 
                    Range[Length[positionsOfInnerNodes]]]\), ";", 
              "\[IndentingNewLine]", 
              "\[IndentingNewLine]", \(Return[currentThroughBox]\)}]}], 
          "\[IndentingNewLine]", "\[IndentingNewLine]", "]"}]}]}]], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["CurrentThroughBoxFunction3D", "Subsection"],

Cell[BoxData[
    \(\(CurrentThroughBoxFunction3D[fixedNode3D_, ansisdata2to3_, 
          listOfGeometriesMcDonald_, concDistributionSteady3DMcDonald_] := 
        Module[{testFunction, testedNodes3D, TestElementOnBoundary, 
            elementsOnBoundary, ReducedListOfGeometries3DFunction, 
            reducedListOfGeometries3D, ElementMatrixAssembleFunction, 
            elementMatrixAssemble, ElementCurrentFunction, 
            ElementCurrentList, positionsOfInnerNodes, 
            CurrentPerElementandNodeFunction, 
            wholeCurrent}, \[IndentingNewLine]\[IndentingNewLine]\n
          testFunction[i_] := 
            PointInBox[fixedNode3D, ansisdata2to3[\([1, i]\)]]; \n
          testedNodes3D = 
            testFunction /@ 
              Range[Length[
                  ansisdata2to3[\([1]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]\n
          TestElementOnBoundary[ansisdata3D_, testedNodes_] := 
            Module[{testedElementFunction, 
                testedElement}, \[IndentingNewLine]\n
              testedElementFunction[i_] := 
                BoundaryElementTest[\(ansisdata3D[\([2, 
                        All, {2, 3, 4, 5}]\)]\)[\([i]\)], 
                  testedNodes3D]; \[IndentingNewLine]testedElement = 
                testedElementFunction /@ 
                  Range[Length[
                      ansisdata3D[\([2, 
                          All, {2, 3, 4, 
                            5}]\)]]]; \
\[IndentingNewLine]\[IndentingNewLine]Return[
                testedElement]\[IndentingNewLine]]; \n
          elementsOnBoundary = 
            DeleteCases[
              TestElementOnBoundary[ansisdata2to3, 
                testedNodes3D], _Symbol]; \n\[IndentingNewLine]\
\[IndentingNewLine]ReducedListOfGeometries3DFunction[listOfGeometries3D_, 
              ansisdata3D_, elementsOnBoundary_] := 
            Module[{BoundaryElementNumberFunction, 
                reducedListOfGeometriesMcDonald}, \[IndentingNewLine]\
\[IndentingNewLine]BoundaryElementNumberFunction[ansisdata_] := 
                Module[{positionNumbers, 
                    eachBoundaryElementNumberFunction}, \[IndentingNewLine]\n
                  eachBoundaryElementNumberFunction[i_] := 
                    Position[ansisdata[\([2, All, {2, 3, 4, 5}]\)], 
                      elementsOnBoundary[\([i, 
                          1]\)]]; \[IndentingNewLine]positionNumbers = 
                    eachBoundaryElementNumberFunction /@ 
                      Range[Length[
                          elementsOnBoundary]]; \[IndentingNewLine]Return[
                    positionNumbers]\[IndentingNewLine]]; \n
              reducedListOfGeometriesMcDonald = 
                listOfGeometries3D[\([Flatten[
                      BoundaryElementNumberFunction[
                        ansisdata3D]]]\)]; \[IndentingNewLine]Return[
                reducedListOfGeometriesMcDonald]\[IndentingNewLine]]; \
\[IndentingNewLine]reducedListOfGeometries3D = 
            ReducedListOfGeometries3DFunction[listOfGeometriesMcDonald, 
              ansisdata2to3, 
              elementsOnBoundary]; \n\
\[IndentingNewLine]\[IndentingNewLine]ElementMatrixAssembleFunction[
              listOfGeometries3D_] := 
            Module[{ElementMatrixFunction, 
                ElementMatrix}, \[IndentingNewLine]\n
              ElementMatrixFunction[
                  i_] := \[IndentingNewLine]Module[{elementData, nodeNumbers, 
                    voro1, voro2, voro3, voro4, voro5, voro6, 
                    elementMatrixInner}, \[IndentingNewLine]\
\[IndentingNewLine]elementData = 
                    listOfGeometries3D[\([i]\)]; \
\[IndentingNewLine]nodeNumbers = {elementData[\([1, 1, 1]\)], 
                      elementData[\([1, 1, 2]\)], elementData[\([2, 1, 2]\)], 
                      elementData[\([3, 1, 2]\)]}; \[IndentingNewLine]voro1 = 
                    elementData[\([1, 3]\)]/elementData[\([1, 2]\)]; \n
                  voro2 = elementData[\([2, 3]\)]/elementData[\([2, 2]\)]; \n
                  voro3 = elementData[\([3, 3]\)]/elementData[\([3, 2]\)]; \n
                  voro4 = elementData[\([4, 3]\)]/elementData[\([4, 2]\)]; \n
                  voro5 = elementData[\([5, 3]\)]/elementData[\([5, 2]\)]; \n
                  voro6 = 
                    elementData[\([6, 3]\)]/
                      elementData[\([6, 
                          2]\)]; \n\[IndentingNewLine]elementMatrixInner = {{\
\(-\((voro1 + voro2 + voro3)\)\), voro1, voro2, 
                        voro3}, {voro1, \(-\((voro1 + voro4 + voro5)\)\), 
                        voro4, voro5}, {voro2, 
                        voro4, \(-\((voro2 + voro4 + voro6)\)\), 
                        voro6}, {voro3, voro5, 
                        voro6, \(-\((voro3 + voro5 + 
                              voro6)\)\)}}; \[IndentingNewLine]Return[{i, 
                      nodeNumbers, 
                      elementMatrixInner}]\[IndentingNewLine]]; \
\[IndentingNewLine]ElementMatrix = 
                ElementMatrixFunction /@ 
                  Range[Length[
                      listOfGeometries3D]]; \[IndentingNewLine]Return[
                ElementMatrix]\[IndentingNewLine]]; \
\[IndentingNewLine]elementMatrixAssemble = 
            ElementMatrixAssembleFunction[
              reducedListOfGeometries3D]; \[IndentingNewLine]\
\[IndentingNewLine]\n
          ElementCurrentFunction[concDistribution_, elementMatrix_] := 
            Module[{EachTimestepFunction, 
                EachTimestepCurrents}, \
\[IndentingNewLine]\[IndentingNewLine]EachTimestepFunction[timestep_] := 
                Module[{concDistributionOfTimestep, 
                    ElementCurrentPerTimestepFunction, 
                    elementCurrentPerTimestep}, \[IndentingNewLine]\n
                  concDistributionOfTimestep = 
                    concDistribution[\([timestep]\)]; \n
                  ElementCurrentPerTimestepFunction[elementNumber_] := 
                    Module[{nodeNumbersPerElement, 
                        elementCurrentInner}, \[IndentingNewLine]\n
                      nodeNumbersPerElement = \
\(elementMatrix[\([elementNumber]\)]\)[\([2]\)]; \n
                      elementCurrentInner = \
\((\(elementMatrix[\([elementNumber]\)]\)[\([3]\)])\) . \
\((concDistributionOfTimestep[\([nodeNumbersPerElement]\)])\); \
\[IndentingNewLine]Return[{nodeNumbersPerElement, 
                          elementCurrentInner}];\[IndentingNewLine]]; \n
                  elementCurrentPerTimestep = 
                    ElementCurrentPerTimestepFunction /@ 
                      Range[Length[elementMatrix]]; \[IndentingNewLine]Return[
                    elementCurrentPerTimestep];\[IndentingNewLine]]; \
\[IndentingNewLine]EachTimestepCurrents = 
                EachTimestepFunction /@ 
                  Range[Length[concDistribution]]; \[IndentingNewLine]Return[
                EachTimestepCurrents]\n]; \n
          ElementCurrentList = 
            ElementCurrentFunction[concDistributionSteady3DMcDonald, 
              elementMatrixAssemble]; \[IndentingNewLine]\n
          positionsOfInnerNodes = 
            Position[elementsOnBoundary[\([All, 2]\)], 
              1]; \[IndentingNewLine]\n
          CurrentPerElementandNodeFunction[i_] := 
            ElementCurrentList[\([1, positionsOfInnerNodes[\([i, 1]\)], 2, 
                positionsOfInnerNodes[\([i, 2]\)]]\)]; \n
          wholeCurrent = 
            Apply[Plus, 
              CurrentPerElementandNodeFunction /@ 
                Range[Length[positionsOfInnerNodes]]]; \[IndentingNewLine]\n
          Return[wholeCurrent]\[IndentingNewLine]];\)\)], "Input"],

Cell[BoxData[
    \(\[IndentingNewLine]\)], "Input"],

Cell[CellGroupData[{

Cell["PlotMesh (*specified *)", "Subsubsection"],

Cell[BoxData[
    \(\(PlotMesh[
          easymeshData : {nodeList : {\(({_Integer, _Real, _Real, \
_Integer})\) .. }, \[IndentingNewLine]sideList : {\(({_Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementList : {\(({_Integer, _Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, _Real, \
_Integer})\) .. }}] := \[IndentingNewLine]\[IndentingNewLine]Module[\
\[IndentingNewLine]{easymeshMeshGraphics, linienPlotFunkt, liste333, 
            voronoilinienPlotFunkt, liste222, voronoiBoundaryNodesFunction, 
            voronoiBoundaryNodes, voronoiNeighbours, 
            voronoiBoundaryPlotFunkt, voronoiBoundaryPlot, 
            delaunayBoundaryNodesFunction, 
            delaunayBoundaryNodes}, \
\[IndentingNewLine]\[IndentingNewLine]linienPlotFunkt[i_] := 
            Line[{easymeshData[\([1, easymeshData[\([2, i, 2]\)], {2, 3}]\)], 
                easymeshData[\([1, 
                    easymeshData[\([2, i, 3]\)], {2, 3}]\)]}]; \n
          liste333 = 
            linienPlotFunkt /@ 
              Range[Length[
                  easymeshData[\([2]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]Off[Part::"\<partd\>"]; \n
          voronoilinienPlotFunkt[i_] := 
            Line[{easymeshData[\([3, 
                    easymeshData[\([2, i, 4]\)], {11, 12}]\)], 
                easymeshData[\([3, 
                    easymeshData[\([2, i, 5]\)], {11, 12}]\)]}]; \n
          liste222 = 
            voronoilinienPlotFunkt /@ 
              Range[Length[
                  easymeshData[\([2]\)]]]; \[IndentingNewLine]\
\[IndentingNewLine]voronoiBoundaryNodesFunction[i_] := 
            Apply[Plus, easymeshData[\([1, i, {2, 3}]\)]]/2; \n
          voronoiBoundaryNodes = 
            voronoiBoundaryNodesFunction /@ 
              easymeshData[\([2, 
                  Flatten[
                    Position[\(Transpose[easymeshData[\([2]\)]]\)[\([5]\)], 
                      0]], {2, 3}]\)] (*randpunkte\ Voronoi*) ; \n
          voronoiNeighbours = 
            easymeshData[\([3, 
                easymeshData[\([2, 
                    Flatten[
                      Position[\(Transpose[easymeshData[\([2]\)]]\)[\([5]\)], 
                        0]], 4]\)], {11, 12}]\)]; \n
          voronoiBoundaryPlotFunkt[i_] := 
            Line[{voronoiBoundaryNodes[\([i]\)], 
                voronoiNeighbours[\([i]\)]}]; \n
          voronoiBoundaryPlot = 
            voronoiBoundaryPlotFunkt /@ 
              Range[Length[voronoiNeighbours]];  (*\ 
            Liste\ mit\ den\ zwei\ Punkten\ einer\ VoronoiRandSeite\ \
*) \[IndentingNewLine]\[IndentingNewLine]delaunayBoundaryNodesFunction[i_] := 
            Line[easymeshData[\([1, i, {2, 3}]\)]]; \n
          delaunayBoundaryNodes = 
            delaunayBoundaryNodesFunction /@ 
              Append[easymeshData[\([2, 
                    Flatten[
                      Position[\(Transpose[easymeshData[\([2]\)]]\)[\([5]\)], 
                        0]], {2, 3}]\)], 
                Flatten[
                  easymeshData[\([2, 
                      Flatten[
                        Position[\(Transpose[
                              easymeshData[\([2]\)]]\)[\([4]\)], 0]], {2, 
                        3}]\)], 
                  1]]; \[IndentingNewLine]\[IndentingNewLine]Off[
            Graphics::"\<gpt\>"]; \
\[IndentingNewLine]\[IndentingNewLine]StylePrint[
            Length[easymeshData[\([1]\)]] "\<Nodes\>", "\<Title\>"]; \
\[IndentingNewLine]\[IndentingNewLine]Show[
            Graphics[{RGBColor[0, 0, 0], liste333}, 
              PlotLabel \[Rule] "\< Delaunay mesh\>", 
              TextStyle \[Rule] {FontSize \[Rule] 16}, 
              AspectRatio \[Rule] Automatic]]; \[IndentingNewLine]\n
          Show[Graphics[{RGBColor[1, 0, 0], liste222, RGBColor[1, 0, 0], 
                voronoiBoundaryPlot, RGBColor[1, 0, 0], 
                delaunayBoundaryNodes}, PlotLabel \[Rule] "\<Voronoi mesh\>", 
              TextStyle \[Rule] {FontSize \[Rule] 16}, 
              AspectRatio \[Rule] Automatic]]; \n
          Show[Graphics[{\[IndentingNewLine]RGBColor[0, 0, 0], liste333, 
                RGBColor[1, 0, 0], liste222, RGBColor[1, 0, 0], 
                voronoiBoundaryPlot}, PlotLabel \[Rule] "\<both meshes\>", 
              TextStyle \[Rule] {FontSize \[Rule] 16}, 
              AspectRatio \[Rule] 
                Automatic]];\[IndentingNewLine]\[IndentingNewLine]];\)\)], \
"Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["CVplot   (*specified *)", "Subsubsection"],

Cell[BoxData[
    \(\(CVPlotData[\ cvStrom : {\((_Real | _Integer)\) .. }\ ] := 
        Module[{geteilt}, \[IndentingNewLine]\[IndentingNewLine]geteilt = 
            Partition[cvStrom, 
              Length[cvStrom]/
                2]; \n\[IndentingNewLine]Return[{geteilt[\([1]\)], 
              Reverse[geteilt[\([2]\)]]}];\[IndentingNewLine]\
\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["SurfacePlot   (*specified *)", "Subsubsection"],

Cell[BoxData[
    \( (*\(Needs["\<DiscreteMath`ComputationalGeometry`\>"];\)*) \)], "Input"],

Cell[BoxData[
    \(\(SurfacePlotData[
          meshData : {\[IndentingNewLine]nodeListvariable : {\(({_Integer, \
_Real, _Real, _Integer})\) .. }, \[IndentingNewLine]sideListvariable : \
{\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, \[IndentingNewLine]concDistribution : \
{{\((_Real)\) .. } .. }, 
          timestep_Integer\ ] := \[IndentingNewLine]Module[{coord, 
            data11}, \[IndentingNewLine]coord = 
            Transpose[\(Transpose[meshData[\([1]\)]]\)[\([{2, 3}]\)]]; \n
          data11 = 
            Partition[
              Flatten[Transpose[{coord, \((\(Partition[
                          100*concDistribution[\([timestep]\)], 
                          Length[coord]]\)[\([2]\)])\)}]], 
              3]; \[IndentingNewLine]Return[
            data11];\[IndentingNewLine]];\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["3Dplots   (*specified *)", "Subsubsection"],

Cell[BoxData[{
    \(\(wireFrameMesh[pointOfView_, 
          ansisdata : {n : {{_Integer, _Real, _Real, _Real, _Integer} .. }, 
              e : {{_Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer} .. }}] := 
        Module[{nodeCoordRules, 
            BCNodes}, \[IndentingNewLine]nodeCoordRules = \((\(\((Rule[#\
\[LeftDoubleBracket]1\[RightDoubleBracket], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]3\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket]}])\) &\) /@ 
                n)\); \[IndentingNewLine]BCNodes = \(Point[#] &\) /@ \
\((\(Drop[#, 1] &\) /@ \((\(Drop[#, \(-1\)] &\) /@ 
                      Select[n, \((#\[LeftDoubleBracket]\(-1\)\
\[RightDoubleBracket] > 
                              0)\) &])\))\); \
\[IndentingNewLine]Graphics3D[{PointSize[ .02], \((\(Line[
                        Join[Drop[#, {1, 6, 
                              5}], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]3\[RightDoubleBracket], #\[LeftDoubleBracket]5\
\[RightDoubleBracket]}]] &\) /@ e)\) /. nodeCoordRules, RGBColor[1, 0, 0], 
              BCNodes}, pointOfView, Boxed \[Rule] False, Axes \[Rule] True, 
            PlotRange \[Rule] 
              All]\[IndentingNewLine]];\)\), "\[IndentingNewLine]", 
    \(\(WireFrameMeshWithBCNodes[pointOfView_, tetgenData_] := 
        Module[{}, << Default3D`; 
          wireFrameMesh[pointOfView, tetgenData] // 
            Show;];\)\[IndentingNewLine]\), "\[IndentingNewLine]", 
    \(\(WireFrameMeshWitRotation[pointOfView_, tetgenData_] := 
        Module[{}, << RealTime3D`; 
          wireFrameMesh[pointOfView, tetgenData] // 
            Show;];\)\), "\[IndentingNewLine]", 
    \(\)}], "Input"],

Cell["\<\
\"wireFrameMeshold\" to be used for the Ansys datastructure as used \
befor.\
\>", "Text"],

Cell[BoxData[{
    \(\(\(wireFrameMeshold[pointOfView_, 
          ansisdata : {n : {{_Integer, _Real, _Real, _Real, _Integer} .. }, 
              e : {{_Integer, _Integer, _Integer, _Integer, _Integer, \
_Integer} .. }}] := 
        Module[{nodeCoordRules, 
            BCNodes}, \[IndentingNewLine]nodeCoordRules = \((\(\((Rule[#\
\[LeftDoubleBracket]1\[RightDoubleBracket], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]3\[RightDoubleBracket], #\
\[LeftDoubleBracket]4\[RightDoubleBracket]}])\) &\) /@ 
                n)\); \[IndentingNewLine]BCNodes = \(Point[#] &\) /@ \
\((\(Drop[#, 1] &\) /@ \((\(Drop[#, \(-1\)] &\) /@ 
                      Select[n, \((#\[LeftDoubleBracket]\(-1\)\
\[RightDoubleBracket] > 
                              0)\) &])\))\); \
\[IndentingNewLine]Graphics3D[{PointSize[ .02], \((\(Line[
                        Join[Drop[#, {1, 6, 
                              5}], {#\[LeftDoubleBracket]2\
\[RightDoubleBracket], #\[LeftDoubleBracket]4\[RightDoubleBracket], #\
\[LeftDoubleBracket]3\[RightDoubleBracket], #\[LeftDoubleBracket]5\
\[RightDoubleBracket]}]] &\) /@ e)\) /. nodeCoordRules, RGBColor[1, 0, 0], 
              BCNodes}, pointOfView, Boxed \[Rule] False, Axes \[Rule] True, 
            PlotRange \[Rule] 
              All]\[IndentingNewLine]];\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(\(WireFrameMeshWithBCNodesold[pointOfView_, tetgenData_] := 
        Module[{}, << Default3D`; 
          wireFrameMeshold[pointOfView, tetgenData] // 
            Show;];\)\(\[IndentingNewLine]\)
    \)\), "\[IndentingNewLine]", 
    \(\(WireFrameMeshWitRotationold[pointOfView_, tetgenData_] := 
        Module[{}, << RealTime3D`; 
          wireFrameMeshold[pointOfView, tetgenData] // Show;];\)\)}], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["Feldplot    (*specified *)", "Subsubsection"],

Cell[BoxData[
    \(\(Feldplot[
          meshData : {\[IndentingNewLine]nodeListvariable : {\(({_Integer, \
_Real, _Real, _Integer})\) .. }, \[IndentingNewLine]sideListvariable : \
{\(({_Integer, _Integer, _Integer, _Integer, _Integer, _Integer})\) .. }, \
\[IndentingNewLine]elementListvariable : {\(({_Integer, _Integer, _Integer, \
_Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Integer, _Real, \
_Real, _Integer})\) .. }}, concDistribution : {{\((_Real)\) .. } .. }, 
          plotFrequency_Integer] := 
        Module[{coord, ele, v, vals}, \[IndentingNewLine]coord = 
            Transpose[\(Transpose[meshData[\([1]\)]]\)[\([{2, 3}]\)]]; \n
          ele = Transpose[\(Transpose[
                  meshData[\([3]\)]]\)[\([{2, 3, 4}]\)]]; \n
          For[v = 1, v \[LessEqual] Length[concDistribution], 
            v += plotFrequency, \[IndentingNewLine]vals = \(Partition[
                    concDistribution[\([v]\)], 
                    Length[coord]]\)[\([1 (*gibt\ die\ Nummer\ der\ \
Spezie*) ]\)]* .87; \[IndentingNewLine]Show[
              Graphics[
                Transpose[{Map[GrayLevel, 
                      Map[\((vals[\([#[\([1]\)]]\)] + 
                                vals[\([#[\([2]\)]]\)] + 
                                vals[\([#[\([3]\)]]\)])\)/3.  &, ele]], \n
                    Map[Polygon, 
                      Map[{coord[\([#[\([1]\)]]\)], coord[\([#[\([2]\)]]\)], 
                            coord[\([#[\([3]\)]]\)]} &, ele]]}], 
                AspectRatio \[Rule] 
                  Automatic]]\[IndentingNewLine]];\[IndentingNewLine]];\)\)], \
"Input"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{

Cell["Representors", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(\( (*\ representors\ *) \)\(\[IndentingNewLine]\)\)\)], "Input"]
}, Closed]],

Cell[CellGroupData[{

Cell["End Private", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(\(End[]\)\(\ \)\( (*\ of\ Begin\ Private\ *) \)\)\)], "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["End Package", "Section",
  InitializationCell->True],

Cell[BoxData[
    \(\(\( (*\ 
      Protect[]\  (*\ 
        anything\ *) \ *) \)\(\[IndentingNewLine]\)\(\(EndPackage[]\)\(\ \)\(\
\n\)
    \)\)\)], "Input",
  InitializationCell->True]
}, Closed]]
}, Open  ]]
},
FrontEndVersion->"5.0 for X",
ScreenRectangle->{{0, 1024}, {0, 768}},
AutoGeneratedPackage->Automatic,
WindowSize->{983, 715},
WindowMargins->{{Automatic, 10}, {0, Automatic}},
PrintingPageRange->{Automatic, Automatic},
PrintingOptions->{"PaperSize"->{597.562, 842.375},
"PaperOrientation"->"Portrait",
"PostScriptOutputFile":>FrontEnd`FileName[{$RootDirectory, "home", "koziol", \
"privat", "math", "1linear"}, "SECMnew4.nb.ps", CharacterEncoding -> \
"iso8859-1"],
"Magnification"->1},
Magnification->1
]

(*******************************************************************
Cached data follows.  If you edit this Notebook file directly, not
using Mathematica, you must remove the line containing CacheID at
the top of  the file.  The cache data will then be recreated when
you save this file from within Mathematica.
*******************************************************************)

(*CellTagsOutline
CellTagsIndex->{}
*)

(*CellTagsIndex
CellTagsIndex->{}
*)

(*NotebookFileOutline
Notebook[{

Cell[CellGroupData[{
Cell[1776, 53, 32, 0, 51, "Subtitle"],

Cell[CellGroupData[{
Cell[1833, 57, 59, 1, 74, "Section",
  InitializationCell->True],
Cell[1895, 60, 1202, 20, 299, "Input",
  InitializationCell->True],
Cell[3100, 82, 115, 2, 27, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[3252, 89, 60, 1, 44, "Section",
  InitializationCell->True],
Cell[3315, 92, 113, 2, 27, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[3465, 99, 80, 1, 44, "Section",
  InitializationCell->True],

Cell[CellGroupData[{
Cell[3570, 104, 54, 1, 38, "Subsection",
  InitializationCell->True],
Cell[3627, 107, 26958, 410, 5259, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[30622, 522, 34, 0, 30, "Subsection"],
Cell[30659, 524, 281, 7, 59, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[30977, 536, 36, 0, 30, "Subsection"],
Cell[31016, 538, 143, 2, 59, "Input"]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[31208, 546, 58, 1, 44, "Section",
  InitializationCell->True],
Cell[31269, 549, 940, 19, 219, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[32246, 573, 60, 1, 44, "Section",
  InitializationCell->True],
Cell[32309, 576, 88, 2, 27, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[32434, 583, 42, 0, 44, "Section"],
Cell[32479, 585, 270, 4, 59, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[32786, 594, 54, 1, 44, "Section",
  InitializationCell->True],
Cell[32843, 597, 301, 6, 75, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[33181, 608, 27, 0, 44, "Section"],
Cell[33211, 610, 413, 8, 59, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[33661, 623, 29, 0, 44, "Section"],
Cell[33693, 625, 112, 2, 43, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[33842, 632, 56, 1, 44, "Section",
  InitializationCell->True],

Cell[CellGroupData[{
Cell[33923, 637, 60, 0, 38, "Subsection"],
Cell[33986, 639, 2677, 53, 651, "Input",
  InitializationCell->True],
Cell[36666, 694, 7414, 144, 1483, "Input"],
Cell[44083, 840, 7176, 139, 1467, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[51296, 984, 48, 0, 30, "Subsection"],
Cell[51347, 986, 4766, 103, 283, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[56150, 1094, 77, 1, 30, "Subsection",
  InitializationCell->True],
Cell[56230, 1097, 83, 2, 27, "Input",
  InitializationCell->True],
Cell[56316, 1101, 2876, 56, 827, "Input",
  InitializationCell->True],
Cell[59195, 1159, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[59284, 1165, 94, 3, 30, "Subsection"],
Cell[59381, 1170, 6170, 100, 939, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[65588, 1275, 131, 4, 30, "Subsection",
  InitializationCell->True],
Cell[65722, 1281, 18185, 317, 2571, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[83944, 1603, 127, 4, 30, "Subsection",
  InitializationCell->True],
Cell[84074, 1609, 19514, 335, 2859, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[103625, 1949, 112, 2, 30, "Subsection",
  InitializationCell->True],
Cell[103740, 1953, 284, 6, 50, "Text",
  InitializationCell->True],
Cell[104027, 1961, 9323, 176, 1659, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[113387, 2142, 102, 1, 30, "Subsection",
  InitializationCell->True],
Cell[113492, 2145, 3548, 66, 747, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[117077, 2216, 76, 0, 30, "Subsection"],
Cell[117156, 2218, 3575, 65, 747, "Input"],
Cell[120734, 2285, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[120823, 2291, 104, 1, 30, "Subsection",
  InitializationCell->True],
Cell[120930, 2294, 19644, 336, 2811, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[140611, 2635, 106, 1, 30, "Subsection",
  InitializationCell->True],
Cell[140720, 2638, 18384, 319, 2555, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[159141, 2962, 105, 1, 30, "Subsection",
  InitializationCell->True],
Cell[159249, 2965, 284, 6, 50, "Text",
  InitializationCell->True],
Cell[159536, 2973, 9346, 176, 1643, "Input",
  InitializationCell->True],
Cell[168885, 3151, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[168974, 3157, 79, 1, 30, "Subsection",
  InitializationCell->True],
Cell[169056, 3160, 1033, 17, 283, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[170126, 3182, 82, 1, 30, "Subsection",
  InitializationCell->True],
Cell[170211, 3185, 1423, 25, 395, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[171671, 3215, 88, 1, 30, "Subsection",
  InitializationCell->True],
Cell[171762, 3218, 1210, 20, 299, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[173009, 3243, 91, 1, 30, "Subsection",
  InitializationCell->True],
Cell[173103, 3246, 1331, 23, 331, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[174471, 3274, 112, 2, 30, "Subsection",
  InitializationCell->True],
Cell[174586, 3278, 22097, 370, 2747, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[196720, 3653, 105, 1, 30, "Subsection",
  InitializationCell->True],
Cell[196828, 3656, 3803, 66, 795, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[200668, 3727, 95, 3, 30, "Subsection"],
Cell[200766, 3732, 18316, 333, 3179, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[219119, 4070, 107, 1, 30, "Subsection",
  InitializationCell->True],
Cell[219229, 4073, 21753, 403, 3451, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[241019, 4481, 66, 0, 30, "Subsection"],
Cell[241088, 4483, 2979, 50, 443, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[244104, 4538, 82, 1, 30, "Subsection",
  InitializationCell->True],
Cell[244189, 4541, 3402, 61, 747, "Input",
  InitializationCell->True],
Cell[247594, 4604, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[247683, 4610, 46, 0, 30, "Subsection"],
Cell[247732, 4612, 13264, 213, 1819, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[261033, 4830, 46, 0, 30, "Subsection"],
Cell[261082, 4832, 13201, 212, 1819, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[274320, 5049, 74, 1, 30, "Subsection",
  InitializationCell->True],
Cell[274397, 5052, 13292, 214, 1819, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[287726, 5271, 135, 4, 30, "Subsection",
  InitializationCell->True],
Cell[287864, 5277, 17206, 313, 2011, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[305107, 5595, 77, 0, 30, "Subsection"],
Cell[305187, 5597, 18650, 337, 3115, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[323874, 5939, 77, 0, 30, "Subsection"],
Cell[323954, 5941, 18235, 330, 2987, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[342226, 6276, 125, 4, 30, "Subsection",
  InitializationCell->True],
Cell[342354, 6282, 21566, 393, 3371, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[363957, 6680, 90, 1, 30, "Subsection",
  InitializationCell->True],
Cell[364050, 6683, 3439, 61, 747, "Input",
  InitializationCell->True],
Cell[367492, 6746, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[367581, 6752, 104, 1, 30, "Subsection",
  InitializationCell->True],
Cell[367688, 6755, 704, 13, 187, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[368429, 6773, 101, 1, 30, "Subsection",
  InitializationCell->True],
Cell[368533, 6776, 991, 18, 203, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[369561, 6799, 66, 0, 30, "Subsection"],
Cell[369630, 6801, 1546, 28, 283, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[371213, 6834, 103, 1, 30, "Subsection",
  InitializationCell->True],
Cell[371319, 6837, 1976, 35, 379, "Input",
  InitializationCell->True],
Cell[373298, 6874, 52, 1, 43, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[373387, 6880, 95, 1, 30, "Subsection",
  InitializationCell->True],
Cell[373485, 6883, 3587, 67, 539, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[377109, 6955, 136, 4, 30, "Subsection",
  InitializationCell->True],
Cell[377248, 6961, 1327, 24, 299, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[378612, 6990, 87, 1, 30, "Subsection",
  InitializationCell->True],
Cell[378702, 6993, 11961, 209, 1643, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[390700, 7207, 73, 1, 30, "Subsection",
  InitializationCell->True],
Cell[390776, 7210, 1070, 18, 107, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[391883, 7233, 77, 1, 30, "Subsection",
  InitializationCell->True],
Cell[391963, 7236, 7690, 140, 1451, "Input",
  InitializationCell->True],
Cell[399656, 7378, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[399745, 7384, 68, 1, 30, "Subsection",
  InitializationCell->True],
Cell[399816, 7387, 1800, 34, 203, "Input",
  InitializationCell->True],
Cell[401619, 7423, 1204, 22, 139, "Input"],

Cell[CellGroupData[{
Cell[402848, 7449, 48, 0, 28, "Subsubsection"],
Cell[402899, 7451, 4525, 88, 763, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[407461, 7544, 80, 1, 28, "Subsubsection",
  InitializationCell->True],
Cell[407544, 7547, 414, 8, 123, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[407995, 7560, 89, 1, 28, "Subsubsection",
  InitializationCell->True],
Cell[408087, 7563, 488, 9, 107, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[408612, 7577, 81, 1, 28, "Subsubsection",
  InitializationCell->True],
Cell[408696, 7580, 92, 1, 27, "Input"],
Cell[408791, 7583, 1059, 19, 187, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[409887, 7607, 77, 1, 28, "Subsubsection",
  InitializationCell->True],
Cell[409967, 7610, 1800, 32, 235, "Input",
  InitializationCell->True],
Cell[411770, 7644, 100, 3, 32, "Text"],
Cell[411873, 7649, 1785, 32, 251, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[413695, 7686, 79, 1, 28, "Subsubsection",
  InitializationCell->True],
Cell[413777, 7689, 1647, 29, 251, "Input",
  InitializationCell->True]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[415485, 7725, 55, 0, 44, "Section"],

Cell[CellGroupData[{
Cell[415565, 7729, 60, 0, 38, "Subsection"],
Cell[415628, 7731, 2649, 52, 651, "Input"],
Cell[418280, 7785, 7414, 144, 1483, "Input"],
Cell[425697, 7931, 7148, 138, 1467, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[432882, 8074, 48, 0, 30, "Subsection"],
Cell[432933, 8076, 4741, 102, 267, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[437711, 8183, 49, 0, 30, "Subsection"],
Cell[437763, 8185, 55, 1, 27, "Input"],
Cell[437821, 8188, 2848, 55, 827, "Input"],
Cell[440672, 8245, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[440761, 8251, 94, 3, 30, "Subsection"],
Cell[440858, 8256, 6142, 99, 939, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[447037, 8360, 103, 3, 30, "Subsection"],
Cell[447143, 8365, 18157, 316, 2571, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[465337, 8686, 99, 3, 30, "Subsection"],
Cell[465439, 8691, 19486, 334, 2859, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[484962, 9030, 84, 1, 30, "Subsection"],
Cell[485049, 9033, 256, 5, 50, "Text"],
Cell[485308, 9040, 9295, 175, 1659, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[494640, 9220, 74, 0, 30, "Subsection"],
Cell[494717, 9222, 3520, 65, 747, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[498274, 9292, 76, 0, 30, "Subsection"],
Cell[498353, 9294, 3575, 65, 747, "Input"],
Cell[501931, 9361, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[502020, 9367, 76, 0, 30, "Subsection"],
Cell[502099, 9369, 19617, 336, 2811, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[521753, 9710, 78, 0, 30, "Subsection"],
Cell[521834, 9712, 18356, 318, 2555, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[540227, 10035, 77, 0, 30, "Subsection"],
Cell[540307, 10037, 256, 5, 50, "Text"],
Cell[540566, 10044, 9318, 175, 1643, "Input"],
Cell[549887, 10221, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[549976, 10227, 51, 0, 30, "Subsection"],
Cell[550030, 10229, 1005, 16, 283, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[551072, 10250, 54, 0, 30, "Subsection"],
Cell[551129, 10252, 1395, 24, 395, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[552561, 10281, 60, 0, 30, "Subsection"],
Cell[552624, 10283, 1069, 17, 283, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[553730, 10305, 63, 0, 30, "Subsection"],
Cell[553796, 10307, 1294, 22, 331, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[555127, 10334, 84, 1, 30, "Subsection"],
Cell[555214, 10337, 22069, 369, 2667, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[577320, 10711, 77, 0, 30, "Subsection"],
Cell[577400, 10713, 3775, 65, 795, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[581212, 10783, 95, 3, 30, "Subsection"],
Cell[581310, 10788, 18288, 332, 3179, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[599635, 11125, 79, 0, 30, "Subsection"],
Cell[599717, 11127, 21725, 402, 3451, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[621479, 11534, 66, 0, 30, "Subsection"],
Cell[621548, 11536, 2951, 49, 443, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[624536, 11590, 54, 0, 30, "Subsection"],
Cell[624593, 11592, 3374, 60, 747, "Input"],
Cell[627970, 11654, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[628059, 11660, 46, 0, 30, "Subsection"],
Cell[628108, 11662, 13264, 213, 1819, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[641409, 11880, 77, 0, 30, "Subsection"],
Cell[641489, 11882, 18280, 332, 3003, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[659806, 12219, 97, 3, 30, "Subsection"],
Cell[659906, 12224, 21538, 392, 3387, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[681481, 12621, 62, 0, 30, "Subsection"],
Cell[681546, 12623, 3411, 60, 747, "Input"],
Cell[684960, 12685, 52, 1, 40, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[685049, 12691, 76, 0, 30, "Subsection"],
Cell[685128, 12693, 676, 12, 187, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[685841, 12710, 73, 0, 30, "Subsection"],
Cell[685917, 12712, 963, 17, 203, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[686917, 12734, 66, 0, 30, "Subsection"],
Cell[686986, 12736, 1518, 27, 283, "Input"],
Cell[688507, 12765, 52, 1, 43, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[688596, 12771, 67, 0, 30, "Subsection"],
Cell[688666, 12773, 3559, 66, 539, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[692262, 12844, 108, 3, 30, "Subsection"],
Cell[692373, 12849, 1297, 22, 299, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[693707, 12876, 59, 0, 30, "Subsection"],
Cell[693769, 12878, 11444, 198, 1643, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[705250, 13081, 49, 0, 30, "Subsection"],
Cell[705302, 13083, 7662, 139, 1451, "Input"],
Cell[712967, 13224, 52, 1, 40, "Input"],

Cell[CellGroupData[{
Cell[713044, 13229, 48, 0, 42, "Subsubsection"],
Cell[713095, 13231, 4497, 87, 763, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[717629, 13323, 48, 0, 28, "Subsubsection"],
Cell[717680, 13325, 386, 7, 123, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[718103, 13337, 53, 0, 28, "Subsubsection"],
Cell[718159, 13339, 92, 1, 27, "Input"],
Cell[718254, 13342, 1031, 18, 187, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[719322, 13365, 49, 0, 28, "Subsubsection"],
Cell[719374, 13367, 1783, 32, 251, "Input"],
Cell[721160, 13401, 100, 3, 32, "Text"],
Cell[721263, 13406, 1796, 32, 251, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[723096, 13443, 51, 0, 28, "Subsubsection"],
Cell[723150, 13445, 1619, 28, 251, "Input"]
}, Closed]]
}, Closed]]
}, Closed]],

Cell[CellGroupData[{
Cell[724830, 13480, 59, 1, 44, "Section",
  InitializationCell->True],
Cell[724892, 13483, 86, 1, 43, "Input"]
}, Closed]],

Cell[CellGroupData[{
Cell[725015, 13489, 58, 1, 44, "Section",
  InitializationCell->True],
Cell[725076, 13492, 112, 2, 27, "Input",
  InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{
Cell[725225, 13499, 58, 1, 44, "Section",
  InitializationCell->True],
Cell[725286, 13502, 186, 6, 59, "Input",
  InitializationCell->True]
}, Closed]]
}, Open  ]]
}
]
*)



(*******************************************************************
End of Mathematica Notebook file.
*******************************************************************)

