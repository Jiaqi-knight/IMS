(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: Line.m *)
(* Context: *)
(* Author:Jan G. Korvink *)
(* 
  Date: 12.02.2005, Karlsruhe *)
(* 
  Summary: This emulates a semiconductor Process*)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.1.1 *)
(* 
  Mathematica Version: 5.1 *)
(* History: *)
(* Keywords: *)
(* Sources: *)
(* 
  Warnings: *)
(* Limitations: *)
(* Discussion: *)
(* Requirements: *)
(* 
  Examples: *)
(* *)



(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* <one line to give the program's name and a brief idea of what it does.> *)
\

(* Copyright (C) <year> <name of author> *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)



(* Start Package *)
BeginPackage["Imtek`ProcessEmulate`"];





(* *)
(* documentation *)
(* *)

(* constructors *)

imsMakeStack::usage="imsMakeStack[ stack , lateralsize ] creates a layer layer stack based on the stack specification. The stack is a list of lists, whereby the inner list(s) contain a data pair of material head and layer thickness. Any number of material layers can be specified. The lateral size is specified in 2D by a pair of numbers { deltaX , nX } that characterize the lateral regular discretization of each layer into nX segments of size deltaX. In 3D two pairs of numbers { { deltaX , nX } , { deltaY , nY } } are required. The horizontal raster determines the accuracy of subsequent processing. Also see Stack and imsStackDraw.";

imsStack::usage="imsStack[ layers , lateralsize ] is a representation for a semiconductor processed material stack. Each layer consists of a material name as the head, and a list of number pairs { height , thickness } in a 1D or 2D array, for 2D or 3D processing, that describe the upper profile and the thickness profile of the material. The lateral size is specified in 2D by a pair of numbers { deltaX , nX } that characterize the lateral regular discretization of each layer into nX segments of size deltaX. In 3D two pairs of numbers { { deltaX , nX } , { deltaY , nY } } are required. Also see imsMakeStack, imsStackDraw and imsStackProcess.";

(* functions *)

imsStackProcess::usage="imsStackProcess[ processsteps , imsStack ] applies a list of process steps to the layer stack. One or more of the following process steps can be applied in any order and as often as required: imsDeposit, imsPattern, imsReflow, imsStrip, imsDrill, imsMill, imsPlanarize, imsErode, imsEmboss, imsWetEtch, imsGrow, imsCut, imsBond, imsFlip, imsRotate, imsDispense. A step is specified by a list containing the step specification followed by the step's parameters, e.g. { imsDeposit , imsSilicon, 10 } specifies the deposition of a 10 unit thick layer of silicon. All steps are individually available as separate functions, and take exactly the same parameters as the functions E.g., for imsDeposit, see the function imsStackDeposit. Also see imsStack, imsMakeStack and imsStackDraw.";

imsStackDraw::usage="imsStackDraw[ imsStack ] creates a Graphics or Graphics3D picture of the stack. imsStackDraw[ {imsStack..} ] returns a GraphicsArray object. The picture is controlled by options. Each known layer is assigned a color. An alternative coloring scheme can be provided by defining imsLayerColorRules={myLayerHead:>myColorDirective,...}. In addition, the material layers can be outlined by specifying imsOutlineColor\[RuleDelayed]myColor where myColor is a color directive. To draw only a subset of the layer stack, specify imsCellRange->{i,j} for 2D or imsCellRange->{{i,j},{k,l}} for 3D layer stacks. Also see imsMakeStack and imsStackProcess.";

imsMaskDraw::usage="imsMaskDraw[ mask , { delta , n } , vc ] and imsMaskDraw[ mask , { { deltaX , nX } , { deltaY , nY } } , vc ] draws a series of horizontal line segments or polygons to represent a mask. The segments are placed at the given vertical coordinate value vc, so as to be conveniently combined with other graphics.";

imsStackDeposit::usage="imsStackDeposit[ imsStack , material , thickness ] adds a new material layer with the specified thickness on top of the layer stack. The layer is anisotropically shaped from the vertical direction. Its shape follows the shape of the layer immediately preceding it on the layer stack. Also see imsStackReflow, imsStackPattern, imsStackStrip and imsStackProcess.";

imsStackPattern::usage="imsStackPattern[ imsStack , material , thickness , mask , field ] patterns the top material layer of the layer stack. The layer is anisotropically thinned from above in the vertical direction. It will only be shaped down to the layer immediately preceding it on the layer stack. In this sense one can underetch and overetch without affecting the other layers. The mask and the field variable specify where the thickness shaping should be done. The mask is a 1D list of True/False entries. If field==True, then the layer is shaped at positions where the mask holds True entries, and vice versa. Also see imsStackReflow, imsStackStrip, imsStackDeposit and imsStackProcess.";

imsStackStrip::usage="imsStackStrip[ imsStack , material ] completely removes a layer from the material stack. A gap is left in the stack, so that this step represents a typical sacrificial etch step as used in MST processes. Also see imsStackReflow, imsStackPattern, imsStackDeposit and imsStackProcess.";\


imsStackReflow::usage="imsStackReflow[ imsStack , material ] smoothens the surface of a layer, as during thermal reflow treatment. Also see imsStackStrip, imsStackPattern, imsStackDeposit and imsStackProcess.";\


imsStackDrill::usage="imsStackDrill[ ls , holes ] drills holes into the layer stack. Each hole is specified as a list consisting of coordinates, the hole diameter and the hole depth: { {x,y,depth}, diameter}. Any number of holes can be specified.";\


imsStackMill::usage="imsStackMill[ ls , millpaths ] mills, using a vertical milling tool, along paths into the layer stack. Each path consists of a list with a 3D line specification and a milling tool diameter: { {{x1,y2,z3}, ..., {xn,yn,zy}}, diameter}";\


imsStackPlanarize::usage="imsStackPlanarize[ ls , height ] emulates the action of lapping and chemical-mechanical polishing (CMP). Any feature on any layer in the stack is chopped to the specified height. Any empty upper layer is stripped from the stack.";\


imsStackErode::usage="imsStackErode[ ls , mask , field , height ] emulates the action of electrical discharge milling. All positions in mask that corresponds to field are chopped to the specified height.";\


imsStackEmboss::usage="imsStackEmboss[ ls , material , thickness ] emulates the action of hot embossing. The material of specified thickness is pressed onto the layer stack. If the thickness is insufficient for embossing, the height is automatically adjusted. Note that the new layer stack is returned with its embossed surface pointing down.";\


imsStackWetEtch::usage=
    "imsStackWetEtch[ ls , material , depth ] emulates the behaviour of wet etching processes such as Silicon in KOH. Its behaviour can be controlled using specified options. The default imsMethod is imsKOH.";\


imsStackGrow::usage="imsStackGrow[ ls , attackMaterial->growMaterial , { tgrow , tconsume , wcovered } ] emulates the action of thermal oxidation. An exposed material is partially consumed to produce a new material. The new material has a thickness of tgrow. The consumed material loses tconsume in thickness. At covered edges, there is a smooth transition from zero thickness to tgrow.";\


imsStackToNexus::usage="imsStackToNexus[ ls ] generates an imsGraph of the layer stack suitable for finite element modelling.";\


imsStackToDomainNexus::usage="imsStackToDomainNexus[ ls ] generates an imsGraph of the layer stack boundaries suitable for mesh generators.";\


imsStackCut::usage="imsStackCut[ ls , position ] divides the layer stack into two pieces at the indicated cell position. The position must lie in the range {2,...,n-1}, where n is the cell width of the layer stack.";\


imsStackFlip::usage="imsStackFlip[ ls ] flips the layer stack over. In 3D we may select the flip axis.";\


imsStackRotate::usage="imsStackFlip[ ls ] a 2D layer by 180 degrees and a 3D stack by 90 degrees about the vertical axis.";\


imsStackBond::usage="imsStackFlip[ lsBottom , lsTop ] glues the second stack on top of the first stack only if they have the same width and number of cells. A single stack is returned.";\


imsGraphicsToBitMask::usage="imsGraphicsToBitMask[ g , \[Delta] ] creates a planar imsBitMask from the planar graphics picture g. The pixel edge length is specified by \[Delta].";\


imsGraphics3DToBitMask::usage="imsGraphics3DToBitMask[ g , \[Delta] ] creates a planar imsBitMask from the 3d graphics picture g. The pixel edge length is specified by \[Delta].";\


imsBitMaskQ::usage="imsBitMaskQ[ m ] returns True if m is a valid mask.";

imsBitMaskDimensions::usage="imsBitMaskDimensions[ m ] returns the lateral array dimensions of the bitmask m.";\


imsStackQ::usage="imsStackQ[ ls ] returns True if ls is a valid layer stack.";\


imsStackDepth::usage="imsStackDepth[ ls ] returns the number of layers in the layer stack ls.";\


imsStackLayers::usage="imsStackLayers[ ls ] returns the list of layers of the layer stack ls.";\


imsStackDimensions::usage="imsStackDimensions[ ls ] returns the lateral array dimensions of the layer stack ls.";\


imsStackSize::usage="imsStackSize[ ls ] returns the lateral size(s) (length) of the layer stack.";\


imsStackMaterials::usage="imsStackMaterials[ ls ] returns the materials used in the layer stack in the order of the layers. Duplicate materials in the stack appear duplicated in the list.";

imsAluminium::usage="Predefined material layer imsAluminium for imsStack processing.";\

imsCopper::usage="Predefined material layer imsCopper for imsStack processing.";\

imsGap::usage="Predefined stripped material placeholder for imsStack processing.";\

imsGold::usage="Predefined material layer imsGold for imsStack processing.";
imsKOH::usage="Predefined etchant imsKOH for imsStack processing";
imsNickel::usage="Predefined material layer imsNickel for imsStack processing.";\

imsPolySilicon::usage="Predefined material layer imsPolySilicon for imsStack processing.";\

imsSilicon::usage="Predefined material layer imsSilicon for imsStack processing.";\

imsSiliconNitride::usage="Predefined material layer imsSiliconNitride for imsStack processing.";\

imsSiliconOxide::usage="Predefined material layer imsSiliconOxide for imsStack processing.";\

imsSU8::usage="Predefined material layer imsSU8 for imsStack processing.";
imsTiNi::usage="Predefined material layer imsTiNi for imsStack processing.";
imsTitanium::usage="Predefined material layer imsTitanium for imsStack processing.";\

imsZinc::usage="Predefined material layer imsZinc for imsStack processing.";

imsBitMask::usage="imsBitMask[ ( True | False ) .. ] and imsBitMask[ { ( True | False ) .. } .. ] are boolean 1D or 2D arrays. Bit masks can be used as if with a light-field or a dark-field resist, specified when using the mask by selecting to pattern (etch) the True or False areas. Currently a bitmask must have the same dimensions as the layer stack it is used with.";\


imsDeposit::usage="imsDeposit is a symbol to select imsStack deposition. For the required parameters, see imsStackDeposit.";\

imsPattern::usage="imsPattern is a symbol to select imsStack patterning. For the required parameters, see imsStackPattern.";\

imsReflow::usage="imsReflow is a symbol to select imsStack thermal reflow. For the required parameters, see imsStackReflow.";\

imsStrip::usage="imsStrip is a symbol to select imsStack material stripping. For the required parameters, see imsStackStrip.";\

imsDrill::usage="imsDrill is a symbol to select imsStack hole drilling. For the required parameters, see imsStackDrill.";\

imsMill::usage="imsMill is a symbol to select imsStack milling. For the required parameters, see imsStackMill.";\

imsPlanarize::usage="imsPlanarize is a symbol to select imsStack planarizing. For the required parameters, see imsStackPlanarize.";\

imsErode::usage="imsErode is a symbol to select imsStack eroding. For the required parameters, see imsStackErode.";\

imsEmboss::usage="imsEmboss is a symbol to select imsStack embossing. For the required parameters, see imsStackEmboss.";\

imsWetEtch::usage="imsWetEtch is a symbol to select imsStack wet etching. For the required parameters, see imsStackWetEtch.";\

imsGrow::usage="imsGrow is a symbol to select imsStack layer growing. For the required parameters, see imsStackGrow.";\

imsCut::usage="imsCut is a symbol to select imsStack cutting. For the required parameters, see imsStackCut.";\

imsBond::usage="imsBond is a symbol to select imsStack bonding of one layer stack to another. For the required parameters, see imsStackBond.";\

imsFlip::usage="imsFlip is a symbol to select imsStack upside down flipping. For the required parameters, see imsStackFlip.";\

imsRotate::usage="imsRotate is a symbol to select imsStack rotation about the z axis. For the required parameters, see imsStackRotate.";\

imsDispense::usage="imsDispense is a symbol to select imsStack droplet dispensing. For the required parameters, see imsDispenseStack.";\







(* MyOption::usage =
      "MyOption -> value is an option of NameOfYourFunction1 that [...] "; *)

imsLayerColorRules::usage="imsLayerColorRules -> { materialtag :> colordirective ...} specifies the colour that a material layer will be rendered. The default value for the imsLayerColorRules list is: imsLayerColorRules -> { imsSilicon :> RGBColor[0.439207`,0.501999`,0.564699`],imsPolySilicon :> RGBColor[0.415693`,0.352901`,0.803903`],imsAluminium :> RGBColor[0.990005`,1.`,0.940001`] , imsSiliconOxide :> RGBColor[0.640004`,0.580004`,0.5`] , imsSiliconNitride :> RGBColor[0.5`,0.5`,0.410001`] , imsCopper :> RGBColor[1.`,0.898053`,0.771844`] , imsGold :> RGBColor[1.`,0.843104`,0.`] , imsTitanium :> RGBColor[0.990005`,1.`,0.940001`] , imsZinc :> RGBColor[0.990005`,0.97`,1.`] , imsSU8 :> RGBColor[0.6039`,0.803903`,0.196097`] } ";\

imsOutlineColor::usage="imsOutlineColor -> Colour will cause imsStackDraw to draw a coloured outline for each material in the imsStack in the specified colour. You can use any correct colour specification, such as Hue, CMYKColor, GrayLevel or RGBColor.";\

imsMethod::usage="imsMethod -> imsAnisotropic is an option of both imsStackDeposit and imsStackPattern to affect the way in which layers are modified. Currently it has no special effect.";\

imsAngle::usage="imsAngle -> value is an option of both imsStackDeposit and imsStackPattern with which to specify the angle of deposition or etching. Currently it has no effect.";\

imsTransition::usage="imsTransition -> Ramp is a specification of imsStackPattern to affect the way in which a step is covered. Currently it has no effect.";\

imsShowAllSteps::usage="imsShowAllSteps -> True will cause imsStackProcess[..] to return the stack for each intermediate process step. This is useful for didactic purposes when explaining process sequences.";\

imsConformal::usage="imsMethod -> imsConformal selects a conformal growth algorithm for layer deposition.";\

imsAnisotropic::usage="imsMethod -> imsAnisotropic selects an anisotropic growth algorithm for layer deposition.";\

imsCellRange::usage="imsCellRange -> All selects the entire stack. imsCellRange->{i,j} selects the 2D stack cells ranging from i to j. imsCellRange->{{i,j},{l,m}} selects a range of stack cells from a 3D stack.";\

(*
  imsConvert::usage=
      "imsConvert->convert specifies the path to the executable binary file convert, a renderer which is used to generate accurate bitmaps from postscript files.";\

  *)



(* *)
(* Error and Warning Messages *)
(* *)

Stack::mt="Layer stack is empty.";
Stack::rng="Layer stack range `1` has incorrect format or data.";
Stack::col="Material <`1`> has no defined color, using red instead.";
Stack::incom="The two layer stacks must have identical lateral dimensions and cell numbers.";\

Stack::touch2d="The two layer stacks must touch in at least 2 points.";
Stack::touch3d="The two layer stacks must touch in at least 3 points.";
Stack::badmask="The mask with dimensions `1` does not match the layer stack with dimensions `2`.";\

Stack::etchpair="Currently you can only wet etch Silicon with KOH. No other material-etchant pairs are supported.";\

Stack::convert="Attempting to convert the graphics with the external program <convert>, called as:\n `1`";



Begin["`Private`"];



Needs["Imtek`Polygon`"];
Needs["Imtek`Nodes`"];
Needs["Imtek`Graph`"];
Needs["Imtek`MeshElementLibrary`"];
Needs["Imtek`DomainElementLibrary`"];

Needs["Imtek`Voxel`"];
Needs["Imtek`Graphics3D`"];

Needs["Utilities`FilterOptions`"];



(* *)
(* implementation part *)
(* *)

(* constructor *)
(* MakeLine[ a_?PointQ, b_?PointQ ] := Line[ a, b ]; *)



(* *)
(* define your options *)
(* *)

Options[imsStackDraw]={imsLayerColorRules\[Rule]{imsSilicon\[RuleDelayed]
            RGBColor[0.439207`,0.501999`,0.564699`],
          imsPolySilicon\[RuleDelayed]RGBColor[0.415693`,0.352901`,0.803903`],
          imsAluminium\[RuleDelayed]RGBColor[0.990005`,1.`,0.940001`],
          imsSiliconOxide\[RuleDelayed]RGBColor[0.640004`,0.580004`,0.5`],
          imsSiliconNitride\[RuleDelayed]RGBColor[0.5`,0.5`,0.410001`],
          imsCopper\[RuleDelayed]RGBColor[1.`,0.898053`,0.771844`],
          imsGold\[RuleDelayed]RGBColor[1.`,0.843104`,0.`],
          imsTitanium:>RGBColor[0.990005`,1.`,0.940001`],
          imsZinc\[RuleDelayed]RGBColor[0.990005`,0.97`,1.`],
          imsSU8\[RuleDelayed]RGBColor[0.6039`,0.803903`,0.196097`]},
      imsOutlineColor\[RuleDelayed]headColor,imsCellRange\[Rule]All};

Options[imsStackDeposit]={imsMethod\[Rule]imsConformal,imsAngle\[Rule]0};

Options[imsStackPattern]={imsMethod\[Rule]imsAnisotropic,imsAngle\[Rule]0,
      imsTransition\[Rule]Ramp};

Options[imsStackWetEtch]={imsMethod\[Rule]imsKOH};

Options[imsStackStrip]={};

Options[imsStackProcess]={imsShowAllSteps\[Rule]False};

(*
  Options[imsGraphicsToBitMask]={imsConvert\[Rule]"convert"};
  *)

Options[imsGraphicsToBitMask]=
    Options[imsGraphics3DToBitMask]={imsPictureDimensions\[Rule]Automatic};



(* selector *)

imsStackDepth[imsStack[layers_,dims_]]:=Length[layers];

imsStackLayers[imsStack[layers_,dims_]]:=layers;

imsStackDimensions[
      imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:={n};
imsStackDimensions[
      imsStack[layers_,{{deltaX:(_Integer|_Real),
            nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:={nX,nY};

imsStackSize[imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=delta*n;
imsStackSize[
      imsStack[layers_,{{deltaX:(_Integer|_Real),
            nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:={deltaX*nX,
      deltaY*nY};

imsStackMaterials[imsStack[layers_,dims_]]:=Head[#]&/@layers;



(* predicates *)

imsBitMaskQ[m:imsBitMask[{(_)..}..]]:=
    And@@Flatten[Map[((#)||(!#))&,List@@m,{2}]];
imsBitMaskQ[m:imsBitMask[(_)..]]:=And@@Map[((#)||(!#))&,List@@m];
imsBitMaskQ[___]:=False;
imsBitMaskDimensions[m:imsBitMask[{(_)..}..]]:=Dimensions[List@@m];
imsBitMaskDimensions[m:imsBitMask[(_)..]]:=Length[List@@m];
imsBitMaskDimensions[___]:=False;


imsLayerAsListQ[l:{{(_Integer|_Real),(_Integer|_Real)}..}]:=True;
imsLayerAsListQ[l:{{{(_Integer|_Real),(_Integer|_Real)}..}..}]:=True;
imsLayerAsListQ[ ___ ]:=False;

imsStackQ[imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    And@@(imsLayerAsListQ[List@@#]&/@layers);
imsStackQ[
      imsStack[layers_,{{deltaX:(_Integer|_Real),
            nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    And@@(imsLayerAsListQ[List@@#]&/@layers);
imsStackQ[ ___ ]:=False;





(* *)
(* public functions *)
(* *)





imsMakeStack[
      stack:{{_Symbol,(_Integer|_Real)}..},{delta:(_Integer|_Real),
        n_Integer}]:=Module[{height=0},
      imsStack@@{Block[{},
                height+=#[[2]];#[[1]]@@Table[{height,#[[2]]},{n+1}]]&/@
            stack,{delta,n+1}}
      ];



imsMakeStack[
      stack:{{_Symbol,(_Integer|_Real)}..},{{deltaX_,nX_Integer},{deltaY_,
          nY_Integer}}]:=Module[{height=0},
      imsStack@@{Block[{},
                height+=#[[2]];#[[1]]@@Table[{height,#[[2]]},{nX+1},{nY+1}]]&/@
            stack,{{deltaX,nX+1},{deltaY,nY+1}}}
      ];



Format[ a_imsStack,StandardForm ]:=
    DisplayForm[
      RowBox[{"\[SkeletonIndicator]","imsStack","\[SkeletonIndicator]"}]];
Format[ a_imsBitMask,StandardForm ]:=
    DisplayForm[
      RowBox[{"\[SkeletonIndicator]","imsBitMask","\[SkeletonIndicator]"}]];






imsStackDraw[s:{imsStack[__]..},opts___?OptionQ]:=
    Block[{pics,plotRanges,extremalRange,mx=0,my=0,Mx=0,My=0,mz=0,Mz=0},
      
      extremalRange[{{x1_,x2_},{y1_,y2_}}]:=Block[{},
          mx=Min[mx,x1];
          my=Min[my,y1];
          Mx=Max[Mx,x2];
          My=Max[My,y2]
          ];
      extremalRange[{{x1_,x2_},{y1_,y2_},{z1_,z2_}}]:=Block[{},
          mx=Min[mx,x1];
          my=Min[my,y1];
          mz=Min[mz,z1];
          Mx=Max[Mx,x2];
          My=Max[My,y2];
          Mz=Max[Mz,z2]
          ];
      
      pics=imsStackDraw[#,opts]&/@s;
      If[Union[Head[#]&/@pics]\[Equal]{Graphics},
        plotRanges=
          extremalRange[#]&/@((#[[2]])&/@
                Flatten[(Options[#,PlotRange]&/@pics)])
        ];
      GraphicsArray[
        Partition[
          pics/.{Rule[PlotRange,a:{{_,_},{_,_}}]->
                Rule[PlotRange,{{mx,Mx},{my,My}}],
              Rule[PlotRange,a:{{_,_},{_,_},{_,_}}]->
                Rule[PlotRange,{{mx,Mx},{my,My},{mz,Mz}}]},1]]
      ];



range2dQ[{_Integer,_Integer}]:=True;
range2dQ[___]:=False;
range3dQ[{{_Integer,_Integer},{_Integer,_Integer}}]:=True;
range3dQ[___]:=False;
rangeQ[{_Integer,_Integer}]:=True;
rangeQ[{{_Integer,_Integer},{_Integer,_Integer}}]:=True;
rangeQ[___]:=False;

imsStackDraw[imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      opts___?OptionQ]:=
    Module[{drawLayer,xCoords,colors,picture,range,myOptions},
      myOptions={FilterOptions[imsStackDraw,opts]};
      colors=imsLayerColorRules/.myOptions/.Options[imsStackDraw];
      
      range=imsCellRange/.myOptions/.Options[imsStackDraw];
      If[range\[Equal]All,
        range={1,n},
        If[!range2dQ[range],
          Message[Stack::rng,range];
          Return[{}]
          ];
        {i,j}=range;
        If[j\[LessEqual]i||i<1||j>n,
          Message[Stack::rng,range];
          Return[{}]
          ]
        ];
      
      drawLayer[l_]:=Block[{top,bot,headColor,outlineColor},
          If[Head[l]\[Equal]imsGap,Return[{}]];
          headColor=Evaluate[(Head[l]/.colors)];
          
          If[Head[headColor]=!=RGBColor&&Head[headColor]=!=CMYKColor&&
              Head[headColor]=!=GrayLevel&&
              
              Head[headColor]=!=Hue,
            Message[Stack::col,Head[l]];
            headColor=RGBColor[1,0,0]
            ];
          
          outlineColor=
            Evaluate[imsOutlineColor/.myOptions/.Options[imsStackDraw]];
          top=Transpose[{xCoords,(#[[1]])&/@(List@@l)}];
          bot=Transpose[{xCoords,(#[[1]]-#[[2]])&/@(List@@l)}];
          curve=Join[top,Reverse[bot],{top[[1]]}];
          {headColor,Polygon[curve],
            If[outlineColor===headColor,{},{outlineColor,Line[curve]}]}
          ];
      
      xCoords=Table[i delta,{i,0,n-1}][[Range@@range]];
      
      picture=drawLayer[#[[Range@@range]]]&/@layers;
      
      If[Length[Flatten[picture]]\[Equal]0,
        Message[Stack::mt];
        picture=Line[{#,0}&/@xCoords]
        ];
      
      zmax=Max[Flatten[Map[{#[[1]]}&,((List@@#)&/@layers),{2}]]];
      Graphics[picture,PlotRange\[Rule]{{0,delta n},{0,zmax}},
        AspectRatio\[Rule]Automatic]
      ];

imsStackDraw[
      imsStack[layers_,{{deltaX:(_Integer|_Real),
            nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      opts___?OptionQ]:=
    Module[{drawLayer,xCoords,yCoords,colors,picture,rx,RX,ry,RY,range,
        myOptions},
      myOptions={FilterOptions[imsStackDraw,opts]};
      colors=imsLayerColorRules/.myOptions/.Options[imsStackDraw];
      
      range=imsCellRange/.myOptions/.Options[imsStackDraw];
      If[range===All,
        
        {{rx,RX},{ry,RY}}=range={{1,nX},{1,nY}},
        
        If[!range3dQ[range],
          Message[Stack::rng,range];
          Print["a"];
          Return[{}]
          ];
        
        {{rx,RX},{ry,RY}}=range;
        If[RX\[LessEqual]rx||rx<1||RX>nX||RY\[LessEqual]ry||ry<1||RY>nY,
          Message[Stack::rng,range];
          Return[{}]
          ]
        ];
      
      drawLayer[l_]:=
        Block[{top,topArray,bot,botArray,headColor,outlineColor,frontLine,
            backLine,leftLine,rightLine,topLine,botLine,closeLine,frontTop,
            frontBot,backTop,backBot,leftTop,leftBot,rightTop,rightBot,panel,
            drawLids},
          
          If[Head[l]\[Equal]imsGap,Return[{}]];
          
          closeLine[m:{{_,_,_}..}]:=Join[m,{m[[1]]}];
          
          
          panel[line1_,line2_]:=(Polygon[closeLine[#]])&/@
              Partition[
                Flatten[
                  Transpose[{Drop[Transpose[{line1,RotateLeft[line1]}],-1],
                      
                      Reverse[#]&/@
                        Drop[Transpose[{line2,RotateLeft[line2]}],-1]
                      }],2],4];
          
          
          drawLids[{{z1_,t1_},{z2_,t2_},{z3_,t3_},{z4_,t4_}},{m_,n_}]:=
            If[(t1\[LessEqual]0)&&(t2\[LessEqual]0)&&(t3\[LessEqual]0)&&(t4\
\[LessEqual]0),
              {},
              {Polygon[{{(m)deltaX,(n)deltaY,z1},{(m+1)deltaX,(n)deltaY,
                      z2},{(m+1)deltaX,(n+1)deltaY,z3},{(m)deltaX,(n)deltaY,
                      z1}}],
                
                Polygon[{{(m)deltaX,(n)deltaY,z1},{(m+1)deltaX,(n+1)deltaY,
                      z3},{(m)deltaX,(n+1)deltaY,z4},{(m)deltaX,(n)deltaY,
                      z1}}],
                Polygon[{{(m)deltaX,(n)deltaY,z1-t1},{(m+1)deltaX,(n)deltaY,
                      z2-t2},{(m+1)deltaX,(n+1)deltaY,
                      z3-t3},{(m)deltaX,(n)deltaY,z1-t1}}],
                
                Polygon[{{(m)deltaX,(n)deltaY,z1-t1},{(m+1)deltaX,(n+1)deltaY,
                      z3-t3},{(m)deltaX,(n+1)deltaY,
                      z4-t4},{(m)deltaX,(n)deltaY,z1-t1}}]}
              ];
          
          
          lids=Table[
              Table[drawLids[{l[[m,n]],l[[m+1,n]],l[[m+1,n+1]],
                    l[[m,n+1]]},{rx+m-1,ry+n-1}],{n,1,RY-ry}],{m,1,RX-rx}];
          
          headColor=Evaluate[(Head[l]/.colors)];
          
          
          If[Head[headColor]=!=RGBColor&&Head[headColor]=!=CMYKColor&&
              Head[headColor]=!=GrayLevel&&
              
              Head[headColor]=!=Hue,
            Message[Stack::col,Head[l]];
            headColor=RGBColor[1,0,0]
            ];
          
          outlineColor=
            Evaluate[imsOutlineColor/.myOptions/.Options[imsStackDraw]];
          
          
          top=Graphics3D[
                SurfaceGraphics[topArray=Map[(#[[1]])&,(List@@l),{2}]]][[1]];
          
          bot=Graphics3D[
                SurfaceGraphics[
                  botArray=Map[(#[[1]]-#[[2]])&,(List@@l),{2}]]][[1]];
          
          
          frontTop=
            Transpose[{Table[xCoords[[1]],{i,ry,RY}],yCoords,topArray[[1]]}];
          
          frontBot=
            Transpose[{Table[xCoords[[1]],{i,ry,RY}],yCoords,botArray[[1]]}];
          
          backTop=Transpose[{Table[xCoords[[-1]],{i,ry,RY}],yCoords,
                topArray[[-1]]}];
          
          backBot=Transpose[{Table[xCoords[[-1]],{i,ry,RY}],yCoords,
                botArray[[-1]]}];
          
          leftTop=Transpose[{xCoords,
                Table[yCoords[[1]],{i,rx,RX}],(#[[1]])&/@topArray}];
          
          leftBot=Transpose[{xCoords,
                Table[yCoords[[1]],{i,rx,RX}],(#[[1]])&/@botArray}];
          
          rightTop=
            Transpose[{xCoords,
                Table[yCoords[[-1]],{i,rx,RX}],(#[[-1]])&/@topArray}];
          
          rightBot=
            Transpose[{xCoords,
                Table[yCoords[[-1]],{i,rx,RX}],(#[[-1]])&/@botArray}];
          
          
          topLine=Polygon[
              Join@@{frontTop,Drop[Drop[rightTop,1],-1],Reverse[backTop],
                  Reverse[Drop[leftTop,-1]]}];
          botLine=
            Polygon[Join@@{frontBot,Drop[Drop[rightBot,1],-1],
                  Reverse[backBot],Reverse[Drop[leftBot,-1]]}];
          
          frontLine=panel[frontTop,frontBot];
          backLine=panel[backTop,backBot];
          leftLine=panel[leftTop,leftBot];
          rightLine=panel[rightTop,rightBot];
          
          
          Flatten[{FaceForm[SurfaceColor[headColor],SurfaceColor[headColor]],
              EdgeForm[],lids,frontLine,backLine,leftLine,rightLine,
              If[outlineColor===
                  headColor,{},{outlineColor,
                    Line[closeLine[Join[frontTop,Reverse[frontBot]]]],
                    Line[closeLine[Join[backTop,Reverse[backBot]]]],
                    Line[closeLine[Join[rightTop,Reverse[rightBot]]]],
                    Line[closeLine[Join[leftTop,Reverse[leftBot]]]],topLine,
                    botLine}/.Polygon\[Rule]Line]}]
          ];
      
      xCoords=Table[i deltaX,{i,rx,RX}];
      yCoords=Table[i deltaY,{i,ry,RY}];
      
      picture=drawLayer[#[[Range[rx,RX],Range[ry,RY]]]]&/@layers;
      
      If[Length[Flatten[picture]]\[Equal]0,
        Message[Stack::mt];
        picture={Line[{#,0,0}&/@xCoords],Line[{0,#,0}&/@yCoords]}
        ];
      
      Graphics3D[picture,PlotRange\[Rule]All,Boxed\[Rule]False]
      ];





imsMaskDraw[mask:imsBitMask[__],{delta:(_Integer|_Real),n_Integer},
      y:(_Integer|_Real)]:=Module[{drawBit},
      drawBit[b_,{m_}]:=
        If[b\[Equal]True,Line[{{(m-1.5)delta,y},{(m-.5)delta,y}}],{}];
      Graphics[{Red,MapIndexed[drawBit,List@@mask]}]
      ];

imsMaskDraw[
      mask:imsBitMask[__],{{deltaX:(_Integer|_Real),
          nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}},
      z:(_Integer|_Real)]:=Module[{drawBit},
      drawBit[b_,{n_,m_}]:=
        If[b\[Equal]True,
          Polygon[{{(m-1.5)deltaX,(n-1.5)deltaY,
                z},{(m-.5)deltaX,(n-1.5)deltaY,z},{(m-.5)deltaX,(n-.5)deltaY,
                z},{(m-1.5)deltaX,(n-.5)deltaY,
                z},{(m-1.5)deltaX,(n-1.5)deltaY,z}}],{}];
      Graphics3D[{FaceForm[SurfaceColor[Red],SurfaceColor[Red]],EdgeForm[],
          MapIndexed[drawBit,List@@mask,{2}]}]
      ];





imsStackDeposit[imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      material_,thickness:(_Integer|_Real),opts___?OptionQ]:=
    Module[{top,theMethod,pairs,myOptions},
      myOptions={FilterOptions[imsStackDeposit,opts]};
      theMethod=imsMethod/.myOptions/.Options[imsStackDeposit];
      top=((#[[1]])&/@(List@@(layers[[-1]])));
      If[theMethod===imsConformal,
        pairs=growGrid[top,delta,thickness];
        pairs=Transpose[{pairs,pairs-top}],
        If[theMethod===imsAnisotropic,
          pairs=(({#+thickness,thickness})&/@top)]
        ];
      
      Return[imsStack[Join[layers,{material@@pairs}],{delta,n}]]
      ];

imsStackDeposit[
      imsStack[layers_,{{deltaX:(_Integer|_Real),
            nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],material_,
      thickness:(_Integer|_Real),opts___?OptionQ]:=
    Module[{top,theMethod,pairs,myOptions},
      myOptions={FilterOptions[imsStackDeposit,opts]};
      theMethod=imsMethod/.myOptions/.Options[imsStackDeposit];
      top=Map[#[[1]]&,List@@layers[[-1]],{2}];
      
      If[theMethod===imsConformal,
        pairs=growGrid[top,deltaX,deltaY,thickness];
        
        pairs=MapThread[{#1,#2}&,{pairs,pairs-top},2],
        If[theMethod===imsAnisotropic,
          pairs=Map[{#+thickness,thickness}&,top,{2}]]
        ];
      
      Return[
        imsStack[Join[layers,{material@@pairs}],{{deltaX,nX},{deltaY,nY}}]]
      ];





imsStackPattern[
      ls:imsStack[layers:{(_)..},{delta:(_Integer|_Real),n_Integer}],
      material_,thickness:(_Integer|_Real),m:imsBitMask[(_)..],field_,
      opts___?OptionQ]:=
    Module[{top,rest,d,newTop,theTransition,dmask,dStack,myOptions},
      myOptions={FilterOptions[imsStackPattern,opts]};
      If[(dmask=Dimensions[List@@m])\[NotEqual](dStack=
              imsStackDimensions[ ls ]),Message[Stack::badmask,dmask,dStack];
        Return[ls]
        ];
      theTransition=imsTransition/.myOptions/.Options[imsStackPattern];
      top=layers[[-1]];
      If[Head[top]=!=material,
        Return[ls]
        ];
      rest=Drop[layers,-1];
      d=(If[#\[Equal]field,{-thickness,-thickness},{0,0}])&/@(List@@m);
      newTop=
        material@@((If[#[[2]]<0,{#[[1]]-#[[2]],0},#])&/@((List@@top)+d));
      imsStack[Join[rest,{newTop}],{delta,n}]
      ];

imsStackPattern[
      ls:imsStack[
          layers:{(_)..},{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],material_,
      thickness:(_Integer|_Real),m:imsBitMask[{(_)..}..],field_,
      opts___?OptionQ]:=
    Module[{top,rest,d,newTop,theTransition,dmask,dStack,myOptions},
      myOptions={FilterOptions[imsStackPattern,opts]};
      If[(dmask=Dimensions[List@@m])\[NotEqual](dStack=
              imsStackDimensions[ ls ]),Message[Stack::badmask,dmask,dStack];
        Return[ls]
        ];
      theTransition=imsTransition/.myOptions/.Options[imsStackPattern];
      top=layers[[-1]];
      If[Head[top]=!=material,
        Return[ls]
        ];
      rest=Drop[layers,-1];
      d=Map[If[#\[Equal]field,{-thickness,-thickness},{0,0}]&,List@@m,{2}];
      newTop=
        material@@Map[If[#[[2]]<0,{#[[1]]-#[[2]],0},#]&,(List@@top)+d,{2}];
      imsStack[Join[rest,{newTop}],{{deltaX,nX},{deltaY,nY}}]
      
      ];





imsStackStrip[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      material_,opts___?OptionQ]:=Module[{pos,newLayer},
      pos=Position[ls,material[___]][[1]];
      newLayer=imsGap@@Extract[ls,pos];
      ReplacePart[ls,newLayer,pos]
      ];

imsStackStrip[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],material_,
      opts___?OptionQ]:=Module[{pos,newLayer},
      pos=Position[ls,material[___]][[1]];
      newLayer=imsGap@@Extract[ls,pos];
      ReplacePart[ls,newLayer,pos]
      ];





imsStackReflow[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      material_,opts___?OptionQ]:=Module[{top,rest,zVals,newTop,dVals},
      top=layers[[-1]];
      If[Head[top]=!=material,
        Return[ls]
        ];
      rest=Drop[layers,-1];
      zVals=((#[[1]])&/@(List@@top));
      
      dVals=
        Join[{zVals[[1]]},
          Drop[Drop[(RotateRight[zVals]+2.zVals+RotateLeft[zVals])/4.,-1],
            1],{zVals[[-1]]}];
      newTop=
        material@@Transpose[{dVals,((#[[2]])&/@(List@@top))-(zVals-dVals)}];
      
      imsStack[Join[rest,{newTop}],{delta,n}]
      ];

imsStackReflow[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],material_,
      opts___?OptionQ]:=Module[{top,rest,zVals,newTop,dVals,smoothPoint},
      smoothPoint[v_,{i_,j_}]:=Block[{},
          
          If[i>1&&j>1&&i<nX&&j<nY,
            Return[(zVals[[i-1,j]]+zVals[[i+1,j]]+4.zVals[[i,j]]+
                    zVals[[i,j-1]]+zVals[[i,j+1]])/8.]];
          
          
          If[i==1&&j>1&&j<nY,
            Return[(zVals[[i+1,j]]+4.zVals[[i,j]]+zVals[[i,j-1]]+
                    zVals[[i,j+1]])/7.]];
          
          If[i>1&&j==1&&i<nX,
            Return[(zVals[[i-1,j]]+zVals[[i+1,j]]+4.zVals[[i,j]]+
                    zVals[[i,j+1]])/7.]];
          
          If[j>1&&i==nX&&j<nY,
            Return[(zVals[[i-1,j]]+4.zVals[[i,j]]+zVals[[i,j-1]]+
                    zVals[[i,j+1]])/7.]];
          
          If[i>1&&i<nX&&j==nY,
            Return[(zVals[[i-1,j]]+zVals[[i+1,j]]+4.zVals[[i,j]]+
                    zVals[[i,j-1]])/7.]];
          
          
          If[i==1&&j==1,
            Return[(zVals[[i+1,j]]+4.zVals[[i,j]]+zVals[[i,j+1]])/6.]];
          
          If[i==1&&j==nY,
            Return[(zVals[[i+1,j]]+4.zVals[[i,j]]+zVals[[i,j-1]])/6.]];
          
          If[i\[Equal]nX&&j==1,
            Return[(zVals[[i-1,j]]+4.zVals[[i,j]]+zVals[[i,j+1]])/6.]];
          
          If[i==nX&&j==nY,
            Return[(zVals[[i-1,j]]+4.zVals[[i,j]]+zVals[[i,j-1]])/6.]];
          
          Return[0]
          ];
      
      top=layers[[-1]];
      If[Head[top]=!=material,
        Return[ls]
        ];
      rest=Drop[layers,-1];
      zVals=Map[(#[[1]])&,List@@top,{2}];
      dVals=MapIndexed[smoothPoint,zVals,{2}];
      newTop=
        material@@
          MapThread[{#1,#2}&,{dVals,
              Map[(#[[2]])&,List@@top,{2}]-(zVals-dVals)},2];
      
      imsStack[Join[rest,{newTop}],{{deltaX,nX},{deltaY,nY}}]
      ];



imsStackDrill[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      holes:{{{(_Integer|_Real),(_Integer|_Real)},(_Integer|_Real)}..}]:=
    Module[{newHeights,markHole},
      
      markHole[{xposition_,newHeight_},diameter_]:=
        Block[{leftStart,rightEnd},
          leftStart=Max[1,Round[(xposition-(diameter/2.))/delta]];
          rightEnd=Min[n,Round[(xposition+(diameter/2.))/delta]];
          (newHeights[[#]]=newHeight)&/@Range[leftStart,rightEnd]
          ];
      
      newHeights=Table[Infinity,{n}];
      Map[(markHole@@#)&,holes];
      trimStack[ls,newHeights]
      ];

imsStackDrill[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      holes:{{{(_Integer|_Real),(_Integer|_Real),(_Integer|_Real)},(_Integer|_\
Real)}..}]:=Module[{newHeights,markHole},
      
      markHole[{xposition_,yposition_,newHeight_},diameter_]:=
        Block[{leftStart,rightEnd,frontStart,backEnd,r=diameter/2},
          leftStart=Max[1,Round[(xposition-(diameter/2.))/deltaX]];
          frontStart=Max[1,Round[(yposition-(diameter/2.))/deltaY]];
          rightEnd=Min[nX,Round[(xposition+(diameter/2.))/deltaX]];
          backEnd=Min[nY,Round[(yposition+(diameter/2.))/deltaY]];
          
          
          Map[If[(N[Sqrt[((#*{deltaX,deltaY})-{xposition,
                                yposition}).((#*{deltaX,deltaY})-{xposition,
                                yposition})]]<r),
                newHeights[[Sequence@@#]]=newHeight
                ]&,
            Outer[List,Range[leftStart,rightEnd],
              Range[frontStart,backEnd]],{2}]
          ];
      
      newHeights=Table[Infinity,{nX},{nY}];
      Map[(markHole@@#)&,holes];
      trimStack[ls,newHeights]
      ];





imsStackPlanarize[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      newz:(_Integer|_Real)]:=Module[{newHeights},
      newHeights=Table[newz,{n}];
      trimStack[ls,newHeights]
      ];

imsStackPlanarize[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      newz:(_Integer|_Real)]:=Module[{newHeights},
      newHeights=Table[newz,{nX},{nY}];
      trimStack[ls,newHeights]
      ];



imsStackErode[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      m:imsBitMask[(_)..],field_,newHeight:(_Integer|_Real)]:=
    Module[{newHeights,markMask},
      
      markMask[v_,{i_}]:=Block[{},
          If[v\[Equal]field,
            newHeights[[i]]=newHeight
            ]
          ];
      
      newHeights=Table[Infinity,{n}];
      MapIndexed[markMask,List@@m];
      trimStack[ls,newHeights]
      ];

imsStackErode[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      m:imsBitMask[{(_)..}..],field_,newHeight:(_Integer|_Real)]:=
    Module[{newHeights,markMask},
      
      markMask[v_,{i_,j_}]:=Block[{},
          If[v\[Equal]field,
            newHeights[[i,j]]=newHeight
            ]
          ];
      
      newHeights=Table[Infinity,{nX},{nY}];
      MapIndexed[markMask,List@@m,{2}];
      trimStack[ls,newHeights]
      ];



imsStackEmboss[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      material_Symbol,slabHeight:(_Integer|_Real)]:=
    Module[{mySkyline,volume,z0},
      
      mySkyline=skyline[ls];
      volume=Plus@@mySkyline;
      z0=volume/n;
      imsStack[{material@@({slabHeight,slabHeight-(#-z0)}&/@
                mySkyline)},{delta,n}]
      ];

imsStackEmboss[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      material_Symbol,slabHeight:(_Integer|_Real)]:=
    Module[{mySkyline,volume,z0},
      
      mySkyline=skyline[ls];
      volume=Plus@@Flatten[mySkyline];
      z0=volume/(nX nY);
      imsStack[{material@@(Map[{slabHeight,slabHeight-(#-z0)}&,
                mySkyline,{2}])},{{deltaX,nX},{deltaY,nY}}]
      ];



imsStackWetEtch[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      attackMaterial_Symbol,depth:(_Integer|_Real),opts___?OptionQ]:=
    Module[{myMethod,pickCellLayer,processLayer,attackLayers,top,
        exposedLayers,exposedLayerCellsAreTop,processedLayers,myOptions},
      myOptions={FilterOptions[imsStackWetEtch,opts]};
      pickCellLayer[{z_,t_,l_,m_}]:=l;
      processLayer[l_]:=Map[markCell[#,l]&,top,{1}];
      markCell[{z_,t_,l_,m_},ll_]:=If[l===ll,True,False];
      
      myMethod=imsMethod/.myOptions/.Options[imsStackWetEtch];
      If[myMethod!=imsKOH||attackMaterial!=Silicon,
        Message[Stack::etchpair];
        Return[ls]
        ];
      
      attackLayers=Flatten[Position[imsStackMaterials[ls],attackMaterial]];
      
      top=topmostLayer[ls];
      
      exposedLayers=Union[Flatten[Map[pickCellLayer,top,{1}]]];
      
      exposedLayerCellsAreTop=Map[processLayer[#]&,attackLayers];
      
      processedLayers=
        MapThread[
          evolveLayerEtchfront[#1,#2,delta,depth]&,{layers[[attackLayers]],
            exposedLayerCellsAreTop}];
      
      newLayers=layers;
      MapThread[(newLayers=ReplacePart[newLayers,#1,#2])&,{processedLayers,
          attackLayers}];
      
      imsStack[newLayers,{delta,n}]
      
      ];

imsStackWetEtch[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      attackMaterial_Symbol,depth:(_Integer|_Real),opts___?OptionQ]:=
    Module[{myMethod,pickCellLayer,processLayer,attackLayers,top,
        exposedLayers,exposedLayerCellsAreTop,processedLayers,myOptions},
      myOptions={FilterOptions[imsStackWetEtch,opts]};
      pickCellLayer[{z_,t_,l_,m_}]:=l;
      processLayer[l_]:=Map[markCell[#,l]&,top,{2}];
      markCell[{z_,t_,l_,m_},ll_]:=If[l===ll,True,False];
      
      myMethod=imsMethod/.myOptions/.Options[imsStackWetEtch];
      If[myMethod!=imsKOH||attackMaterial!=Silicon,
        Message[Stack::etchpair];
        Return[ls]
        ];
      
      attackLayers=Flatten[Position[imsStackMaterials[ls],attackMaterial]];
      
      top=topmostLayer[ls];
      
      exposedLayers=Union[Flatten[Map[pickCellLayer,top,{2}]]];
      
      exposedLayerCellsAreTop=Map[processLayer[#]&,attackLayers];
      
      processedLayers=
        MapThread[
          evolveLayerEtchfront[#1,#2,deltaX,depth]&,{layers[[attackLayers]],
            exposedLayerCellsAreTop}];
      
      newLayers=layers;
      MapThread[(newLayers=ReplacePart[newLayers,#1,#2])&,{processedLayers,
          attackLayers}];
      
      imsStack[newLayers,{{deltaX,nX},{deltaY,nY}}]
      
      ];



imsStackCut[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      position_Integer]:=Module[{rangeLeft,rangeRight},
      If[position<=1||position>=n,
        Message[Stack::rng,position];
        Return[ls],
        rangeLeft={1,position};
        rangeRight={position,n}
        ];
      {imsStack[(#[[Range@@rangeLeft]])&/@layers,{delta,position}],
        imsStack[(#[[Range@@rangeRight]])&/@layers,{delta,n-position+1}]}
      ];

imsStackCut[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      position:(_Integer|{_Integer})]:=
    Module[{rangeLeft,rangeRight,rangeFront,rangeBack},
      If[Head[position]===Integer,
        If[position<=1||position>=nX,
          Message[Stack::rng,position];
          Return[ls],
          rangeLeft={1,position};
          rangeRight={position,nX};
          rangeFront={1,nY};
          rangeBack={1,nY};
          ],
        If[position[[1]]<=1||position[[1]]>=nY,
          Message[Stack::rng,position];
          Return[ls],
          rangeLeft={1,nX};
          rangeRight={1,nX};
          rangeFront={1,position[[1]]};
          rangeBack={position[[1]],nY};
          ]
        ];
      {imsStack[(#[[Range@@rangeLeft,Range@@rangeFront]])&/@
            layers,{{deltaX,rangeLeft[[2]]-rangeLeft[[1]]+1},{deltaY,
              rangeFront[[2]]-rangeFront[[1]]+1}}],
        imsStack[(#[[Range@@rangeRight,Range@@rangeBack]])&/@
            layers,{{deltaX,rangeRight[[2]]-rangeRight[[1]]+1},{deltaY,
              rangeBack[[2]]-rangeBack[[1]]+1}}]}
      ];



imsStackBond[
      lsBottom:imsStack[layersBottom_,{delta:(_Integer|_Real),n_Integer}],
      lsTop:imsStack[layersTop_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{separation,minSeparation,posSeparation,gapZ,gapT,newGap,
        newLsTop},
      separation=layersSeparation[layersBottom[[-1]],layersTop[[1]]];
      minSeparation=Min[separation];
      posSeparation=Flatten[Position[separation,minSeparation]];
      If[Length[posSeparation]>1,
        gapZ=(#[[1]]-#[[1]])&/@(List@@layersTop[[1]]);
        gapT=(#-minSeparation)&/@separation;
        newGap=imsGap@@(Transpose[{gapZ,gapT}]);
        newLsTop=translateStack[lsTop,-minSeparation];
        Return[imsStack[Join[layersBottom,{newGap},newLsTop[[1]]],{delta,n}]]
        ];
      Message[Stack::touch2d];
      {lsBottom,lsTop}
      ];

imsStackBond[
      lsBottom:imsStack[
          layersBottom_,{deltaBottom:(_Integer|_Real),nBottom_Integer}],
      lsTop:imsStack[layersTop_,{deltaTop:(_Integer|_Real),nTop_Integer}]]:=
    Module[{},
      Message[Stack::incom];
      {lsBottom,lsTop}
      ];

imsStackBond[
      lsBottom:imsStack[
          layersBottom_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      lsTop:imsStack[
          layersTop_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    Module[{separation,minSeparation,posSeparation,gapZ,gapT,newGap,
        newLsTop},
      separation=layersSeparation[layersBottom[[-1]],layersTop[[1]]];
      minSeparation=Min[separation];
      posSeparation=Position[separation,minSeparation];
      If[Length[posSeparation]>2,
        gapZ=Map[(#[[1]]-#[[1]])&,(List@@layersTop[[1]]),{2}];
        gapT=Map[(#-minSeparation)&,separation,{2}];
        newGap=imsGap@@(MapThread[{#1,#2}&,{gapZ,gapT},2]);
        newLsTop=translateStack[lsTop,-minSeparation];
        Return[
          imsStack[
            Join[layersBottom,{newGap},
              newLsTop[[1]]],{{deltaX,nX},{deltaY,nY}}]]
        ];
      Message[Stack::touch3d];
      {lsBottom,lsTop}
      ];

imsStackBond[
      lsBottom:imsStack[
          layersBottom_,{{deltaXbottom:(_Integer|_Real),
              nXbottom_Integer},{deltaYbottom:(_Integer|_Real),
              nYbottom_Integer}}],
      lsTop:imsStack[
          layersTop_,{{deltaXtop:(_Integer|_Real),
              nXtop_Integer},{deltaYtop:(_Integer|_Real),nYtop_Integer}}]]:=
    Module[{},
      Message[Stack::incom];
      {lsBottom,lsTop}
      ];



imsStackFlip[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{newLayers,rearrangeCells,minMaxZ,minZ=Infinity,maxZ=-Infinity},
      
      minMaxZ[l_]:=Block[{},
              If[#[[1]]>maxZ,maxZ=#[[1]]];
              If[(#[[1]]-#[[2]])<minZ,minZ=(#[[1]]-#[[2]])]
              ]&/@l;
      rearrangeCells[l_]:={-(#[[1]]-#[[2]])+maxZ+minZ,#[[2]]}&/@l;
      
      minMaxZ[#]&/@layers;
      newLayers=Reverse[Reverse[rearrangeCells[#]]&/@layers];
      imsStack[newLayers,{delta,n}]
      ];

imsStackFlip[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    Module[{newLayers,rearrangeCells,minMaxZ,minZ=Infinity,maxZ=-Infinity},
      
      minMaxZ[l_]:=Map[Block[{},
              If[#[[1]]>maxZ,maxZ=#[[1]]];
              If[(#[[1]]-#[[2]])<minZ,minZ=(#[[1]]-#[[2]])]
              ]&,l,{2}];
      rearrangeCells[l_]:=Map[{-(#[[1]]-#[[2]])+maxZ+minZ,#[[2]]}&,l,{2}];
      
      minMaxZ[#]&/@layers;
      
      newLayers=Reverse[rearrangeCells[Reverse[#]]&/@layers];
      imsStack[newLayers,{{deltaX,nX},{deltaY,nY}}]
      
      ];



imsStackRotate[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    imsStack[Reverse[#]&/@layers,{delta,n}];

imsStackRotate[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    imsStack[Map[
        Reverse[#]&,((Head[#]@@Transpose[List@@#])&/@layers),{2}],{{deltaX,
          nX},{deltaY,nY}}];





\!\(\(imsStackGrow[ls : imsStack[layers_, {delta : \((_Integer | _Real)\), n_Integer}], attackMaterial_Symbol -> growMaterial_Symbol, {tgrow : \((_Integer | _Real)\), tconsume : \((_Integer | _Real)\), wcovered : \((_Integer | _Real)\)}] := Module[{top, pickLayer, markCell, processLayer, exposedLayers, attackLayers, layerCellsAreTop, attackLayer, makeGrowLayer, newLayers = layers, adjustHeights, downProfileRules = {}}, \[IndentingNewLine]pickCellLayer[{z_, t_, l_, m_}] := l; \[IndentingNewLine]markCell[{z_, t_, l_, m_}, ll_] := If[l === ll, True, False]; \[IndentingNewLine]processLayer[l_] := Map[markCell[#, l] &, top, {1}]; \[IndentingNewLine]\[IndentingNewLine]attackLayer[l_Integer] := Block[{profile, tProfile, zProfile, dProfile}, \[IndentingNewLine]profile = paintGrid[exposedLayerCellsAreTop[\([l]\)], {delta, 3  wcovered, tconsume \((5/2)\) Exp[\(-\((#^2)\)\)/\((2\ wcovered^2)\)]/\((\@\(2  Pi\))\) &}]; \[IndentingNewLine]If[Head[newLayers[\([l]\)]] === attackMaterial, \[IndentingNewLine]tProfile = List @@ \((\(#[\([2]\)] &\) /@ newLayers[\([l]\)])\) - profile; \[IndentingNewLine]zProfile = List @@ \((\(#[\([1]\)] &\) /@ newLayers[\([l]\)])\) - profile; \[IndentingNewLine]If[Or @@ \((\(\((# < 0)\) &\) /@ tProfile)\), \[IndentingNewLine]dProfile = \(\((If[# > 0, 0, #])\) &\) /@ tProfile; \[IndentingNewLine]downProfileRules = Join[downProfileRules, {l \[Rule] dProfile}]; \[IndentingNewLine]tProfile = tProfile - dProfile; \[IndentingNewLine]zProfile = zProfile - dProfile;\[IndentingNewLine]]; \[IndentingNewLine]Head[newLayers[\([l]\)]] @@ Transpose[{zProfile, tProfile}], \[IndentingNewLine]newLayers[\([l]\)]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]makeGrowLayer[l_Integer] := Block[{profile, dProfile}, \[IndentingNewLine]If[Head[newLayers[\([l]\)]] === attackMaterial, \[IndentingNewLine]profile = paintGrid[exposedLayerCellsAreTop[\([l]\)], {delta, 3  wcovered, tgrow \((5/2)\) Exp[\(-\((#^2)\)\)/\((2\ wcovered^2)\)]/\((\@\(2  Pi\))\) &}]; \[IndentingNewLine]If[dProfile = \((l /. downProfileRules)\); Head[dProfile] === List, \[IndentingNewLine]profile = profile + \((tgrow/tconsume)\) dProfile\[IndentingNewLine]]; \[IndentingNewLine]growMaterial @@ Transpose[{profile + List @@ \((\(#[\([1]\)] &\) /@ newLayers[\([l]\)])\), profile}], \[IndentingNewLine]newLayers[\([l]\)]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]adjustHeights[myLayers : {\((_)\) .. }] := Block[{d, zLast, zNew}, \[IndentingNewLine]d = Length[myLayers]; \[IndentingNewLine]zLast = \(\((#[\([1]\)])\) &\) /@ \((List @@ myLayers[\([1]\)])\); \[IndentingNewLine]Join[{myLayers[\([1]\)]}, \[IndentingNewLine]Table[t = \(#[\([2]\)] &\) /@ \((List @@ myLayers[\([l]\)])\); zNew = t + zLast; \[IndentingNewLine]zLast = zNew; \[IndentingNewLine]Head[myLayers[\([l]\)]] @@ Transpose[{zNew, t}], {l, 2, d}]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]attackLayers = Flatten[Position[imsStackMaterials[ls], attackMaterial]]; \[IndentingNewLine]\[IndentingNewLine]insertGrowLayer[l_] := Block[{d = Length[newLayers], botL, topL}, \[IndentingNewLine]botL = newLayers[\([Range[1, l]]\)]; \[IndentingNewLine]topL = newLayers[\([Range[l + 1, d]]\)]; \[IndentingNewLine]Join[botL, {makeGrowLayer[l]}, topL]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]top = topmostLayer[ls]; \[IndentingNewLine]\[IndentingNewLine]exposedLayers = Union[Map[pickCellLayer, top, {1}]]; \[IndentingNewLine]\[IndentingNewLine]exposedLayerCellsAreTop = \(processLayer[#] &\) /@ attackLayers; \[IndentingNewLine]\[IndentingNewLine]MapThread[\((newLayers = ReplacePart[newLayers, #1, #2])\) &, {\(attackLayer[#] &\) /@ attackLayers, attackLayers}]; \[IndentingNewLine]\[IndentingNewLine]\(\((newLayers = insertGrowLayer[#])\) &\) /@ attackLayers; \[IndentingNewLine]\[IndentingNewLine]newLayers = adjustHeights[newLayers]; \[IndentingNewLine]\[IndentingNewLine]imsStack[newLayers, {delta, n}]\[IndentingNewLine]];\)\)

\!\(\(imsStackGrow[ls : imsStack[layers_, {{deltaX : \((_Integer | _Real)\), nX_Integer}, {deltaY : \((_Integer | _Real)\), nY_Integer}}], attackMaterial_Symbol -> growMaterial_Symbol, {tgrow : \((_Integer | _Real)\), tconsume : \((_Integer | _Real)\), wcovered : \((_Integer | _Real)\)}] := Module[{top, pickLayer, markCell, processLayer, exposedLayers, attackLayers, layerCellsAreTop, attackLayer, makeGrowLayer, newLayers = layers, adjustHeights, downProfileRules = {}}, \[IndentingNewLine]pickCellLayer[{z_, t_, l_, m_}] := l; \[IndentingNewLine]markCell[{z_, t_, l_, m_}, ll_] := If[l \[Equal] ll, True, False]; \[IndentingNewLine]processLayer[l_] := Map[markCell[#, l] &, top, {2}]; \[IndentingNewLine]\[IndentingNewLine]attackLayer[l_Integer] := Block[{profile, tProfile, zProfile, dProfile}, \[IndentingNewLine]profile = paintGrid[exposedLayerCellsAreTop[\([l]\)], {deltaX, deltaY, 3  wcovered, tconsume \((5/2)\) Exp[\(-\((#^2)\)\)/\((2\ wcovered^2)\)]/\((\@\(2  Pi\))\) &}]; \[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]\[IndentingNewLine]If[Head[newLayers[\([l]\)]] === attackMaterial, \[IndentingNewLine]tProfile = List @@ Map[#[\([2]\)] &, List @@ newLayers[\([l]\)], {2}] - profile; \[IndentingNewLine]zProfile = List @@ Map[#[\([1]\)] &, List @@ newLayers[\([l]\)], {2}] - profile; \[IndentingNewLine]If[Or @@ Flatten[Map[\((# < 0)\) &, tProfile, {2}]], \[IndentingNewLine]dProfile = Map[\((If[# > 0, 0, #])\) &, tProfile, {2}]; \[IndentingNewLine]downProfileRules = Join[downProfileRules, {l \[Rule] dProfile}]; \[IndentingNewLine]tProfile = tProfile - dProfile; \[IndentingNewLine]zProfile = zProfile - dProfile;\[IndentingNewLine]]; \[IndentingNewLine]Head[newLayers[\([l]\)]] @@ MapThread[{#1, #2} &, {zProfile, tProfile}, 2], \[IndentingNewLine]newLayers[\([l]\)]\[IndentingNewLine]]\[IndentingNewLine]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]makeGrowLayer[l_Integer] := Block[{profile, dProfile}, \[IndentingNewLine]If[Head[newLayers[\([l]\)]] === attackMaterial, \[IndentingNewLine]profile = paintGrid[exposedLayerCellsAreTop[\([l]\)], {deltaX, deltaY, 3  wcovered, tgrow \((5/2)\) Exp[\(-\((#^2)\)\)/\((2\ wcovered^2)\)]/\((\@\(2  Pi\))\) &}]; \[IndentingNewLine]\[IndentingNewLine]If[dProfile = \((l /. downProfileRules)\); Head[dProfile] === List, \[IndentingNewLine]profile = profile + \((tgrow/tconsume)\) dProfile\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]growMaterial @@ MapThread[{#1, #2} &, {profile + List @@ \((Map[#[\([1]\)] &, newLayers[\([l]\)], {2}])\), profile}, 2], \[IndentingNewLine]newLayers[\([l]\)]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]adjustHeights[myLayers : {\((_)\) .. }] := Block[{d, zLast, zNew}, \[IndentingNewLine]d = Length[myLayers]; \[IndentingNewLine]zLast = Map[\((#[\([1]\)])\) &, \((List @@ myLayers[\([1]\)])\), {2}]; \[IndentingNewLine]Join[{myLayers[\([1]\)]}, \[IndentingNewLine]Table[t = Map[\((#[\([2]\)])\) &, \((List @@ myLayers[\([l]\)])\), {2}]; zNew = t + zLast; \[IndentingNewLine]zLast = zNew; \[IndentingNewLine]Head[myLayers[\([l]\)]] @@ MapThread[{#1, #2} &, {zNew, t}, 2], {l, 2, d}]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]attackLayers = Flatten[Position[imsStackMaterials[ls], attackMaterial]]; \[IndentingNewLine]\[IndentingNewLine]insertGrowLayer[l_] := Block[{d = Length[newLayers], botL, topL}, \[IndentingNewLine]botL = newLayers[\([Range[1, l]]\)]; \[IndentingNewLine]topL = newLayers[\([Range[l + 1, d]]\)]; \[IndentingNewLine]Join[botL, {makeGrowLayer[l]}, topL]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]top = topmostLayer[ls]; \[IndentingNewLine]\[IndentingNewLine]exposedLayers = Union[Flatten[Map[pickCellLayer, top, {2}]]]; \[IndentingNewLine]\[IndentingNewLine]exposedLayerCellsAreTop = Map[processLayer[#] &, attackLayers]; \[IndentingNewLine]\[IndentingNewLine]MapThread[\((newLayers = ReplacePart[newLayers, #1, #2])\) &, {\(attackLayer[#] &\) /@ attackLayers, attackLayers}]; \[IndentingNewLine]\[IndentingNewLine]\(\((newLayers = insertGrowLayer[#])\) &\) /@ attackLayers; \[IndentingNewLine]\[IndentingNewLine]newLayers = adjustHeights[newLayers]; \[IndentingNewLine]\[IndentingNewLine]imsStack[newLayers, {{deltaX, nX}, {deltaY, nY}}]\[IndentingNewLine]];\)\)



imsStackProcess[steps:{{___}..},ls_imsStack,opts___?OptionQ]:=
    Module[{s=ls,showSteps,allSteps,myOptions},
      myOptions={FilterOptions[imsStackProcess,opts]};
      showSteps=imsShowAllSteps/.myOptions/.Options[imsStackProcess];
      If[showSteps,
        allSteps=(s=ProcessStep[s,#])&/@steps;
        Return[allSteps],
        (s=ProcessStep[s,#];)&/@steps;
        Return[flattenStack[s]]
        ]
      ];









imsGraphicsToBitMask[g_Graphics,d_,opts___?OptionQ]:=
    imsGraphics3DToBitMask[imsToGraphics3D[g],d,opts];

imsGraphics3DToBitMask[g_Graphics3D,d_,opts___?OptionQ]:=
    Module[{vm,dims,dx,dy,nx,ny},
      (* The graphics picture can draw all over the place. 
              We will project the converted voxel picture onto the z=0 plane *)

            dims=
        imsPictureDimensions/.{opts}/.Options[imsGraphics3DToBitMask];
      vm=imsGraphics3DToVoxel[ Graphics3D[Flatten[{g[[1]]}]] ,d];
      vm=Normal[
          SparseArray[(#\[Rule]True)&/@
              Union[(Drop[ #, -1 ]& /@ imsVoxelMeshData[ vm ] ) ], 
            Drop[ imsVoxelMeshDimensions[ vm ], -1 ], False ]
          ];
      If[dims\[NotEqual]Automatic&&VectorQ[dims]&&Length[dims]\[Equal]2&&
          And@@(IntegerQ[#]&/@dims),
        {dx,dy}=Dimension[vm];
        {nx,ny}=dims;
        If[nx<dx,
          vm=Map[Drop[#,nx-dx]&,vm,1]
          ];
        If[nx>dx,
          vm=Map[Join[#,Table[False,{nx-dx}]]&,vm,1]
          ];
        If[ny<dy,
          vm=Drop[vm,ny-dy]
          ];
        If[ny>dy,
          vm=Join[vm,Table[False,{ny-dy}]]
          ];
        ];
      Return[imsBitMask@@Transpose[vm]]
      ];



imsStackToNexus[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{d,uniqueNodes,checkThickness,checkLayer,numberNodes,createNodes,
        resolveHangingNumbers,currentLayer,nodeNumber=0,elementNumber=0,
        meshNodeNumbers,generateElement,coordinates,nodes,elements},
      
      (* The local functions *)
      
      checkThickness[{z_,thickness_},{i_}]:=
        If[thickness>0,True,uniqueNodes[[currentLayer,i]]];
      checkLayer[l_]:=Block[{},
          currentLayer=l+1;
          
          uniqueNodes[[currentLayer]]=
            MapIndexed[checkThickness,List@@layers[[l]]]
          ];
      numberNodes[val_]:=If[val\[Equal]True,++nodeNumber,False];
      
      resolveHangingNumbers[val_,{ilayer_,jcolumn_}]:=
        If[!IntegerQ[val],
          If[ilayer>1,
            meshNodeNumbers[[ilayer,jcolumn]]=
              meshNodeNumbers[[ilayer-1,jcolumn]],
            meshNodeNumbers[[ilayer,jcolumn]]=val],
          meshNodeNumbers[[ilayer,jcolumn]]=val];
      
      generateElements[{ilayer_,jcolumn_}]:=
        Block[{n1,n2,n3,n4},
          If[Head[layers[[ilayer]]]===imsGap,Return[{{}}]];
          {n1,n2,n3,n4}={meshNodeNumbers[[ilayer,jcolumn]],
              meshNodeNumbers[[ilayer,jcolumn+1]],
              meshNodeNumbers[[ilayer+1,jcolumn]],
              meshNodeNumbers[[ilayer+1,jcolumn+1]]};
          If[layers[[ilayer,jcolumn]][[2]]>0,
            If[layers[[ilayer,jcolumn+1]][[2]]>0,
              {imsMakeTriangleLinear1DOF[++elementNumber,List[n1,n2,n3],{}],
                imsMakeTriangleLinear1DOF[++elementNumber,
                  List[n2,n4,n3],{}]},
              imsMakeTriangleLinear1DOF[++elementNumber,List[n1,n2,n3],{}]
              ],
            If[layers[[ilayer,jcolumn+1]][[2]]>0,
              imsMakeTriangleLinear1DOF[++elementNumber,List[n1,n2,n4],{}],
              {{}}
              ]
            ]
          ];
      
      (* The code *)
      
      d=imsStackDepth[ls];
      uniqueNodes=Table[False,{d+1},{n}];
      currentLayer=1;
      uniqueNodes[[currentLayer]]=
        MapIndexed[checkThickness,List@@layers[[1]]];
      checkLayer[#]&/@Range[d];
      
      meshNodeNumbers=Map[numberNodes,uniqueNodes,{2}];
      MapIndexed[resolveHangingNumbers,meshNodeNumbers,{2}];
      
      elements=
        Flatten[Map[generateElements,
            Flatten[Outer[List,Range[d],Range[n-1]],1]]];
      coordinates=(Transpose[{Table[(i delta),{i,0,n-1}],#}])&/@
          Join[{MapIndexed[(#[[1]]-#[[2]])&,List@@layers[[1]]]},
            Map[#[[1]]&,Map[(List@@#)&,layers],{2}]];
      nodeCoordinateRules=
        Flatten[Union[
            MapThread[(#1\[Rule]#2)&,{meshNodeNumbers,coordinates},2]]];
      nodes=(imsMakeNode[#,#/.nodeCoordinateRules])&/@Range[nodeNumber];
      imsMakeNexus[nodes,{},elements]
      ];

imsStackToNexus[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    Module[{d,uniqueNodes,checkThickness,checkLayer,numberNodes,createNodes,
        resolveHangingNumbers,currentLayer,nodeNumber=0,elementNumber=0,
        meshNodeNumbers,generateElement,coordinates,nodes,elements},
      
      (* The local functions *)
      
      checkThickness[{z_,thickness_},{i_,j_}]:=
        If[thickness>0,True,uniqueNodes[[currentLayer,i,j]]];
      checkLayer[l_]:=Block[{},
          currentLayer=l+1;
          
          uniqueNodes[[currentLayer]]=
            MapIndexed[checkThickness,List@@layers[[l]],{2}]
          ];
      numberNodes[val_]:=If[val\[Equal]True,++nodeNumber,False];
      
      resolveHangingNumbers[val_,{ilayer_,jcolumn_,krow_}]:=
        If[!IntegerQ[val],
          If[ilayer>1,
            meshNodeNumbers[[ilayer,jcolumn,krow]]=
              meshNodeNumbers[[ilayer-1,jcolumn,krow]],
            meshNodeNumbers[[ilayer,jcolumn,krow]]=val],
          meshNodeNumbers[[ilayer,jcolumn,krow]]=val];
      
      generateElements[{ilayer_,jcolumn_,krow_}]:=
        
        Block[{n1,n2,n3,n4,n5,n6,n7,n8},
          If[Head[layers[[ilayer]]]===imsGap,Return[{{}}]];
          {n1,n2,n3,n4,n5,n6,n7,n8}={meshNodeNumbers[[ilayer,jcolumn,krow]],
              meshNodeNumbers[[ilayer,jcolumn+1,krow]],
              meshNodeNumbers[[ilayer+1,jcolumn,krow]],
              meshNodeNumbers[[ilayer+1,jcolumn+1,krow]],
              meshNodeNumbers[[ilayer,jcolumn,krow+1]],
              meshNodeNumbers[[ilayer,jcolumn+1,krow+1]],
              meshNodeNumbers[[ilayer+1,jcolumn,krow+1]],
              meshNodeNumbers[[ilayer+1,jcolumn+1,krow+1]]};
          
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n5,n3],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n5,n8],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n3,n4,n8,n2],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n3,n8,n7,n5],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n5,n3,n8],{}]}]
            ];
          
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n6,n5,n7],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n6,n4],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n4,n8,n6,n7],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n7,n4,n6],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n5,n3],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n5,n8],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n3,n8,n7,n5],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n5,n3,n8],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n5,n3],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n5,n8],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n3,n4,n8,n2],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n5,n3,n8],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n6,n5,n7],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n3,n7,n4],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n6,n4],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n7,n4,n6],{}]}]
            ];
          
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n5,n6,n7],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n6,n2,n7],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n8,n7],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n6,n4],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n5,n1,n6,n4],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n5,n1,n3,n4],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n5,n8],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n5,n8],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n4,n8],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n5,n3],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n5,n3],{}],
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n7,n5,n6,n3],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n3,n5],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n8,n5],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n4,n6],{}],
                
                imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n6,n5,n7],{}]}]
            ];
          
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]>0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n2,n6,n5,n8],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n5,n3],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]>0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n2,n6,n4],{}]}]
            ];
          
          If[layers[[ilayer,jcolumn,krow]][[2]]==0&&
              layers[[ilayer,jcolumn+1,krow]][[2]]==0&&
              layers[[ilayer,jcolumn,krow+1]][[2]]>0&&
              layers[[ilayer,jcolumn+1,krow+1]][[2]]==0,
            
            Return[{imsMakeTetrahedronLinear1DOF[++elementNumber,
                  List[n1,n6,n5,n7],{}]}]
            ];
          Return[{{}}]
          ];
      
      
      (* The code *)
      
      d=imsStackDepth[ls];
      uniqueNodes=Table[False,{d+1},{nX},{nY}];
      currentLayer=1;
      uniqueNodes[[currentLayer]]=
        MapIndexed[checkThickness,List@@layers[[1]],{2}];
      Map[checkLayer[#]&,Range[d]];
      
      meshNodeNumbers=Map[numberNodes,uniqueNodes,{3}];
      MapIndexed[resolveHangingNumbers,meshNodeNumbers,{3}];
      
      elements=
        Flatten[Map[generateElements,
            Flatten[Outer[List,Range[d],Range[nX-1],Range[nY-1]],2]]];
      coordinates=
        MapThread[
              Join,{Outer[List,Table[(i deltaX),{i,0,nX-1}],
                  Table[(i deltaY),{i,0,nY-1}]],#},2]&/@(Map[{#}&,
              Join[{MapIndexed[(#[[1]]-#[[2]])&,List@@layers[[1]],{2}]},
                Map[#[[1]]&,Map[(List@@#)&,layers],{3}]],{3}]);
      
      nodeCoordinateRules=
        Flatten[Union[
            MapThread[(#1\[Rule]#2)&,{meshNodeNumbers,coordinates},3]]];
      nodes=(imsMakeNode[#,#/.nodeCoordinateRules])&/@Range[nodeNumber];
      
      imsMakeNexus[nodes,{},elements]
      ];





imsStackToDomainNexus[
      ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{nodes,layerToSegments,topCoords,botCoords,layerThickness},
      
      (* local functions *)
      layerToSegments[l_]:=Module[{h,newL},
          h=Head[l];
          
          newL=List@@
              Split[h@@MapIndexed[(Join[{(#2[[1]]-1)delta},#1])&,(List@@
                        l)],((#1[[-1]]\[NotEqual]0&&#2[[-1]]\[NotEqual]0)||(#\
1[[-1]]==0&&#2[[-1]]==0))&]
          ];
      topCoords[l_]:=List@@(#[[1]]&/@l);
      botCoords[l_]:=List@@((#[[1]]-#[[2]])&/@l);
      layerThickness[l_]:=List@@(#[[2]]&/@l);
      
      t=Drop[topCoords[#]&/@layers,1];
      b=Drop[botCoords[#]&/@layers,-1];
      h=layerThickness[#]&/@layers;
      
      Print[t];
      Print[MapThread[(#1-#2)&,{t,b}]];
      
      layerToSegments[#]&/@layers
      (*imsMakeNexus[nodes,{},elements]*)
      ];

imsStackToDomainNexus[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=Module[{},
      
      imsMakeNexus[nodes,{},elements]
      ];



(* *)
(* private functions *)
(* *)



(* imsDeposit, imsPattern, imsReflow, imsStrip, imsDrill, imsMill, \
imsPlanarize, imsErode, imsEmboss, imsWetEtch, imsGrow, imsCut, imsBond, \
imsFlip, imsRotate, imsDispense *)

ProcessStep[
      ls_imsStack,{imsDeposit,material_Symbol,thickness:(_Integer|_Real)}]:=
    imsStackDeposit[ls,material,thickness];

ProcessStep[
      ls_imsStack,{imsPattern,material_Symbol,thickness:(_Integer|_Real),
        mask_imsBitMask,field_Symbol}]:=
    imsStackPattern[ls,material,thickness,mask,field];

ProcessStep[ls_imsStack,{imsReflow,material_Symbol}]:=
    imsStackReflow[ls,material];

ProcessStep[ls_imsStack,{imsStrip,material_Symbol}]:=
    imsStackStrip[ls,material];

ProcessStep[ls_imsStack,{imsDrill,holes:{{__}..}}]:=imsStackDrill[ls,holes];

ProcessStep[ls_imsStack,{imsMill,paths:{{__}..}}]:=imsStackMill[ls,paths];

ProcessStep[ls_imsStack,{imsPlanarize,depth_}]:=imsStackPlanarize[ls,depth];

ProcessStep[ls_imsStack,{imsErode,mask_imsBitMask,field_,depth_}]:=
    imsStackErode[ls,mask,field,depth];

ProcessStep[
      ls_imsStack,{imsEmboss,material_Symbol,
        slicethickness:(_Integer|_Real)}]:=
    imsStackEmboss[ls,material,slicethickness];

ProcessStep[ls_imsStack,{imsWetEtch,material_Symbol,depth:(_Integer|_Real)}]:=
    imsStackWetEtch[ls,material,depth];

ProcessStep[
      ls_imsStack,{imsGrow,
        attackMaterial_Symbol->growMaterial_Symbol,{tgrow:(_Integer|_Real),
          tconsume:(_Integer|_Real),wcovered:(_Integer|_Real)}}]:=
    imsStackGrow[ls,attackMaterial->growMaterial,{tgrow,tconsume,wcovered}];

ProcessStep[ls_imsStack,{imsCut,position_Integer}]:=imsStackCut[ls,position];

ProcessStep[lsBottom_imsStack,{imsBond,lstop_imsStack}]:=
    imsStackBond[lsBottom,lstop];

ProcessStep[ls_imsStack,{imsFlip}]:=imsStackFlip[ls];

ProcessStep[ls_imsStack,{imsRotate}]:=imsStackRotate[ls];

ProcessStep[ls_imsStack,{imsDispense,data_List}]:=
    imsDispenseStack[ls,material,data];



skyline[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    
    Module[{processSite,layerDepth=Length[layers]},
      
      processSite[i_Integer]:=Block[{height=layerDepth,z,t},
          While[height>0,
            {z,t}=(List@@(layers[[height]]))[[i]];
            If[t\[Equal]0,
              --height,
              Return[z]
              ]
            ];
          Return[0]
          ];
      
      processSite[#]&/@Range[n]
      ];

skyline[ls:
        imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    
    Module[{processSite,layerDepth=Length[layers]},
      
      processSite[{i_Integer,j_Integer}]:=Block[{height=layerDepth,z,t},
          While[height>0,
            {z,t}=(List@@(layers[[height]]))[[i,j]];
            If[t\[Equal]0,
              --height,
              Return[z]
              ]
            ];
          Return[0]
          ];
      
      Map[processSite,Outer[List,Range[nX],Range[nY]],{2}]
      ];



flattenStack[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{height=Length[layers],processSite,currentLayer,nz,nt},
      processSite[{z_,t_},{m_Integer}]:=
        
        If[(t==0)&&(layers[[currentLayer,m+1,2]]==
                  0)&&(layers[[currentLayer,m-1,2]]==0),
            {layers[[currentLayer-1,m,1]],0},
            {z,t}
            ]/;(m>1&&m<n);
      processSite[{z_,t_},{m_Integer}]:=
        
        If[(t==0)&&(layers[[currentLayer,m+1,2]]==0),
            {layers[[currentLayer-1,m,1]],0},
            {z,t}
            ]/;(m==1);
      processSite[{z_,t_},{m_Integer}]:=
        
        If[(t==0)&&(layers[[currentLayer,m-1,2]]==0),
            {layers[[currentLayer-1,m,1]],0},
            {z,t}
            ]/;(m==n);
      imsStack[
        Join[{layers[[1]]},
          Table[MapIndexed[processSite,layers[[currentLayer]]],{currentLayer,
              2,height}]],{delta,n}]
      ];
flattenStack[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=ls;



dropEmptyLayersFromStack[
      ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{newLayers},
      
      processSite[{z_,t_}]:=
        If[(t==0),
          True,
          False
          ];
      
      (* Drop the collapsed layers *)
      
      newLayers=
        Drop[layers,
          Flatten[Position[(And@@Map[processSite,#])&/@layers,True]]];
      
      (* Drop any top imsGap layer: there may be many of them! *)
      
      While[Length[newLayers]>0&&Head[newLayers[[-1]]]\[Equal]imsGap,
        newLayers=Drop[newLayers,-1]
        ];
      
      If[Length[newLayers]\[Equal]0,
        Message[Stack::mt]
        ];
      
      imsStack[newLayers,{delta,n}]
      ];

dropEmptyLayersFromStack[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    Module[{height=Length[layers],processSite,currentLayer,nz,nt},
      
      processSite[{z_,t_}]:=
        If[(t==0),
          True,
          False
          ];
      
      (* Drop the collapsed layers *)
      
      newLayers=
        Drop[layers,
          Flatten[Position[(And@@Flatten[List@@Map[processSite,#,{2}]])&/@
                layers,True]]];
      
      (* Drop any top imsGap layer: there may be many of them! *)
      
      While[Length[newLayers]>0&&Head[newLayers[[-1]]]\[Equal]imsGap,
        newLayers=Drop[newLayers,-1]
        ];
      
      If[Length[newLayers]\[Equal]0,
        Message[Stack::mt]
        ];
      
      imsStack[newLayers,{{deltaX,nX},{deltaY,nY}}]
      ];



growGrid[g:{(_)..},delta_,thickness_]:=
    Module[{myCircle,n,m,addCircle,newGrid},
      newGrid=g;
      m=Length[g];
      n=Floor[thickness/delta];
      
      addCircle[z_,{i_}]:=Block[{minG,minC,maxG,maxC,zTest,j,k},
          minC=Max[1,n-i+1];
          maxC=Min[2n-1,(m-i+n)];
          minG=Max[1,i-n+1];
          maxG=Min[i+n,m];
          j=minC;
          k=minG;
          While[j<=maxC,
            zTest=(z+myCircle[[j]]);
            If[newGrid[[k]]<zTest,
              newGrid[[k]]=zTest
              ];
            ++j;
            ++k
            ]
          ];
      
      If[n>0,
        myCircle=Table[Sqrt[thickness^2-((n-i)delta)^2]//N,{i,1,2n-1}];
        MapIndexed[addCircle,g],
        newGrid=(#+thickness)&/@g;
        ];
      newGrid
      ];

growGrid[g:{{(_)..}..},deltaX_,deltaY_,thickness_]:=
    Module[{mySphere,n,m,p,q,addSphere,newGrid},
      newGrid=g;
      m=Length[g];
      n=Length[g[[1]]];
      p=Floor[thickness/deltaX];
      q=Floor[thickness/deltaY];
      
      addSphere[z_,{i_,j_}]:=
        Block[{minGX,minCX,maxGX,maxCX,minGY,minCY,maxGY,maxCY,zTest,l,k,r,
            s},
          
          minCX=Max[1,p-i+1];
          maxCX=Min[2p-1,(m-i+p)];
          minGX=Max[1,i-p+1];
          maxGX=Min[i+p,m];
          
          minCY=Max[1,q-j+1];
          maxCY=Min[2q-1,(n-j+q)];
          minGY=Max[1,j-q+1];
          maxGY=Min[j+q,n];
          
          l=minCX;
          k=minGX;
          While[l<=maxCX,
            r=minCY;
            s=minGY;
            While[r<=maxCY,
              zTest=(z+mySphere[[l,r]]);
              If[newGrid[[k,s]]<zTest,
                newGrid[[k,s]]=zTest
                ];
              ++r;
              ++s
              ];
            ++l;
            ++k
            ]
          ];
      
      If[p==0||q\[Equal]0,
        mySphere=
          Table[If[(rr=N[thickness^2-((p-i)deltaX)^2-((q-j)deltaY)^2])<0,0,
              Sqrt[rr]],{i,1,2p-1},{j,1,2q-1}];
        
        MapIndexed[addSphere,g,2],
        newGrid=Map[(#+thickness)&,g,{2}];
        ];
      newGrid
      ];



\!\(\(\(paintGrid[g : {\((_Symbol)\) .. }, {delta_?NumericQ, radius_?NumericQ, brushForm_Function}] := Module[{myBrush, n, m, addBrush, newGrid}, \[IndentingNewLine]m = Length[g]; \[IndentingNewLine]newGrid = Table[0, {m}]; \[IndentingNewLine]n = Floor[radius/delta]; \[IndentingNewLine]\[IndentingNewLine]addBrush[z_, {i_}] := Block[{minG, minC, maxG, maxC, zTest, j, k}, \[IndentingNewLine]If[z, \[IndentingNewLine]minC = Max[1, n - i + 1]; \[IndentingNewLine]maxC = Min[2  n - 1, \((m - i + n)\)]; \[IndentingNewLine]minG = Max[1, i - n + 1]; \[IndentingNewLine]maxG = Min[i + n, m]; \[IndentingNewLine]j = minC; \[IndentingNewLine]k = minG; \[IndentingNewLine]While[j <= maxC, \[IndentingNewLine]zTest = \((myBrush[\([j]\)])\); \[IndentingNewLine]If[newGrid[\([k]\)] < zTest, \[IndentingNewLine]newGrid[\([k]\)] = zTest\[IndentingNewLine]]; \[IndentingNewLine]\(++j\); \[IndentingNewLine]\(++k\)\[IndentingNewLine]]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]If[n > 0, \[IndentingNewLine]myBrush = Table[brushForm[\((n - i)\) delta] // N, {i, 1, 2  n - 1}]; \[IndentingNewLine]MapIndexed[addBrush, g], \[IndentingNewLine]\(newGrid = \(\((# + brushForm[0])\) &\) /@ newGrid;\)\[IndentingNewLine]]; \[IndentingNewLine]newGrid\[IndentingNewLine]];\)\(\[IndentingNewLine]\)
  \)\[IndentingNewLine]
  \(paintGrid[g : {{\((_Symbol)\) .. } .. }, {deltaX_?NumericQ, deltaY_?NumericQ, radius_?NumericQ, brushForm_Function}] := Module[{myBrush, n, m, p, q, addBrush, newGrid}, \[IndentingNewLine]m = Length[g]; \[IndentingNewLine]n = Length[g[\([1]\)]]; \[IndentingNewLine]newGrid = Table[0, {m}, {n}]; \[IndentingNewLine]p = Floor[radius/deltaX]; \[IndentingNewLine]q = Floor[radius/deltaY]; \[IndentingNewLine]\[IndentingNewLine]addBrush[z_, {i_, j_}] := Block[{minGX, minCX, maxGX, maxCX, minGY, minCY, maxGY, maxCY, zTest, l, k, r, s}, \[IndentingNewLine]\[IndentingNewLine]If[z, \[IndentingNewLine]minCX = Max[1, p - i + 1]; \[IndentingNewLine]maxCX = Min[2  p - 1, \((m - i + p)\)]; \[IndentingNewLine]minGX = Max[1, i - p + 1]; \[IndentingNewLine]maxGX = Min[i + p, m]; \[IndentingNewLine]\[IndentingNewLine]minCY = Max[1, q - j + 1]; \[IndentingNewLine]maxCY = Min[2  q - 1, \((n - j + q)\)]; \[IndentingNewLine]minGY = Max[1, j - q + 1]; \[IndentingNewLine]maxGY = Min[j + q, n]; \[IndentingNewLine]\[IndentingNewLine]l = minCX; \[IndentingNewLine]k = minGX; \[IndentingNewLine]While[l <= maxCX, \[IndentingNewLine]r = minCY; \[IndentingNewLine]s = minGY; \[IndentingNewLine]While[r <= maxCY, \[IndentingNewLine]zTest = \((myBrush[\([l, r]\)])\); \[IndentingNewLine]If[newGrid[\([k, s]\)] < zTest, \[IndentingNewLine]newGrid[\([k, s]\)] = zTest\[IndentingNewLine]]; \[IndentingNewLine]\(++r\); \[IndentingNewLine]\(++s\)\[IndentingNewLine]]; \[IndentingNewLine]\(++l\); \[IndentingNewLine]\(++k\)\[IndentingNewLine]]\[IndentingNewLine]]\[IndentingNewLine]]; \[IndentingNewLine]\[IndentingNewLine]If[p > 0 || q > 0, \[IndentingNewLine]myBrush = Table[N[brushForm[\@\(\((\((p - i)\) deltaX)\)^2 + \((\((q - j)\) deltaY)\)^2\)]], {i, 1, 2  p - 1}, {j, 1, 2  q - 1}]; \[IndentingNewLine]\[IndentingNewLine]MapIndexed[addBrush, g, 2], \[IndentingNewLine]\(newGrid = Map[\((# + N[brushForm[0]])\) &, newGrid, {2}];\)\[IndentingNewLine]]; \[IndentingNewLine]newGrid\[IndentingNewLine]];\)\)



trimStack[ st:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      newHeights:{(_)..}]:=Module[{nlayers,newLayers,processSite},
      
      processSite[{z_,t_},{i_}]:=Block[{znew=newHeights[[i]],tnew},
          If[znew\[Equal]Infinity||znew\[GreaterEqual]z,Return[{z,t}]];
          If[znew<z,
            If[(tnew=t-(z-znew))>t||tnew<0,
              Return[{z-t,0}],
              Return[{znew,tnew}]
              ]
            ];
          Return[{0,0}]
          ];
      
      nlayers=Length[layers];
      Return[
        imsStack[
          Table[MapIndexed[processSite,layers[[l]]],{l,1,nlayers}],{delta,
            n}]]
      ];

trimStack[ 
      st:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      newHeights:{{(_)..}..}]:=Module[{nlayers,newLayers,processSite},
      
      processSite[{z_,t_},{i_,j_}]:=Block[{znew=newHeights[[i,j]],tnew},
          If[znew\[Equal]Infinity||znew\[GreaterEqual]z,Return[{z,t}]];
          If[znew<z,
            If[(tnew=t-(z-znew))>t||tnew<0,
              Return[{z-t,0}],
              Return[{znew,tnew}]
              ]
            ];
          Return[{0,0}]
          ];
      
      nlayers=Length[layers];
      Return[
        imsStack[
          Table[MapIndexed[processSite,layers[[l]],{2}],{l,1,
              nlayers}],{{deltaX,nX},{deltaY,nY}}]]
      ];







layersSeparation[bottomLayer_,topLayer_]:=Module[{tl,bl},
      tl=List@@topLayer;bl=List@@bottomLayer;
      If[Depth[tl]\[Equal]3,
        Return[Map[(#[[1]]-#[[2]])&,tl]-Map[(#[[1]])&,bl]]
        ];
      If[Depth[tl]\[Equal]4,
        Return[Map[(#[[1]]-#[[2]])&,tl,{2}]-Map[(#[[1]])&,bl,{2}]]
        ];
      {}
      ];



translateStack[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}],
      deltaZ:(_Integer|_Real)]:=
    imsStack[Map[{#[[1]]+deltaZ,#[[2]]}&,layers,{2}],{delta,n}];

translateStack[
      ls:imsStack[
          layers_,{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}],
      deltaZ:(_Integer|_Real)]:=
    imsStack[Map[{#[[1]]+deltaZ,#[[2]]}&,
        layers,{3}],{{deltaX,nX},{deltaY,nY}}];



EtchAngle[Silicon,100,KOH]=(54.7 Pi/180.);

EtchStep[horizontalStep_]:=Tan[EtchAngle[Silicon,100,KOH]]*horizontalStep;



maxdepth=0;

evolveLayerEtchfront[l_,mask:{(_Symbol)..},delta_,howDeep_]:=
    Module[{etchFront,maskCell,deltaZ,digitizeZ,trimFront},
      
      digitizeZ[z_]:=Round[N[z/deltaZ]];
      normalizeZ[d_]:=N[d*deltaZ];
      maskCell[c:(_MaskCell|_FreeCell),{i_}]:=Module[{},
          If[mask[[i]],
            c,
            MaskCell@@c
            ]
          ];
      trimFront[newZ_,{oldZ_,oldT_}]:=If[newZ<(oldZ-oldT),
          {oldZ-oldT,0},{newZ,oldT-(oldZ-newZ)}
          ];
      
      deltaZ=EtchStep[delta];
      maxdepth=digitizeZ[howDeep];
      
      etchFront=
        MapIndexed[maskCell,Map[FreeCell[digitizeZ[#[[1]]]]&,(List@@l)]];
      
      etchFront=
        Map[normalizeZ[#[[1]]]&,
          Nest[evolveArray,etchFront,2digitizeZ[howDeep]]];
      
      etchFront=MapThread[trimFront[#1,#2]&,{etchFront,List@@l}];
      
      Head[l]@@etchFront 
      
      ];

evolveLayerEtchfront[l_,mask:{{(_Symbol)..}..},delta_,howDeep_]:=
    Module[{etchFront,maskCell,deltaZ,digitizeZ,trimFront},
      
      digitizeZ[z_]:=Round[N[z/deltaZ]];
      normalizeZ[d_]:=N[d*deltaZ];
      
      maskCell[c:(_MaskCell|_FreeCell),{i_,j_}]:=Module[{},
          If[mask[[i,j]],
            c,
            MaskCell@@c
            ]
          ];
      trimFront[newZ_,{oldZ_,oldT_}]:=If[newZ<(oldZ-oldT),
          {oldZ-oldT,0},{newZ,oldT-(oldZ-newZ)}
          ];
      
      deltaZ=EtchStep[delta];
      maxdepth=digitizeZ[howDeep];
      
      etchFront=
        MapIndexed[maskCell,
          Map[FreeCell[digitizeZ[#[[1]]]]&,(List@@l),{2}],{2}];
      
      etchFront=
        Map[normalizeZ[#[[1]]]&,
          Nest[evolveArray,etchFront,2digitizeZ[howDeep]],{2}];
      
      etchFront=MapThread[trimFront[#1,#2]&,{etchFront,List@@l},2];
      
      Head[l]@@etchFront 
      
      ];


evolveArray[myArray:{(_FreeCell|_MaskCell)..}]:=
    Module[{createEntryArray,etchRules,m},
      
      m=Length[myArray];
      
      etchRules={
          {a_,b_,c_}/;
              Block[{},((a[[1]]\[Equal](b[[1]]+1))&&((c[[1]])\[Equal]((b[[1]])\
-1)))]\[Rule](b),(* 
            left wall *)
          {a_,b_,c_}/;
              Block[{},(((a[[1]])\[Equal]((b[[1]])-1))&&((c[[1]])\[Equal]((b[[\
1]])+1)))]\[Rule](b),(* 
            right wall *)
          {MaskCell[a_],FreeCell[b_],_}/;
              Block[{},((b)<(a))]\[Rule](FreeCell[b]),(* 
            mask *)
          {_,MaskCell[a_],_}\[Rule](MaskCell[a]),(* 
            mask *)
          {FreeCell[b_],FreeCell[b_],FreeCell[b_]}\[Rule]
            FreeCell[(b-1)],(* flat *)
          {_,b_,_}\[Rule](b)(* 
            default *)
          };
      
      createEntryArray[v_,{i_}]:=Module[{fi},
          fi=myArray[[i]];
          If[i>1&&i<m,
            Return[{myArray[[i-1]],fi,myArray[[i+1]]}]
            ];
          
          If[i==1,
            Return[{fi,fi,myArray[[i+1]]}]
            ];
          If[i\[Equal]m,
            Return[{myArray[[i-1]],fi,fi}]
            ];
          
          Infinity
          ];
      MapIndexed[createEntryArray,myArray,{1}]/.etchRules
      ];

evolveArray[myArray:{{(_FreeCell|_MaskCell)..}..}]:=
    Module[{createEntryArray,etchRules,m,n},
      
      {m,n}=Dimensions[myArray];
      
      etchRules={
          {{a_,FreeCell[b_],c_},{a_,FreeCell[b_],c_},{a_,FreeCell[b_],
                  c_}}/;(a[[1]]\[Equal]b+1&&
                  c[[1]]\[Equal]b-1)\[Rule](FreeCell[b]),(* 
            left wall *)
          {{a_,FreeCell[b_],c_},{a_,FreeCell[b_],
                  c_},{a_,FreeCell[b_],c_}}/;(a[[1]]\[Equal]b-1&&
                  c[[1]]\[Equal]b+1)\[Rule](FreeCell[b]),(* 
            right wall *)
          {{a_,a_,a_},{FreeCell[b_],FreeCell[b_],
                  FreeCell[b_]},{c_,c_,c_}}/;(a[[1]]\[Equal]b+1&&
                  c[[1]]\[Equal]b-1)\[Rule](FreeCell[b]),(* 
            back wall *)
          {{a_,a_,a_},{FreeCell[b_],FreeCell[b_],
                  FreeCell[b_]},{c_,c_,c_}}/;(a[[1]]\[Equal]b-1&&
                  c[[1]]\[Equal]b+1)\[Rule](FreeCell[b]),(* 
            front wall *)
          
          {{a_,a_,a_},{a_,FreeCell[b_],FreeCell[b_]},{a_,FreeCell[b_],
                  c_}}/;(a[[1]]\[Equal]b+1&&
                  c[[1]]\[Equal]b-1)\[Rule](FreeCell[b]),(* 
            left-back corner *)
          {{a_,a_,a_},{FreeCell[b_],
                  FreeCell[b_],a_},{c_,FreeCell[b_],a_}}/;(a[[1]]\[Equal]b+1&&
                  c[[1]]\[Equal]b-1)\[Rule](FreeCell[b]),(* 
            right-back corner *)
          {{a_,FreeCell[b_],c_},{a_,
                  FreeCell[b_],FreeCell[b_]},{a_,a_,a_}}/;(a[[1]]\[Equal]b+1&&
                  c[[1]]\[Equal]b-1)\[Rule](FreeCell[b]),(* 
            left-front corner *)
          {{c_,FreeCell[b_],
                  a_},{FreeCell[b_],FreeCell[b_],a_},{a_,a_,
                  a_}}/;(a[[1]]\[Equal]b+1&&
                  c[[1]]\[Equal]b-1)\[Rule](FreeCell[b]),(* 
            right-front corner *)
          
          {{_,_,_},{MaskCell[b_],MaskCell[b_],
                MaskCell[b_]},{_,_,_}}\[Rule](MaskCell[b]),(* 
            mask *)
          {{_,MaskCell[b_],_},{_,MaskCell[b_],_},{_,
                MaskCell[b_],_}}\[Rule](MaskCell[b]),(* 
            mask *)
          {{_,_,_},{FreeCell[a_],
                  MaskCell[b_],_},{_,_,_}}/;(b\[Equal]a-1)\[Rule](MaskCell[
                b]),(* mask *)
          {{_,_,_},{_,MaskCell[b_],
                  FreeCell[a_]},{_,_,_}}/;(b\[Equal]a-1)\[Rule](MaskCell[b]),(* 
            mask *)
          {{_,FreeCell[a_],_},{_,
                  MaskCell[b_],_},{_,_,_}}/;(b\[Equal]a-1)\[Rule](MaskCell[
                b]),(* mask *)
          {{_,_,_},{_,MaskCell[b_],_},{_,
                  FreeCell[a_],_}}/;(b\[Equal]a-1)\[Rule](MaskCell[b]),(* 
            mask *)
          
          {{_,MaskCell[b_],_},{MaskCell[b_],MaskCell[b_],
                  FreeCell[a_]},{_,_,_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,MaskCell[b_],_},{MaskCell[b_],
                  MaskCell[b_],_},{_,FreeCell[a_],_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,_,_},{MaskCell[b_],MaskCell[b_],
                  FreeCell[a_]},{_,MaskCell[b_],_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,FreeCell[a_],_},{MaskCell[b_],
                  MaskCell[b_],_},{_,MaskCell[b_],_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,MaskCell[b_],_},{FreeCell[a_],
                  MaskCell[b_],MaskCell[b_]},{_,_,_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,MaskCell[b_],_},{_,MaskCell[b_],
                  MaskCell[b_]},{_,FreeCell[a_],_}}/;(a<b&&b>maxdepth)\[Rule]
            FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,_,_},{FreeCell[a_],MaskCell[b_],
                  MaskCell[b_]},{_,MaskCell[b_],_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,FreeCell[a_],_},{_,MaskCell[b_],
                  MaskCell[b_]},{_,MaskCell[b_],_}}/;(a<b&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          
          {{_,FreeCell[a_],_},{_,MaskCell[b_],FreeCell[c_]},{_,
                  FreeCell[d_],_}}/;((a<b||c<b||d<b)&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,_,_},{FreeCell[a_],MaskCell[b_],
                  FreeCell[c_]},{_,FreeCell[d_],_}}/;((a<b||c<b||d<b)&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,FreeCell[a_],_},{FreeCell[c_]_,
                  MaskCell[b_],_},{_,FreeCell[d_],_}}/;((a<b||c<b||d<b)&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          {{_,FreeCell[d_],_},{FreeCell[a_],
                  MaskCell[b_],FreeCell[c_]},{_,_,_}}/;((a<b||c<b||d<b)&&
                  b>maxdepth)\[Rule]FreeCell[(b-1)],(* 
            mask underetch *)
          
          
          {{FreeCell[a_],FreeCell[a_],FreeCell[a_]},{FreeCell[a_],
                  FreeCell[a_],FreeCell[a_]},{FreeCell[a_],FreeCell[a_],
                  FreeCell[a_]}}/;(a>maxdepth)\[Rule]FreeCell[a-1],(* 
            flat *)
          {{a_,b_,c_},{d_,FreeCell[e_],f_},{g_,h_,
                  i_}}/;(e\[GreaterEqual]a[[1]]&&e\[GreaterEqual]b[[1]]&&
                  e\[GreaterEqual]c[[1]]&&e\[GreaterEqual]d[[1]]&&
                  e\[GreaterEqual]f[[1]]&&e\[GreaterEqual]g[[1]]&&
                  e\[GreaterEqual]h[[1]]&&e\[GreaterEqual]i[[1]]&&
                  e>maxdepth)\[Rule]FreeCell[e-1],(* 
            peak *)
          {{_,_,_},{_,a_,_},{_,_,_}}\[Rule](a)(* 
            default *)
          };
      
      createEntryArray[v_,{i_,j_}]:=Module[{fij},
          fij=myArray[[i,j]];
          If[i>1&&i<m&&j>1&&j<n,
            
            Return[{{myArray[[i-1,j-1]],myArray[[i-1,j]],
                  myArray[[i-1,j+1]]},{myArray[[i,j-1]],fij,
                  myArray[[i,j+1]]},{myArray[[i+1,j-1]],myArray[[i+1,j]],
                  myArray[[i+1,j+1]]}}]
            ];
          
          If[i==1j==1,
            
            Return[{{fij,fij,myArray[[i,j+1]]},{fij,fij,
                  myArray[[i,j+1]]},{myArray[[i+1,j]],myArray[[i+1,j]],
                  myArray[[i+1,j+1]]}}]
            ];
          If[i==1&&j\[Equal]n,
            
            Return[{{myArray[[i,j-1]],fij,fij},{myArray[[i,j-1]],fij,
                  fij},{myArray[[i+1,j-1]],myArray[[i+1,j]],
                  myArray[[i+1,j]]}}]
            ];
          If[i\[Equal]m&&j\[Equal]n,
            
            Return[{{myArray[[i-1,j-1]],myArray[[i-1,j]],
                  myArray[[i-1,j]]},{myArray[[i,j-1]],fij,
                  fij},{myArray[[i,j-1]],fij,fij}}]
            ];
          If[i\[Equal]m&&j\[Equal]1,
            
            Return[{{myArray[[i-1,j]],myArray[[i-1,j]],
                  myArray[[i-1,j+1]]},{fij,fij,myArray[[i,j+1]]},{fij,fij,
                  myArray[[i,j+1]]}}]
            ];
          
          If[i==1&&j>1&&j<n,
            
            Return[{{myArray[[i,j-1]],fij,myArray[[i,j+1]]},{myArray[[i,j-1]],
                  fij,myArray[[i,j+1]]},{myArray[[i+1,j-1]],myArray[[i+1,j]],
                  myArray[[i+1,j+1]]}}]
            ];
          If[i\[Equal]m&&j>1&&j<n,
            
            Return[{{myArray[[i-1,j-1]],myArray[[i-1,j]],
                  myArray[[i-1,j+1]]},{myArray[[i,j-1]],fij,
                  myArray[[i,j+1]]},{myArray[[i,j-1]],fij,myArray[[i,j+1]]}}]
            ];
          If[i>1&&i<m&&j==1,
            
            Return[{{myArray[[i-1,j]],myArray[[i-1,j]],
                  myArray[[i-1,j+1]]},{fij,fij,
                  myArray[[i,j+1]]},{myArray[[i+1,j]],myArray[[i+1,j]],
                  myArray[[i+1,j+1]]}}]
            ];
          If[i>1&&i<m&&j==n,
            
            Return[{{myArray[[i-1,j-1]],myArray[[i-1,j]],
                  myArray[[i-1,j]]},{myArray[[i,j-1]],fij,
                  fij},{myArray[[i+1,j-1]],myArray[[i+1,j]],
                  myArray[[i+1,j]]}}]
            ];
          
          Infinity
          ];
      MapIndexed[createEntryArray,myArray,{2}]/.etchRules
      ];



sampleLine[l:{{_,_}..},m_Integer]:=
    Module[{currentPoint,n,currentX,dX,samples,x0,x1,a,currentIndex},
      n=Length[l];
      currentX=l[[1,1]];
      dX=(l[[n,1]]-l[[1,1]])/(m-1);
      
      samples={l[[1]]};
      currentPoint=2;
      currentIndex=1;
      While[currentPoint<=m,
        currentX+=dX;
        While[currentIndex<n,
          
          If[currentX\[GreaterEqual](x0=l[[currentIndex,1]])&&
              currentX\[LessEqual](x1=l[[currentIndex+1,1]]),
            a=(currentX-x0)/(x1-x0);
            
            AppendTo[
              samples,{currentX,
                l[[currentIndex,2]]+
                  a(l[[currentIndex+1,2]]-l[[currentIndex,2]])}];
            ++currentPoint;
            Break[],
            ++currentIndex
            ]
          ]
        ];
      Return[samples]
      
      ];



refineLine[l:{{_,_}..},s_Integer]:=Module[{n},
      n=Length[l];
      Flatten[
        Table[Table[l[[i]]+j((l[[i+1]]-l[[i]])/s),{j,0.,s-1}],{i,1,n-1}],1]
      ];



(* Good to find out where an etchant could attack! *)

topmostLayer[ls:imsStack[layers_,{delta:(_Integer|_Real),n_Integer}]]:=
    Module[{processZeroes},
      
      processZeroes[index_Integer]:=Block[{height=Length[layers],z,t},
          While[height>0,
            {z,t}=(List@@(layers[[height]]))[[index]];
            If[t\[Equal]0,
              --height,
              Return[{z,t,height,Head[layers[[height]]]}]
              ]
            ];
          Return[Null]
          ];
      processZeroes[#]&/@Range[n]
      ];

topmostLayer[
      ls:imsStack[
          layers:{(_)..},{{deltaX:(_Integer|_Real),
              nX_Integer},{deltaY:(_Integer|_Real),nY_Integer}}]]:=
    Module[{processZeroes},
      
      processZeroes[{i_Integer,j_Integer}]:=
        Block[{height=Length[layers],z,t},
          While[height>0,
            {z,t}=(List@@(layers[[height]]))[[i,j]];
            If[t\[Equal]0,
              --height,
              Return[{z,t,height,Head[layers[[height]]]}]
              ]
            ];
          Return[Null]
          ];
      Map[processZeroes[#]&,Outer[List,Range[nX],Range[nY]],{2}]
      
      ];







End[] (* of Begin Private *)



(* Protect[] (* anything *) *)
EndPackage[] 




