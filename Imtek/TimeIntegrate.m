(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: TimeIntegrate.m *)
(* Context: *)
(* 
  Author: Christian Moosmann and Jan Lienemann *)
(* 
  Date: 22.6.2005, Freiburg *)
(* 
  Summary: This package is a collection of time integrators*)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.1.3 *)
(* 
  Mathematica Version: 5.11 *)
(* History:,
  07.12.2005: imsNewmarkIntegrate, 0.25 \[Rule] 1/4 for rational Numbers,
  11.01.2007: 
    Now supports dot products in excitation function of nonlinear parts,
  15.1.2007: NewtonIterate: HoldAll + Blocks in NewtonSolve,
  24.1.2007: Replaced some replaces by Blocks,
  22.2.2007: 
    Included imsSystem in the packages that are publically loaded as default. 
        o.r. 
  *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* 
  Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Disclaimer *)

(* Whereever the GNU GPL is not applicable, 
  the software should be used in the same spirit. *)

(* Users of this code must verify correctness for their application. *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)

(* Disclaimer: *)

(* <one line to give the program's name and a brief idea of what it does.> *)
\

(* Copyright (C) <year> <name of author> *)

(* This program is free software; *)

(* you can redistribute it and/
      or modify it under the terms of the GNU General Public License *)

(* as published by the Free Software Foundation;
  either version 2 of the License, *)

(* or (at your option) any later version.This program is distributed in the \
hope that *)

(* it will be useful,but WITHOUT ANY WARRANTY; *)

(* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \
PARTICULAR PURPOSE. *)

(* See the GNU General Public License for more details. 
      You should have received a copy of *)

(* the GNU General Public License along with this program;if not, 
  write to the *)

(* Free Software Foundation,Inc.,59 Temple Place,Suite 330,Boston,
  MA 02111-1307 USA *)



(* Start Package *)
BeginPackage["Imtek`TimeIntegrate`",{"Imtek`System`"}];





(* *)
(* documentation *)
(* *)

(* constructors *)

(* selectors *)

(* predicates *)

(* functions *)

(*imsVerletIntegrate::usage="imsVerletIntegrate[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt},List x0, List v0, Function excitation] is a Verlet explicit time integrator for a second order system.";\

  
  imsNewmarkIntegrate::usage="imsNewmarkIntegrate[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt},List x0, List v0, Function excitation] is a Newmark time integrator for a second order system. The Newmark parameters can be given as option imsNewmarkIntegrateGamma.";\

  
  imsNewmarkIntegrateTimeVariant::usage="imsNewmarkIntegrate[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt},List x0, List v0, Function excitation] is a Newmark time integrator for a second order system. The Newmark parameters can be given as option imsNewmarkIntegrateGamma. Matrices can depend on tvar.";\

  
  imsTrapezoidalIntegrate::usage="imsTrapezoidalIntegrate[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt},List x0, Function excitation] is a trapzoidal rule time integrator for a first order system. The integrator parameter can be tuned with imsTrapezoidTheta.";\

  
  imsTrapezoidalIntegrateTimeVariant::usage="imsTrapezoidalIntegrateTimeVariant[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt},List x0, Function excitation] is a trapzoidal rule time integrator for a first order system. The integrator parameter can be tuned with imsTrapezoidTheta.  Matrices can depend on tvar.";\

  
  *)

imsTimeIntegrate::usage=
      "imsTimeIntegrate[sys_imsSystem,{tvar_Symbol,tstart_Number, tend_Number, dt_Number}, x0_List, (v0_List,) excitation] integrates the imsSystem sys from time tstart to tstop starting with the states x0 and, in the case of second order systems, with velocities v0. The matrices may depend on the time variable tvar.";\

  
  imsTimeIntegrateNonlinear::usage=
    "imsTimeIntegrateNonlinear[sys_imsSystem, xvar_Symbol, {tvar_Symbol,tstart_Number, tend_Number, dt_Number}, x0_List, (v0_List,) excitation] integrates the nonlinear imsSystem sys from time tstart to tstop starting with the states x0 and, in the case of second order systems, with velocities v0. The matrices may depend on the time variable tvar and on the states xvar[\!\(\*
    StyleBox[\"i\",\nFontSlant->\"Italic\"]\)]";
  
  imsStationarySolveNonlinear::usage="imsStationarySolveNonlinear[sys_imsSystem, xvar_Symbol, {tvar_Symbol, currentime_Number}] solves a stationary nonlinear system at time currenttime."
\
  
  (*imsNewmarkIntegrateNonlinear::usage=
      "imsNewmarkIntegrateNonlinear[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt}, Symbol xvar, List x0, List v0, Function excitation] is a Newmark time integrator for a second order system. The Newmark parameters can be given as option imsNewmarkIntegrateGamma. Matrices can depend on tvar and xvar.";\

    
    imsTrapezoidalIntegrateNonlinear::usage=
      "imsNewmarkIntegrate[imsSystem sys, {Symbol tvar, Number tstart, Number tend, Number dt}, Symbol xvar, List x0, Function excitation] is a Newmark time integrator for a second order system. The Newmark parameters can be given as option imsNewmarkIntegrateGamma. Matrices can depend on tvar and xvar.";\

    
    imsNewtonIterate::usage=
      "imsNewtonIterate[imsSystem sys, {Symbol tvar, Number t}, Symbol xvar, Function excitation] is a Newton solver for a stationary system. Matrices can depend on tvar and xvar.";\
*)



(* *)
(* options docu *)
(* *)
imsOutputSteps::usage="Number of result steps to write"

imsNewmarkIntegrateGamma::usage="Damping parameter for newmark integration"

StepMonitor::usage="Step monitor as used by NDSolve"

imsTrapezoidalIntegrateTheta::usage="Implicit parameter"
imsMethod::usage="Integration method"

imsInitialAcc::usage="Initial acceleration"
imsInitialVel::usage="Initial velocity"

imsInitialState::usage="Initial state"
imsMaxIterations::usage="Maximal number of iterations for Newton"

imsMaxResidual::usage="Convergence criterion: Residual"

imsMaxDOFChange::usage="Convergence criterion: Change of DOFs"

(* For StepMonitor *)

imsResidualL2Norm::usage="Variable for L2 norm of residual";
imsIterationNumber::usage="Variable for iteration number";
imsStateVar::usage="Variable for states";



(* *)
(* error messages *)
(* *)

imsTimeIntegrate::"method"="Method `1` not known."



Begin["`Private`"];



(* *)
(* private imports *)
(* *)
Needs["Utilities`FilterOptions`"];
Needs["Imtek`SystemAnalysis`"];



(* *)
(* implementation part *)
(* *)

(* constructor *)
(* *)



(* *)
(* define your options *)
(* *)

Options[imsVerletIntegrate]={imsOutputSteps\[Rule]All,
      imsInitialAcc\[Rule]Automatic,StepMonitor\[Rule]None};
Options[imsVerletIntegrateTimeVariant]={imsOutputSteps\[Rule]All,
      imsInitialAcc\[Rule]Automatic,StepMonitor\[Rule]None};
Options[imsNewmarkIntegrate]={imsOutputSteps\[Rule]All,
      imsNewmarkIntegrateGamma\[Rule]5/100,StepMonitor\[Rule]None,
      imsInitialAcc\[Rule]Automatic};
Options[imsNewmarkIntegrateTimeVariant]={imsOutputSteps\[Rule]All,
      imsNewmarkIntegrateGamma\[Rule]5/100,StepMonitor\[Rule]None,
      imsInitialAcc\[Rule]Automatic};
Options[imsTrapezoidalIntegrate]={imsOutputSteps\[Rule]All,
      imsTrapezoidalIntegrateTheta\[Rule]1,imsInitialVel\[Rule]Automatic,
      StepMonitor\[Rule]None};
Options[imsTrapezoidalIntegrateTimeVariant]={imsOutputSteps\[Rule]All,
      imsTrapezoidalIntegrateTheta\[Rule]1,imsInitialVel\[Rule]Automatic,
      StepMonitor\[Rule]None};
Options[imsNewmarkIntegrateNonlinear]={imsOutputSteps\[Rule]All,
      imsNewmarkIntegrateGamma\[Rule]5/100,StepMonitor\[Rule]None,
      imsInitialAcc\[Rule]Automatic,imsMaxIterations\[Rule]20,
      imsMaxResidual\[Rule]1*^-10,imsMaxDOFChange\[Rule]Infinity};
Options[imsTrapezoidalIntegrateNonlinear]={imsOutputSteps\[Rule]All,
      imsTrapezoidalIntegrateTheta\[Rule]1,StepMonitor\[Rule]None,
      imsInitialVel\[Rule]Automatic,imsMaxIterations\[Rule]20,
      imsMaxResidual\[Rule]1*^-10,imsMaxDOFChange\[Rule]Infinity};
Options[imsNewtonSolve]={StepMonitor\[Rule]None,
    imsInitialState\[Rule]Automatic,imsMaxIterations\[Rule]20,
    imsMaxResidual\[Rule]1*^-10,imsMaxDOFChange\[Rule]Infinity}

Options[imsStationarySolveNonlinear]={imsMethod\[Rule]Automatic};
Options[imsTimeIntegrate]={imsMethod\[Rule]Automatic,
      imsInitialVel\[Rule]Automatic,imsInitialAcc\[Rule]Automatic,
      imsOutputSteps\[Rule]All,StepMonitor\[Rule]None};
Options[imsTimeIntegrateNonlinear]={imsMethod\[Rule]Automatic,
      imsInitialVel\[Rule]Automatic,imsInitialAcc\[Rule]Automatic,
      imsOutputSteps\[Rule]All,StepMonitor\[Rule]None};



(* selector *)
(* *)



(* predicates *)
(* *)





Options[NewtonIterate]={StepMonitor\[Rule]None};

NewtonIterate[xvar_,func_,tangentfunc_,start_,maxIt_,maxRes_,maxDx_,t_,tvar_,
      opts___]:=Module[{stepMon,funcr,tangentfuncr,x=start,xi,f,rules,j=0,res,
        resn,dx=Table[Infinity,{Length[start]}]},
      stepMon:=StepMonitor/.{opts}/.Options[NewtonIterate];
      
      Do[xi[i]=x[[i]],{i,Length[x]}];
      funcr[x2_]:=Block[{xvar=x2},func];
      tangentfuncr[x2_]:=Block[{xvar=x2},tangentfunc];
      
      res=funcr[xi];
      resn=Norm[Flatten[res]];
      While[(++j\[LessEqual]
              maxIt)&&((resn>maxRes)||(Max[Abs/@Flatten[dx]]>maxDx)),
        
        dx=
          LinearSolve[tangentfuncr[xi],-res,FilterOptions[LinearSolve,opts]];
        x+=dx;
        Do[xi[i]=x[[i]],{i,Length[x]}];
        res=funcr[xi];
        resn=Norm[Flatten[res]];
        
        Block[{tvar=t,imsResidualL2Norm=resn,xvar=x,imsStateVar=x,
            imsIterationNumber=j},stepMon];
        
        ];
      Return[x];
      ];
SetAttributes[NewtonIterate,HoldAll];

ArcLengthIterate[xvar_,func_,tangentfunc_,start_,maxIt_,maxRes_,maxDx_,t_,
      stepMon_,opts___]:=Module[{funcr,tangentfuncr,x=start},
      
      funcr[x2_]:=Block[{xvar=x2},func];
      tangentfuncr[x2_]:=Block[{xvar=x2},tangentfunc];
      
      Return[x];];
SetAttributes[ArcLengthIterate,HoldFirst];





imsNewtonSolve[
    System_imsSystem/;(imsStationaryQ[System]&&Not[imsParametricQ[System]]),
    xvar_,{tvar_,tstart_},excitation_:({1}),opts___]:=
  Module[{stepMon,firstState,maxIt,maxRes,maxDu,matS,load,xvec,start,func,
      jacobian,derivvars,a,b,tfunc,row,y,func0},
    stepMon:=StepMonitor/.{opts}/.Options[imsNewtonSolve];
    firstState=imsInitialState/.{opts}/.Options[imsNewtonSolve];
    maxIt=imsMaxIterations/.{opts}/.Options[imsNewtonSolve];
    maxRes=imsMaxResidual/.{opts}/.Options[imsNewtonSolve];
    maxDu=imsMaxDOFChange/.{opts}/.Options[imsNewtonSolve];
    matS=imsGetStiffness[System][[1]];
    load=imsGetLoad[System];
    xvec=Table[xvar[i],{i,Length[imsGetLoad[System]]}];
    start=Which[
        firstState===Automatic,Table[0,{Length[imsGetLoad[System]]}],
        True,firstState];
    imsDebugMessage["Imtek`TimeIntegrate`imsNewtonSolve",1,
      "Basic preparing done"];
    func0=
      Flatten[Block[{tvar=
              tstart},(matS.xvec-load.excitation)/.xvar[b:___]\[Rule]
                y[b]/.xvar\[Rule]xvec]];
    imsDebugMessage["Imtek`TimeIntegrate`imsNewtonSolve",1,
      "Preparing function 1 done"];
    func=Block[{y=xvar},func0];
    imsDebugMessage["Imtek`TimeIntegrate`imsNewtonSolve",1,
      "Preparing function done"];
    jacobian=SparseArray[(Rule[#[[All,1]],#[[All,2]]]&)[Flatten[
            MapIndexed[(
                  (*If[Mod[#2[[1]],100]\[Equal]0,Print[#2[[1]]]];*)
          
                          
                  derivvars=
                    Transpose[
                      Union[Cases[#1,
                          b:xvar[a:_]\[Rule]{b,a},{0,\[Infinity]}]]];
                  row=#2[[1]];
                  
                  MapThread[{{row,#1},#2}&,{derivvars[[2]],
                      D[#1,{derivvars[[1]]}]}]
                  )&,func],
            1]],{Length[xvec],Length[xvec]}];
    imsDebugMessage["Imtek`TimeIntegrate`imsNewtonSolve",1,"Jacobian done"];
    (* tfunc[t2_,xx_,vv_]=
        Block[{tvar=t2,oldstatev=xx,oldvelv=vv},
          SparseArray[D[func[t2,oldstatev,oldvelv],{xvec}]]]; 
      which is faster? *)
    tfunc=Block[{tvar=tstart},jacobian];
    
    Return[
      NewtonIterate[xvar,func,tfunc,start,maxIt,maxRes,maxDu,tstart,tvar,
        FilterOptions[LinearSolve,opts],FilterOptions[NewtonIterate,opts]]];
    ]





imsVerletIntegrate[sys_imsSystem,{tvar_Symbol,tstart_,tend_,dt_},x0_List,
    v0_List,aexcitation_:({1}),opts___]:=
  Module[{
      mat,d,k,f,t2,excitation,
      x=x0,v=v0,t=tstart,acc,accstart,v12,
      numsteps,outfreq,minv,firstAcc,stepMon
      },
    (* Parse options *)
    
    firstAcc=imsInitialAcc/.{opts}/.Options[imsVerletIntegrate];
    stepMon:=StepMonitor/.{opts}/.Options[imsVerletIntegrate];
    
    numSteps=(tend-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsVerletIntegrate];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    mat=imsGetInertia[ sys ][[1]];
    d=imsGetDamping[ sys ][[1]];
    k=imsGetStiffness[ sys ][[1]];
    f=imsGetLoad[ sys ];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    
    minv=LinearSolve[mat,FilterOptions[LinearSolve,opts]];
    
    accstart=
      acc=Switch[firstAcc,Automatic,minv[-d.v-k.x+f.excitation[t]],_,
          firstAcc];
    Transpose[Prepend[Table[Do[t=(j*outfreq+i)*dt+tstart;
            x=x+dt*v+dt^2/2*acc;
            v12=v+dt/2*acc;
            acc=minv[-d.v12-k.x+f.excitation[t]];
            v=v12+dt/2*acc;,{i,outfreq}];
          Block[{tvar=t,imsStateVar=x},stepMon];
          {t,x,v,acc},{j,0,numSteps/outfreq-1}],{tstart,x0,v0,accstart}]]
    ]



imsVerletIntegrateTimeVariant[sys_imsSystem,{tvar_Symbol,tstart_,tend_,dt_},
    x0_List,v0_List,aexcitation_:({1}),opts___]:=
  Module[{
      mat,d,k,f,excitation, 
      x=x0,v=v0,t=tstart,acc,accstart,v12,
      numsteps,outfreq,minv,firstAcc,stepMon,
      t2
      },
    (* Parse options *)
    
    firstAcc=imsInitialAcc/.{opts}/.Options[imsVerletIntegrateTimeVariant];
    stepMon:=StepMonitor/.{opts}/.Options[imsVerletIntegrateTimeVariant];
    
    numSteps=(tend-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsVerletIntegrateTimeVariant];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    mat[t2_]:=Block[{tvar=t2},imsGetInertia[ sys ][[1]]];
    d[t2_]:=Block[{tvar=t2},imsGetDamping[ sys ][[1]]];
    k[t2_]:=Block[{tvar=t2},imsGetStiffness[ sys ][[1]]];
    f[t2_]:=Block[{tvar=t2},imsGetLoad[ sys ]];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    
    accstart=
      acc=Switch[firstAcc,Automatic,
          LinearSolve[mat[t],-d[t].v-k[t].x+f[t].excitation[t],
            FilterOptions[LinearSolve,opts]],_,firstAcc];
    Transpose[Prepend[Table[Do[t=(j*outfreq+i)*dt+tstart;
            x=x+dt*v+dt^2/2*acc;
            v12=v+dt/2*acc;
            acc=LinearSolve[mat[t],-d[t].v12-k[t].x+f[t].excitation[t]];
            v=v12+dt/2*acc;,{i,outfreq}];
          Block[{tvar=t,imsStateVar=x},stepMon];
          {t,x,v,acc},{j,0,numSteps/outfreq-1}],{tstart,x0,v0,accstart}]]
    ]



imsNewmarkIntegrate[
    System_imsSystem/;(imsSecondOrderQ[System]&&
          Not[imsParametricQ[System]]),{tvar_,tstart_,tstop_,dt_},state0_,
    vel0_,aexcitation_:({1}),opts___]:=
  Module[{alpha,delta,a0,a1,a2,a3,a4,a5,a6,a7,resList,numSteps,oldstate,
      oldvel,oldacc,newstate,newvel,newacc,integrationFunc,gamma,t=0,outfreq,
      stepMon,firstAcc,acc0,time,matS,matD,matM,load,excitation,t2,
      actualExcit,a},
    gamma=imsNewmarkIntegrateGamma/.{opts}/.Options[imsNewmarkIntegrate];
    stepMon:=StepMonitor/.{opts}/.Options[imsNewmarkIntegrate];
    firstAcc=imsInitialAcc/.{opts}/.Options[imsNewmarkIntegrate];
    
    alpha=(1/4) *(1+gamma)^2;
    delta=(1/2)+gamma;
    a0=1/(alpha*dt^2);
    a1=delta/(alpha*dt);
    a2=1/(alpha*dt);
    a3=1/(2*alpha)-1;
    a4=delta/alpha -1;
    a5=dt/2*( delta / alpha -2);
    a6=dt *( 1 -delta );
    a7=delta * dt;
    
    numSteps=(tstop-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsNewmarkIntegrate];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    
    matM=imsGetInertia[System][[1]];
    matD=imsGetDamping[System][[1]];
    matS=imsGetStiffness[System][[1]];
    load=imsGetLoad[System];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    t=tstart;
    
    acc0=Which[
        firstAcc===Automatic,
        LinearSolve[matM,(load.excitation[t]-(matD.vel0)-(matS.state0)),
          FilterOptions[LinearSolve,opts]],
        True,firstAcc
        ];
    integrationFunc=
      LinearSolve[a0*matM+a1*matD+matS,FilterOptions[LinearSolve,opts]];
    resList={{t,state0,vel0,acc0}};
    
    oldstate=state0;
    oldvel=vel0;
    oldacc=acc0;
    
    Do[
      Do[t=(j*outfreq+i)*dt+tstart;
        Do[stateVar[i]=oldstate[[i]],{i,1,Length[state0]}];
        newstate=
          integrationFunc[
            Normal[load.excitation[t]+matM.(a0*oldstate+a2*oldvel+a3*oldacc)+
                matD.(a1*oldstate+a4*oldvel+a5*oldacc)]];
        
        newacc=a0*(newstate-oldstate)-a2*oldvel - a3*oldacc;
        
        newvel=oldvel+a6*oldacc+a7*newacc; 
        
        oldstate=newstate;
        oldvel=newvel;
        oldacc=newacc;
        ,{i,outfreq}];
      AppendTo[resList,{N[t],newstate,newvel,newacc}];
      Block[{tvar=t,imsStateVar=newstate},stepMon];
      ,{j,0,numSteps/outfreq-1}];
    Return[Transpose[resList]]
    ]



imsNewmarkIntegrateTimeVariant[
    System_imsSystem/;(imsSecondOrderQ[System]&&
          Not[imsParametricQ[System]]),{tvar_,tstart_,tstop_,dt_},state0_,
    vel0_,aexcitation_:({1}),opts___]:=
  Module[{alpha,delta,a0,a1,a2,a3,a4,a5,a6,a7,resList,numSteps,oldstate,
      oldvel,oldacc,newstate,newvel,newacc,integrationFunc,gamma,t,t2,outfreq,
      stepMon,firstAcc,acc0,time,matS,matD,matM,load,excitation},
    gamma=
      imsNewmarkIntegrateGamma/.{opts}/.Options[
          imsNewmarkIntegrateTimeVariant];
    stepMon:=StepMonitor/.{opts}/.Options[imsNewmarkIntegrateTimeVariant];
    firstAcc=imsInitialAcc/.{opts}/.Options[imsNewmarkIntegrateTimeVariant];
    
    alpha=(1/4)*(1+gamma)^2;
    delta=(1/2)+gamma;
    a0=1/(alpha*dt^2);
    a1=delta/(alpha*dt);
    a2=1/(alpha*dt);
    a3=1/(2*alpha)-1;
    a4=delta/alpha -1;
    a5=dt/2*( delta / alpha -2);
    a6=dt *( 1 -delta );
    a7=delta * dt;
    
    numSteps=(tstop-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsNewmarkIntegrateTimeVariant];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    
    matM[t2_]:=Block[{tvar=t2},imsGetInertia[ System ][[1]]];
    matD[t2_]:=Block[{tvar=t2},imsGetDamping[ System ][[1]]];
    matS[t2_]:=Block[{tvar=t2},imsGetStiffness[ System ][[1]]];
    load[t2_]:=Block[{tvar=t2},imsGetLoad[ System ]];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    t=tstart;
    
    acc0=Which[
        firstAcc===Automatic,
        LinearSolve[
          matM[t],(load[t].excitation[t]-(matD[t].vel0)-(matS[t].state0)),
          FilterOptions[LinearSolve,opts]],
        True,firstAcc
        ];
    resList={{t,state0,vel0,acc0}};
    
    oldstate=state0;
    oldvel=vel0;
    oldacc=acc0;
    
    Do[
      Do[t=(j*outfreq+i)*dt+tstart;
        newstate=
          LinearSolve[a0*matM[t]+a1*matD[t]+matS[t], 
            Normal[load[t].excitation[t]+
                matM[t].(a0*oldstate+a2*oldvel+a3*oldacc)+
                matD[t].(a1*oldstate+a4*oldvel+a5*oldacc)],
            FilterOptions[LinearSolve,opts]];
        
        newacc=a0*(newstate-oldstate)-a2*oldvel - a3*oldacc;
        
        newvel=oldvel+a6*oldacc+a7*newacc; 
        
        oldstate=newstate;
        oldvel=newvel;
        oldacc=newacc;
        ,{i,outfreq}];
      AppendTo[resList,{N[t],newstate,newvel,newacc}];
      Block[{tvar=t,imsStateVar=newstate},stepMon];
      ,{j,0,numSteps/outfreq-1}];
    Return[Transpose[resList]]
    ]



imsNewmarkIntegrateNonlinearRHS[
    System_imsSystem/;(imsSecondOrderQ[System]&&Not[imsParametricQ[System]]),
    xvar_,{tvar_,tstart_,tstop_,dt_},state0_,vel0_,aexcitation_:({1}),
    opts___]:=Module[{alpha,delta,a0,a1,a2,a3,a4,a5,a6,a7,resList,numSteps,
      oldstate,oldvel,oldacc,newstate,newvel,newacc,integrationFunc,gamma,t=0,
      outfreq,stepMon,firstAcc,acc0,time,matS,matD,matM,load,excitation,t2,
      actualExcit,a},
    gamma=imsNewmarkIntegrateGamma/.{opts}/.Options[imsNewmarkIntegrate];
    stepMon:=StepMonitor/.{opts}/.Options[imsNewmarkIntegrate];
    firstAcc=imsInitialAcc/.{opts}/.Options[imsNewmarkIntegrate];
    
    alpha=(1/4) *(1+gamma)^2;
    delta=(1/2)+gamma;
    a0=1/(alpha*dt^2);
    a1=delta/(alpha*dt);
    a2=1/(alpha*dt);
    a3=1/(2*alpha)-1;
    a4=delta/alpha -1;
    a5=dt/2*( delta / alpha -2);
    a6=dt *( 1 -delta );
    a7=delta * dt;
    
    numSteps=(tstop-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsNewmarkIntegrate];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    
    matM=imsGetInertia[System][[1]];
    matD=imsGetDamping[System][[1]];
    matS=imsGetStiffness[System][[1]];
    load=imsGetLoad[System];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    t=tstart;
    
    actualExcit=excitation[t]/.xvar[a_]:>state0[[a]];
    acc0=Which[
        firstAcc===Automatic,
        LinearSolve[matM,(load.actualExcit-(matD.vel0)-(matS.state0)),
          FilterOptions[LinearSolve,opts]],
        True,firstAcc
        ];
    integrationFunc=
      LinearSolve[a0*matM+a1*matD+matS,FilterOptions[LinearSolve,opts]];
    resList={{t,state0,vel0,acc0}};
    
    oldstate=state0;
    oldvel=vel0;
    oldacc=acc0;
    
    Do[
      Do[t=(j*outfreq+i)*dt+tstart;
        Do[stateVar[i]=oldstate[[i]],{i,1,Length[state0]}];
        actualExcit=excitation[t]/.xvar[a_]:>oldstate[[a]];
        newstate=
          integrationFunc[
            Normal[
              load.actualExcit+matM.(a0*oldstate+a2*oldvel+a3*oldacc)+
                matD.(a1*oldstate+a4*oldvel+a5*oldacc)]];
        
        newacc=a0*(newstate-oldstate)-a2*oldvel - a3*oldacc;
        
        newvel=oldvel+a6*oldacc+a7*newacc; 
        
        oldstate=newstate;
        oldvel=newvel;
        oldacc=newacc;
        ,{i,outfreq}];
      AppendTo[resList,{N[t],newstate,newvel,newacc}];
      Block[{tvar=t,imsStateVar=newstate},stepMon];
      ,{j,0,numSteps/outfreq-1}];
    Return[Transpose[resList]]
    ]



imsNewmarkIntegrateNonlinear[
    System_imsSystem/;(imsSecondOrderQ[System]&&Not[imsParametricQ[System]]),
    xvar_,{tvar_,tstart_,tstop_,dt_},state0_,vel0_,excitation_:({1}),opts___]:=
  Module[{alpha,delta,a0,a1,a2,a3,a4,a5,a6,a7,gamma,(*stepMon,*)firstAcc,
      maxIt,maxRes,maxDu,numSteps,outfreq,matM,matD,matS,load,xvec,
      oldstatevec,oldvelvec,oldaccvec, oldstatev,oldvelv,oldaccv,oldstate,
      oldvel,oldacc,func, tfunc,
      t=tstart,xi,matM0,matD0,matS0,load0,resList,derivvars,derivrow,a,b,
      xx,vv,aa,oldstatei,oldveli,oldacci,excitation0,y
      },
    
    gamma=
      imsNewmarkIntegrateGamma/.{opts}/.Options[
          imsNewmarkIntegrateNonlinear];
    firstAcc=imsInitialAcc/.{opts}/.Options[imsNewmarkIntegrateNonlinear];
    maxIt=imsMaxIterations/.{opts}/.Options[imsNewmarkIntegrateNonlinear];
    maxRes=imsMaxResidual/.{opts}/.Options[imsNewmarkIntegrateNonlinear];
    maxDu=imsMaxDOFChange/.{opts}/.Options[imsNewmarkIntegrateNonlinear];
    
    alpha=(1/4)*(1+gamma)^2;
    delta=(1/2)+gamma;
    a0=1/(alpha*dt^2);
    a1=delta/(alpha*dt);
    a2=1/(alpha*dt);
    a3=1/(2*alpha)-1;
    a4=delta/alpha-1;
    a5=dt/2*(delta/alpha-2);
    a6=dt*(1-delta);
    a7=delta*dt;
    
    numSteps=(tstop-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsNewmarkIntegrateTimeVariant];
    outfreq=Switch[outfreq,_Integer,numSteps/outfreq,_,1];
    
    (*f[x2_]:=Block[{xvar=x2},func];
      t[x2_]:=Block[{xvar=x2},tangentfunc];*)
    
    (* Get matrices *)
    matM=imsGetInertia[System][[1]];
    matD=imsGetDamping[System][[1]];
    matS=imsGetStiffness[System][[1]];
    load=imsGetLoad[System];
    
    (* Form variable vectors for building scalar products and derivatives *)
 
       xvec=Table[xvar[i],{i,Length[imsGetLoad[System]]}];
    oldstatevec=Table[oldstatev[i],{i,Length[imsGetLoad[System]]}];
    oldaccvec=Table[oldaccv[i],{i,Length[imsGetLoad[System]]}];
    oldvelvec=Table[oldvelv[i],{i,Length[imsGetLoad[System]]}];
    
    (* Get initial acceleration *)
    oldacc=Which[firstAcc===Automatic,
        Do[xi[i]=state0[[i]],{i,Length[state0]}];
        matM0=Block[{xvar=xi,tvar=t},matM];
        matD0=Block[{xvar=xi,tvar=t},matD];
        matS0=Block[{xvar=xi,tvar=t},matS];
        load0=Block[{xvar=xi,tvar=t},load];
        excitation0=Block[{xvar=xi,tvar=t},excitation];
        LinearSolve[matM0,(load0.excitation0-(matD0.vel0)-(matS0.state0)),
          FilterOptions[LinearSolve,opts]],True,firstAcc];
    
    func[t2_,xx_,vv_,aa_]:=
      Flatten[Block[{tvar=t2,oldstatev=xx,oldaccv=aa,
            oldvelv=vv},(matS.xvec+
                    matM.(-a0*(oldstatevec-xvec)-a2*oldvelvec-a3*oldaccvec)+
                    matD.(oldvelvec+a6*oldaccvec-
                          a7*(a0*(oldstatevec-xvec)+a2*oldvelvec+
                                a3*oldaccvec))-load.excitation)/.xvar[
                    b:___]\[Rule]y[b]/.xvar\[Rule]xvec/.y\[Rule]xvar]];
    
    jacobian=SparseArray[
        Flatten[
          MapIndexed[(derivrow=#2[[1]];
                If[Mod[derivrow,10]\[Equal]0,
                  Block[{tvar=t,imsResidualL2Norm=0.,imsStateVar=state0,
                      xvar=state0,imsIterationNumber=derivrow},stepMon]];
                
                derivvars=
                  Transpose[
                    Union[Cases[#1,
                        b:xvar[a:_]\[Rule]{b,a},{0,\[Infinity]}]]];
                
                MapThread[({derivrow,#1}\[Rule]#2)&,{derivvars[[2]],
                    D[#1,{derivvars[[1]]}]}]
                (*jacobian[[#2[[1]],derivvars[[2]]]]=
                    D[#1,{derivvars[[1]]}]*)
                )&,
            func[tvar,oldstatev,oldvelv,oldaccv]],1]];
    (* tfunc[t2_,xx_,vv_,aa_]=
        Block[{tvar=t2,oldstatev=xx,oldaccv=aa,oldvelv=vv},
          SparseArray[D[func[t2,oldstatev,oldvelv,oldaccv],{xvec}]]]; 
      which is faster? *)
    
    tfunc[t2_,xx_,vv_,aa_]:=
      Block[{tvar=t2,oldstatev=xx,oldvelv=vv,oldaccv=aa},jacobian];
    
    oldstate=state0;
    oldvel=vel0;
    resList={{t,state0,vel0,oldacc}};
    
    Do[
      Do[
        
        t=(j*outfreq+i)*dt+tstart;
        Do[oldstatei[i]=oldstate[[i]],{i,Length[oldstate]}];
        Do[oldveli[i]=oldvel[[i]],{i,Length[oldvel]}];
        Do[oldacci[i]=oldacc[[i]],{i,Length[oldacc]}];
        
        (*stepMon:=
              StepMonitor/.{opts}/.Options[
                  imsNewmarkIntegrateNonlinear];*)
        
        newstate=
          NewtonIterate[xvar,func[t,oldstatei,oldveli,oldacci],
            tfunc[t,oldstatei,oldveli,oldacci],oldstate,maxIt,maxRes,maxDu,t,
            tvar,FilterOptions[LinearSolve,opts],
            FilterOptions[NewtonIterate,opts]];
        
        newacc=a0*(newstate-oldstate)-a2*oldvel-a3*oldacc;
        newvel=oldvel+a6*oldacc+a7*newacc;
        oldstate=newstate;
        oldvel=newvel;
        oldacc=newacc;,{i,outfreq}];
      
      AppendTo[resList,{N[t],newstate,newvel,newacc}];
      ,{j,0,numSteps/outfreq-1}
      ];
    Return[Transpose[resList]];
    ]





imsTrapezoidalIntegrateTimeVariant[
    System_imsSystem/;(imsFirstOrderQ[System]&&
          Not[imsParametricQ[System]]),{tvar_,tstart_,tstop_,dt_},state0_,
    aexcitation_:({1}),opts___]:=
  Module[{theta,t,t2,firstVel,vel0,integrationFunc,oldstate,newstate,oldvel,
      newvel,resList,matD,matS,load,numSteps,outfreq,stepMon,excitation},
    theta=
      imsTrapezoidalIntegrateTheta/.{opts}/.Options[
          imsTrapezoidalIntegrateTimeVariant];
    firstVel=
      imsInitialVel/.{opts}/.Options[imsTrapezoidalIntegrateTimeVariant];
    stepMon:=
      StepMonitor/.{opts}/.Options[imsTrapezoidalIntegrateTimeVariant];
    
    numSteps=(tstop-tstart)/dt;
    outfreq=
      imsOutputSteps/.{opts}/.Options[imsTrapezoidalIntegrateTimeVariant];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    
    matD[t2_]:=Block[{tvar=t2},imsGetDamping[ System ][[1]]];
    matS[t2_]:=Block[{tvar=t2},imsGetStiffness[ System ][[1]]];
    load[t2_]:=Block[{tvar=t2},imsGetLoad[ System ]];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    t=tstart;
    vel0=Which[
        firstVel===Automatic,
        LinearSolve[matD[t],(load[t].excitation[t]-(matS[t].state0)),
          FilterOptions[LinearSolve,opts]],
        True,firstVel
        ];
    
    resList={{t,state0,vel0}};
    
    oldstate=state0;
    oldvel=vel0;
    Do[
      Do[t=(j*outfreq+i)*dt+tstart;
        newstate=
          LinearSolve[matD[t]/(theta*dt)+matS[t],
            Normal[load[t].excitation[t]+
                matD[t].(oldstate/(theta*dt)+oldvel*(1-theta)/theta)],
            FilterOptions[LinearSolve,opts]];
        
        newvel=(newstate-oldstate)/(theta*dt)-oldvel*(1-theta)/theta; 
        
        oldstate=newstate;
        oldvel=newvel;
        ,{i,outfreq}];
      AppendTo[resList,{N[t],newstate,newvel}];
      
      Block[{tvar=t,imsStateVar=newstate},stepMon];
      ,{j,0,numSteps/outfreq-1}];
    Return[Transpose[resList]]
    ]



imsTrapezoidalIntegrate[
    System_imsSystem/;(imsFirstOrderQ[System]&&
          Not[imsParametricQ[System]]),{tvar_,tstart_,tstop_,dt_},state0_,
    aexcitation_:({1}),opts___]:=
  Module[{theta,t,t2,firstVel,vel0,integrationFunc,oldstate,newstate,oldvel,
      newvel,resList,matD,matS,load,numSteps,outfreq,stepMon,excitation},
    theta=
      imsTrapezoidalIntegrateTheta/.{opts}/.Options[imsTrapezoidalIntegrate];
    firstVel=imsInitialVel/.{opts}/.Options[imsTrapezoidalIntegrate];
    stepMon:=StepMonitor/.{opts}/.Options[imsTrapezoidalIntegrate];
    
    numSteps=(tstop-tstart)/dt;
    outfreq=imsOutputSteps/.{opts}/.Options[imsTrapezoidalIntegrate];
    outfreq=Switch[outfreq,
        _Integer,numSteps/outfreq,
        _,1
        ];
    matD=imsGetDamping[System][[1]];
    matS=imsGetStiffness[System][[1]];
    load=imsGetLoad[System];
    excitation[t2_]:=Block[{tvar=t2},aexcitation];
    
    t=tstart;
    vel0=Which[
        firstVel===Automatic,
        LinearSolve[matD,(load.excitation[t]-(matS.state0)),
          FilterOptions[LinearSolve,opts]],
        True,firstVel
        ];
    integrationFunc=
      LinearSolve[matD/(theta*dt)+matS,FilterOptions[LinearSolve,opts]];
    
    resList={{t,state0,vel0}};
    
    oldstate=state0;
    oldvel=vel0;
    Do[
      Do[t=(j*outfreq+i)*dt+tstart;
        newstate=
          integrationFunc[
            Normal[load.excitation[t]+
                matD.(oldstate/(theta*dt)+oldvel*(1-theta)/theta)]];
        
        newvel=(newstate-oldstate)/(theta*dt)-oldvel*(1-theta)/theta; 
        
        oldstate=newstate;
        oldvel=newvel;
        ,{i,outfreq}];
      AppendTo[resList,{N[t],newstate,newvel}];
      
      Block[{tvar=t,imsStateVar=newstate},stepMon];
      ,{j,0,numSteps/outfreq-1}];
    Return[Transpose[resList]]
    ]



imsTrapezoidalIntegrateNonlinear[
    System_imsSystem/;(imsFirstOrderQ[System]&&Not[imsParametricQ[System]]),
    xvar_,{tvar_,tstart_,tstop_,dt_},state0_,excitation_:({1}),opts___]:=
  Module[{theta,(*stepMon,*)firstVel,maxIt,maxRes,maxDu,numSteps,outfreq,matD,
      matS,load,xvec,oldstatevec,oldvelvec, oldstatev,oldvelv,oldstate,oldvel,
      func, tfunc,
      t=tstart,xi,matM0,matD0,matS0,load0,derivvars,resList,a,b,jacobian,
      xx,vv,oldstatei,oldveli,excitation0,i,y
      },
    theta=
      imsTrapezoidalIntegrateTheta/.{opts}/.Options[
          imsTrapezoidalIntegrateNonlinear];
    (*stepMon:=
          StepMonitor/.{opts}/.Options[imsTrapezoidalIntegrateNonlinear];*)
  
      firstVel=
      imsInitialVel/.{opts}/.Options[imsTrapezoidalIntegrateNonlinear];
    maxIt=
      imsMaxIterations/.{opts}/.Options[imsTrapezoidalIntegrateNonlinear];
    maxRes=imsMaxResidual/.{opts}/.Options[imsTrapezoidalIntegrateNonlinear];
    maxDu=imsMaxDOFChange/.{opts}/.Options[imsTrapezoidalIntegrateNonlinear];
    
    numSteps=(tstop-tstart)/dt;
    outfreq=
      imsOutputSteps/.{opts}/.Options[imsTrapezoidalIntegrateNonlinear];
    outfreq=Switch[outfreq,_Integer,numSteps/outfreq,_,1];
    
    (* Get matrices *)
    matD=imsGetDamping[System][[1]];
    matS=imsGetStiffness[System][[1]];
    load=imsGetLoad[System];
    
    (* Form variable vectors for building scalar products and derivatives *)
 
       xvec=Table[xvar[i],{i,Length[imsGetLoad[System]]}];
    oldstatevec=Table[oldstatev[i],{i,Length[imsGetLoad[System]]}];
    oldvelvec=Table[oldvelv[i],{i,Length[imsGetLoad[System]]}];
    
    (* Get initial acceleration *)
    oldvel=Which[firstVel===Automatic,
        Do[xi[i]=state0[[i]],{i,Length[state0]}];
        matD0=Block[{xvar=xi,tvar=t},matD];
        matS0=Block[{xvar=xi,tvar=t},matS];
        load0=Block[{xvar=xi,tvar=t},load];
        excitation0=Block[{xvar=xi,tvar=t},excitation];
        LinearSolve[matD0,(load0.excitation0-(matS0.state0)),
          FilterOptions[LinearSolve,opts]],
        True,firstVel];
    
    func[t2_,xx_,vv_]:=
      Flatten[Block[{tvar=t2,oldstatev=xx,
            oldvelv=vv},(matD.((xvec-oldstatevec)/theta/dt-(1-theta)/theta*
                            oldvelvec)+matS.xvec-load.excitation)/.xvar[
                    b:___]\[Rule]y[b]/.xvar\[Rule]xvec/.y\[Rule]xvar]];
    
    jacobian=SparseArray[
        Flatten[
          MapIndexed[(derivrow=#2[[1]];
                If[Mod[derivrow,10]\[Equal]0,
                  Block[{tvar=t,imsResidualL2Norm=0.,imsStateVar=state0,
                      xvar=state0,imsIterationNumber=derivrow},stepMon]];
                
                derivvars=
                  Transpose[
                    Union[Cases[#1,
                        b:xvar[a:_]\[Rule]{b,a},{0,\[Infinity]}]]];
                
                MapThread[({derivrow,#1}\[Rule]#2)&,{derivvars[[2]],
                    D[#1,{derivvars[[1]]}]}]
                )&,
            func[tvar,oldstatev,oldvelv]],
          1]
        ];
    
    (* tfunc[t2_,xx_,vv_]=
        Block[{tvar=t2,oldstatev=xx,oldvelv=vv},
          SparseArray[D[func[t2,oldstatev,oldvelv],{xvec}]]]; 
      which is faster? *)
    
    tfunc[t2_,xx_,vv_]:=Block[{tvar=t2,oldstatev=xx,oldvelv=vv},jacobian];
    
    oldstate=state0;
    resList={{t,state0,oldvel}};
    
    Do[
      Do[
        t=(j*outfreq+i)*dt+tstart;
        Do[oldstatei[i]=oldstate[[i]],{i,Length[oldstate]}];
        Do[oldveli[i]=oldvel[[i]],{i,Length[oldvel]}];
        newstate=
          NewtonIterate[xvar,func[t,oldstatei,oldveli],
            tfunc[t,oldstatei,oldveli],oldstate,maxIt,maxRes,maxDu,t,tvar,
            FilterOptions[LinearSolve,opts],
            FilterOptions[NewtonIterate,opts]];
        
        newvel=(newstate-oldstate)/(theta*dt)-oldvel*(1-theta)/theta; 
        
        oldstate=newstate;
        oldvel=newvel;
        ,{i,outfreq}];
      AppendTo[resList,{N[t],newstate,newvel}];
      ,{j,0,numSteps/outfreq-1}
      ];
    Return[Transpose[resList]];
    ]





imsStationarySolveNonlinear[
      System_imsSystem/;(imsStationaryQ[System]&&Not[imsParametricQ[System]]),
      xvar_,{tvar_,tstart_},excitation_:{1},opts___]:=
    Module[{method,sol,timevariant=!imsLinearQ[ System, tvar ]},
      method=imsMethod/.{opts}/.Options[imsStationarySolveNonlinear];
      sol=Switch[method,
          "Newton"|"Automatic"|Automatic,
          imsNewtonSolve[System,xvar,{tvar,tstart},excitation,
            FilterOptions[imsNewtonSolve,opts],
            FilterOptions[LinearSolve,opts]],
          _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
          ];Return[sol];
      ];

imsTimeIntegrateNonlinear[
      System_imsSystem/;(imsSecondOrderQ[System]&&
            Not[imsParametricQ[System]]),xvar_,{tvar_,tstart_,tstop_,dt_},
      state0_,vel0_,excitation_:{1},opts___]:=
    Module[{method,sol,timevariant=!imsLinearQ[ System, tvar ]},
      method=imsMethod/.{opts}/.Options[imsTimeIntegrateNonlinear];
      sol=Switch[method,
          "Newmark"|"Implicit"|"Automatic"|Automatic,
          
          imsNewmarkIntegrateNonlinear[System,xvar,{tvar,tstart,tstop,dt},
            state0,vel0,excitation,
            FilterOptions[imsNewmarkIntegrateNonlinear,opts],
            FilterOptions[LinearSolve,opts]],
          "RHSOnlyOnce",
          
          imsNewmarkIntegrateNonlinearRHS[System,xvar,{tvar,tstart,tstop,dt},
            state0,vel0,excitation,
            FilterOptions[imsNewmarkIntegrateNonlinear,opts],
            FilterOptions[LinearSolve,opts]],
          _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
          ];Return[sol];
      ];

imsTimeIntegrateNonlinear[
    System_imsSystem/;(imsFirstOrderQ[System]&&Not[imsParametricQ[System]]),
    xvar_,{tvar_,tstart_,tstop_,dt_},state0_,excitation_:{1},opts___]:=
  Module[{method,sol,timevariant=!imsLinearQ[ System, tvar ],x},
    method=imsMethod/.{opts}/.Options[imsTimeIntegrateNonlinear];
    sol=Switch[method,
        "NDSolve",
        x/.imsTransientSolve[ System, x, { tvar, tstart, tstop } ],
        "BackwardEuler"|"Implicit"|"Automatic"|Automatic,
        imsTrapezoidalIntegrateNonlinear[System,xvar,{tvar,tstart,tstop,dt},
          state0,excitation,imsTrapezoidalIntegrateTheta\[Rule]1,
          FilterOptions[imsTrapezoidalIntegrateNonlinear,opts],
          FilterOptions[LinearSolve,opts]],
        "CrankNicolson",
        imsTrapezoidalIntegrateNonlinear[System,xvar,{tvar,tstart,tstop,dt},
          state0,excitation,imsTrapezoidalIntegrateTheta\[Rule]1/2,
          FilterOptions[imsTrapezoidalIntegrateNonlinear,opts],
          FilterOptions[LinearSolve,opts]],
        "Trapezoidal",
        imsTrapezoidalIntegrateNonlinear[System,xvar,{tvar,tstart,tstop,dt},
          state0,excitation,
          FilterOptions[imsTrapezoidalIntegrateNonlinear,opts],
          FilterOptions[LinearSolve,opts]],
        _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
        ];Return[sol];
    ]

imsTimeIntegrate[
    System_imsSystem/;(imsSecondOrderQ[System]&&
          Not[imsParametricQ[System]]),{tvar_,tstart_,tstop_,dt_},state0_,
    vel0_,excitation_:{1},opts___]:=
  Module[{method,sol,timevariant=!imsLinearQ[ System, tvar ]},
    If[!(opts\[Equal]{}),opts={}];
    method=imsMethod/.{opts}/.Options[imsTimeIntegrate];
    If[timevariant,
      sol=Switch[method,
          "Newmark"|"Implicit"|"Automatic"|Automatic,
          
          imsNewmarkIntegrateTimeVariant[System,{tvar,tstart,tstop,dt},state0,
            vel0,excitation,
            FilterOptions[imsNewmarkIntegrateTimeVariant,opts],
            FilterOptions[LinearSolve,opts]],
          "Verlet"|"Explicit",
          
          imsVerletIntegrateTimeVariant[System,{tvar,tstart,tstop,dt},state0,
            vel0,excitation,
            FilterOptions[imsVerletIntegrateTimeVariant,opts],
            FilterOptions[LinearSolve,opts]],
          _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
          ],
      sol=Switch[method,
          "Newmark"|"Implicit"|"Automatic"|Automatic,
          
          imsNewmarkIntegrate[System,{tvar,tstart,tstop,dt},state0,vel0,
            excitation,
            FilterOptions[imsNewmarkIntegrate,opts],
            FilterOptions[LinearSolve,opts]],
          "Verlet"|"Explicit",
          
          imsVerletIntegrate[System,{tvar,tstart,tstop,dt},state0,vel0,
            excitation,
            FilterOptions[imsVerletIntegrate,opts],
            FilterOptions[LinearSolve,opts]],
          _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
          ]
      ];Return[sol];
    ]

imsTimeIntegrate[
    System_imsSystem/;(imsFirstOrderQ[System]&&
          Not[imsParametricQ[System]]),{tvar_,tstart_,tstop_,dt_},state0_,
    excitation_:{1},opts___]:=
  Module[{method,sol,timevariant=!imsLinearQ[ System, tvar ],x},
    If[!(opts\[Equal]{}),opts={}];
    method=imsMethod/.{opts}/.Options[imsTimeIntegrate];
    If[timevariant,
      sol=Switch[method,
          "BackwardEuler"|"Implicit"|"Automatic"|Automatic,
          
          imsTrapezoidalIntegrateTimeVariant[System,{tvar,tstart,tstop,dt},
            state0,excitation,imsTrapezoidalIntegrateTheta\[Rule]1,
            (*FilterOptions[imsTrapezoidalIntegrateTimeVariant,Method/.opts],*)

                        
            FilterOptions[imsTrapezoidalIntegrateTimeVariant,opts],
            FilterOptions[LinearSolve,opts]],
          "CrankNicolson",
          
          imsTrapezoidalIntegrateTimeVariant[System,{tvar,tstart,tstop,dt},
            state0,excitation,imsTrapezoidalIntegrateTheta\[Rule]1/2,
            (*FilterOptions[imsTrapezoidalIntegrateTimeVariant,Method/.opts],*)

                        
            FilterOptions[imsTrapezoidalIntegrateTimeVariant,opts],
            FilterOptions[LinearSolve,opts]],
          "Trapezoidal",
          
          imsTrapezoidalIntegrateTimeVariant[System,{tvar,tstart,tstop,dt},
            state0,excitation,
            (*FilterOptions[imsTrapezoidalIntegrateTimeVariant,Method/.opts],*)

                        
            FilterOptions[imsTrapezoidalIntegrateTimeVariant,opts],
            FilterOptions[LinearSolve,opts]],
          "NDSolve",
          x/.imsTransientSolve[ System, x, { tvar, tstart, tstop } ],
          _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
          ],
      sol=Switch[method,
          "BackwardEuler"|"Implicit"|"Automatic"|Automatic,
          
          imsTrapezoidalIntegrate[System,{tvar,tstart,tstop,dt},state0,
            excitation,imsTrapezoidalIntegrateTheta\[Rule]1,
            (*FilterOptions[imsTrapezoidalIntegrate,Method/.opts],*)
         
               FilterOptions[imsTrapezoidalIntegrate,opts],
            FilterOptions[LinearSolve,opts]],
          "CrankNicolson",
          
          imsTrapezoidalIntegrate[System,{tvar,tstart,tstop,dt},state0,
            excitation,imsTrapezoidalIntegrateTheta\[Rule]1/2,
            (*FilterOptions[imsTrapezoidalIntegrate,Method/.opts],*)
         
               FilterOptions[imsTrapezoidalIntegrate,opts],
            FilterOptions[LinearSolve,opts]],
          "Trapezoidal",
          
          imsTrapezoidalIntegrate[System,{tvar,tstart,tstop,dt},state0,
            excitation,
            (*FilterOptions[imsTrapezoidalIntegrateTimeVariant,Method/.opts],*)

                        
            FilterOptions[imsTrapezoidalIntegrateTimeVariant,opts],
            FilterOptions[LinearSolve,opts]],
          "NDSolve",
          x/.imsTransientSolve[ System, x, { tvar, tstart, tstop } ],
          _,Message[imsTimeIntegrate::"method",method];Return[$Failed]
          ]
      ];Return[sol];
    ]



(* representors *)
(* *)



(* Begin Private *)
End[]



(* Protect[] *)
EndPackage[] 






