(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: SparseUtils *)
(* Context: *)
(* Author:oliver ruebenkoenig
      Jan Korvink contributed the the Dimensions overload
   *)
(* Date: 20.2.2007, Leipzig *)
(* 
  Summary: This is the IMTEK template for writing a mathematica packages *)
(* 
  Package Copyright: GNU GPL *)
(* Package Version: 0.2.3 *)
(* 
  Mathematica Version: 5.2 *)
(* History:
    added imsSparseIdentityMatrix and imsSparseDiagonalMatrix
   *)
(* Keywords: *)
(* Sources: *)
(* Warnings: *)
(* Limitations: *)
(* 
  Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Start Package *)
BeginPackage["Imtek`SparseUtils`"];





(* *)
(* documentation *)
(* *)
Needs["Imtek`Maintenance`"]
imsCreateObsoleteFunctionInterface[ SparseMatrixQ, $Context ];
imsCreateObsoleteFunctionInterface[ MatrixToSparseMatrix, $Context ];
imsCreateObsoleteFunctionInterface[ SparseMatrixToMatrix, $Context ];
imsCreateObsoleteFunctionInterface[ SparseProcedure, $Context ];
imsCreateObsoleteFunctionInterface[ SparseProcedureValues, $Context ];
imsCreateObsoleteFunctionInterface[ 
    SparseProcedureToSparseMatrix, $Context ];

(* constructors *)

(* selectors *)

(* predicates *)
imsSparseMatrixQ::usage = 
    "imsSparseMatrixQ[ expr ] returns True if expr is a List of Rules building up a sparse matrix.";\


(* functions *)

imsMatrixToSparseMatrix::usage="imsMatrixToSparseMatrix[ matrix ] converts a matrix into a sparse matrix."
\

imsSparseMatrixToMatrix::usage="imsSparseMatrixToMatrix[ sparseMatrix ] converts a sparse matrix to a dense matrix."
\

imsSparseProcedure::usage="THE USE IS DEPRECIATED. imsSparseProcedure[matrixName, rowList, columnList] initalises so called sparse procedures with the names matrixName[row, column] to the value 0. row and column are computed from the outer product of the rowList and columnList. The length of the integer rowList and columnList must be the same."
\

imsSparseProcedureValues::usage="THE USE IS DEPRECIATED. imsSparseProcedureValues[matrixName, rowList, columnList, values] sets the initalised so called sparse procedure to the values values. See also imsSparseProcedure."
\

imsSparseProcedureToSparseMatrix::usage="THE USE IS DEPRECIATED. imsSparseProcedureToSparseMatrix[matrixName] converts a so called sparse procedure into a conventional sparse matix. The conversion is different in the way that the rules produced are RuleDelayed insted of normal Rule. This should cause no problems. See also imsSparseProcedure and imsSparseProcedureValues."
\


imsSparseDiagonalMatrix::usage =
  "imsSparseDiagonalMatrix[list, z_:0 ] returns a SparseArray with list elements on the diagonal. The zero element defaults to integer 0."
\

imsSparseIdentityMatrix::usage=
  "imsSparseIdentityMatrix[d, z_:0 ] returns an IdentityMatrix of dimensions d as a SparseArray. The zero element defaults to integer 0."









(* *)
(* implementation part *)
(* *)

(* constructor *)



Begin["`Private`"];





(* *)
(* define your options *)
(* *)



(* selector *)



(* predicates *)

imsSparseMatrixQ[ matrix_ ] :=
    
    MatchQ[ matrix, { Rule[ List[ _, _ ], _ ]  .. } ];
imsSparseMatrixQ[  ___ ] := False;



(* functions *)

imsMatrixToSparseMatrix[ matrix_ ] := 
  Module[
      { notZeroQ },
      
      (* the Position line finds non zero (integer) entries*)(* 
        the select line selectes the values from the matrix*)(* 
        the map through builds the rule*)
      
      notZeroQ=(#\[NotEqual]0&);
      
      Return[
        MapThread[ 
          Rule, { Position[ matrix, _?( notZeroQ ), { 2 }, 
              Heads \[Rule] False ],( Select[ #1, notZeroQ ]& /@ matrix ) // 
              Flatten }
          ]
        ];
      ] /;MatrixQ[matrix]||
      Message[ imsSparseUtils::"Error type: badarg", imsMatrixToSparseMatrix, 
        matrix ]

imsSparseMatrixToMatrix[ sparseMatrix_ ] := 
  Module[
      { indices, flatInd, colInd, rowInd, rows, columns, matrix, values },
      
      indices = sparseMatrix[[ All, 1 ]];
      values = sparseMatrix[[ All, 2 ]];
      flatInd = indices // Flatten;
      { colInd, rowInd } = 
        Drop[ flatInd, { #1, Length[ flatInd ], 2 } ]& /@ {1,2};
      { rows, columns } = Max[ #1 ]& /@ { rowInd, colInd };
      matrix = Table[ 0., { rows }, { columns } ];
      ( matrix[[ #1[[ 1, 1 ]], #1[[ 1, 2 ]] ]] = #1[[ 2 ]] )& /@ 
        sparseMatrix;
      
      Return[ matrix ];
      
      ] /; VectorQ[ sparseMatrix, ( Head[ # ] === Rule )& ] || 
      VectorQ[ sparseMatrix, ( Head[ # ] === RuleDelayed )& ] || 
      Message[ imsSparseUtils::"Error type: badarg", imsSparseMatrixToMatrix, 
        sparseMatrix ]

imsSparseProcedure[matrixName_Symbol,row_List,column_List]:=
    Outer[(matrixName[#1,#2]=0.)&,row,column]//Flatten;

(*this is not as nice at imsSparseProcedure*)
(*could not find similar way-
    try your luck*)
(*use Unique?*)

imsSparseProcedureValues[matrixName_Symbol,row_List,column_List,
      values_List]:=(Clear[oXtmpoXNameoX];
      ((HoldForm[(#1+=#2)]&[Outer[oXtmpoXNameoX,row,column],
                values])/.oXtmpoXNameoX\[Rule]matrixName)//ReleaseHold);

imsSparseProcedureToSparseMatrix[matrixName_Symbol]:=
    DeleteCases[
      ReleaseHold[#1]&/@(DownValues[
              matrixName]/.matrixName[row_,column_]\[Rule]{row,
                column}),{_,_}\[RuleDelayed]0.];



(* overload for Dimensions by Jan Korvink *)
Unprotect[ Dimensions ];
Dimensions[m:{({_,_}\[Rule]_)..}]:=Max[#]&/@Transpose[#[[1]]&/@m];
Protect[ Dimensions ];

imsSparseIdentityMatrix[d_, z_:0]:=
  SparseArray[ {{i_, i_}\[Rule] SetPrecision[1,Precision[z] ]},{d,d},z ]

imsSparseDiagonalMatrix[ l_List, z_:0 ] := 
  SparseArray[ 
    Transpose[ {#,#} ]&[ Range[ Length[ l ] ] ] \[Rule] l, {Length[l],
      Length[l]}, z ]



End[] (* of Begin Private *)



(* Protect[] (* anything *) *)
EndPackage[] 
