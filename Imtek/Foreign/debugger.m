(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





BeginPackage["Imtek`Foreign`debugger`"]; 

Dbg\[Breve]Make\[Breve]Palette::usage=
    "Call this with no arguments to re-build the debug palette"; 
Dbg::usage="Use as follows:\n
    <Expression to debug> //Dbg[<options>]\n
    Where options include:\n
    MaxSteps \[Dash] Maximum number of intermediate steps to print (default \
10)\n
    StartStep - Number of step at which printing begins (default 1)\n
    ShowHeads \[Dash] Head or list of heads. Print only expressions that \
match one of these\n
    ExcludeHeads - List of heads of expressions not to print\n
    FilterHeads - User-supplied predicate to test heads to determine if they \
require printing\n
    ContinueExecution \[Dash] Whether to continue execution after print limit \
exceeded (default True)\n
    ShowLevels - Show the level on the stack of each expression (advanced \
feature)\n
    HiddenFunctions - List of functions whose inner workings are not of \
interest\n
    AbortStep - Abort with traceback after this step number\n
    AbortStepCount - Number of steps to print after the abort button is \
pressed before entering traceback\n
    BreakAt - Execute a breakpoint when this pattern is reached\n
    Step - Break at first step\n
    BreakFail - Set tue to make program failure/aborts enter breakpoint \
mechanism\n
    TriggerOn - Start printing after this pattern is reached\n
    SuppressPackages - Do not print steps inside packages (default True)\n
    TriggerOff - Stop printing after this pattern has been reached\n\n
    If an error message is generated Dbg will stop the execution and provide \
a traceback.";

MaxSteps ::usage=
    "Option to Dbg:\nMaximum number of intermediate steps to print (default \
10)";
ContinueExecution::usage=
    "Option to Dbg:\nWhether to continue execution after print limit exceeded \
(default True)";
ExcludeHeads::usage="List of heads of expression not to print";
FilterHeads::usage=
    "User supplied predicate to determine if a head requires printing";
StartStep ::usage=
    "Option to Dbg:\nNumber of step at which printing begins (default 1)";
ShowHeads ::usage=
    "Option to Dbg:\nHead or list of heads. Print only expressions that match \
one of these";
ShowLevels::usage=
    "Option to Dbg:\nShow the level on the stack of each expression (advanced \
feature)";
HiddenFunctions::usage=
    "Option to Dbg:\nList of functions whose inner workings are not of \
interest";
AbortStep::usage=
    "Option to Dbg:\nAbort with traceback after this step number";
AbortStepCount::usage=
    "Number of steps to print after the abort button is pressed before \
entering traceback";
BreakAt::usage="Execute a breakpoint when this pattern is reached";
Step::usage="Execute a breakboint on first step";
BreakFail ::usage=
    "Set tue to make program failure/aborts enter breakpoint mechanism";
TriggerOn::usage=
    "Option to Dbg:\nStart printing after this pattern is reached";
SuppressPackages::usage=
    "Option to Dbg:\nDo not print steps inside packages (default True)";
TriggerOff ::usage=
    "Option to Dbg:\nStop printing after this pattern has been reached";
Dbg\[Breve]Coloured::usage=
    "Function used to represent coloured objects in the debugger - do not use \
explicitly";

Begin["`Private`"];



Resume\[Breve]Mode=100000;
Trace\[Breve]Mode=100001;
Step\[Breve]Mode=100002;
Abort\[Breve]Mode=100003;
Step\[Breve]Over\[Breve]Mode=100004;
New\[Breve]Break\[Breve]Mode=100005;
Colour\[Breve]Break\[Breve]Mode=100006;

(*Constructs which never print*)
  Excluded\[Breve]Constructs={CompoundExpression,RuleCondition,$ConditionHold,
      Pattern,Blank,Slot,Function,List,MakeExpression,MakeBoxes,MessageName,
      StackComplete,$Off};
(*These print specially*)
Abbreviated\[Breve]Constructs={Module,While,Block,With,For,Which,Cases};
(*This is a list of functions whose internals are not to be shown*)
Hidden\[Breve]Functions={CellPrint};
Dbg\[Breve]Running=False;
Dbg\[Breve]Inside\[Breve]Breakpoint=False;



Make\[Breve]Palette[title_String,info_List,nb_]:=
  Module[{s,wm,nb1=SelectedNotebook[],ans},
    If[nb===None,
      wm={{Automatic,5.`},{Automatic,2.`}},
      wm=(WindowMargins/.Options[nb,WindowMargins]);
      ];
    s=Notebook[{Cell[
            BoxData[GridBox[info,RowSpacings\[Rule]{0,0,1,0},
                RowLines\[Rule]False]],"NotebookDefault"] }, 
        ClosingAutoSave\[Rule]True,
        Editable\[Rule]False,
        WindowToolbars\[Rule]{},
        WindowSize\[Rule]{Fit,Fit},
        WindowMargins\[Rule]wm, 
        WindowFrame\[Rule]"Palette",
        WindowElements\[Rule]{"StatusArea"},
        WindowFrameElements\[Rule]"CloseBox",
        WindowClickSelect\[Rule]False,
        WindowTitle\[Rule]title,
        ShowCellBracket\[Rule]False,
        Selectable\[Rule]False;
        CellMargins\[Rule]{{0.`,0.`},{0,0.`}}, 
        CellOpen\[Rule]True,
        ShowCellLabel\[Rule]False,
        ShowCellTags\[Rule]False,
        ImageMargins\[Rule]{{0.`,Inherited},{Inherited,0.`}},
        Background\[Rule]GrayLevel[0.7]
        ];
    ans=If[nb===None,
        NotebookPut[s],
        NotebookPut[s,nb]
        ];
    SetSelectedNotebook[nb1];
    ans
    ]



Debug\[Breve]Palette\[Breve]Title="Dbg";

Dbg\[Breve]Make\[Breve]Palette[]:=Module[{nbl=Notebooks[],k,oldnb=None},
    (* Seek for an existing notebook before creating a new one. 
          We identify one of ours by the title *)
    k=1;
    While[k\[LessEqual]Length[nbl],
      If[(WindowTitle /. Options[nbl[[k]],WindowTitle])\[Equal]
          Debug\[Breve]Palette\[Breve]Title,
        oldnb=nbl[[k]];
        (*Break[]; *)
        ];
      k++;
      ];
    With[{Resume\[Breve]Mode=Resume\[Breve]Mode,
        Trace\[Breve]Mode=Trace\[Breve]Mode,Step\[Breve]Mode=Step\[Breve]Mode,
        Step\[Breve]Over\[Breve]Mode=Step\[Breve]Over\[Breve]Mode,
        Abort\[Breve]Mode=Abort\[Breve]Mode,
        New\[Breve]Break\[Breve]Mode=New\[Breve]Break\[Breve]Mode,
        Colour\[Breve]Break\[Breve]Mode=Colour\[Breve]Break\[Breve]Mode},
      Dbg\[Breve]Palette\[Breve]Notebook=
        Imtek`Foreign`debugger`Private`Make\[Breve]Palette[
          Debug\[Breve]Palette\[Breve]Title, {
            {ButtonBox[
                MakeBoxes[Dbg\[Breve]Coloured["Colour selection"],
                  StandardForm],ButtonEvaluator\[Rule]Automatic,
                ButtonFunction \[RuleDelayed] Dbg\[Breve]Add\[Breve]Colour[],
                Active\[Rule]True]},
            
            {ButtonBox["Remove colour",ButtonEvaluator\[Rule]Automatic,
                ButtonFunction \[RuleDelayed] 
                  Dbg\[Breve]Remove\[Breve]Colour[],Active\[Rule]True]},
            
            {ButtonBox["Abort process",ButtonEvaluator\[Rule]None,
                ButtonFunction\[Rule](FrontEnd`SetOptions[$FrontEnd,
                      StartupSound\[Rule]True]),Active\[Rule]True]},
            
            {ButtonBox["Resume",ButtonEvaluator\[Rule]None,
                ButtonFunction \[RuleDelayed]  (FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]Resume\[Breve]Mode];
                    FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]},
            
            {ButtonBox["Step",ButtonEvaluator\[Rule]None,
                ButtonFunction\[RuleDelayed](FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]Step\[Breve]Mode];
                    FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]},
            
            {ButtonBox["Step over",ButtonEvaluator\[Rule]None,
                ButtonFunction\[RuleDelayed](FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]Step\[Breve]Over\[Breve]\
Mode];FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]},
            
            {ButtonBox["Set break point",ButtonEvaluator\[Rule]None,
                ButtonFunction\[RuleDelayed](FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]New\[Breve]Break\[Breve]\
Mode];FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]},
            
            {ButtonBox["Colour break",ButtonEvaluator\[Rule]None,
                ButtonFunction\[RuleDelayed](FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]Colour\[Breve]Break\
\[Breve]Mode];FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]},
            
            {ButtonBox["Trace back",ButtonEvaluator\[Rule]None,
                ButtonFunction \[RuleDelayed] (FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]Trace\[Breve]Mode];
                    FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]},
            
            {ButtonBox["Abort",ButtonEvaluator\[Rule]None,
                ButtonFunction \[RuleDelayed] (FrontEnd`SetOptions[$FrontEnd,
                      AnimationCycleRepetitions\[Rule]Abort\[Breve]Mode];
                    FrontEnd`ExitSubsession[Automatic]),Active\[Rule]True]}
            } ,oldnb
          ]
      ]
    ]

Write\[Breve]Status\[Breve]Line[]:=
    LinkWrite[$ParentLink,
      SetNotebookStatusLine[Dbg\[Breve]Palette\[Breve]Notebook,
        "Step "<>ToString[Dbg\[Breve]Expression\[Breve]Count]]];



MakeExpression[TagBox[a_,Identity],StandardForm]:=
  MakeExpression[RowBox[{"Dbg\[Breve]Coloured","[",a,"]"},StandardForm]]

Dbg\[Breve]Coloured/: MakeBoxes[Dbg\[Breve]Coloured[x_],StandardForm]:=
  TagBox[StyleBox[MakeBoxes[x,StandardForm],Background\[Rule]RGBColor[0,1,1]],
    Identity]

SetAttributes[Dbg\[Breve]Coloured,HoldAll];

Dbg\[Breve]Coloured[x_Symbol/;(! ValueQ[x])]:=x;
Dbg\[Breve]Coloured[x_]:=Module[{ans},
    If[! Dbg\[Breve]Running,Dbg\[Breve]Notebook=InputNotebook[]];
    ans=x;
    Dbg\[Breve]Print[HoldForm[Dbg\[Breve]Coloured[x]],
      Dbg\[Breve]Blue["  \[LongRightArrow]  "],ans];
    ans
    ]


Dbg\[Breve]Add\[Breve]Colour[]:=Module[{d,nb=InputNotebook[],bc},
    (* Strip any colour within colour *)
    d=NotebookRead[nb]/.BoxData[x_,___]\[Rule]x//.TagBox[StyleBox[x_,___],
              Identity]\[Rule]x/.StyleBox[x_,
            Background\[Rule]RGBColor[0,1,1]]\[Rule]x;
    (* Don't proceed if there is colour extending outside the selection *)
    bc=(List@@
            Options[NotebookSelection[nb],Background]\[LeftDoubleBracket]1,
              2\[RightDoubleBracket])-{0,1,1};
    If[Dot[bc,bc]<0.1,Return[]];
    If[d=!={},
      NotebookWrite[nb,
          TagBox[StyleBox[d,Background\[Rule]RGBColor[0,1,1]],Identity]];
      ]
    ]

Dbg\[Breve]Remove\[Breve]Colour[]:=Module[{d,nb=InputNotebook[]},
    d=NotebookRead[nb];
    If[! MatchQ[d,TagBox[_,Identity,___]],
      (* The selection may have selected the contents of the colour, 
        but not the colour itself *)
      SelectionMove[nb,All,Expression];
      d=NotebookRead[nb];
      ];
    d=d/.TagBox[StyleBox[x_,___],Identity]\[Rule]x;
    NotebookWrite[nb,d];
    ]



Build\[Breve]Triviality\[Breve]Table[]:=Module[{},
    Clear[Trivial];
    If[Filter\[Breve]Predicate=!=Null,
      With[{p=Filter\[Breve]Predicate},Trivial[q_]:=(!p[q])]];
    Map[(Trivial[#]=True)&,Exclude\[Breve]Head\[Breve]Set];
    If[Show\[Breve]Heads=!={},
      Map[(Trivial[#]=False)&,Show\[Breve]Heads];
      Trivial[_]=True
      ];
    ]

Essentially\[Breve]Constant[HoldForm[DirectedInfinity[1]]]:=True;
Essentially\[Breve]Constant[HoldForm[Infinity]]:=True;
Essentially\[Breve]Constant[HoldForm[x_Symbol]]:=(!ValueQ[x]);
Essentially\[Breve]Constant[HoldForm[x_String]]:=True;
Essentially\[Breve]Constant[HoldForm[x_Integer]]:=True;
 Essentially\[Breve]Constant[HoldForm[x_Real]]:=True; 
Essentially\[Breve]Constant[HoldForm[x_Rational]]:=True;
Essentially\[Breve]Constant[HoldForm[x_Complex]]:=True;
Essentially\[Breve]Constant[HoldForm[x_List]]:=True;


Dbg\[Breve]Head[HoldForm[s_[___]]]:=If[ValueQ[s],HoldForm[s],s]

Dbg\[Breve]Lhs\[Breve]Atom[HoldForm[s_[a_Symbol,___]]]:=OwnValues[a];
Dbg\[Breve]Lhs\[Breve]Atom[_]:={};

Dbg\[Breve]Pr1[Dbg\[Breve]Red[x___]]:=
    StyleBox[Dbg\[Breve]Pr1[x],FontColor\[Rule]RGBColor[1,0,0]];
Dbg\[Breve]Pr1[Dbg\[Breve]Blue[x___]]:=
  StyleBox[Dbg\[Breve]Pr1[x],FontColor\[Rule]RGBColor[0,0,1]]
Dbg\[Breve]Pr1[
      Dbg\[Breve]Tag[tag_]]:=(Dbg\[Breve]Cell\[Breve]Tag=ToString[tag];"");
Dbg\[Breve]Pr1[Dbg\[Breve]Full[x_]]:=
    ToBoxes[Short[x/.s_String\[RuleDelayed]FullForm[s],4]];
Dbg\[Breve]Pr1[Dbg\[Breve]Button[]]:=
    Module[{},
      Dbg\[Breve]Cell\[Breve]Tag=
        Dbg\[Breve]Tag\[Breve]Prefix<>
          ToString[Dbg\[Breve]Tags[Dbg\[Breve]Stack\[Breve]Level]];
      Return[
        ButtonBox[StyleBox["?",FontWeight\[Rule]"Bold"],
          ButtonFunction\[RuleDelayed]Dbg\[Breve]Select[],
          ButtonEvaluator\[Rule]Automatic,Active\[Rule]True]]];
Dbg\[Breve]Pr1[Dbg\[Breve]Button\[Breve]Up[tag_String]]:=
    ButtonBox[StyleBox["\[UpArrow]",FontWeight\[Rule]"Bold"],
      ButtonFunction\[RuleDelayed]Dbg\[Breve]Select\[Breve]Up[tag],
      ButtonEvaluator\[Rule]Automatic,Active\[Rule]True];
Dbg\[Breve]Pr1[Dbg\[Breve]Button\[Breve]Up[_]]:=Sequence[];
Dbg\[Breve]Pr1[Dbg\[Breve]Set[x___]]:=RowBox[Map[Dbg\[Breve]Pr1,{x}]];
Dbg\[Breve]Pr1[x_]:=ToBoxes[Short[x,4]];
Dbg\[Breve]Pr1[xx_,x__]:=RowBox[Map[Dbg\[Breve]Pr1,{xx,x}]]

Dbg\[Breve]Print[args___]:=Module[{},
    Dbg\[Breve]Cell\[Breve]Tag="Info";
    NotebookWrite[Dbg\[Breve]Notebook,
      Cell[BoxData[Dbg\[Breve]Pr1[args]],"Print",
        Background\[Rule]Dbg\[Breve]Print\[Breve]Colour,
        CellTags\[Rule]Dbg\[Breve]Cell\[Breve]Tag]]
    ]



Dbg\[Breve]Select[]:=
  Module[{nb=SelectedNotebook[],tags},SelectionMove[nb,All,ButtonCell];
    tags=Cases[NotebookRead[nb],(CellTags\[Rule]s_)\[Rule]s];
    SetOptions[nb,ShowCellBracket\[Rule]True];
    If[tags=!={},NotebookLocate[tags[[1]]]];
    ]

Dbg\[Breve]Select\[Breve]Up[tag_]:=Module[{nb=SelectedNotebook[],tags},
    SetOptions[nb,ShowCellBracket\[Rule]True];
    NotebookLocate[tag];
    ]



Print\[Breve]Stack[]:=
  Module[{s=Stack[_],ns,q,this\[Breve]head,started=False},
    ns=Length[s];
    While[ns\[GreaterEqual]1,
      q=s[[ns]];
      this\[Breve]head=Dbg\[Breve]Head[q];
      If[this\[Breve]head===TraceScan||this\[Breve]head===StackComplete,
        Break[]];
      If[started,
        Which[MemberQ[{While,Module,If},this\[Breve]head],
          Dbg\[Breve]Print[
            Dbg\[Breve]Red["Inside ",this\[Breve]head,"[",
              Extract[q,{1,1},HoldForm],",..."]],
          MemberQ[Abbreviated\[Breve]Constructs,this\[Breve]head],
          Dbg\[Breve]Print[
            Dbg\[Breve]Red["Inside ",this\[Breve]head,
              " construct: "]],(!MemberQ[Excluded\[Breve]Constructs,
                this\[Breve]head]),
          Dbg\[Breve]Print[Dbg\[Breve]Red["While evaluating: "],q]]];
      If[this\[Breve]head===Dbg1,started=True];
      ns--;
      ];
    ]



Dbg\[Breve]Stack\[Breve]Check[lev_]:=Block[{stk,ll,pp},
    pp=Dbg\[Breve]Last\[Breve]Goal\[Breve]Pos[lev];
    If[! NumberQ[pp],Return[False]];
    stk=Stack[_];
    ll=Length[stk];
    If[ll<pp ||  stk[[pp]]=!=Dbg\[Breve]Last\[Breve]Goal[lev],False,True]
    ]



Dbg\[Breve]Tag\[Breve]No=1;
Dbg\[Breve]New\[Breve]Tag[]:=Dbg\[Breve]Tag\[Breve]No++;



Dbg\[Breve]Clear\[Breve]Tags[lev_,old\[Breve]lev_]:=
  Module[{k=old\[Breve]lev},
    While[k>lev,
      Dbg\[Breve]Tags[k]=False;
      k--;
      ];
    k=lev;
    While[k>old\[Breve]lev,
      Dbg\[Breve]Tags[k]=False;
      k--;
      ];
    ]



Dbg\[Breve]Bumf[sl_]:=Module[{k=Dbg\[Breve]Stack\[Breve]Level-1,tg=""},
    While[k>0,
      If[IntegerQ[Dbg\[Breve]Tags[k]],Break[]];
      k--;
      ];
    If[k>0,tg=Dbg\[Breve]Tags[k]];
    Dbg\[Breve]Set[Dbg\[Breve]Button[],
      Dbg\[Breve]Button\[Breve]Up[Dbg\[Breve]Tag\[Breve]Prefix<>ToString[tg]],
      If[Dbg\[Breve]Show\[Breve]Levels,
        Dbg\[Breve]Red["(",Dbg\[Breve]Expression\[Breve]Count,",",sl,
          ")     "],
        Dbg\[Breve]Red["(",Dbg\[Breve]Expression\[Breve]Count,")     "]]]
    ]



Dbg\[Breve]Release[g_]:=Module[{prot=Attributes[g]},
      Unprotect[g];
      DownValues[g]=
        Select[DownValues[g],FreeQ[#,Dbg\[Breve]Identity]&];
      SetAttributes[g,prot];
      ];
Dbg\[Breve]Inhibit[g_]:=Module[{dw=DownValues[g],prot},
      If[FreeQ[dw,Dbg\[Breve]Identity],
          prot=Attributes[g];
          Unprotect[g];
          
          DownValues[g]=
            Prepend[dw,
              HoldPattern[g[x___]]\[RuleDelayed]
                Dbg\[Breve]Identity[g[x]]/;Dbg\[Breve]Flag[]];
          SetAttributes[g,prot];
          ];
      ];
SetAttributes[Dbg\[Breve]Identity,HoldAll];
Dbg\[Breve]Identity[x_]:=(Dbg\[Breve]Flag\[Breve]Result=False;x);
Dbg\[Breve]Flag[]:=
  If[Dbg\[Breve]Flag\[Breve]Result,True,Dbg\[Breve]Flag\[Breve]Result=True;
    False]



Dbg\[Breve]Breakpoint[]:=Module[{looping},
    If[Dbg\[Breve]Return\[Breve]Mode\[NotEqual]Step\[Breve]Mode,
      Dbg\[Breve]Print[Dbg\[Breve]Red["Breakpoint encountered"]]];
    (* Clean up the various flags so things work interactively *)
    Max\[Breve]Dbg\[Breve]Print=\[Infinity];
    Dbg\[Breve]Skip=\[Infinity];
    Dbg\[Breve]Trigger\[Breve]On=Null;
    Dbg\[Breve]Trigger\[Breve]Off=Null;
    (* Loop processing commands until a command requires us to run the users \
code *)
    looping=True;
    While[looping,
      Dbg\[Breve]Return\[Breve]Mode=Resume\[Breve]Mode;
      Dbg\[Breve]Inside\[Breve]Breakpoint=True;
      Dialog[];
      Dbg\[Breve]Return\[Breve]Mode=
        Options[$FrontEnd,AnimationCycleRepetitions][[1,2]];
      Dbg\[Breve]Inside\[Breve]Breakpoint=False;
      SetSelectedNotebook[Dbg\[Breve]Notebook];
      (* Decode the users command *)
      If[Dbg\[Breve]Return\[Breve]Mode==New\[Breve]Break\[Breve]Mode,
        Dbg\[Breve]Read\[Breve]New\[Breve]Breakpoint[]];
      If[Dbg\[Breve]Return\[Breve]Mode\[Equal]
          Colour\[Breve]Break\[Breve]Mode,
        Dbg\[Breve]Break\[Breve]Pattern=HoldForm[Dbg\[Breve]Coloured[_]];
        Dbg\[Breve]Return\[Breve]Mode=Resume\[Breve]Mode;
        ];
      If[Dbg\[Breve]Return\[Breve]Mode==Abort\[Breve]Mode || 
          Dbg\[Breve]Return\[Breve]Mode==Resume\[Breve]Mode||
          Dbg\[Breve]Return\[Breve]Mode==Step\[Breve]Mode ||
          Dbg\[Breve]Return\[Breve]Mode==Step\[Breve]Over\[Breve]Mode,
        looping=False];
      If[Dbg\[Breve]Return\[Breve]Mode==Trace\[Breve]Mode,
        Print\[Breve]Stack[]];
      ];
    ]

Dbg\[Breve]Read\[Breve]New\[Breve]Breakpoint[]:=Module[{s},
    s=InputString["Enter new breakpoint pattern"];
    Dbg\[Breve]Break\[Breve]Pattern=ToExpression[s,InputForm,HoldForm];
    Dbg\[Breve]Return\[Breve]Mode=Resume\[Breve]Mode;
    ]



Dbg1[HoldForm[m_Message]]:=Module[{this\[Breve]head},
    (* If we debug a Message construct then we want to give up with a stack \
print unless the nessage has been turned off *)
    If[Check[m,$Failed]=!=$Failed,Return[]];
    Dbg\[Breve]Print[
      Dbg\[Breve]Red["Dbg aborting at step ",
        Dbg\[Breve]Expression\[Breve]Count]];
    If[Dbg\[Breve]Break\[Breve]Fail,
      Dbg\[Breve]Breakpoint[],
       Print\[Breve]Stack[]
      ];
           Abort[];
    ]; 
Dbg1[x_]:=StackInhibit[
    Block[{sl=TraceLevel[],this\[Breve]tag="",next\[Breve]tag,tmp,at, 
        last\[Breve]level=Dbg\[Breve]Last\[Breve]Level,
        About\[Breve]To\[Breve]Break=False},
       Dbg\[Breve]Clear\[Breve]Tags[sl,last\[Breve]level]; 
      Dbg\[Breve]Last\[Breve]Level=sl;
      (* Some stuff is not required for printing *)
      this\[Breve]head=Dbg\[Breve]Head[x];
      If[ this\[Breve]head===Dbg\[Breve]Flag,Return[]];
      If[this\[Breve]head===Dbg\[Breve]Identity ,
        Dbg\[Breve]Pop\[Breve]Level=sl;
        Return[]
        ]; 
      (* We check for the pressing of the abort button every 500 steps to \
avoid the cost of interrogating the frontend.If the user presses the abort \
button this is signalled by setting the startupsound option. *) 
      If[ 
        Dbg\[Breve]Abort\[Breve]Counter--<
            0 && (!Dbg\[Breve]User\[Breve]Abort) ,
        Write\[Breve]Status\[Breve]Line[];
        Dbg\[Breve]Abort\[Breve]Counter=500;
        If[ StartupSound/.Options[$FrontEnd,StartupSound],
          If[Dbg\[Breve]Break\[Breve]Fail,
            Dbg\[Breve]Return\[Breve]Mode=Step\[Breve]Mode,
            (* 
              Set up to print a few steps before aborting in response to a \
press of the abort button *)
            Max\[Breve]Dbg\[Breve]Print=\[Infinity];
            Dbg\[Breve]Skip=-1;
            Dbg\[Breve]User\[Breve]Abort=True;
            Dbg\[Breve]Step\[Breve]Over\[Breve]Level=\[Infinity];
            Dbg\[Breve]Abort\[Breve]Step=
              Dbg\[Breve]Expression\[Breve]Count+
                Dbg\[Breve]Abort\[Breve]Step\[Breve]Count;
            Exclude\[Breve]Head\[Breve]Set=Excluded\[Breve]Constructs;
            Show\[Breve]Heads={};
            Build\[Breve]Triviality\[Breve]Table[];
            ];
          SetOptions[$FrontEnd,StartupSound\[Rule]False]
          ];
        ]; 
      If[Trivial[this\[Breve]head],Return[]];
      If[Dbg\[Breve]Step\[Breve]Over\[Breve]Level<sl,Return[]];
      If[sl>last\[Breve]level || (!Dbg\[Breve]Stack\[Breve]Check[sl]) ,
        If[sl \[NotEqual] Dbg\[Breve]Pop\[Breve]Level,
          (* Start of new evaluation chain *)
          If[Essentially\[Breve]Constant[x],Return[]];
          Dbg\[Breve]Tags[sl]=Dbg\[Breve]New\[Breve]Tag[]; 
          Dbg\[Breve]Last\[Breve]Goal[sl]=x;
          
          If[Dbg\[Breve]Return\[Breve]Mode\[Equal]Step\[Breve]Over\[Breve]\
Mode,
            Dbg\[Breve]Return\[Breve]Mode=Step\[Breve]Mode;
            Dbg\[Breve]Step\[Breve]Over\[Breve]Level=\[Infinity];
            ];
          (* 
            Note that we use Stack[] rather than Stack[_] - 
              there is a vast difference in performance! *)
          Dbg\[Breve]Last\[Breve]Goal\[Breve]Pos[sl]=Length[Stack[]];
          ]
        ];
      Dbg\[Breve]Pop\[Breve]Level=-1;
      Dbg\[Breve]Stack\[Breve]Level=sl;
      Dbg\[Breve]Expression\[Breve]Count++;
      If[Dbg\[Breve]Step\[Breve]Over\[Breve]Level==sl,Return[]];
      (* Suppress hidden functions and package functions if required *)
      If[Dbg\[Breve]Suppress\[Breve]Packages && (AtomQ[
                this\[Breve]head] && (!MemberQ[{"Global`","System`"},
                    Context[Evaluate[this\[Breve]head]]])&&
              this\[Breve]head =!=Dbg\[Breve]Coloured),
        Dbg\[Breve]Inhibit[this\[Breve]head];
        Hidden\[Breve]Functions=
          Union[Hidden\[Breve]Functions,{this\[Breve]head}]
        ]; 
      Dbg\[Breve]Step\[Breve]Over\[Breve]Level=\[Infinity];
      If[Dbg\[Breve]Step\[Breve]Over\[Breve]Level==\[Infinity] && 
          Dbg\[Breve]Return\[Breve]Mode\[Equal]Step\[Breve]Over\[Breve]Mode,
        Dbg\[Breve]Return\[Breve]Mode=Step\[Breve]Mode];
      If[MatchQ[x,Dbg\[Breve]Trigger\[Breve]On],Dbg\[Breve]Triggered=True];
      If[MatchQ[x,Dbg\[Breve]Break\[Breve]Pattern] || 
          Dbg\[Breve]Return\[Breve]Mode\[Equal]Step\[Breve]Mode,
        About\[Breve]To\[Breve]Break=True];
      If[About\[Breve]To\[Breve]Break || (Max\[Breve]Dbg\[Breve]Print>0 && 
              Dbg\[Breve]Triggered),
        If[Dbg\[Breve]Skip\[LessEqual]0 || About\[Breve]To\[Breve]Break,
          Max\[Breve]Dbg\[Breve]Print--;
          Write\[Breve]Status\[Breve]Line[];
          Which[
            
            MatchQ[x,HoldForm[z_Symbol/;ValueQ[z]]],
            
            Dbg\[Breve]Print[Dbg\[Breve]Bumf[sl],x,
              Dbg\[Breve]Blue["  \[LongRightArrow]  "],
              Extract[x/.HoldForm\[Rule]OwnValues,{1,2},HoldForm]],
            
            MemberQ[{For,Which},this\[Breve]head], 
            Dbg\[Breve]Print[Dbg\[Breve]Bumf[sl],this\[Breve]head,"[..."], 
            MemberQ[{While,With,Module,Block,If},this\[Breve]head],
            Dbg\[Breve]Print[Dbg\[Breve]Bumf[sl],this\[Breve]head,"[",
              Extract[x,{1,1},HoldForm],",..."],
            
            
            this\[Breve]head===
                Increment && (at=Dbg\[Breve]Lhs\[Breve]Atom[x])=!={},
            Dbg\[Breve]Print[Dbg\[Breve]Bumf[sl],x,
              Dbg\[Breve]Blue["  \[LongRightArrow]  "],
              Extract[at,{1,2},HoldForm]+1],
            
            
            this\[Breve]head===
                Decrement && (at=Dbg\[Breve]Lhs\[Breve]Atom[x])=!={},
            Dbg\[Breve]Print[Dbg\[Breve]Bumf[sl],x,
              Dbg\[Breve]Blue["  \[LongRightArrow]  "],
              Extract[at,{1,2},HoldForm]-1],
            
            True,
            
            If[MemberQ[Abbreviated\[Breve]Constructs,this\[Breve]head],
                Dbg\[Breve]Print[Dbg\[Breve]Bumf[sl],this\[Breve]head,"[...",
                  Dbg\[Breve]Link["Exit",next\[Breve]tag],
                  Dbg\[Breve]Tag[this\[Breve]tag]],Dbg\
                    \[Breve]Print[Dbg\[Breve]Bumf[sl],Dbg\[Breve]Full[x]]];
            ];
          
          If[Dbg\[Breve]Abort\[Breve]Step\[LessEqual]
              Dbg\[Breve]Expression\[Breve]Count,
            
            Dbg\[Breve]Print["Dbg aborting as requested at step ",
              Dbg\[Breve]Expression\[Breve]Count];
            Abort[]
            ];
          If[About\[Breve]To\[Breve]Break,
            Dbg\[Breve]Breakpoint[];
            If[Dbg\[Breve]Return\[Breve]Mode\[Equal]Abort\[Breve]Mode,
              Dbg\[Breve]Print[Dbg\[Breve]Red["Aborting as requested"]];
              Abort[]
              ];
            
            If[Dbg\[Breve]Return\[Breve]Mode\[Equal]Step\[Breve]Over\[Breve]\
Mode,
              Dbg\[Breve]Step\[Breve]Over\[Breve]Level=sl;
              ];
            ];
          If[Max\[Breve]Dbg\[Breve]Print==0,
            (* We have enough output, 
              so abort or continue silently as the user desires *)
             If[Dbg\[Breve]Continue,
                                                        
              Dbg\[Breve]Print[
                Dbg\[Breve]Red[
                  "Dbg print limit exceeded - execution continuing"]],
               
              Dbg\[Breve]Print[
                Dbg\[Breve]Red["Dbg print limit exceeded - aborting"]];
                                                        Abort[]
              ]
            ]
          ];
        Dbg\[Breve]Skip--;
        ];
      If[MatchQ[x,Dbg\[Breve]Trigger\[Breve]Off],Dbg\[Breve]Triggered=False] 
      ]
    ]



Dbg::badargs="Invalid options to Dbg";
Dbg::notreentrant="You are already using Dbg to debug another program";
SetAttributes[Dbg,HoldAll];
SetAttributes[Dbg2,HoldAll];
Options[Dbg]={MaxSteps\[Rule]10,ShowHeads\[Rule]{},ExcludeHeads\[Rule]{},
      FilterHeads\[Rule]Null,ContinueExecution\[Rule]True,StartStep\[Rule]1,
      TriggerOn\[Rule]Null,BreakAt\[Rule]Null,BreakFail\[Rule]False,
      Step\[Rule]False,TriggerOff\[Rule]Null,ShowLevels\[Rule]False,
      SuppressPackages\[Rule]True,HiddenFunctions\[Rule]{},
      AbortStep\[Rule]\[Infinity],AbortStepCount\[Rule]10};
Dbg\[Breve]Print\[Breve]Colour=RGBColor[1.,0.8,0.8];
Dbg2[x_,opt___?OptionQ]:=
  Module[{ans,Dbg\[Breve]Opts=Options[Dbg],options,ssound,sanimation},
    If[Dbg\[Breve]Inside\[Breve]Breakpoint,Message[Dbg::notreentrant];
      Abort[]]; 
    options=Part[Hold[{opt}]/.Rule\[Rule]RuleDelayed,1];
    Dbg\[Breve]Notebook=InputNotebook[];
    Dbg\[Breve]Expression\[Breve]Count=0;
    Clear[Dbg\[Breve]Tags];
    Dbg\[Breve]Flag\[Breve]Result=True;
    (* Ensure tags do not match stuff from other runs of Dbg! *)
    Dbg\[Breve]Tag\[Breve]Prefix=
      "Dbg_"<>StringJoin@@Map[ToString[#]<>"_"&,Date[]];
    Dbg\[Breve]Pop\[Breve]Level=-1;
    Dbg\[Breve]Step\[Breve]Over\[Breve]Level=\[Infinity];
    Dbg\[Breve]Tags[1]=Dbg\[Breve]New\[Breve]Tag[];
    Dbg\[Breve]Tags[2]=Dbg\[Breve]New\[Breve]Tag[];
    Dbg\[Breve]Last\[Breve]Level=0;
    Dbg\[Breve]Return\[Breve]Mode=Resume\[Breve]Mode;
    Dbg\[Breve]Abort\[Breve]Counter=0;
    Dbg\[Breve]User\[Breve]Abort=False;
    (*Test for meaningless arguments*)
    If[Complement[options/.\[InvisibleSpace](a_\[RuleDelayed]b_)\[Rule]a,
          Options[Dbg]/.Rule\[Rule]
                RuleDelayed/.\[InvisibleSpace](a_\[RuleDelayed]b_)\[Rule]
              a]=!={},Message[Dbg::badargs];Abort[]];
    (*Decode the arguments*)
    Max\[Breve]Dbg\[Breve]Print=MaxSteps/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Abort\[Breve]Step=AbortStep/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Break\[Breve]Fail=BreakFail/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Abort\[Breve]Step\[Breve]Count=
      AbortStepCount/.options/.Dbg\[Breve]Opts;
    If[Step/.options/.Dbg\[Breve]Opts,
      Dbg\[Breve]Return\[Breve]Mode=Step\[Breve]Mode];
    Dbg\[Breve]Skip=(StartStep/.options/.Dbg\[Breve]Opts)-1;
    Dbg\[Breve]Break\[Breve]Pattern=
      HoldForm[BreakAt]/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Trigger\[Breve]On=
      HoldForm[TriggerOn]/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Trigger\[Breve]Off=
      HoldForm[TriggerOff]/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Show\[Breve]Levels=ShowLevels/.options/.Dbg\[Breve]Opts;
    If[Dbg\[Breve]Trigger\[Breve]On===HoldForm[Null],
      Dbg\[Breve]Trigger\[Breve]On=Null];
    If[Dbg\[Breve]Trigger\[Breve]Off===HoldForm[Null],
      Dbg\[Breve]Trigger\[Breve]Off=Null];
    If[Dbg\[Breve]Break\[Breve]Pattern===HoldForm[Null],
      Dbg\[Breve]Break\[Breve]Pattern=Null];
    Dbg\[Breve]Triggered=If[Dbg\[Breve]Trigger\[Breve]On===Null,True,False];
    Dbg\[Breve]Continue=ContinueExecution/.options/.Dbg\[Breve]Opts;
    Dbg\[Breve]Suppress\[Breve]Packages=
      SuppressPackages/.options/.Dbg\[Breve]Opts;
    Show\[Breve]Heads=Flatten[{ShowHeads/.options/.Dbg\[Breve]Opts}];
    Filter\[Breve]Predicate=FilterHeads/.options/.Dbg\[Breve]Opts;
    Exclude\[Breve]Head\[Breve]Set=
      Flatten[{ExcludeHeads/.options/.Dbg\[Breve]Opts}]\[Union]Excluded\
\[Breve]Constructs;
    Hidden\[Breve]Functions=
      Flatten[{HiddenFunctions/.options/.Dbg\[Breve]Opts}];
    Map[Dbg\[Breve]Inhibit,Hidden\[Breve]Functions];
    ssound=StartupSound/.Options[$FrontEnd,StartupSound];
    sanimation=
      AnimationCycleRepetitions/.Options[$FrontEnd,
          AnimationCycleRepetitions];
    SetOptions[$FrontEnd,StartupSound\[Rule]False];
    Build\[Breve]Triviality\[Breve]Table[];
    (*Start the debug*)
    Dbg\[Breve]Running=True;
    CheckAbort[Dbg\[Breve]Initial\[Breve]Expression=HoldForm[x];
      ans=
        TraceScan[Dbg1,StackComplete[x],
          TraceOff\[RuleDelayed] (_Dbg\[Breve]Identity | \
_Dbg\[Breve]Flag|_Dbg\[Breve]Coloured)],ans=$Aborted];
    Map[Dbg\[Breve]Release,Hidden\[Breve]Functions];
    SetOptions[$FrontEnd,StartupSound\[Rule]ssound];
    SetOptions[$FrontEnd,AnimationCycleRepetitions\[Rule]sanimation];
    Dbg\[Breve]Print[
      Dbg\[Breve]Red[Dbg\[Breve]Expression\[Breve]Count," steps in all"]]; 
    Dbg\[Breve]Running=False;
    Write\[Breve]Status\[Breve]Line[];
    ans
    ];

Dbg[opt___]:=Function[u,Dbg2[u,opt],{HoldAll}];

End[];

EndPackage[]

Dbg\[Breve]Make\[Breve]Palette[];

