(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)





(* *)
(* Title: Polygon.m *)
(* Context: *)
(* Author:oliver ruebenkoenig *)
(* 
  Date: 5.11.2007, somewhere close to erfurt *)
(* 
  Summary: Polygon convex intersection *)
(* Package Copyright: GNU GPL *)
(* 
  Package Version: 0.4.6 *)
(* Mathematica Version: 5.1 *)
(* History: 
    Added a check for imsConvexIntersect if polygons are in counterclockwise \
orientation.;
  Introduced compatability stuff for mma6.0;
  Introduced imsCenterOfMass for nD polygons;
  Area computed real solutions for integer input - fixed that;
  Made name change from MakeGraph to imsMakeNexus;
  Prof. J. G. Korvink contributed the PolygonToGraph;
  Prof. J. G. Korvink contributed the imsTriangulatePolygon;
  imsMonotoneSplitPolygon, imsTriangulateMonotonePolygon to version 0.4.0;
  Bug fix;
  Added some special cases
  *)
(* Keywords: *)
(* Sources:"Computation Geometry in C", J.O`Rourke  *)
(* 
  Warnings: *)
(* 
  Limitations:  
    ConvexPolygonIntersect is on J.O`Rourke and his copyright conditions *)
(* 
  Discussion: *)
(* Requirements: *)
(* Examples: *)
(* *)



(* Start Package *)
BeginPackage["Imtek`Polygon`", {"Imtek`Graph`"} ]





(* *)
(* documentation *)
(* *)
Needs["Imtek`Maintenance`"]
imsCreateObsoleteFunctionInterface[ Polygon2DQ, $Context ];
imsCreateObsoleteFunctionInterface[ Polygon3DQ, $Context ];
imsCreateObsoleteFunctionInterface[ PolygonQ, $Context ];
imsCreateObsoleteFunctionInterface[ PointInPolygonQ, $Context ];
imsCreateObsoleteFunctionInterface[ Area, $Context ];
imsCreateObsoleteFunctionInterface[ ClosePolygon, $Context ];
imsCreateObsoleteFunctionInterface[ ConvexIntersect, $Context ];
imsCreateObsoleteFunctionInterface[ EdgeLength, $Context ];
imsCreateObsoleteFunctionInterface[ MonotoneSplitPolygon, $Context ];
imsCreateObsoleteFunctionInterface[ PolygonizeCircle, $Context ];
imsCreateObsoleteFunctionInterface[ PolygonToNexus, $Context ];
imsCreateObsoleteFunctionInterface[ TriangulateMonotonePolygon, $Context ];
imsCreateObsoleteFunctionInterface[ TriangulatePolygon, $Context ];

(* constructors *)

(* selectors *)

(* predicates *)
imsPolygon2DQ::usage = 
    "imsPolygon2DQ[ expr ] returns true if expr is a 2D polygon.";

imsPolygon3DQ::usage =
    "imsPolygon3DQ[ expr ] returns true if expr is a 3D polygon.";

imsPolygonQ::usage =
    "imsPolygonQ[ expr ] returns true if expr is a polygon.";

imsPointInPolygonQ::usage = "imsPointInPolygonQ[ point, polygon, n ] returns True if the point is within the Polygon. You can set the precision with n. Default is $MachinePrecision."
\

(* functions *)

imsArea::usage = "imsArea[ polygon ] returns the Area of the polygon." 

imsCenterOfMass::usage = \
"imsCenterOfMass[ polygon ] returns the center of mass for the polygon.";

imsClosePolygon::usage = "imsClosePolygon[ polygon ] appends the first coordinate of polygon to its end."
\

imsConvexIntersect::usage = 
  "imsConvexIntersect[ { polygon, polygon } ] returns the intersection of the two polygons. You can set the precision with n. Default is $MachinePrecision."
\

imsEdgeLength::usage="imsEdgeLength[ polygon ] gives edge length making up polygon."
\

imsMonotoneSplitPolygon::usage="imsMonotoneSplitPolygon[ polygon ] splits the general planar polygon into nonoverlapping vertically monotone polygons.";\


imsPolygonizeCircle::usage = "imsPolygonizeCircle[ Circle, n ] returns a polygonized version of the circle specified. The polygon is made up from n points on the circumference of the circle."
\

imsPolygonToNexus::usage="PolygonToGraph[ polygon ] triangulates polygon and and returns the result as imsNexus.";\


imsTriangulateMonotonePolygon::usage="imsTriangulateMonotonePolygon[ polygon ] triangulates the monotone polygon into nonoverlapping polygons.";\


imsTriangulatePolygon::usage="imsTriangulatePolygon[ polygon ] triangulates the general planar polygon into nonoverlapping triangles.";\






(* *)
(* Error Messages *)
(* *)

yIntersection::"outOfRange"="Edge out of range";

makePolygonUnique::"nonUnique"="Polygon has duplicate vertices. These will be removed before continuing.";\

makePolygonUnique::"notAPoly"="The number of unique vertices of the polygon are less than 3.";\


imsTriangulatePolygon::"notA3DPoly"="The polygon should have 3D vertex coordinates.";\

imsTriangulatePolygon::"notAPoly"="The polygon should have at least 3 vertices.";\

imsTriangulatePolygon::"notAPlanarPoly"="The polygon is not planar.";

imsConvexIntersect::"clockwiseOrientation" = "Polygon `1` should be given in counter clockwise orientation. Use Revers[].";



Begin["`Private`"];



If[$VersionNumber \[LessEqual] 5.2, Get["Geometry`Rotations`"],Null;];
Needs[ "Imtek`Point`" ];
Needs[ "Imtek`LineSegment`" ];
Needs["Imtek`Nodes`"];
Needs["Imtek`MeshElementLibrary`"];



(* *)
(* define your options *)
(* *)



(* selector *)



(* predicates *)
imsPolygon2DQ[ { { _, _ }... } ] := True 
imsPolygon2DQ[ ___ ] := False
imsPolygon3DQ[ { { _,_, _ } ... } ] := True
imsPolygon3DQ[ ___ ] := False;
imsPolygonQ[ expr_ ] := imsPolygon2DQ[ expr ] || imsPolygon3DQ[ expr ];
imsPolygonQ[ ___ ] := False;

imsPointInPolygonQ[ point_, polygon_, n_:$MachinePrecision ] := 
    And @@ ( imsCollinearQ[ #, point, GreaterEqual, n ]& /@ 
          Partition[ polygon, 2, 1, { 1 } ] );



(* version dependent definition of rotate function for mma6.0 *)
If[ \
$VersionNumber \[LessEqual] 5.2,
  versionRotate2D[ v_, t_, c_  ] := Rotate2D[ v, t, c ],
  versionRotate2D[ v_, t_, c_  ] :=  c + RotationMatrix[ -t ].(v-c)
  ]

(* *)
(* functions *)
(* *)



imsCenterOfMass[ a:{ {_, ___ } .. } ] := 
  1/Length[ a ] *  Plus@@@ Transpose[ a ]



imsClosePolygon[p:{{_,_}..}]:=Join[p,{p[[1]]}];
imsClosePolygon[p:{{_,_,_}..}]:=Join[p,{p[[1]]}];



imsEdgeLength[ a_ ] /; imsPolygonQ[ a ]:=
    
    MapThread[ imsDistance[ { #1, #2 } ]&, { a, RotateLeft[ a, 1 ] } ] ;



(* triangle imsArea *)
(* 2D *)

imsArea[ { { xi_, yi_ }, { xj_, yj_ }, { xk_, yk_ } } ] :=
    
    1/2  * ( xi * ( yj - yk ) + xj * ( yk -yi ) + xk * ( yi - yj ) );

(* 3D *)
imsArea[ { { xi_, yi_, zi_ }, { xj_, yj_, zj_ }, { xk_, yk_, 
          zk_} } ]:=
    1/2*Sqrt[ ((xj * yi-xk * yi-xi * yj+xk * yj+xi * yk-xj * yk)^2+(xj * zi-
                  xk * zi-xi * zj+xk * zj+xi * zk-xj * zk)^2+(yj * zi-yk * zi-
                  yi * zj+yk * zj+yi * zk-yj * zk)^2) ];

(* 2D polygon area *)

imsArea[ a_ ] /; imsPolygon2DQ[ a ] := 
    1/2 * Plus @@
        Apply[ Function[ { x1, y1, x2, y2 },  ( x1 + x2 ) * ( y2 - y1 ) ], 
          Partition[ Flatten[ a ], 4, 2, { 1,1 } ], 1 ] ;



imsPolygonizeCircle[ Circle[ { x_, y_ }, r_ ], n_ ] := With[
      { theta = 2 Pi / n,
        vec =  { x +r * Cos[ 2 Pi / n ], y + r * Sin[ 2 Pi / n ] } },
      versionRotate2D[ vec , theta * #,  {x, y }  ]& /@ Range[ n ,1, -1 ]
      ];



imsConvexIntersect[ { p_, q_ }, accugoal_:$MachinePrecision ] /; 
      imsPolygon2DQ[ p ] && imsPolygon2DQ[ q ]:= Module[
      {
        n = Length[ p ],
        m = Length[ q ],
        a = 1, b = 1, aa = 0, ba = 0,A, B,
        pointA, pointA1, pointB, pointB1,
        inFlag = Unknown,FirstPoint = True,
        cross, aHB, bHA,
        Origin = { 0, 0 },
        intersecPoint,
        newPolygonPoints = {}
        },
      
      (* check if orientation is counter clockwise, else reverse polygon *)
  
          If[ imsArea[ p ] < 0, 
        Message[imsConvexIntersect::"clockwiseOrientation", 1 ]; Abort[]; ];
      If[ imsArea[ q ] < 0, 
        Message[imsConvexIntersect::"clockwiseOrientation", 2 ]; Abort[]; ];
      
      
      While[
        ( ( aa < n ) || ( ba < m ) ) &&  ( aa < 2*n ) && ( ba < 2*m ),
        
        
        a1 = Mod[ a + n -2, n ] + 1;
        b1 = Mod[ b + m -2, m ] + 1;
        (* Print[ " a: ", a, " a1: ", a1, " b: ", b, " b1: ", 
              b1 ]; *)
        
        pointA =  p[[ a ]] ;
        pointA1 = p[[ a1 ]];
        pointB =  q[[ b ]];
        pointB1 =  q[[ b1 ]];
        (* Print[ " pointA: ", pointA, " pA1: ", pointA1, " pB: ", pointB, 
              " pB1: ", pointB1 ]; *)
        
        A = pointA - pointA1;
        B = pointB - pointB1;
        
        (* these are triangle areas *)
        
        cross =  Sign[ Chop[ imsArea[ { Origin, A, B }  ], 10^-accugoal ] ];
        aHB = 
          Sign[ Chop[ imsArea[ { pointB1, pointB, pointA } ], 
              10^-accugoal ] ];
        bHA = 
          Sign[ Chop[ imsArea[ { pointA1, pointA, pointB } ], 
              10^-accugoal ] ];
        (* Print[ cross, " ", aHB, " ",  bHA ]; *)
        
        intersecPoint =
          imsLineSegmentIntersect[ { { pointA1, pointA }, { pointB1, 
                pointB } }, accugoal ];
        
        If[ imsCoord2DQ[ intersecPoint ],
          If[ inFlag === Unknown && FirstPoint,
            aa = ba = 0;
            FirstPoint = False;
            ];
          newPolygonPoints = { newPolygonPoints, intersecPoint };
          If[ aHB > 0, inFlag = Pin ];
          If[ bHA > 0, inFlag = Qin ];
          ];
        
        If[ imsLineSegmentQ[ intersecPoint ] && A.B < 0,
          Return[ intersecPoint ];
          ];
        
        
        (* If[ cross \[Equal] 0 && aHB < 0 && bHA < 0, Return[ List[] ] ];
          
          If[ cross \[Equal] 0 && aHB \[Equal] 0 && bHA \[Equal] 0,
            If[ inFlag === Pin,
              ba++; b = Mod[ b, m ] + 1,
              aa++;a = Mod[ a, n ] + 1;
              ]
            ];
          
          
          If[ cross \[Equal] 0 && aHB \[LessEqual] 0 && 
              bHA \[GreaterEqual] 0,
            If[ inFlag === Pin,
              ba++; b = Mod[ b, m ] + 1,
              aa++;a = Mod[ a, n ] + 1
              ]
            ];
          
          
          If[ cross \[Equal] 0 && aHB \[GreaterEqual] 0 && 
              bHA \[GreaterEqual] 0,
            If[ inFlag === Pin,
              ba++; b = Mod[ b, m ] + 1,
              aa++;a = Mod[ a, n ] + 1
              ]
            ];
          
          If[ cross \[Equal] 0 && aHB >  0 && bHA <  0,
            If[ inFlag === Pin,
              ba++; b = Mod[ b, m ] + 1,
              aa++;a = Mod[ a, n ] + 1
              ]
            ];
          *)
        
        If[ cross \[Equal] 0,
          Which[
            aHB < 0 && bHA < 0,  Return[ List[] ],
            
            True, If[ inFlag === Pin,
              ba++; b = Mod[ b, m ] + 1,
              aa++;a = Mod[ a, n ] + 1
              ]
            
            ]
          ];
        
        If[ cross >  0, If[ bHA >  0,
            
            If[ inFlag === Pin, 
              newPolygonPoints = { newPolygonPoints, p[[ a ]] } ]; aa++;
            a = Mod[ a, n ] + 1,
            
            If[ inFlag === Qin, 
              newPolygonPoints = { newPolygonPoints, q[[ b ]] } ]; ba++; 
            b = Mod[ b, m ] + 1 ;
            ]
          ];
        
        If[ cross < 0, If[ aHB > 0,
            
            If[ inFlag === Qin, 
              newPolygonPoints = { newPolygonPoints, q[[ b ]] } ]; ba++; 
            b = Mod[ b, m ] + 1,
            
            If[ inFlag === Pin, 
              newPolygonPoints = { newPolygonPoints, p[[ a ]] } ]; aa++; 
            a = Mod[ a, n ] + 1 ;
            ]
          ];
        
        
        ];
      
      newPolygonPoints =Partition[ Flatten[ Union[ newPolygonPoints ] ], 2 ];
      
      If[ inflag \[Equal] Unknown, Return[ List[] ] ];
      (* if a point is found it can appear duplicate *)
      
      Return[ newPolygonPoints  ];
      ];





uniqueVerticiesQ[poly_Polygon]:=uniqueVerticiesQ[poly[[1]]];
uniqueVerticiesQ[poly_List]:=Union[Chop[poly]]===Chop[N[poly]];

makePolygonUnique[poly_List]:=Module[{oldPoly,newPoly},
      oldPoly=Chop[poly];
      newPoly=Union[oldPoly];
      If[Length[newPoly]!=Length[oldPoly],
        Message[makePolygonUnique::"nonUnique"];
        newPoly=
          Part[oldPoly,
            Complement[
              Range[Length[oldPoly]],(Flatten[
                  Drop[#,1]&/@(Flatten[#]&/@
                        Select[(Position[oldPoly,#]&/@
                              newPoly),(Length[#]>1)&])])]];
        If[Length[newPoly]<3,
          Message[makePolygonUnique::"notAPoly"];
          Abort[]
          ],
        newPoly=oldPoly
        ];
      Return[newPoly]
      ];

collinearQ[a_List,b_List,c_List]:=Return[Chop[Cross[b-a,c-a]]=={0.,0.,0.}];

polygonArea[poly_List]:=Module[{i,j,n=Length[poly],cg},
      cg=poly[[1]];
      Return[(Plus@@Table[j=Mod[i,n]+1;
                (poly[[i,1]]-cg[[1]])*(poly[[j,2]]-cg[[2]])-(poly[[i,2]]-
                        cg[[2]])*(poly[[j,1]]-cg[[1]]),{i,1,n}])/2.]
      ];

makePolygonVerticallyUnique[badPoly_List]:=
    Module[{newPoly=badPoly,Theta=0,Theta1=N[E^1]/25.},
      While[Length[
            N[IntegerPart[Sort[(10^12*#1[[2]]&)/@newPoly]]/10^12]//.{x___,a_,
                  a_,y___}\[Rule]{x,a,y}]\[NotEqual]Length[newPoly],
        Theta+=N[E^1]/25.;
        newPoly=({{Cos[Theta],-Sin[Theta]},{Sin[Theta],Cos[Theta]}}.#1&)/@
            newPoly];
      Return[{Theta,newPoly}]];

vertexArea[a_List,b_List,c_List]:=a[[1]]*b[[2]]-a[[2]]*b[[1]]+
      a[[2]]*c[[1]]-a[[1]]*c[[2]]+
      b[[1]]*c[[2]]-b[[2]]*c[[1]];

vectorEqualQ[a:{_,(_)..},b:{_,(_)..}]:=((a-b).(a-b)<(Epsilon^2));

replacePolygonNodesByOriginals[originalInputPolygon:{{_,(_)..}..},
      polygonWithModifiedCoordinates:{{_,(_)..}..}]:=Module[{makeRule},
      
      (* Here we create some variant rules *)
      
      makeRule[lhs_,{rhs_}]:=
        Sequence[lhs\[Rule]rhs,N[lhs]\[Rule]rhs,
          Chop[lhs]\[Rule]rhs,{lhs[[1]],N[lhs[[2]]]}\[Rule]
            rhs,{N[lhs[[1]]],lhs[[2]]}\[Rule]rhs];
      originalInputPolygon[[#]]&/@(polygonWithModifiedCoordinates/.MapIndexed[
              makeRule,originalInputPolygon])
      ];





imsMonotoneSplitPolygon[imsPolygon[poly_],rotatePoly_:True]:=
    imsPolygon[#]&/@imsMonotoneSplitPolygon[poly,rotatePoly];

imsMonotoneSplitPolygon[Line[poly_],rotatePoly_:True]:=
    Line[#]&/@imsMonotoneSplitPolygon[poly,rotatePoly];

imsMonotoneSplitPolygon[polyList:{(_Line|_Polygon|{{_,_}..})..},
      rotatePoly_:True]:=imsMonotoneSplitPolygon[#,rotatePoly]&/@polyList;

imsMonotoneSplitPolygon[poly:{{_,_}..},rotatePoly_:True]:=
    Module[{sortedCoordRules,aAboveQ,cAboveQ,aLeftQ,classRules,
          vertexClassRules,sortedVertices,vertexBlockRules,
          blockUpSupportVertexRules,xIntersection,sideOfEdgeQ,sideOfBlockQ,
          gobbleRules,insertPositionQ,processVertex,
          planeSweepTable=Table[{},{Length[sortedVertices]}],
          edgesBlockRules={},blockEdgesRules={},upBlockRules={},
          downBlockRules={},criticalVertexClassRules,splits,splitPositions,
          newPolys,splitRun,newPoly,myDebug=False,i,Theta=0
          },
        
        newPoly=makePolygonUnique[poly];
        If[rotatePoly,
          {Theta,newPoly}=makePolygonVerticallyUnique[newPoly]
          ];
        
        sortedCoordRules=
          Sort[(C[#[[1]]]\[Rule]#[[2]])&/@
              Transpose[{Table[i,{i,1,Length[newPoly]}],
                  newPoly}],(#1[[2,2]]>#2[[2,
                        2]]||(#1[[2,1]]<#2[[2,1]]&&#1[[2,2]]==#2[[2,2]]))&];
        
        aAboveQ[{a_,b_,c_}]:=a[[2]]>b[[2]];
        cAboveQ[{a_,b_,c_}]:=c[[2]]>=b[[2]];
        aLeftQ[{a_,b_,c_}]:=a[[1]]<c[[1]];
        classRules={{False,False,False}\[Rule]UpTip,{False,False,True}\[Rule]
              BelowCusp,{False,True,False}\[Rule]
              RightFlank,{False,True,True}\[Rule]
              RightFlank,{True,False,False}\[Rule]
              LeftFlank,{True,False,True}\[Rule]
              LeftFlank,{True,True,False}\[Rule]
              AboveCusp,{True,True,True}\[Rule]DownTip};
        vertexClassRules=(VCR[#[[1]]]\[Rule]#[[2]])&/@
            Transpose[{Table[
                  i,{i,1,Length[
                      newPoly]}],(({aAboveQ[#],cAboveQ[#],aLeftQ[#]})&/@
                      Transpose[{RotateRight[newPoly],newPoly,
                          RotateLeft[newPoly]}])/.classRules}];
        
        sortedVertices=((#[[1]]/.C[v_]\[Rule]v)&/@sortedCoordRules);
        vertexBlockRules=(VBR[#[[1]]]\[Rule]#[[2]])&/@
            Transpose[{sortedVertices,(numBlocks=0;
                  (If[#===DownTip,{Null},
                          If[#===BelowCusp,
                            {++numBlocks,++numBlocks}
                            ,
                            {++numBlocks}]
                          ])&/@((VCR[#])&/@
                          sortedVertices/.vertexClassRules))}];
        
        blockUpSupportVertexRules=
          Complement[Flatten[If[#[[2,1]]=!=Null,If[Length[#[[2]]]\[Equal]2,
                      {(BUV[#[[2,
                                  1]]]\[Rule](#[[1]]/.VBR[
                                    v_]\[Rule]v)),(BUV[#[[2,
                                  2]]]\[Rule](#[[1]]/.VBR[v_]\[Rule]v))},
                      (BUV[#[[2,1]]]\[Rule](#[[1]]/.VBR[v_]\[Rule]v))
                      ]]&/@vertexBlockRules],{Null}];
        
        xIntersection[y_,edge_]:=Module[{p1,p2,t},
            p1=(C[(Mod[edge-1,Length[sortedVertices]]+1)]/.sortedCoordRules);
            p2=(C[(Mod[edge,Length[sortedVertices]]+1)]/.sortedCoordRules);
            If[p2[[2]]!=p1[[2]],
              t=(y-p1[[2]])/(p2[[2]]-p1[[2]]);
              If[t<-10^(-9)||t>1+10^(-9),
                
                Print["pt1: ",p1," pt2: ",p2," t: ",t," edge: ",edge," y-coord: ",
                  y];
                Message[yIntersection::"outOfRange"]
                ];
              Return[p1[[1]]+t(p2[[1]]-p1[[1]])],
              Return[p1[[1]]+0.5(p2[[1]]-p1[[1]])]
              ]
            ];
        
        sideOfEdgeQ[vertex_,edge_]:=Module[{vertexCoord,diff},
            vertexCoord=C[vertex]/.sortedCoordRules;
            diff=Chop[vertexCoord[[1]]-xIntersection[vertexCoord[[2]],edge]];
            If[diff<0,Return[AtLeft[edge]]];
            If[diff>0,Return[AtRight[edge]]];
            If[diff\[Equal]0,Return[OnEdge[edge]]]
            ];
        
        sideOfBlockQ[vertex_,block_List]:=Module[{},
            
            Head[#]&/@(sideOfEdgeQ[vertex,#]&/@block)/.{{AtLeft,
                    AtLeft}\[Rule]AtLeft[1],{AtRight,AtRight}\[Rule]AtRight[
                    1],{AtRight,AtLeft}\[Rule]SplitBlock[1],{OnEdge,
                    AtLeft}\[Rule]LeftOn[1],{AtRight,OnEdge}\[Rule]RightOn[
                    1],{OnEdge,OnEdge}\[Rule]DropBlock[1],_\[Rule]Error}
            ];
        
        gobbleRules={
            {x___,a_AtRight,b_AtRight,y___}\[RuleDelayed]{x,
                AtRight[a[[1]]+b[[1]]],y},
            {x___,a_AtRight,b_RightOn,y___}\[RuleDelayed]{x,
                RightOn[a[[1]]+b[[1]]],y},
            {x___,a_AtLeft,b_AtLeft,y___}\[Rule]{x,a,y},
            {x___,a_AtRight,b_SplitBlock,y___}\[RuleDelayed]{x,
                SplitBlock[a[[1]]+b[[1]]],y},
            {x___,a_SplitBlock,b_AtLeft,y___}\[RuleDelayed]{x,a,y},
            {x___,a_LeftOn,b_AtLeft,y___}\[Rule]{x,a,y},
            {x___,a_RightOn,b_LeftOn,y___}\[RuleDelayed]{x,
                MergeToRight[a[[1]]],y},
            {x___,a_AtRight,b_AtLeft,y___}\[RuleDelayed]{x,
                InsertAfter[a[[1]]],y},
            {x___,a_AtRight,b_LeftOn,y___}\[RuleDelayed]{x,
                LeftOn[a[[1]]+b[[1]]],y},
            {x___,a_AtRight,b_DropBlock,y___}\[RuleDelayed]{x,
                DropBlock[a[[1]]+b[[1]]],y},
            {x___,a_DropBlock,b_AtLeft,y___}\[RuleDelayed]{x,a,y},
            {x___,a_RightOn,b_AtLeft,y___}\[RuleDelayed]{x,a,y}
            };
        
        insertPositionQ[vertex_,sweepLine_List]:=
          Module[{where,pos=0,n=Length[sweepLine],scanned},
            
            scanned=Table[
                  sideOfBlockQ[vertex,sweepLine[[i]]],{i,1,n}]//.gobbleRules;
            Return[scanned[[1]]]
            ];
        
        processVertex[v_]:=
          Module[{currentBlock,n=Length[sortedVertices],positionV,insPos,
              edgeLeft,edgeRight,tmp},
            currentBlock=VBR[v]/.\[InvisibleSpace]vertexBlockRules;
            positionV=Flatten[Position[sortedVertices,v]][[1]];
            {edgeLeft,edgeRight}={Mod[v-1,n]+1,Mod[v-2,n]+1};
            
            If[positionV==1,
              
              blockEdgesRules={blockEdgesRules,
                  BER[currentBlock[[1]]]\[Rule]{edgeLeft,edgeRight}};
              
              edgesBlockRules={edgesBlockRules,
                  EBR[edgeLeft,edgeRight]\[Rule]currentBlock[[1]]};
              
              upBlockRules={upBlockRules,
                  UBR[currentBlock[[1]]]\[Rule]{Null}};
              tmp={{edgeLeft,edgeRight}};
              planeSweepTable[[positionV]]=tmp;
              Return[tmp]
              ];
            
            If[positionV>1,
              tmp=planeSweepTable[[positionV-1]];
              
              If[tmp=!={},
                insPos=insertPositionQ[v,planeSweepTable[[positionV-1]]];
                If[myDebug,
                  Print["processing: ",v];
                  Print["insPos: ",insPos]
                  ],
                Print[positionV," Failure"];
                Return[{}]
                ];
              
              Switch[VCR[v]/.\[InvisibleSpace]vertexClassRules,
                
                UpTip,
                
                blockEdgesRules=
                  Flatten[{blockEdgesRules,
                      BER[currentBlock[[1]]]\[Rule]{edgeLeft,edgeRight}}];
                
                edgesBlockRules=
                  Flatten[{edgesBlockRules,
                      EBR[edgeLeft,edgeRight]\[Rule]currentBlock[[1]]}];
                upBlockRules=
                  Flatten[{upBlockRules,UBR[currentBlock[[1]]]\[Rule]{Null}}];
                If[insPos===AtLeft[1],
                  tmp=Join[{{edgeLeft,edgeRight}},tmp]
                  ];
                If[insPos===AtRight[Length[tmp]],
                  tmp=Join[tmp,{{edgeLeft,edgeRight}}]
                  ];
                If[Head[insPos]===InsertAfter,
                  i=insPos[[1]];
                  
                  tmp=Join[Take[tmp,i],{{edgeLeft,edgeRight}},
                      Take[tmp,-(Length[tmp]-i)]]
                  ],
                
                DownTip,
                If[Head[insPos]===DropBlock,
                  i=insPos[[1]];
                  
                  downBlockRules={downBlockRules,
                      DBR[(EBR@@tmp[[i]])/.edgesBlockRules]\[Rule]{Null}};
                  tmp=Join[Take[tmp,i-1],Take[tmp,-(Length[tmp]-i)]]
                  ],
                
                LeftFlank,
                If[Head[insPos]===LeftOn,
                  i=insPos[[1]];
                  
                  blockEdgesRules=
                    Flatten[{blockEdgesRules,
                        BER[currentBlock[[1]]]\[Rule]{edgeLeft,tmp[[i,2]]}}];
                  edgesBlockRules=
                    Flatten[{edgesBlockRules,
                        EBR[edgeLeft,tmp[[i,2]]]\[Rule]currentBlock[[1]]}];
                  upBlockRules=
                    Flatten[{upBlockRules,
                        UBR[currentBlock[[1]]]\[Rule]{(EBR@@
                                  tmp[[i]])/.edgesBlockRules}}];
                  downBlockRules={downBlockRules,
                      DBR[(EBR@@
                                tmp[[i]])/.edgesBlockRules]\[Rule]{\
currentBlock[[1]]}};
                  
                  tmp=Join[Take[tmp,i-1],{{edgeLeft,tmp[[i,2]]}},
                      Take[tmp,-(Length[tmp]-i)]]
                  ],
                
                RightFlank,
                If[Head[insPos]===RightOn,
                  i=insPos[[1]];
                  
                  blockEdgesRules=
                    Flatten[{blockEdgesRules,
                        BER[currentBlock[[1]]]\[Rule]{tmp[[i,1]],
                            edgeRight}}];
                  
                  edgesBlockRules=
                    Flatten[{edgesBlockRules,
                        EBR[tmp[[i,1]],edgeRight]\[Rule]currentBlock[[1]]}];
                  upBlockRules=
                    Flatten[{upBlockRules,
                        UBR[currentBlock[[1]]]\[Rule]{(EBR@@
                                  tmp[[i]])/.edgesBlockRules}}];
                  downBlockRules={downBlockRules,
                      DBR[(EBR@@
                                tmp[[i]])/.edgesBlockRules]\[Rule]{\
currentBlock[[1]]}};
                  
                  tmp=Join[Take[tmp,i-1],{{tmp[[i,1]],edgeRight}},
                      Take[tmp,-(Length[tmp]-i)]]
                  ],
                
                AboveCusp,
                If[Head[insPos]===MergeToRight,
                  i=insPos[[1]];
                  
                  blockEdgesRules=
                    Flatten[{blockEdgesRules,
                        BER[currentBlock[[1]]]\[Rule]{tmp[[i,1]],
                            tmp[[i+1,2]]}}];
                  
                  edgesBlockRules=
                    Flatten[{edgesBlockRules,
                        EBR[tmp[[i,1]],
                            tmp[[i+1,2]]]\[Rule]currentBlock[[1]]}];
                  upBlockRules=
                    Flatten[{upBlockRules,
                        UBR[currentBlock[[1]]]\[Rule]{(EBR@@
                                  tmp[[i]])/.edgesBlockRules,(EBR@@
                                  tmp[[i+1]])/.edgesBlockRules}}];
                  
                  downBlockRules={downBlockRules,
                      DBR[(EBR@@
                                tmp[[i]])/.edgesBlockRules]\[Rule]{\
currentBlock[[1]]},DBR[(EBR@@
                                tmp[[i+1]])/.edgesBlockRules]\[Rule]{\
currentBlock[[1]]}};
                  
                  tmp=Join[Take[tmp,i-1],{{tmp[[i,1]],tmp[[i+1,2]]}},
                      Take[tmp,-(Length[tmp]-i-1)]]
                  ],
                
                BelowCusp,
                If[Head[insPos]===SplitBlock,
                  i=insPos[[1]];
                  
                  blockEdgesRules=
                    Flatten[{blockEdgesRules,
                        BER[currentBlock[[1]]]\[Rule]{tmp[[i,1]],edgeRight},
                        BER[currentBlock[[2]]]\[Rule]{edgeLeft,tmp[[i,2]]}}];
                  
                  edgesBlockRules=
                    Flatten[{edgesBlockRules,
                        EBR[tmp[[i,1]],edgeRight]\[Rule]currentBlock[[1]],
                        EBR[edgeLeft,tmp[[i,2]]]\[Rule]currentBlock[[2]]}];
                  
                  upBlockRules=
                    Flatten[{upBlockRules,
                        UBR[currentBlock[[1]]]\[Rule]{(EBR@@
                                  tmp[[i]])/.edgesBlockRules},
                        UBR[currentBlock[[2]]]\[Rule]{(EBR@@
                                  tmp[[i]])/.edgesBlockRules}}];
                  
                  downBlockRules={downBlockRules,
                      DBR[(EBR@@tmp[[i]])/.edgesBlockRules]\[Rule]
                        currentBlock};
                  
                  tmp=Join[
                      Take[tmp,
                        i-1],{{tmp[[i,1]],edgeRight},{edgeLeft,tmp[[i,2]]}},
                      Take[tmp,-(Length[tmp]-i)]]
                  ],
                
                _,
                Print["ERROR: Otherwise positionV ",positionV];
                Return[{}]
                ];
              planeSweepTable[[positionV]]=tmp;
              Return[tmp]
              ]
            ];
        
        planeSweepTable=Table[{},{Length[sortedVertices]}];
        edgesBlockRules={};
        blockEdgesRules={};
        upBlockRules={};
        downBlockRules={};
        (processVertex[#1]&)/@sortedVertices;
        blockEdgesRules=Flatten[blockEdgesRules];
        edgesBlockRules=Flatten[edgesBlockRules];
        upBlockRules=Flatten[upBlockRules];
        downBlockRules=Flatten[downBlockRules];
        
        criticalVertexClassRules=
          Drop[Union[(If[#[[2]]===BelowCusp||#[[2]]===AboveCusp,#,{}])&/@
                vertexClassRules],1];
        splits=If[#[[2]]===AboveCusp,
                {BUV[(DBR[(VBR[#[[1,
                                        1]]]/.vertexBlockRules)[[1]]]/.\
downBlockRules)[[1]]]//.blockUpSupportVertexRules,#[[1,1]]},
                If[#[[2]]===BelowCusp,
                  {#[[1,1]],
                    BUV[(UBR[(VBR[#[[1,
                                        1]]]/.vertexBlockRules)[[1]]]/.\
upBlockRules)[[1]]]//.blockUpSupportVertexRules}
                  ]
                ]&/@criticalVertexClassRules;
        
        splitRun[l_List,pos_List]:=Module[{p1,p2},
            {p1,p2}=Sort[pos];
            List[Join[Take[l,{1,p1}],Take[l,{p2,Length[l]}]],Take[l,{p1,p2}]]
            ];
        splitRun[l_List,pos_]:=If[pos===Null,{l}];
        
        newPolys={Table[i,{i,1,Length[newPoly]}]};
        Table[
          
          splitPositions=
            Transpose[{Flatten[(Position[#,splits[[j,1]]]&/@
                          newPolys)/.{}\[Rule]Null],
                  
                  Flatten[(Position[#,splits[[j,2]]]&/@newPolys)/.{}\[Rule]
                        Null]}]/.{{a_,Null}\[Rule]Null,{Null,a_}\[Rule]Null};
          
          newPolys=
            Flatten[Table[
                splitRun[newPolys[[i]],splitPositions[[i]]],{i,1,
                  Length[splitPositions]}],1];
          newPolys
          ,{j,1,Length[splits]}];
        newPolys=(Part[newPoly,#])&/@newPolys;
        
        If[myDebug,
          Print["processing: ",v];
          Print["vertexBlockRules: ",vertexBlockRules];
          Print["vertexClassRules: ",vertexClassRules];
          Print["blockUpSupportVertexRules: ",blockUpSupportVertexRules];
          Print["planeSweepTable: ",planeSweepTable];
          Print["blockEdgesRules: ",blockEdgesRules];
          Print["edgesBlockRules: ",edgesBlockRules];
          Print["upBlockRules: ",upBlockRules];
          Print["downBlockRules: ",downBlockRules];
          Print["criticalVertexClassRules: ",criticalVertexClassRules];
          Print["newPolys: ",newPolys]
          ];
        
        If[Depth[newPolys]==3,newPolys={newPolys}];
        If[Theta\[NotEqual]0,
          newPolys=
            Map[{{Cos[-Theta],-Sin[-Theta]},{Sin[-Theta],Cos[-Theta]}}.#1&,
              newPolys,{2}]];
        Return[replacePolygonNodesByOriginals[poly,#]&/@newPolys]
        ]/;Depth[poly]\[Equal]3;



imsPolygonToNexus[ imsPolygon[ poly_ ] ]:=PolygonToGraph[ poly ];

imsPolygonToNexus[ Line[ poly ] ]:=PolygonToGraph[ poly,opts ];

imsPolygonToNexus[ polyList:{(_Line|_Polygon|{{_,_}..} )..} ]:=
    PolygonToGraph[ #,opts ]& /@ polyList;

(* 2D case *)

imsPolygonToNexus[ poly:{{_,_}..} ]:=
    
    Module[{vertices,unsortedUnion,vertexRules,makeIndexedRule,createNode,
        createElement,triangulation, nodes, elements},
      
      unsortedUnion[x_]:=Module[{f},f[y_]:=(f[y]=Sequence[];y);f/@x];
      
      makeIndexedRule[lhs_,{rhs_}]:=lhs\[Rule]rhs;
      createNode[coord_,{nodeNumber_}]:=imsMakeNode[ nodeNumber,  coord];
      createElement[nodes:{_,_,_},{elementNumber_}]:=
        imsMakeTriangleLinear1DOF[elementNumber,nodes,{}];
      
      triangulation=imsTriangulatePolygon[poly];
      vertices=unsortedUnion[Flatten[triangulation,1]];
      vertexRules=MapIndexed[makeIndexedRule,vertices];
      
      nodes=MapIndexed[createNode,vertices];
      elements=MapIndexed[createElement,triangulation/.vertexRules];
      
      imsMakeNexus[nodes,{},elements]
      ];



imsTriangulateMonotonePolygon[imsPolygon[poly_],rotatePoly_:True]:=
    imsPolygon[#]&/@imsTriangulateMonotonePolygon[poly,rotatePoly];

imsTriangulateMonotonePolygon[Line[poly_],rotatePoly_:True]:=
    Line[#]&/@imsTriangulateMonotonePolygon[poly,rotatePoly];

imsTriangulateMonotonePolygon[polyList:{(_Line|_Polygon|{{_,_}..})..},
      rotatePoly_:True]:=
    imsTriangulateMonotonePolygon[#,rotatePoly]&/@polyList;

imsTriangulateMonotonePolygon[poly:{{_,_}..},rotatePoly_:True]:=
    Module[{maxVertex,minVertex,n,sortedCoordRules,onLeftChainQ,onRightChainQ,
        whichChain,connectorRules={},currentVertex,vertexCounter,reflexChain,
        newPoly,Theta=0,tmp},newPoly=makePolygonUnique[poly];
      n=Length[newPoly];If[n==3,Return[{newPoly}]];If[False&&n==4,
        tmp=
          Union[(vertexArea@@#)&/@\[InvisibleSpace]Transpose[{RotateRight[
                    newPoly],newPoly,RotateLeft[newPoly]}]];
        If[Min[tmp]<0,tmp=Flatten[Position[tmp,Min[tmp]]][[1]],
          tmp=Flatten[Position[tmp,Min[tmp]]][[1]]];
        Return[{{newPoly[[tmp]],newPoly[[Mod[tmp,4]+1]],
              newPoly[[Mod[tmp+1,4]+1]]},{newPoly[[Mod[tmp+1,4]+1]],
              newPoly[[Mod[tmp+2,4]+1]],newPoly[[Mod[tmp+3,4]+1]]}}]];
      If[rotatePoly,
        {Theta,newPoly}=makePolygonVerticallyUnique[newPoly]
        ];
      sortedCoordRules=
        Sort[(C[#1[[1]]]\[Rule]#1[[2]]&)/@
            Transpose[{Table[i,{i,1,Length[newPoly]}],
                newPoly}],#1[[2,2]]>#2[[2,
                    2]]||#1[[2,1]]<#2[[2,1]]&&#1[[2,2]]==#2[[2,
                      2]]&];{maxVertex,minVertex}={sortedCoordRules[[1,1,1]],
          sortedCoordRules[[n,1,1]]};
      If[minVertex>maxVertex,
        onLeftChainQ[v_]:=
          If[v\[LessEqual]minVertex&&v\[GreaterEqual]maxVertex,True,False];
        onRightChainQ[v_]:=
          If[v\[GreaterEqual]minVertex||v\[LessEqual]maxVertex,True,False],
        onLeftChainQ[v_]:=
          If[v\[GreaterEqual]maxVertex||v\[LessEqual]minVertex,True,False];
        onRightChainQ[v_]:=
          If[v\[LessEqual]maxVertex&&v\[GreaterEqual]minVertex,True,False]];
      whichChain[v_]:=If[onLeftChainQ[v],leftChain,rightChain];
      strictlyConvex[v_]:=
        Module[{vMinus=Mod[v-2,n]+1,vPlus=Mod[v,n]+1,a,b,c},
          a=C[vMinus]//.\[InvisibleSpace]sortedCoordRules;
          b=C[v]//.\[InvisibleSpace]sortedCoordRules;
          c=C[vPlus]//.\[InvisibleSpace]sortedCoordRules;
          Return[a[[1]] b[[2]]-a[[2]] b[[1]]+a[[2]] c[[1]]-a[[1]] c[[2]]+
                b[[1]] c[[2]]-b[[2]] c[[1]]>0]];
      reflexChain={sortedCoordRules[[1,1,1]],sortedCoordRules[[2,1,1]]};
      vertexCounter=3;currentVertex=sortedCoordRules[[vertexCounter,1,1]];
      While[currentVertex!=minVertex,
        currentChain=whichChain[reflexChain[[-1]]];
        Switch[currentChain===whichChain[currentVertex],
          False,
          connectorRules={connectorRules,
              Polygon[(C[#1]&)/@{currentVertex,reflexChain[[2]],
                      reflexChain[[1]]}]//.\[InvisibleSpace]sortedCoordRules};
          reflexChain=Drop[reflexChain,1];
          If[Length[reflexChain]==1,
            reflexChain=Join[reflexChain,{currentVertex}];++vertexCounter;
            currentVertex=sortedCoordRules[[vertexCounter,1,1]]],
          True,
          If[strictlyConvex[Last[reflexChain]],
            connectorRules={connectorRules,
                Polygon[(C[#1]&)/@{currentVertex,reflexChain[[-1]],
                        reflexChain[[-2]]}]//.\[InvisibleSpace]\
sortedCoordRules};reflexChain=Drop[reflexChain,-1];
            If[Length[reflexChain]==1,
              reflexChain=Join[reflexChain,{currentVertex}];++vertexCounter;
              currentVertex=sortedCoordRules[[vertexCounter,1,1]]],
            reflexChain=Join[reflexChain,{currentVertex}];++vertexCounter;
            currentVertex=sortedCoordRules[[vertexCounter,1,1]]]]];
      While[Length[reflexChain]>1,
        connectorRules={connectorRules,
            Polygon[(C[#1]&)/@{minVertex,reflexChain[[-1]],
                    reflexChain[[-2]]}]//.\[InvisibleSpace]sortedCoordRules};
        reflexChain=Drop[reflexChain,-1]];
      newPoly=(#1[[1]]&)/@Flatten[connectorRules];
      
      If[Depth[newPoly]==3,newPoly={newPoly}];
      If[Theta\[NotEqual]0,
        newPoly=
          Map[{{Cos[-Theta],-Sin[-Theta]},{Sin[-Theta],Cos[-Theta]}}.#1&,
            newPoly,{2}]
        ];
      Return[replacePolygonNodesByOriginals[poly,#]&/@newPoly]
      
      ];



imsTriangulatePolygon[imsPolygon[poly_]]:=
    imsPolygon[#]&/@imsTriangulatePolygon[poly];

imsTriangulatePolygon[Line[poly_]]:=Line[#]&/@imsTriangulatePolygon[poly];

imsTriangulatePolygon[polyList:{(_Line|_Polygon|{{_,_}..}|{{_,_,_}..})..},
      rotatePoly_:True]:=imsTriangulatePolygon[#,rotatePoly]&/@polyList;

imsTriangulatePolygon[poly:{{_,_}..}]:=
    Module[{newPoly,Theta},
      {Theta,newPoly}=makePolygonVerticallyUnique[poly];
      newPoly=imsMonotoneSplitPolygon[newPoly,False];
      newPoly=
        Join@@(imsTriangulateMonotonePolygon[#,False]&/@
              
              newPoly);
      If[Depth[newPoly]==3,newPoly={newPoly}];
      If[Theta\[NotEqual]0,
        newPoly=
          Map[{{Cos[-Theta],-Sin[-Theta]},{Sin[-Theta],Cos[-Theta]}}.#1&,
            newPoly,{2}]
        ];
      Return[replacePolygonNodesByOriginals[poly,#]&/@newPoly]
      ];



imsTriangulatePolygon[poly:{{_,_,_}..}]:=
    
    Module[{poly2D,vertexRules,ranges,polyTranspose,retainCoordinates},
      polyTranspose=Transpose[poly];
      ranges=(Max[#]&/@polyTranspose)-(Min[#]&/@polyTranspose);
      retainCoordinates=
        Complement[{1,2,3},Flatten[Position[ranges,Min[ranges]]]];
      poly2D=(#[[retainCoordinates]])&/@poly;
      vertexRules=(Rule@@#)&/@Transpose[{poly2D,poly}];
      imsTriangulatePolygon[poly2D]/.vertexRules
      ];



End[] (* of Begin Private *)



(* Protect[] (* anything *) *)
EndPackage[] 
